// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IRouter_Velodrome {
  struct Route {
    address from;
    address to;
    bool stable;
  }

  error ETHTransferFailed();
  error Expired();
  error InsufficientAmount();
  error InsufficientAmountA();
  error InsufficientAmountB();
  error InsufficientAmountADesired();
  error InsufficientAmountBDesired();
  error InsufficientLiquidity();
  error InsufficientOutputAmount();
  error InvalidPath();
  error OnlyWETH();
  error SameAddresses();
  error ZeroAddress();

  /// @notice Address of Velodrome v2 pool factory
  function factory() external view returns (address);

  /// @notice Address of Velodrome v2 pool implementation
  function poolImplementation() external view returns (address);

  /// @notice Sort two tokens by which address value is less than the other
  /// @param tokenA   Address of token to sort
  /// @param tokenB   Address of token to sort
  /// @return token0  Lower address value between tokenA and tokenB
  /// @return token1  Higher address value between tokenA and tokenB
  function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);

  /// @notice Calculate the address of a pool by its' factory.
  /// @dev Returns a randomly generated address for a nonexistent pool
  /// @param tokenA   Address of token to query
  /// @param tokenB   Address of token to query
  /// @param stable   True if pool is stable, false if volatile
  function poolFor(address tokenA, address tokenB, bool stable) external view returns (address pool);

  /// @notice Fetch and sort the reserves for a pool
  /// @param tokenA       .
  /// @param tokenB       .
  /// @param stable       True if pool is stable, false if volatile
  /// @return reserveA    Amount of reserves of the sorted token A
  /// @return reserveB    Amount of reserves of the sorted token B
  function getReserves(
    address tokenA,
    address tokenB,
    bool stable
  ) external view returns (uint256 reserveA, uint256 reserveB);

  /// @notice Perform chained getAmountOut calculations on any number of pools
  function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);

  // **** ADD LIQUIDITY ****

  /// @notice Quote the amount deposited into a Pool
  /// @param tokenA           .
  /// @param tokenB           .
  /// @param stable           True if pool is stable, false if volatile
  /// @param amountADesired   Amount of tokenA desired to deposit
  /// @param amountBDesired   Amount of tokenB desired to deposit
  /// @return amountA         Amount of tokenA to actually deposit
  /// @return amountB         Amount of tokenB to actually deposit
  /// @return liquidity       Amount of liquidity token returned from deposit
  function quoteAddLiquidity(
    address tokenA,
    address tokenB,
    bool stable,
    uint256 amountADesired,
    uint256 amountBDesired
  ) external view returns (uint256 amountA, uint256 amountB, uint256 liquidity);

  /// @notice Quote the amount of liquidity removed from a Pool
  /// @param tokenA       .
  /// @param tokenB       .
  /// @param stable       True if pool is stable, false if volatile
  /// @param liquidity    Amount of liquidity to remove
  /// @return amountA     Amount of tokenA received
  /// @return amountB     Amount of tokenB received
  function quoteRemoveLiquidity(
    address tokenA,
    address tokenB,
    bool stable,
    uint256 liquidity
  ) external view returns (uint256 amountA, uint256 amountB);

  /// @notice Add liquidity of two tokens to a Pool
  /// @param tokenA           .
  /// @param tokenB           .
  /// @param stable           True if pool is stable, false if volatile
  /// @param amountADesired   Amount of tokenA desired to deposit
  /// @param amountBDesired   Amount of tokenB desired to deposit
  /// @param amountAMin       Minimum amount of tokenA to deposit
  /// @param amountBMin       Minimum amount of tokenB to deposit
  /// @param to               Recipient of liquidity token
  /// @param deadline         Deadline to receive liquidity
  /// @return amountA         Amount of tokenA to actually deposit
  /// @return amountB         Amount of tokenB to actually deposit
  /// @return liquidity       Amount of liquidity token returned from deposit
  function addLiquidity(
    address tokenA,
    address tokenB,
    bool stable,
    uint256 amountADesired,
    uint256 amountBDesired,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);

  /// @notice Add liquidity of a token and WETH (transferred as ETH) to a Pool
  /// @param token                .
  /// @param stable               True if pool is stable, false if volatile
  /// @param amountTokenDesired   Amount of token desired to deposit
  /// @param amountTokenMin       Minimum amount of token to deposit
  /// @param amountETHMin         Minimum amount of ETH to deposit
  /// @param to                   Recipient of liquidity token
  /// @param deadline             Deadline to add liquidity
  /// @return amountToken         Amount of token to actually deposit
  /// @return amountETH           Amount of tokenETH to actually deposit
  /// @return liquidity           Amount of liquidity token returned from deposit
  function addLiquidityETH(
    address token,
    bool stable,
    uint256 amountTokenDesired,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);

  // **** REMOVE LIQUIDITY ****

  /// @notice Remove liquidity of two tokens from a Pool
  /// @param tokenA       .
  /// @param tokenB       .
  /// @param stable       True if pool is stable, false if volatile
  /// @param liquidity    Amount of liquidity to remove
  /// @param amountAMin   Minimum amount of tokenA to receive
  /// @param amountBMin   Minimum amount of tokenB to receive
  /// @param to           Recipient of tokens received
  /// @param deadline     Deadline to remove liquidity
  /// @return amountA     Amount of tokenA received
  /// @return amountB     Amount of tokenB received
  function removeLiquidity(
    address tokenA,
    address tokenB,
    bool stable,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountA, uint256 amountB);

  /// @notice Remove liquidity of a token and WETH (returned as ETH) from a Pool
  /// @param token            .
  /// @param stable           True if pool is stable, false if volatile
  /// @param liquidity        Amount of liquidity to remove
  /// @param amountTokenMin   Minimum amount of token to receive
  /// @param amountETHMin     Minimum amount of ETH to receive
  /// @param to               Recipient of liquidity token
  /// @param deadline         Deadline to receive liquidity
  /// @return amountToken     Amount of token received
  /// @return amountETH       Amount of ETH received
  function removeLiquidityETH(
    address token,
    bool stable,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountToken, uint256 amountETH);

  /// @notice Remove liquidity of a fee-on-transfer token and WETH (returned as ETH) from a Pool
  /// @param token            .
  /// @param stable           True if pool is stable, false if volatile
  /// @param liquidity        Amount of liquidity to remove
  /// @param amountTokenMin   Minimum amount of token to receive
  /// @param amountETHMin     Minimum amount of ETH to receive
  /// @param to               Recipient of liquidity token
  /// @param deadline         Deadline to receive liquidity
  /// @return amountETH       Amount of ETH received
  function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    bool stable,
    uint256 liquidity,
    uint256 amountTokenMin,
    uint256 amountETHMin,
    address to,
    uint256 deadline
  ) external returns (uint256 amountETH);

  /// @notice Swap one token for another
  /// @param amountIn     Amount of token in
  /// @param amountOutMin Minimum amount of desired token received
  /// @param routes       Array of trade routes used in the swap
  /// @param to           Recipient of the tokens received
  /// @param deadline     Deadline to receive tokens
  /// @return amounts     Array of amounts returned per route
  function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,
    Route[] calldata routes,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);

  /// @notice Swap ETH for a token
  /// @param amountOutMin Minimum amount of desired token received
  /// @param routes       Array of trade routes used in the swap
  /// @param to           Recipient of the tokens received
  /// @param deadline     Deadline to receive tokens
  /// @return amounts     Array of amounts returned per route
  function swapExactETHForTokens(
    uint256 amountOutMin,
    Route[] calldata routes,
    address to,
    uint256 deadline
  ) external payable returns (uint256[] memory amounts);

  /// @notice Swap a token for WETH (returned as ETH)
  /// @param amountIn     Amount of token in
  /// @param amountOutMin Minimum amount of desired ETH
  /// @param routes       Array of trade routes used in the swap
  /// @param to           Recipient of the tokens received
  /// @param deadline     Deadline to receive tokens
  /// @return amounts     Array of amounts returned per route
  function swapExactTokensForETH(
    uint256 amountIn,
    uint256 amountOutMin,
    Route[] calldata routes,
    address to,
    uint256 deadline
  ) external returns (uint256[] memory amounts);
}
