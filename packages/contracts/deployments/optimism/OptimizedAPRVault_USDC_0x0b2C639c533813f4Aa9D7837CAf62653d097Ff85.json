{
  "address": "0xBF2FFc4DCA552b16fd67B6b55A2458E70D1D39f0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        },
        {
          "internalType": "address",
          "name": "_currentImpl",
          "type": "address"
        }
      ],
      "name": "FunctionAlreadyAdded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "FunctionNotFound",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "stateMutability": "nonpayable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DECIMAL_OFFSET",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "_listExtensions",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract DiamondExtension",
          "name": "extensionToAdd",
          "type": "address"
        },
        {
          "internalType": "contract DiamondExtension",
          "name": "extensionToReplace",
          "type": "address"
        }
      ],
      "name": "_registerExtension",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "adapters",
      "outputs": [
        {
          "internalType": "contract CompoundMarketERC4626",
          "name": "adapter",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "allocation",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "adaptersCount",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "asFirstExtension",
      "outputs": [
        {
          "internalType": "contract OptimizedAPRVaultFirstExtension",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "asSecondExtension",
      "outputs": [
        {
          "internalType": "contract OptimizedAPRVaultSecondExtension",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "assetsCheckpoint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "depositLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "emergencyExit",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fees",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "deposit",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "withdrawal",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "management",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "performance",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feesUpdatedAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20Upgradeable",
          "name": "",
          "type": "address"
        }
      ],
      "name": "flywheelForRewardToken",
      "outputs": [
        {
          "internalType": "contract IonicFlywheel",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "flywheelLogic",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "highWaterMark",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract OptimizedAPRVaultExtension[]",
          "name": "extensions",
          "type": "address[]"
        },
        {
          "internalType": "bytes",
          "name": "initData",
          "type": "bytes"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedAdapterTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "proposedAdapters",
      "outputs": [
        {
          "internalType": "contract CompoundMarketERC4626",
          "name": "adapter",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "allocation",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedAdaptersCount",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedFeeTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedFees",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "deposit",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "withdrawal",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "management",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "performance",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "quitPeriod",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registry",
      "outputs": [
        {
          "internalType": "contract OptimizedVaultsRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "rewardTokens",
      "outputs": [
        {
          "internalType": "contract IERC20Upgradeable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "upgradeVault",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawalThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf4f6d331fcdafc90903112fa207a1884fd6d91c2814136ddc6307fcefa9b15cc",
  "receipt": {
    "to": null,
    "from": "0x1155b614971f16758C92c4890eD338C9e3ede6b7",
    "contractAddress": "0xBF2FFc4DCA552b16fd67B6b55A2458E70D1D39f0",
    "transactionIndex": 20,
    "gasUsed": "1268090",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000200000000000000000200000000000000000000000000100000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000020000000000400000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5a7f03b4177bcc1196220863073375030d59ca379984d65a714ea8792a1f9f18",
    "transactionHash": "0xf4f6d331fcdafc90903112fa207a1884fd6d91c2814136ddc6307fcefa9b15cc",
    "logs": [
      {
        "transactionIndex": 20,
        "blockNumber": 130108608,
        "transactionHash": "0xf4f6d331fcdafc90903112fa207a1884fd6d91c2814136ddc6307fcefa9b15cc",
        "address": "0xBF2FFc4DCA552b16fd67B6b55A2458E70D1D39f0",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000001155b614971f16758c92c4890ed338c9e3ede6b7"
        ],
        "data": "0x",
        "logIndex": 32,
        "blockHash": "0x5a7f03b4177bcc1196220863073375030d59ca379984d65a714ea8792a1f9f18"
      }
    ],
    "blockNumber": 130108608,
    "cumulativeGasUsed": "5221869",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "00a65ff38d425e65f29b5f926863c5c0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"_currentImpl\",\"type\":\"address\"}],\"name\":\"FunctionAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"FunctionNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DECIMAL_OFFSET\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_listExtensions\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract DiamondExtension\",\"name\":\"extensionToAdd\",\"type\":\"address\"},{\"internalType\":\"contract DiamondExtension\",\"name\":\"extensionToReplace\",\"type\":\"address\"}],\"name\":\"_registerExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adapters\",\"outputs\":[{\"internalType\":\"contract CompoundMarketERC4626\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"allocation\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adaptersCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asFirstExtension\",\"outputs\":[{\"internalType\":\"contract OptimizedAPRVaultFirstExtension\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asSecondExtension\",\"outputs\":[{\"internalType\":\"contract OptimizedAPRVaultSecondExtension\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"deposit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"withdrawal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"management\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"performance\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesUpdatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"flywheelForRewardToken\",\"outputs\":[{\"internalType\":\"contract IonicFlywheel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flywheelLogic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"highWaterMark\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract OptimizedAPRVaultExtension[]\",\"name\":\"extensions\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedAdapterTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposedAdapters\",\"outputs\":[{\"internalType\":\"contract CompoundMarketERC4626\",\"name\":\"adapter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"allocation\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedAdaptersCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedFeeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedFees\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"deposit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"withdrawal\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"management\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"performance\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quitPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract OptimizedVaultsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_registerExtension(address,address)\":{\"details\":\"register a logic extension\",\"params\":{\"extensionToAdd\":\"the extension whose functions are to be added\",\"extensionToReplace\":\"the extension whose functions are to be removed/replaced\"}},\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ionic/vault/OptimizedAPRVaultBase.sol\":\"OptimizedAPRVaultBase\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0x6adb35bab98e4b2aeafeba8d975dd22db19800b7bb15ec58e4fb78c837eeb054\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\",\"keccak256\":\"0xa6a787e7a901af6511e19aa53e1a00352db215a011d2c7a438d0582dd5da76f9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb94eac067c85cd79a4195c0a1f4a878e9827329045c12475a0199f1ae17b9700\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x636eab608b4563c01e88042aba9330e6fe69af2c567fe1adf4d85731974ac81d\",\"license\":\"MIT\"},\"adrastia-periphery/rates/IHistoricalRates.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\nimport \\\"./RateLibrary.sol\\\";\\n\\n/**\\n * @title IHistoricalRates\\n * @notice An interface that defines a contract that stores historical rates.\\n */\\ninterface IHistoricalRates {\\n    /// @notice Gets an rate for a token at a specific index.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param index The index of the rate to get, where index 0 contains the latest rate, and the last\\n    ///   index contains the oldest rate (uses reverse chronological ordering).\\n    /// @return rate The rate for the token at the specified index.\\n    function getRateAt(address token, uint256 index) external view returns (RateLibrary.Rate memory);\\n\\n    /// @notice Gets the latest rates for a token.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param amount The number of rates to get.\\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\\n    function getRates(address token, uint256 amount) external view returns (RateLibrary.Rate[] memory);\\n\\n    /// @notice Gets the latest rates for a token.\\n    /// @param token The address of the token to get the rates for.\\n    /// @param amount The number of rates to get.\\n    /// @param offset The index of the first rate to get (default: 0).\\n    /// @param increment The increment between rates to get (default: 1).\\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\\n    function getRates(\\n        address token,\\n        uint256 amount,\\n        uint256 offset,\\n        uint256 increment\\n    ) external view returns (RateLibrary.Rate[] memory);\\n\\n    /// @notice Gets the number of rates for a token.\\n    /// @param token The address of the token to get the number of rates for.\\n    /// @return count The number of rates for the token.\\n    function getRatesCount(address token) external view returns (uint256);\\n\\n    /// @notice Gets the capacity of rates for a token.\\n    /// @param token The address of the token to get the capacity of rates for.\\n    /// @return capacity The capacity of rates for the token.\\n    function getRatesCapacity(address token) external view returns (uint256);\\n\\n    /// @notice Sets the capacity of rates for a token.\\n    /// @param token The address of the token to set the capacity of rates for.\\n    /// @param amount The new capacity of rates for the token.\\n    function setRatesCapacity(address token, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x2754968c368df628f1ed00c2016b1a73f0f9b44f29e48d405887ad108723b3af\",\"license\":\"MIT\"},\"adrastia-periphery/rates/RateLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nlibrary RateLibrary {\\n    struct Rate {\\n        uint64 target;\\n        uint64 current;\\n        uint32 timestamp;\\n    }\\n}\\n\",\"keccak256\":\"0x397b79cf9f183afa76db3c8d10cffb408e31ba154900f671a7e93c071bacbff4\",\"license\":\"MIT\"},\"contracts/PoolDirectory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\\\";\\n\\nimport { IonicComptroller } from \\\"./compound/ComptrollerInterface.sol\\\";\\nimport { BasePriceOracle } from \\\"./oracles/BasePriceOracle.sol\\\";\\nimport { Unitroller } from \\\"./compound/Unitroller.sol\\\";\\nimport \\\"./ionic/SafeOwnableUpgradeable.sol\\\";\\nimport \\\"./ionic/DiamondExtension.sol\\\";\\n\\n/**\\n * @title PoolDirectory\\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\\n * @notice PoolDirectory is a directory for Ionic interest rate pools.\\n */\\ncontract PoolDirectory is SafeOwnableUpgradeable {\\n  /**\\n   * @dev Initializes a deployer whitelist if desired.\\n   * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\\n   * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\\n   */\\n  function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\\n    __SafeOwnable_init(msg.sender);\\n    enforceDeployerWhitelist = _enforceDeployerWhitelist;\\n    for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\\n  }\\n\\n  /**\\n   * @dev Struct for a Ionic interest rate pool.\\n   */\\n  struct Pool {\\n    string name;\\n    address creator;\\n    address comptroller;\\n    uint256 blockPosted;\\n    uint256 timestampPosted;\\n  }\\n\\n  /**\\n   * @dev Array of Ionic interest rate pools.\\n   */\\n  Pool[] public pools;\\n\\n  /**\\n   * @dev Maps Ethereum accounts to arrays of Ionic pool indexes.\\n   */\\n  mapping(address => uint256[]) private _poolsByAccount;\\n\\n  /**\\n   * @dev Maps Ionic pool Comptroller addresses to bools indicating if they have been registered via the directory.\\n   */\\n  mapping(address => bool) public poolExists;\\n\\n  /**\\n   * @dev Emitted when a new Ionic pool is added to the directory.\\n   */\\n  event PoolRegistered(uint256 index, Pool pool);\\n\\n  /**\\n   * @dev Booleans indicating if the deployer whitelist is enforced.\\n   */\\n  bool public enforceDeployerWhitelist;\\n\\n  /**\\n   * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\\n   */\\n  mapping(address => bool) public deployerWhitelist;\\n\\n  /**\\n   * @dev Controls if the deployer whitelist is to be enforced.\\n   * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\\n   */\\n  function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\\n    enforceDeployerWhitelist = enforce;\\n  }\\n\\n  /**\\n   * @dev Adds/removes Ethereum accounts to the deployer whitelist.\\n   * @param deployers Array of Ethereum accounts to be whitelisted.\\n   * @param status Whether to add or remove the accounts.\\n   */\\n  function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\\n    require(deployers.length > 0, \\\"No deployers supplied.\\\");\\n    for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\\n  }\\n\\n  /**\\n   * @dev Adds a new Ionic pool to the directory (without checking msg.sender).\\n   * @param name The name of the pool.\\n   * @param comptroller The pool's Comptroller proxy contract address.\\n   * @return The index of the registered Ionic pool.\\n   */\\n  function _registerPool(string memory name, address comptroller) internal returns (uint256) {\\n    require(!poolExists[comptroller], \\\"Pool already exists in the directory.\\\");\\n    require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \\\"Sender is not on deployer whitelist.\\\");\\n    require(bytes(name).length <= 100, \\\"No pool name supplied.\\\");\\n    Pool memory pool = Pool(name, msg.sender, comptroller, block.number, block.timestamp);\\n    pools.push(pool);\\n    _poolsByAccount[msg.sender].push(pools.length - 1);\\n    poolExists[comptroller] = true;\\n    emit PoolRegistered(pools.length - 1, pool);\\n    return pools.length - 1;\\n  }\\n\\n  function _deprecatePool(address comptroller) external onlyOwner {\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      if (pools[i].comptroller == comptroller) {\\n        _deprecatePool(i);\\n        break;\\n      }\\n    }\\n  }\\n\\n  function _deprecatePool(uint256 index) public onlyOwner {\\n    Pool storage ionicPool = pools[index];\\n\\n    require(ionicPool.comptroller != address(0), \\\"pool already deprecated\\\");\\n\\n    // swap with the last pool of the creator and delete\\n    uint256[] storage creatorPools = _poolsByAccount[ionicPool.creator];\\n    for (uint256 i = 0; i < creatorPools.length; i++) {\\n      if (creatorPools[i] == index) {\\n        creatorPools[i] = creatorPools[creatorPools.length - 1];\\n        creatorPools.pop();\\n        break;\\n      }\\n    }\\n\\n    // leave it to true to deny the re-registering of the same pool\\n    poolExists[ionicPool.comptroller] = true;\\n\\n    // nullify the storage\\n    ionicPool.comptroller = address(0);\\n    ionicPool.creator = address(0);\\n    ionicPool.name = \\\"\\\";\\n    ionicPool.blockPosted = 0;\\n    ionicPool.timestampPosted = 0;\\n  }\\n\\n  /**\\n   * @dev Deploys a new Ionic pool and adds to the directory.\\n   * @param name The name of the pool.\\n   * @param implementation The Comptroller implementation contract address.\\n   * @param constructorData Encoded construction data for `Unitroller constructor()`\\n   * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\\n   * @param closeFactor The pool's close factor (scaled by 1e18).\\n   * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\\n   * @param priceOracle The pool's PriceOracle contract address.\\n   * @return Index of the registered Ionic pool and the Unitroller proxy address.\\n   */\\n  function deployPool(\\n    string memory name,\\n    address implementation,\\n    bytes calldata constructorData,\\n    bool enforceWhitelist,\\n    uint256 closeFactor,\\n    uint256 liquidationIncentive,\\n    address priceOracle\\n  ) external returns (uint256, address) {\\n    // Input validation\\n    require(implementation != address(0), \\\"No Comptroller implementation contract address specified.\\\");\\n    require(priceOracle != address(0), \\\"No PriceOracle contract address specified.\\\");\\n\\n    // Deploy Unitroller using msg.sender, name, and block.number as a salt\\n    bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode, constructorData);\\n    address proxy = Create2Upgradeable.deploy(\\n      0,\\n      keccak256(abi.encodePacked(msg.sender, name, ++poolsCounter)),\\n      unitrollerCreationCode\\n    );\\n\\n    // Setup the pool\\n    IonicComptroller comptrollerProxy = IonicComptroller(proxy);\\n    // Set up the extensions\\n    comptrollerProxy._upgrade();\\n\\n    // Set pool parameters\\n    require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \\\"Failed to set pool close factor.\\\");\\n    require(\\n      comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0,\\n      \\\"Failed to set pool liquidation incentive.\\\"\\n    );\\n    require(comptrollerProxy._setPriceOracle(BasePriceOracle(priceOracle)) == 0, \\\"Failed to set pool price oracle.\\\");\\n\\n    // Whitelist\\n    if (enforceWhitelist)\\n      require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \\\"Failed to enforce supplier/borrower whitelist.\\\");\\n\\n    // Make msg.sender the admin\\n    require(comptrollerProxy._setPendingAdmin(msg.sender) == 0, \\\"Failed to set pending admin on Unitroller.\\\");\\n\\n    // Register the pool with this PoolDirectory\\n    return (_registerPool(name, proxy), proxy);\\n  }\\n\\n  /**\\n   * @notice Returns `ids` and directory information of all non-deprecated Ionic pools.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getActivePools() public view returns (uint256[] memory, Pool[] memory) {\\n    uint256 count = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      if (pools[i].comptroller != address(0)) count++;\\n    }\\n\\n    Pool[] memory activePools = new Pool[](count);\\n    uint256[] memory poolIds = new uint256[](count);\\n\\n    uint256 index = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      if (pools[i].comptroller != address(0)) {\\n        poolIds[index] = i;\\n        activePools[index] = pools[i];\\n        index++;\\n      }\\n    }\\n\\n    return (poolIds, activePools);\\n  }\\n\\n  /**\\n   * @notice Returns arrays of all Ionic pools' data.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getAllPools() public view returns (Pool[] memory) {\\n    uint256 count = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      if (pools[i].comptroller != address(0)) count++;\\n    }\\n\\n    Pool[] memory result = new Pool[](count);\\n\\n    uint256 index = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      if (pools[i].comptroller != address(0)) {\\n        result[index++] = pools[i];\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * @notice Returns arrays of all public Ionic pool indexes and data.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getPublicPools() external view returns (uint256[] memory, Pool[] memory) {\\n    uint256 arrayLength = 0;\\n\\n    (, Pool[] memory activePools) = getActivePools();\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\\n        if (enforceWhitelist) continue;\\n      } catch {}\\n\\n      arrayLength++;\\n    }\\n\\n    uint256[] memory indexes = new uint256[](arrayLength);\\n    Pool[] memory publicPools = new Pool[](arrayLength);\\n    uint256 index = 0;\\n\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\\n        if (enforceWhitelist) continue;\\n      } catch {}\\n\\n      indexes[index] = i;\\n      publicPools[index] = activePools[i];\\n      index++;\\n    }\\n\\n    return (indexes, publicPools);\\n  }\\n\\n  /**\\n   * @notice Returns arrays of all public Ionic pool indexes and data.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getPoolsOfUser(address user) external view returns (uint256[] memory, Pool[] memory) {\\n    uint256 arrayLength = 0;\\n\\n    (, Pool[] memory activePools) = getActivePools();\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\\n        if (!isUsing) continue;\\n      } catch {}\\n\\n      arrayLength++;\\n    }\\n\\n    uint256[] memory indexes = new uint256[](arrayLength);\\n    Pool[] memory poolsOfUser = new Pool[](arrayLength);\\n    uint256 index = 0;\\n\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\\n        if (!isUsing) continue;\\n      } catch {}\\n\\n      indexes[index] = i;\\n      poolsOfUser[index] = activePools[i];\\n      index++;\\n    }\\n\\n    return (indexes, poolsOfUser);\\n  }\\n\\n  /**\\n   * @notice Returns arrays of Ionic pool indexes and data created by `account`.\\n   */\\n  function getPoolsByAccount(address account) external view returns (uint256[] memory, Pool[] memory) {\\n    uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\\n    Pool[] memory accountPools = new Pool[](_poolsByAccount[account].length);\\n    (, Pool[] memory activePools) = getActivePools();\\n\\n    for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\\n      indexes[i] = _poolsByAccount[account][i];\\n      accountPools[i] = activePools[_poolsByAccount[account][i]];\\n    }\\n\\n    return (indexes, accountPools);\\n  }\\n\\n  /**\\n   * @notice Modify existing Ionic pool name.\\n   */\\n  function setPoolName(uint256 index, string calldata name) external {\\n    IonicComptroller _comptroller = IonicComptroller(pools[index].comptroller);\\n    require(\\n      (msg.sender == _comptroller.admin() && _comptroller.adminHasRights()) || msg.sender == owner(),\\n      \\\"!permission\\\"\\n    );\\n    pools[index].name = name;\\n  }\\n\\n  /**\\n   * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\\n   */\\n  mapping(address => bool) public adminWhitelist;\\n\\n  /**\\n   * @dev used as salt for the creation of new pools\\n   */\\n  uint256 public poolsCounter;\\n\\n  /**\\n   * @dev Event emitted when the admin whitelist is updated.\\n   */\\n  event AdminWhitelistUpdated(address[] admins, bool status);\\n\\n  /**\\n   * @dev Adds/removes Ethereum accounts to the admin whitelist.\\n   * @param admins Array of Ethereum accounts to be whitelisted.\\n   * @param status Whether to add or remove the accounts.\\n   */\\n  function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\\n    require(admins.length > 0, \\\"No admins supplied.\\\");\\n    for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\\n    emit AdminWhitelistUpdated(admins, status);\\n  }\\n\\n  /**\\n   * @notice Returns arrays of all Ionic pool indexes and data with whitelisted admins.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getPublicPoolsByVerification(bool whitelistedAdmin) external view returns (uint256[] memory, Pool[] memory) {\\n    uint256 arrayLength = 0;\\n\\n    (, Pool[] memory activePools) = getActivePools();\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\\n\\n      try comptroller.admin() returns (address admin) {\\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\\n      } catch {}\\n\\n      arrayLength++;\\n    }\\n\\n    uint256[] memory indexes = new uint256[](arrayLength);\\n    Pool[] memory publicPools = new Pool[](arrayLength);\\n    uint256 index = 0;\\n\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\\n\\n      try comptroller.admin() returns (address admin) {\\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\\n      } catch {}\\n\\n      indexes[index] = i;\\n      publicPools[index] = activePools[i];\\n      index++;\\n    }\\n\\n    return (indexes, publicPools);\\n  }\\n\\n  /**\\n   * @notice Returns arrays of all verified Ionic pool indexes and data for which the account is whitelisted\\n   * @param account who is whitelisted in the returned verified whitelist-enabled pools.\\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\\n   */\\n  function getVerifiedPoolsOfWhitelistedAccount(address account)\\n    external\\n    view\\n    returns (uint256[] memory, Pool[] memory)\\n  {\\n    uint256 arrayLength = 0;\\n    (, Pool[] memory activePools) = getActivePools();\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\\n\\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\\n      } catch {}\\n\\n      arrayLength++;\\n    }\\n\\n    uint256[] memory indexes = new uint256[](arrayLength);\\n    Pool[] memory accountWhitelistedPools = new Pool[](arrayLength);\\n    uint256 index = 0;\\n\\n    for (uint256 i = 0; i < activePools.length; i++) {\\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\\n      } catch {}\\n\\n      indexes[index] = i;\\n      accountWhitelistedPools[index] = activePools[i];\\n      index++;\\n    }\\n\\n    return (indexes, accountWhitelistedPools);\\n  }\\n}\\n\",\"keccak256\":\"0xd3d28cd044a0205a86f0c2d82021a36018ec4b0e95f72064c92bcad99f84f6c8\",\"license\":\"UNLICENSED\"},\"contracts/adrastia/PrudentiaLib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nlibrary PrudentiaLib {\\n  struct PrudentiaConfig {\\n    address controller; // Adrastia Prudentia controller address\\n    uint8 offset; // Offset for delayed rate activation\\n    int8 decimalShift; // Positive values scale the rate up (in powers of 10), negative values scale the rate down\\n  }\\n}\\n\",\"keccak256\":\"0x8cc50f1a5dab30e0c205b0bba5f58c18eda9ebf01c661895c8f40678b86bf31f\",\"license\":\"UNLICENSED\"},\"contracts/compound/CTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport { IonicComptroller } from \\\"./ComptrollerInterface.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\nimport { ComptrollerV3Storage } from \\\"./ComptrollerStorage.sol\\\";\\nimport { AddressesProvider } from \\\"../ionic/AddressesProvider.sol\\\";\\n\\nabstract contract CTokenAdminStorage {\\n  /*\\n   * Administrator for Ionic\\n   */\\n  address payable public ionicAdmin;\\n}\\n\\nabstract contract CErc20Storage is CTokenAdminStorage {\\n  /**\\n   * @dev Guard variable for re-entrancy checks\\n   */\\n  bool internal _notEntered;\\n\\n  /**\\n   * @notice EIP-20 token name for this token\\n   */\\n  string public name;\\n\\n  /**\\n   * @notice EIP-20 token symbol for this token\\n   */\\n  string public symbol;\\n\\n  /**\\n   * @notice EIP-20 token decimals for this token\\n   */\\n  uint8 public decimals;\\n\\n  /*\\n   * Maximum borrow rate that can ever be applied (.0005% / block)\\n   */\\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n  /*\\n   * Maximum fraction of interest that can be set aside for reserves + fees\\n   */\\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\\n\\n  /**\\n   * @notice Contract which oversees inter-cToken operations\\n   */\\n  IonicComptroller public comptroller;\\n\\n  /**\\n   * @notice Model which tells what the current interest rate should be\\n   */\\n  InterestRateModel public interestRateModel;\\n\\n  /*\\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\n   */\\n  uint256 internal initialExchangeRateMantissa;\\n\\n  /**\\n   * @notice Fraction of interest currently set aside for admin fees\\n   */\\n  uint256 public adminFeeMantissa;\\n\\n  /**\\n   * @notice Fraction of interest currently set aside for Ionic fees\\n   */\\n  uint256 public ionicFeeMantissa;\\n\\n  /**\\n   * @notice Fraction of interest currently set aside for reserves\\n   */\\n  uint256 public reserveFactorMantissa;\\n\\n  /**\\n   * @notice Block number that interest was last accrued at\\n   */\\n  uint256 public accrualBlockNumber;\\n\\n  /**\\n   * @notice Accumulator of the total earned interest rate since the opening of the market\\n   */\\n  uint256 public borrowIndex;\\n\\n  /**\\n   * @notice Total amount of outstanding borrows of the underlying in this market\\n   */\\n  uint256 public totalBorrows;\\n\\n  /**\\n   * @notice Total amount of reserves of the underlying held in this market\\n   */\\n  uint256 public totalReserves;\\n\\n  /**\\n   * @notice Total amount of admin fees of the underlying held in this market\\n   */\\n  uint256 public totalAdminFees;\\n\\n  /**\\n   * @notice Total amount of Ionic fees of the underlying held in this market\\n   */\\n  uint256 public totalIonicFees;\\n\\n  /**\\n   * @notice Total number of tokens in circulation\\n   */\\n  uint256 public totalSupply;\\n\\n  /*\\n   * Official record of token balances for each account\\n   */\\n  mapping(address => uint256) internal accountTokens;\\n\\n  /*\\n   * Approved token transfer amounts on behalf of others\\n   */\\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\\n\\n  /**\\n   * @notice Container for borrow balance information\\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n   */\\n  struct BorrowSnapshot {\\n    uint256 principal;\\n    uint256 interestIndex;\\n  }\\n\\n  /*\\n   * Mapping of account addresses to outstanding borrow balances\\n   */\\n  mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n  /*\\n   * Share of seized collateral that is added to reserves\\n   */\\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\n\\n  /*\\n   * Share of seized collateral taken as fees\\n   */\\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\\n\\n  /**\\n   * @notice Underlying asset for this CToken\\n   */\\n  address public underlying;\\n\\n  /**\\n   * @notice Addresses Provider\\n   */\\n  AddressesProvider public ap;\\n}\\n\\nabstract contract CTokenBaseEvents {\\n  /* ERC20 */\\n\\n  /**\\n   * @notice EIP20 Transfer event\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n  /*** Admin Events ***/\\n\\n  /**\\n   * @notice Event emitted when interestRateModel is changed\\n   */\\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\n\\n  /**\\n   * @notice Event emitted when the reserve factor is changed\\n   */\\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\\n\\n  /**\\n   * @notice Event emitted when the admin fee is changed\\n   */\\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\\n\\n  /**\\n   * @notice Event emitted when the Ionic fee is changed\\n   */\\n  event NewIonicFee(uint256 oldIonicFeeMantissa, uint256 newIonicFeeMantissa);\\n\\n  /**\\n   * @notice EIP20 Approval event\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n  /**\\n   * @notice Event emitted when interest is accrued\\n   */\\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\\n}\\n\\nabstract contract CTokenFirstExtensionEvents is CTokenBaseEvents {\\n  event Flash(address receiver, uint256 amount);\\n}\\n\\nabstract contract CTokenSecondExtensionEvents is CTokenBaseEvents {\\n  /*** Market Events ***/\\n\\n  /**\\n   * @notice Event emitted when tokens are minted\\n   */\\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\\n\\n  /**\\n   * @notice Event emitted when tokens are redeemed\\n   */\\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\\n\\n  /**\\n   * @notice Event emitted when underlying is borrowed\\n   */\\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n  /**\\n   * @notice Event emitted when a borrow is repaid\\n   */\\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\\n\\n  /**\\n   * @notice Event emitted when a borrow is liquidated\\n   */\\n  event LiquidateBorrow(\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral,\\n    uint256 seizeTokens\\n  );\\n\\n  /**\\n   * @notice Event emitted when the reserves are added\\n   */\\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\\n\\n  /**\\n   * @notice Event emitted when the reserves are reduced\\n   */\\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\\n}\\n\\ninterface CTokenFirstExtensionInterface {\\n  /*** User Interface ***/\\n\\n  function transfer(address dst, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  /*** Admin Functions ***/\\n\\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\\n\\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\\n\\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external returns (uint256);\\n\\n  function getAccountSnapshot(address account)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function borrowRatePerBlock() external view returns (uint256);\\n\\n  function supplyRatePerBlock() external view returns (uint256);\\n\\n  function exchangeRateCurrent() external view returns (uint256);\\n\\n  function accrueInterest() external returns (uint256);\\n\\n  function totalBorrowsCurrent() external view returns (uint256);\\n\\n  function borrowBalanceCurrent(address account) external view returns (uint256);\\n\\n  function getTotalUnderlyingSupplied() external view returns (uint256);\\n\\n  function balanceOfUnderlying(address owner) external view returns (uint256);\\n\\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n\\n  function flash(uint256 amount, bytes calldata data) external;\\n\\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256);\\n\\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256);\\n\\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) external view returns (uint256);\\n\\n  function registerInSFS() external returns (uint256);\\n}\\n\\ninterface CTokenSecondExtensionInterface {\\n  function mint(uint256 mintAmount) external returns (uint256);\\n\\n  function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n  function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\\n\\n  function liquidateBorrow(\\n    address borrower,\\n    uint256 repayAmount,\\n    address cTokenCollateral\\n  ) external returns (uint256);\\n\\n  function getCash() external view returns (uint256);\\n\\n  function seize(\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens\\n  ) external returns (uint256);\\n\\n  /*** Admin Functions ***/\\n\\n  function _withdrawAdminFees(uint256 withdrawAmount) external returns (uint256);\\n\\n  function _withdrawIonicFees(uint256 withdrawAmount) external returns (uint256);\\n\\n  function selfTransferOut(address to, uint256 amount) external;\\n\\n  function selfTransferIn(address from, uint256 amount) external returns (uint256);\\n}\\n\\ninterface CDelegatorInterface {\\n  function implementation() external view returns (address);\\n\\n  /**\\n   * @notice Called by the admin to update the implementation of the delegator\\n   * @param implementation_ The address of the new implementation for delegation\\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n   */\\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external;\\n\\n  /**\\n   * @dev upgrades the implementation if necessary\\n   */\\n  function _upgrade() external;\\n}\\n\\ninterface CDelegateInterface {\\n  /**\\n   * @notice Called by the delegator on a delegate to initialize it for duty\\n   * @dev Should revert if any issues arise which make it unfit for delegation\\n   * @param data The encoded bytes data for any initialization\\n   */\\n  function _becomeImplementation(bytes calldata data) external;\\n\\n  function delegateType() external pure returns (uint8);\\n\\n  function contractType() external pure returns (string memory);\\n}\\n\\nabstract contract CErc20AdminBase is CErc20Storage {\\n  /**\\n   * @notice Returns a boolean indicating if the sender has admin rights\\n   */\\n  function hasAdminRights() internal view returns (bool) {\\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\\n    return\\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\\n      (msg.sender == address(ionicAdmin) && comptrollerStorage.ionicAdminHasRights());\\n  }\\n}\\n\\nabstract contract CErc20FirstExtensionBase is\\n  CErc20AdminBase,\\n  CTokenFirstExtensionEvents,\\n  CTokenFirstExtensionInterface\\n{}\\n\\nabstract contract CTokenSecondExtensionBase is\\n  CErc20AdminBase,\\n  CTokenSecondExtensionEvents,\\n  CTokenSecondExtensionInterface,\\n  CDelegateInterface\\n{}\\n\\nabstract contract CErc20DelegatorBase is CErc20AdminBase, CTokenSecondExtensionEvents, CDelegatorInterface {}\\n\\ninterface CErc20StorageInterface {\\n  function admin() external view returns (address);\\n\\n  function adminHasRights() external view returns (bool);\\n\\n  function ionicAdmin() external view returns (address);\\n\\n  function ionicAdminHasRights() external view returns (bool);\\n\\n  function comptroller() external view returns (IonicComptroller);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function adminFeeMantissa() external view returns (uint256);\\n\\n  function ionicFeeMantissa() external view returns (uint256);\\n\\n  function reserveFactorMantissa() external view returns (uint256);\\n\\n  function protocolSeizeShareMantissa() external view returns (uint256);\\n\\n  function feeSeizeShareMantissa() external view returns (uint256);\\n\\n  function totalReserves() external view returns (uint256);\\n\\n  function totalAdminFees() external view returns (uint256);\\n\\n  function totalIonicFees() external view returns (uint256);\\n\\n  function totalBorrows() external view returns (uint256);\\n\\n  function accrualBlockNumber() external view returns (uint256);\\n\\n  function underlying() external view returns (address);\\n\\n  function borrowIndex() external view returns (uint256);\\n\\n  function interestRateModel() external view returns (address);\\n}\\n\\ninterface CErc20PluginStorageInterface is CErc20StorageInterface {\\n  function plugin() external view returns (address);\\n}\\n\\ninterface CErc20PluginRewardsInterface is CErc20PluginStorageInterface {\\n  function approve(address, address) external;\\n}\\n\\ninterface ICErc20 is\\n  CErc20StorageInterface,\\n  CTokenSecondExtensionInterface,\\n  CTokenFirstExtensionInterface,\\n  CDelegatorInterface,\\n  CDelegateInterface\\n{}\\n\\ninterface ICErc20Plugin is CErc20PluginStorageInterface, ICErc20 {\\n  function _updatePlugin(address _plugin) external;\\n}\\n\\ninterface ICErc20PluginRewards is CErc20PluginRewardsInterface, ICErc20 {}\\n\",\"keccak256\":\"0x7cc75051a5fa860b9ee93d0ba1ac0608921f02308aeff786ce8bbd8d8a70489a\",\"license\":\"UNLICENSED\"},\"contracts/compound/CarefulMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Careful Math\\n * @author Compound\\n * @notice Derived from OpenZeppelin's SafeMath library\\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n */\\ncontract CarefulMath {\\n  /**\\n   * @dev Possible error codes that we can return\\n   */\\n  enum MathError {\\n    NO_ERROR,\\n    DIVISION_BY_ZERO,\\n    INTEGER_OVERFLOW,\\n    INTEGER_UNDERFLOW\\n  }\\n\\n  /**\\n   * @dev Multiplies two numbers, returns an error on overflow.\\n   */\\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n    if (a == 0) {\\n      return (MathError.NO_ERROR, 0);\\n    }\\n\\n    uint256 c;\\n    unchecked {\\n      c = a * b;\\n    }\\n\\n    if (c / a != b) {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    } else {\\n      return (MathError.NO_ERROR, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Integer division of two numbers, truncating the quotient.\\n   */\\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n    if (b == 0) {\\n      return (MathError.DIVISION_BY_ZERO, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, a / b);\\n  }\\n\\n  /**\\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n    if (b <= a) {\\n      return (MathError.NO_ERROR, a - b);\\n    } else {\\n      return (MathError.INTEGER_UNDERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Adds two numbers, returns an error on overflow.\\n   */\\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n    uint256 c;\\n    unchecked {\\n      c = a + b;\\n    }\\n\\n    if (c >= a) {\\n      return (MathError.NO_ERROR, c);\\n    } else {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev add a and b and then subtract c\\n   */\\n  function addThenSubUInt(\\n    uint256 a,\\n    uint256 b,\\n    uint256 c\\n  ) internal pure returns (MathError, uint256) {\\n    (MathError err0, uint256 sum) = addUInt(a, b);\\n\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, 0);\\n    }\\n\\n    return subUInt(sum, c);\\n  }\\n}\\n\",\"keccak256\":\"0x7425598d767521ba25277a7f95273c4705721aef0d7f2cd855cb6a61de709a7c\",\"license\":\"UNLICENSED\"},\"contracts/compound/Comptroller.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport { ICErc20 } from \\\"./CTokenInterfaces.sol\\\";\\nimport { ComptrollerErrorReporter } from \\\"./ErrorReporter.sol\\\";\\nimport { Exponential } from \\\"./Exponential.sol\\\";\\nimport { BasePriceOracle } from \\\"../oracles/BasePriceOracle.sol\\\";\\nimport { Unitroller } from \\\"./Unitroller.sol\\\";\\nimport { IFeeDistributor } from \\\"./IFeeDistributor.sol\\\";\\nimport { IIonicFlywheel } from \\\"../ionic/strategies/flywheel/IIonicFlywheel.sol\\\";\\nimport { DiamondExtension, DiamondBase, LibDiamond } from \\\"../ionic/DiamondExtension.sol\\\";\\nimport { ComptrollerExtensionInterface, ComptrollerBase, ComptrollerInterface } from \\\"./ComptrollerInterface.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @title Compound's Comptroller Contract\\n * @author Compound\\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\\n */\\ncontract Comptroller is ComptrollerBase, ComptrollerInterface, ComptrollerErrorReporter, Exponential, DiamondExtension {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice Emitted when an admin supports a market\\n  event MarketListed(ICErc20 cToken);\\n\\n  /// @notice Emitted when an account enters a market\\n  event MarketEntered(ICErc20 cToken, address account);\\n\\n  /// @notice Emitted when an account exits a market\\n  event MarketExited(ICErc20 cToken, address account);\\n\\n  /// @notice Emitted when close factor is changed by admin\\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\\n\\n  /// @notice Emitted when a collateral factor is changed by admin\\n  event NewCollateralFactor(ICErc20 cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\\n\\n  /// @notice Emitted when liquidation incentive is changed by admin\\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\\n\\n  /// @notice Emitted when price oracle is changed\\n  event NewPriceOracle(BasePriceOracle oldPriceOracle, BasePriceOracle newPriceOracle);\\n\\n  /// @notice Emitted when the whitelist enforcement is changed\\n  event WhitelistEnforcementChanged(bool enforce);\\n\\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\\n  event AddedRewardsDistributor(address rewardsDistributor);\\n\\n  // closeFactorMantissa must be strictly greater than this value\\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\\n\\n  // closeFactorMantissa must not exceed this value\\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\\n\\n  // No collateralFactorMantissa may exceed this value\\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\\n\\n  // liquidationIncentiveMantissa must be no less than this value\\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\\n\\n  // liquidationIncentiveMantissa must be no greater than this value\\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\\n\\n  modifier isAuthorized() {\\n    require(IFeeDistributor(ionicAdmin).canCall(address(this), msg.sender, address(this), msg.sig), \\\"not authorized\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveSupplyCaps(\\n    address cToken\\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 supplyCap) {\\n    return ComptrollerBase.effectiveSupplyCaps(cToken);\\n  }\\n\\n  /**\\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveBorrowCaps(\\n    address cToken\\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 borrowCap) {\\n    return ComptrollerBase.effectiveBorrowCaps(cToken);\\n  }\\n\\n  /*** Assets You Are In ***/\\n\\n  /**\\n   * @notice Returns the assets an account has entered\\n   * @param account The address of the account to pull assets for\\n   * @return A dynamic list with the assets the account has entered\\n   */\\n  function getAssetsIn(address account) external view returns (ICErc20[] memory) {\\n    ICErc20[] memory assetsIn = accountAssets[account];\\n\\n    return assetsIn;\\n  }\\n\\n  /**\\n   * @notice Returns whether the given account is entered in the given asset\\n   * @param account The address of the account to check\\n   * @param cToken The cToken to check\\n   * @return True if the account is in the asset, otherwise false.\\n   */\\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool) {\\n    return markets[address(cToken)].accountMembership[account];\\n  }\\n\\n  /**\\n   * @notice Add assets to be included in account liquidity calculation\\n   * @param cTokens The list of addresses of the cToken markets to be enabled\\n   * @return Success indicator for whether each corresponding market was entered\\n   */\\n  function enterMarkets(address[] memory cTokens) public override isAuthorized returns (uint256[] memory) {\\n    uint256 len = cTokens.length;\\n\\n    uint256[] memory results = new uint256[](len);\\n    for (uint256 i = 0; i < len; i++) {\\n      ICErc20 cToken = ICErc20(cTokens[i]);\\n\\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\\n    }\\n\\n    return results;\\n  }\\n\\n  /**\\n   * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\n   * @param cToken The market to enter\\n   * @param borrower The address of the account to modify\\n   * @return Success indicator for whether the market was entered\\n   */\\n  function addToMarketInternal(ICErc20 cToken, address borrower) internal returns (Error) {\\n    Market storage marketToJoin = markets[address(cToken)];\\n\\n    if (!marketToJoin.isListed) {\\n      // market is not listed, cannot join\\n      return Error.MARKET_NOT_LISTED;\\n    }\\n\\n    if (marketToJoin.accountMembership[borrower] == true) {\\n      // already joined\\n      return Error.NO_ERROR;\\n    }\\n\\n    // survived the gauntlet, add to list\\n    // NOTE: we store these somewhat redundantly as a significant optimization\\n    //  this avoids having to iterate through the list for the most common use cases\\n    //  that is, only when we need to perform liquidity checks\\n    //  and not whenever we want to check if an account is in a particular market\\n    marketToJoin.accountMembership[borrower] = true;\\n    accountAssets[borrower].push(cToken);\\n\\n    // Add to allBorrowers\\n    if (!borrowers[borrower]) {\\n      allBorrowers.push(borrower);\\n      borrowers[borrower] = true;\\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\\n    }\\n\\n    emit MarketEntered(cToken, borrower);\\n\\n    return Error.NO_ERROR;\\n  }\\n\\n  /**\\n   * @notice Removes asset from sender's account liquidity calculation\\n   * @dev Sender must not have an outstanding borrow balance in the asset,\\n   *  or be providing necessary collateral for an outstanding borrow.\\n   * @param cTokenAddress The address of the asset to be removed\\n   * @return Whether or not the account successfully exited the market\\n   */\\n  function exitMarket(address cTokenAddress) external override isAuthorized returns (uint256) {\\n    // TODO\\n    require(markets[cTokenAddress].isListed, \\\"!Comptroller:exitMarket\\\");\\n\\n    ICErc20 cToken = ICErc20(cTokenAddress);\\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\\n    require(oErr == 0, \\\"!exitMarket\\\"); // semi-opaque error code\\n\\n    /* Fail if the sender has a borrow balance */\\n    if (amountOwed != 0) {\\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\\n    }\\n\\n    /* Fail if the sender is not permitted to redeem all of their tokens */\\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\\n    if (allowed != 0) {\\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\\n    }\\n\\n    Market storage marketToExit = markets[cTokenAddress];\\n\\n    /* Return true if the sender is not already \\u2018in\\u2019 the market */\\n    if (!marketToExit.accountMembership[msg.sender]) {\\n      return uint256(Error.NO_ERROR);\\n    }\\n\\n    /* Set cToken account membership to false */\\n    delete marketToExit.accountMembership[msg.sender];\\n\\n    /* Delete cToken from the account\\u2019s list of assets */\\n    // load into memory for faster iteration\\n    ICErc20[] memory userAssetList = accountAssets[msg.sender];\\n    uint256 len = userAssetList.length;\\n    uint256 assetIndex = len;\\n    for (uint256 i = 0; i < len; i++) {\\n      if (userAssetList[i] == ICErc20(cTokenAddress)) {\\n        assetIndex = i;\\n        break;\\n      }\\n    }\\n\\n    // We *must* have found the asset in the list or our redundant data structure is broken\\n    assert(assetIndex < len);\\n\\n    // copy last item in list to location of item to be removed, reduce length by 1\\n    ICErc20[] storage storedList = accountAssets[msg.sender];\\n    storedList[assetIndex] = storedList[storedList.length - 1];\\n    storedList.pop();\\n\\n    // If the user has exited all markets, remove them from the `allBorrowers` array\\n    if (storedList.length == 0) {\\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\\n      allBorrowers.pop(); // Reduce length by 1\\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\\n    }\\n\\n    emit MarketExited(ICErc20(cTokenAddress), msg.sender);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /*** Policy Hooks ***/\\n\\n  /**\\n   * @notice Checks if the account should be allowed to mint tokens in the given market\\n   * @param cTokenAddress The market to verify the mint against\\n   * @param minter The account which would get the minted tokens\\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n   */\\n  function mintAllowed(address cTokenAddress, address minter, uint256 mintAmount) external override returns (uint256) {\\n    // Pausing is a very serious situation - we revert to sound the alarms\\n    require(!mintGuardianPaused[cTokenAddress], \\\"!mint:paused\\\");\\n\\n    // Make sure market is listed\\n    if (!markets[cTokenAddress].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    // Make sure minter is whitelisted\\n    if (enforceWhitelist && !whitelist[minter]) {\\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\\n    }\\n\\n    uint256 supplyCap = effectiveSupplyCaps(cTokenAddress);\\n\\n    // Supply cap of 0 corresponds to unlimited supplying\\n    if (supplyCap != 0 && !supplyCapWhitelist[cTokenAddress].contains(minter)) {\\n      uint256 totalUnderlyingSupply = ICErc20(cTokenAddress).getTotalUnderlyingSupplied();\\n      uint256 whitelistedSuppliersSupply = asComptrollerExtension().getWhitelistedSuppliersSupply(cTokenAddress);\\n      uint256 nonWhitelistedTotalSupply;\\n      if (whitelistedSuppliersSupply >= totalUnderlyingSupply) nonWhitelistedTotalSupply = 0;\\n      else nonWhitelistedTotalSupply = totalUnderlyingSupply - whitelistedSuppliersSupply;\\n\\n      require(nonWhitelistedTotalSupply + mintAmount < supplyCap, \\\"!supply cap\\\");\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreSupplierAction(cTokenAddress, minter);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\\n   * @param cToken The market to verify the redeem against\\n   * @param redeemer The account which would redeem the tokens\\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n   */\\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external override returns (uint256) {\\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\\n    if (allowed != uint256(Error.NO_ERROR)) {\\n      return allowed;\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreSupplierAction(cToken, redeemer);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  function redeemAllowedInternal(\\n    address cToken,\\n    address redeemer,\\n    uint256 redeemTokens\\n  ) internal view returns (uint256) {\\n    if (!markets[cToken].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\n    if (!markets[cToken].accountMembership[redeemer]) {\\n      return uint256(Error.NO_ERROR);\\n    }\\n\\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\n    (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\\n      redeemer,\\n      ICErc20(cToken),\\n      redeemTokens,\\n      0,\\n      0\\n    );\\n    if (err != Error.NO_ERROR) {\\n      return uint256(err);\\n    }\\n    if (shortfall > 0) {\\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\\n    }\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Validates mint and reverts on rejection. May emit logs.\\n   * @param cToken Asset being minted\\n   * @param minter The address minting the tokens\\n   * @param actualMintAmount The amount of the underlying asset being minted\\n   * @param mintTokens The number of tokens being minted\\n   */\\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\\n    // Add minter to suppliers mapping\\n    suppliers[minter] = true;\\n  }\\n\\n  /**\\n   * @notice Validates redeem and reverts on rejection. May emit logs.\\n   * @param cToken Asset being redeemed\\n   * @param redeemer The address redeeming the tokens\\n   * @param redeemAmount The amount of the underlying asset being redeemed\\n   * @param redeemTokens The number of tokens being redeemed\\n   */\\n  function redeemVerify(\\n    address cToken,\\n    address redeemer,\\n    uint256 redeemAmount,\\n    uint256 redeemTokens\\n  ) external override {\\n    require(markets[msg.sender].isListed, \\\"!market\\\");\\n\\n    // Require tokens is zero or amount is also zero\\n    if (redeemTokens == 0 && redeemAmount > 0) {\\n      revert(\\\"!zero\\\");\\n    }\\n  }\\n\\n  function getMaxRedeemOrBorrow(\\n    address account,\\n    ICErc20 cTokenModify,\\n    bool isBorrow\\n  ) external view override returns (uint256) {\\n    address cToken = address(cTokenModify);\\n    // Accrue interest\\n    uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\\n\\n    // Get account liquidity\\n    (Error err, , uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\\n      account,\\n      isBorrow ? cTokenModify : ICErc20(address(0)),\\n      0,\\n      0,\\n      0\\n    );\\n    require(err == Error.NO_ERROR, \\\"!liquidity\\\");\\n    if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\\n\\n    // Get max borrow/redeem\\n    uint256 maxBorrowOrRedeemAmount;\\n\\n    if (!isBorrow && !markets[cToken].accountMembership[account]) {\\n      // Max redeem = balance of underlying if not used as collateral\\n      maxBorrowOrRedeemAmount = balanceOfUnderlying;\\n    } else {\\n      // Avoid \\\"stack too deep\\\" error by separating this logic\\n      maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\\n\\n      // Redeem only: max out at underlying balance\\n      if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\\n    }\\n\\n    // Get max borrow or redeem considering cToken liquidity\\n    uint256 cTokenLiquidity = cTokenModify.getCash();\\n\\n    // Return the minimum of the two maximums\\n    return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\\n  }\\n\\n  /**\\n   * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \\\"stack too deep\\\" errors.\\n   */\\n  function _getMaxRedeemOrBorrow(\\n    uint256 liquidity,\\n    ICErc20 cTokenModify,\\n    bool isBorrow\\n  ) internal view returns (uint256) {\\n    if (liquidity == 0) return 0; // No available account liquidity, so no more borrow/redeem\\n\\n    // Get the normalized price of the asset\\n    uint256 conversionFactor = oracle.getUnderlyingPrice(cTokenModify);\\n    require(conversionFactor > 0, \\\"!oracle\\\");\\n\\n    // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\n    if (!isBorrow) {\\n      uint256 collateralFactorMantissa = markets[address(cTokenModify)].collateralFactorMantissa;\\n      conversionFactor = (collateralFactorMantissa * conversionFactor) / 1e18;\\n    }\\n\\n    // Get max borrow or redeem considering excess account liquidity\\n    return (liquidity * 1e18) / conversionFactor;\\n  }\\n\\n  /**\\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n   * @param cToken The market to verify the borrow against\\n   * @param borrower The account which would borrow the asset\\n   * @param borrowAmount The amount of underlying the account would borrow\\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n   */\\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external override returns (uint256) {\\n    // Pausing is a very serious situation - we revert to sound the alarms\\n    require(!borrowGuardianPaused[cToken], \\\"!borrow:paused\\\");\\n\\n    // Make sure market is listed\\n    if (!markets[cToken].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    if (!markets[cToken].accountMembership[borrower]) {\\n      // only cTokens may call borrowAllowed if borrower not in market\\n      require(msg.sender == cToken, \\\"!ctoken\\\");\\n\\n      // attempt to add borrower to the market\\n      Error err = addToMarketInternal(ICErc20(msg.sender), borrower);\\n      if (err != Error.NO_ERROR) {\\n        return uint256(err);\\n      }\\n\\n      // it should be impossible to break the important invariant\\n      assert(markets[cToken].accountMembership[borrower]);\\n    }\\n\\n    // Make sure oracle price is available\\n    if (oracle.getUnderlyingPrice(ICErc20(cToken)) == 0) {\\n      return uint256(Error.PRICE_ERROR);\\n    }\\n\\n    // Make sure borrower is whitelisted\\n    if (enforceWhitelist && !whitelist[borrower]) {\\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\\n    }\\n\\n    uint256 borrowCap = effectiveBorrowCaps(cToken);\\n\\n    // Borrow cap of 0 corresponds to unlimited borrowing\\n    if (borrowCap != 0 && !borrowCapWhitelist[cToken].contains(borrower)) {\\n      uint256 totalBorrows = ICErc20(cToken).totalBorrowsCurrent();\\n      uint256 whitelistedBorrowersBorrows = asComptrollerExtension().getWhitelistedBorrowersBorrows(cToken);\\n      uint256 nonWhitelistedTotalBorrows;\\n      if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\\n      else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\\n\\n      require(nonWhitelistedTotalBorrows + borrowAmount < borrowCap, \\\"!borrow:cap\\\");\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreBorrowerAction(cToken, borrower);\\n\\n    // Perform a hypothetical liquidity check to guard against shortfall\\n    (uint256 err, , , uint256 shortfall) = this.getHypotheticalAccountLiquidity(borrower, cToken, 0, borrowAmount, 0);\\n    if (err != uint256(Error.NO_ERROR)) {\\n      return err;\\n    }\\n    if (shortfall > 0) {\\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\\n    }\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\n   * @param cToken Asset whose underlying is being borrowed\\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\\n   */\\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view override returns (uint256) {\\n    // Check if min borrow exists\\n    uint256 minBorrowEth = IFeeDistributor(ionicAdmin).minBorrowEth();\\n\\n    if (minBorrowEth > 0) {\\n      // Get new underlying borrow balance of account for this cToken\\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(ICErc20(cToken));\\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\\n        Exp({ mantissa: oraclePriceMantissa }),\\n        accountBorrowsNew\\n      );\\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\\n\\n      // Check against min borrow\\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\\n    }\\n\\n    // Return no error\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\\n   * @param cToken The market to verify the repay against\\n   * @param payer The account which would repay the asset\\n   * @param borrower The account which would borrowed the asset\\n   * @param repayAmount The amount of the underlying asset the account would repay\\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n   */\\n  function repayBorrowAllowed(\\n    address cToken,\\n    address payer,\\n    address borrower,\\n    uint256 repayAmount\\n  ) external override returns (uint256) {\\n    // Make sure market is listed\\n    if (!markets[cToken].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreBorrowerAction(cToken, borrower);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the liquidation should be allowed to occur\\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\\n   * @param liquidator The address repaying the borrow and seizing the collateral\\n   * @param borrower The address of the borrower\\n   * @param repayAmount The amount of underlying being repaid\\n   */\\n  function liquidateBorrowAllowed(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount\\n  ) external override returns (uint256) {\\n    // Make sure markets are listed\\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    // Get borrowers' underlying borrow balance\\n    uint256 borrowBalance = ICErc20(cTokenBorrowed).borrowBalanceCurrent(borrower);\\n\\n    /* allow accounts to be liquidated if the market is deprecated */\\n    if (isDeprecated(ICErc20(cTokenBorrowed))) {\\n      require(borrowBalance >= repayAmount, \\\"!borrow>repay\\\");\\n    } else {\\n      /* The borrower must have shortfall in order to be liquidateable */\\n      (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\\n        borrower,\\n        ICErc20(address(0)),\\n        0,\\n        0,\\n        0\\n      );\\n      if (err != Error.NO_ERROR) {\\n        return uint256(err);\\n      }\\n\\n      if (shortfall == 0) {\\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\\n      }\\n\\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\\n      if (repayAmount > maxClose) {\\n        return uint256(Error.TOO_MUCH_REPAY);\\n      }\\n    }\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the seizing of assets should be allowed to occur\\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\\n   * @param liquidator The address repaying the borrow and seizing the collateral\\n   * @param borrower The address of the borrower\\n   * @param seizeTokens The number of collateral tokens to seize\\n   */\\n  function seizeAllowed(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens\\n  ) external override returns (uint256) {\\n    // Pausing is a very serious situation - we revert to sound the alarms\\n    require(!seizeGuardianPaused, \\\"!seize:paused\\\");\\n\\n    // Make sure markets are listed\\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\\n      return uint256(Error.MARKET_NOT_LISTED);\\n    }\\n\\n    // Make sure cToken Comptrollers are identical\\n    if (ICErc20(cTokenCollateral).comptroller() != ICErc20(cTokenBorrowed).comptroller()) {\\n      return uint256(Error.COMPTROLLER_MISMATCH);\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\\n   * @param cToken The market to verify the transfer against\\n   * @param src The account which sources the tokens\\n   * @param dst The account which receives the tokens\\n   * @param transferTokens The number of cTokens to transfer\\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n   */\\n  function transferAllowed(\\n    address cToken,\\n    address src,\\n    address dst,\\n    uint256 transferTokens\\n  ) external override returns (uint256) {\\n    // Pausing is a very serious situation - we revert to sound the alarms\\n    require(!transferGuardianPaused, \\\"!transfer:paused\\\");\\n\\n    // Currently the only consideration is whether or not\\n    //  the src is allowed to redeem this many tokens\\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\\n    if (allowed != uint256(Error.NO_ERROR)) {\\n      return allowed;\\n    }\\n\\n    // Keep the flywheel moving\\n    flywheelPreTransferAction(cToken, src, dst);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /*** Flywheel Hooks ***/\\n\\n  /**\\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\\n   * @param cToken The relevant market\\n   * @param supplier The minter/redeemer\\n   */\\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\\n  }\\n\\n  /**\\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\\n   * @param cToken The relevant market\\n   * @param borrower The borrower\\n   */\\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\\n  }\\n\\n  /**\\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\\n   * @param cToken The relevant market\\n   * @param src The account which sources the tokens\\n   * @param dst The account which receives the tokens\\n   */\\n  function flywheelPreTransferAction(address cToken, address src, address dst) internal {\\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\\n  }\\n\\n  /*** Liquidity/Liquidation Calculations ***/\\n\\n  /**\\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\\n   */\\n  struct AccountLiquidityLocalVars {\\n    ICErc20 asset;\\n    uint256 sumCollateral;\\n    uint256 sumBorrowPlusEffects;\\n    uint256 cTokenBalance;\\n    uint256 borrowBalance;\\n    uint256 exchangeRateMantissa;\\n    uint256 oraclePriceMantissa;\\n    Exp collateralFactor;\\n    Exp exchangeRate;\\n    Exp oraclePrice;\\n    Exp tokensToDenom;\\n    uint256 borrowCapForCollateral;\\n    uint256 borrowedAssetPrice;\\n    uint256 assetAsCollateralValueCap;\\n  }\\n\\n  function getAccountLiquidity(address account) public view override returns (uint256, uint256, uint256, uint256) {\\n    (\\n      Error err,\\n      uint256 collateralValue,\\n      uint256 liquidity,\\n      uint256 shortfall\\n    ) = getHypotheticalAccountLiquidityInternal(account, ICErc20(address(0)), 0, 0, 0);\\n    return (uint256(err), collateralValue, liquidity, shortfall);\\n  }\\n\\n  /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param cTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return (possible error code (semi-opaque),\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n  function getHypotheticalAccountLiquidity(\\n    address account,\\n    address cTokenModify,\\n    uint256 redeemTokens,\\n    uint256 borrowAmount,\\n    uint256 repayAmount\\n  ) public view returns (uint256, uint256, uint256, uint256) {\\n    (\\n      Error err,\\n      uint256 collateralValue,\\n      uint256 liquidity,\\n      uint256 shortfall\\n    ) = getHypotheticalAccountLiquidityInternal(\\n        account,\\n        ICErc20(cTokenModify),\\n        redeemTokens,\\n        borrowAmount,\\n        repayAmount\\n      );\\n    return (uint256(err), collateralValue, liquidity, shortfall);\\n  }\\n\\n  /**\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\n     * @param cTokenModify The market to hypothetically redeem/borrow in\\n     * @param account The account to determine liquidity for\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\n     * @return (possible error code,\\n                hypothetical account collateral value,\\n                hypothetical account liquidity in excess of collateral requirements,\\n     *          hypothetical account shortfall below collateral requirements)\\n     */\\n  function getHypotheticalAccountLiquidityInternal(\\n    address account,\\n    ICErc20 cTokenModify,\\n    uint256 redeemTokens,\\n    uint256 borrowAmount,\\n    uint256 repayAmount\\n  ) internal view returns (Error, uint256, uint256, uint256) {\\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\\n\\n    if (address(cTokenModify) != address(0)) {\\n      vars.borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\\n    }\\n\\n    // For each asset the account is in\\n    for (uint256 i = 0; i < accountAssets[account].length; i++) {\\n      vars.asset = accountAssets[account][i];\\n\\n      {\\n        // Read the balances and exchange rate from the cToken\\n        uint256 oErr;\\n        (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vars.asset.getAccountSnapshot(\\n          account\\n        );\\n        if (oErr != 0) {\\n          // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\\n          return (Error.SNAPSHOT_ERROR, 0, 0, 0);\\n        }\\n      }\\n      {\\n        vars.collateralFactor = Exp({ mantissa: markets[address(vars.asset)].collateralFactorMantissa });\\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\\n\\n        // Get the normalized price of the asset\\n        vars.oraclePriceMantissa = oracle.getUnderlyingPrice(vars.asset);\\n        if (vars.oraclePriceMantissa == 0) {\\n          return (Error.PRICE_ERROR, 0, 0, 0);\\n        }\\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\\n\\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\\n      }\\n      {\\n        // Exclude the asset-to-be-borrowed from the liquidity, except for when redeeming\\n        vars.assetAsCollateralValueCap = asComptrollerExtension().getAssetAsCollateralValueCap(\\n          vars.asset,\\n          cTokenModify,\\n          redeemTokens > 0,\\n          account\\n        );\\n\\n        // accumulate the collateral value to sumCollateral\\n        uint256 assetCollateralValue = mul_ScalarTruncate(vars.tokensToDenom, vars.cTokenBalance);\\n        if (assetCollateralValue > vars.assetAsCollateralValueCap)\\n          assetCollateralValue = vars.assetAsCollateralValueCap;\\n        vars.sumCollateral += assetCollateralValue;\\n      }\\n\\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n        vars.oraclePrice,\\n        vars.borrowBalance,\\n        vars.sumBorrowPlusEffects\\n      );\\n\\n      // Calculate effects of interacting with cTokenModify\\n      if (vars.asset == cTokenModify) {\\n        // redeem effect\\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n          vars.tokensToDenom,\\n          redeemTokens,\\n          vars.sumBorrowPlusEffects\\n        );\\n\\n        // borrow effect\\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\\n          vars.oraclePrice,\\n          borrowAmount,\\n          vars.sumBorrowPlusEffects\\n        );\\n\\n        uint256 repayEffect = mul_ScalarTruncate(vars.oraclePrice, repayAmount);\\n        if (repayEffect >= vars.sumBorrowPlusEffects) {\\n          vars.sumBorrowPlusEffects = 0;\\n        } else {\\n          vars.sumBorrowPlusEffects -= repayEffect;\\n        }\\n      }\\n    }\\n\\n    // These are safe, as the underflow condition is checked first\\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\\n      return (Error.NO_ERROR, vars.sumCollateral, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\\n    } else {\\n      return (Error.NO_ERROR, vars.sumCollateral, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\\n   * @param cTokenBorrowed The address of the borrowed cToken\\n   * @param cTokenCollateral The address of the collateral cToken\\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\\n   */\\n  function liquidateCalculateSeizeTokens(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    uint256 actualRepayAmount\\n  ) external view override returns (uint256, uint256) {\\n    /* Read oracle prices for borrowed and collateral markets */\\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenBorrowed));\\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenCollateral));\\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\\n      return (uint256(Error.PRICE_ERROR), 0);\\n    }\\n\\n    /*\\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\n     *  seizeTokens = seizeAmount / exchangeRate\\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n     */\\n    ICErc20 collateralCToken = ICErc20(cTokenCollateral);\\n    uint256 exchangeRateMantissa = collateralCToken.exchangeRateCurrent();\\n    uint256 seizeTokens;\\n    Exp memory numerator;\\n    Exp memory denominator;\\n    Exp memory ratio;\\n\\n    uint256 protocolSeizeShareMantissa = collateralCToken.protocolSeizeShareMantissa();\\n    uint256 feeSeizeShareMantissa = collateralCToken.feeSeizeShareMantissa();\\n\\n    /*\\n     * The liquidation penalty includes\\n     * - the liquidator incentive\\n     * - the protocol fees (Ionic admin fees)\\n     * - the market fee\\n     */\\n    Exp memory totalPenaltyMantissa = add_(\\n      add_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: protocolSeizeShareMantissa })),\\n      Exp({ mantissa: feeSeizeShareMantissa })\\n    );\\n\\n    numerator = mul_(totalPenaltyMantissa, Exp({ mantissa: priceBorrowedMantissa }));\\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\\n    ratio = div_(numerator, denominator);\\n\\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\n    return (uint256(Error.NO_ERROR), seizeTokens);\\n  }\\n\\n  /*** Admin Functions ***/\\n\\n  /**\\n   * @notice Add a RewardsDistributor contracts.\\n   * @dev Admin function to add a RewardsDistributor contract\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\\n    require(hasAdminRights(), \\\"!admin\\\");\\n\\n    // Check marker method\\n    require(IIonicFlywheel(distributor).isRewardsDistributor(), \\\"!isRewardsDistributor\\\");\\n\\n    // Check for existing RewardsDistributor\\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) require(distributor != rewardsDistributors[i], \\\"!added\\\");\\n\\n    // Add RewardsDistributor to array\\n    rewardsDistributors.push(distributor);\\n    emit AddedRewardsDistributor(distributor);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets the whitelist enforcement for the comptroller\\n   * @dev Admin function to set a new whitelist enforcement boolean\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\\n    }\\n\\n    // Check if `enforceWhitelist` already equals `enforce`\\n    if (enforceWhitelist == enforce) {\\n      return uint256(Error.NO_ERROR);\\n    }\\n\\n    // Set comptroller's `enforceWhitelist` to `enforce`\\n    enforceWhitelist = enforce;\\n\\n    // Emit WhitelistEnforcementChanged(bool enforce);\\n    emit WhitelistEnforcementChanged(enforce);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets the whitelist `statuses` for `suppliers`\\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\\n    }\\n\\n    // Set whitelist statuses for suppliers\\n    for (uint256 i = 0; i < suppliers.length; i++) {\\n      address supplier = suppliers[i];\\n\\n      if (statuses[i]) {\\n        // If not already whitelisted, add to whitelist\\n        if (!whitelist[supplier]) {\\n          whitelist[supplier] = true;\\n          whitelistArray.push(supplier);\\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\\n        }\\n      } else {\\n        // If whitelisted, remove from whitelist\\n        if (whitelist[supplier]) {\\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\\n          whitelistArray.pop(); // Reduce length by 1\\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\\n        }\\n      }\\n    }\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets a new price oracle for the comptroller\\n   * @dev Admin function to set a new price oracle\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setPriceOracle(BasePriceOracle newOracle) public returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\\n    }\\n\\n    // Track the old oracle for the comptroller\\n    BasePriceOracle oldOracle = oracle;\\n\\n    // Set comptroller's oracle to newOracle\\n    oracle = newOracle;\\n\\n    // Emit NewPriceOracle(oldOracle, newOracle)\\n    emit NewPriceOracle(oldOracle, newOracle);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets the closeFactor used when liquidating borrows\\n   * @dev Admin function to set closeFactor\\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n   */\\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\\n    }\\n\\n    // Check limits\\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\\n    }\\n\\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\\n    }\\n\\n    // Set pool close factor to new close factor, remember old value\\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\\n    closeFactorMantissa = newCloseFactorMantissa;\\n\\n    // Emit event\\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets the collateralFactor for a market\\n   * @dev Admin function to set per-market collateralFactor\\n   * @param cToken The market to set the factor on\\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n   */\\n  function _setCollateralFactor(ICErc20 cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\\n    }\\n\\n    // Verify market is listed\\n    Market storage market = markets[address(cToken)];\\n    if (!market.isListed) {\\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\\n    }\\n\\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\\n\\n    // Check collateral factor <= 0.9\\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\\n    }\\n\\n    // If collateral factor != 0, fail if price == 0\\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\\n    }\\n\\n    // Set market's collateral factor to new collateral factor, remember old value\\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\\n\\n    // Emit event with asset, old collateral factor, and new collateral factor\\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets liquidationIncentive\\n   * @dev Admin function to set liquidationIncentive\\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\\n   */\\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\\n    }\\n\\n    // Check de-scaled min <= newLiquidationIncentive <= max\\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\\n    }\\n\\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\\n    }\\n\\n    // Save current value for use in log\\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\n\\n    // Set liquidation incentive to new incentive\\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\n\\n    // Emit event with old incentive, new incentive\\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Add the market to the markets mapping and set it as listed\\n   * @dev Admin function to set isListed and add support for the market\\n   * @param cToken The address of the market (token) to list\\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n   */\\n  function _supportMarket(ICErc20 cToken) internal returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\\n    }\\n\\n    // Is market already listed?\\n    if (markets[address(cToken)].isListed) {\\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\\n    }\\n\\n    // Check cToken.comptroller == this\\n    require(address(cToken.comptroller()) == address(this), \\\"!comptroller\\\");\\n\\n    // Make sure market is not already listed\\n    address underlying = ICErc20(address(cToken)).underlying();\\n\\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\\n    }\\n\\n    // List market and emit event\\n    Market storage market = markets[address(cToken)];\\n    market.isListed = true;\\n    market.collateralFactorMantissa = 0;\\n    allMarkets.push(cToken);\\n    cTokensByUnderlying[underlying] = cToken;\\n    emit MarketListed(cToken);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n   */\\n  function _deployMarket(\\n    uint8 delegateType,\\n    bytes calldata constructorData,\\n    bytes calldata becomeImplData,\\n    uint256 collateralFactorMantissa\\n  ) external returns (uint256) {\\n    // Check caller is admin\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\\n    }\\n\\n    // Temporarily enable Ionic admin rights for asset deployment (storing the original value)\\n    bool oldIonicAdminHasRights = ionicAdminHasRights;\\n    ionicAdminHasRights = true;\\n\\n    // Deploy via Ionic admin\\n    ICErc20 cToken = ICErc20(IFeeDistributor(ionicAdmin).deployCErc20(delegateType, constructorData, becomeImplData));\\n    // Reset Ionic admin rights to the original value\\n    ionicAdminHasRights = oldIonicAdminHasRights;\\n    // Support market here in the Comptroller\\n    uint256 err = _supportMarket(cToken);\\n\\n    IFeeDistributor(ionicAdmin).authoritiesRegistry().reconfigureAuthority(address(this));\\n\\n    // Set collateral factor\\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\\n  }\\n\\n  function _becomeImplementation() external {\\n    require(msg.sender == address(this), \\\"!self call\\\");\\n\\n    if (!_notEnteredInitialized) {\\n      _notEntered = true;\\n      _notEnteredInitialized = true;\\n    }\\n  }\\n\\n  /*** Helper Functions ***/\\n\\n  /**\\n   * @notice Returns true if the given cToken market has been deprecated\\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\\n   * @param cToken The market to check if deprecated\\n   */\\n  function isDeprecated(ICErc20 cToken) public view returns (bool) {\\n    return\\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\\n      borrowGuardianPaused[address(cToken)] == true &&\\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.ionicFeeMantissa()) == 1e18;\\n  }\\n\\n  function asComptrollerExtension() internal view returns (ComptrollerExtensionInterface) {\\n    return ComptrollerExtensionInterface(address(this));\\n  }\\n\\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory functionSelectors) {\\n    uint8 fnsCount = 32;\\n\\n    functionSelectors = new bytes4[](fnsCount);\\n\\n    functionSelectors[--fnsCount] = this.isDeprecated.selector;\\n    functionSelectors[--fnsCount] = this._deployMarket.selector;\\n    functionSelectors[--fnsCount] = this.getAssetsIn.selector;\\n    functionSelectors[--fnsCount] = this.checkMembership.selector;\\n    functionSelectors[--fnsCount] = this._setPriceOracle.selector;\\n    functionSelectors[--fnsCount] = this._setCloseFactor.selector;\\n    functionSelectors[--fnsCount] = this._setCollateralFactor.selector;\\n    functionSelectors[--fnsCount] = this._setLiquidationIncentive.selector;\\n    functionSelectors[--fnsCount] = this._setWhitelistEnforcement.selector;\\n    functionSelectors[--fnsCount] = this._setWhitelistStatuses.selector;\\n    functionSelectors[--fnsCount] = this._addRewardsDistributor.selector;\\n    functionSelectors[--fnsCount] = this.getHypotheticalAccountLiquidity.selector;\\n    functionSelectors[--fnsCount] = this.getMaxRedeemOrBorrow.selector;\\n    functionSelectors[--fnsCount] = this.enterMarkets.selector;\\n    functionSelectors[--fnsCount] = this.exitMarket.selector;\\n    functionSelectors[--fnsCount] = this.mintAllowed.selector;\\n    functionSelectors[--fnsCount] = this.redeemAllowed.selector;\\n    functionSelectors[--fnsCount] = this.redeemVerify.selector;\\n    functionSelectors[--fnsCount] = this.borrowAllowed.selector;\\n    functionSelectors[--fnsCount] = this.borrowWithinLimits.selector;\\n    functionSelectors[--fnsCount] = this.repayBorrowAllowed.selector;\\n    functionSelectors[--fnsCount] = this.liquidateBorrowAllowed.selector;\\n    functionSelectors[--fnsCount] = this.seizeAllowed.selector;\\n    functionSelectors[--fnsCount] = this.transferAllowed.selector;\\n    functionSelectors[--fnsCount] = this.mintVerify.selector;\\n    functionSelectors[--fnsCount] = this.getAccountLiquidity.selector;\\n    functionSelectors[--fnsCount] = this.liquidateCalculateSeizeTokens.selector;\\n    functionSelectors[--fnsCount] = this._beforeNonReentrant.selector;\\n    functionSelectors[--fnsCount] = this._afterNonReentrant.selector;\\n    functionSelectors[--fnsCount] = this._becomeImplementation.selector;\\n    functionSelectors[--fnsCount] = this.effectiveSupplyCaps.selector;\\n    functionSelectors[--fnsCount] = this.effectiveBorrowCaps.selector;\\n\\n    require(fnsCount == 0, \\\"use the correct array length\\\");\\n  }\\n\\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\\n\\n  /**\\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\\n   */\\n  function _beforeNonReentrant() external override {\\n    require(markets[msg.sender].isListed, \\\"!Comptroller:_beforeNonReentrant\\\");\\n    require(_notEntered, \\\"!reentered\\\");\\n    _notEntered = false;\\n  }\\n\\n  /**\\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\\n   */\\n  function _afterNonReentrant() external override {\\n    require(markets[msg.sender].isListed, \\\"!Comptroller:_afterNonReentrant\\\");\\n    _notEntered = true; // get a gas-refund post-Istanbul\\n  }\\n}\\n\",\"keccak256\":\"0x99b5df813bb4a7619169842591460bd0a13dc2f544f683f4420741bc28079e8a\",\"license\":\"UNLICENSED\"},\"contracts/compound/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport { BasePriceOracle } from \\\"../oracles/BasePriceOracle.sol\\\";\\nimport { ICErc20 } from \\\"./CTokenInterfaces.sol\\\";\\nimport { DiamondExtension } from \\\"../ionic/DiamondExtension.sol\\\";\\nimport { ComptrollerV4Storage } from \\\"../compound/ComptrollerStorage.sol\\\";\\nimport { PrudentiaLib } from \\\"../adrastia/PrudentiaLib.sol\\\";\\nimport { IHistoricalRates } from \\\"adrastia-periphery/rates/IHistoricalRates.sol\\\";\\n\\ninterface ComptrollerInterface {\\n  function isDeprecated(ICErc20 cToken) external view returns (bool);\\n\\n  function _becomeImplementation() external;\\n\\n  function _deployMarket(\\n    uint8 delegateType,\\n    bytes memory constructorData,\\n    bytes calldata becomeImplData,\\n    uint256 collateralFactorMantissa\\n  ) external returns (uint256);\\n\\n  function getAssetsIn(address account) external view returns (ICErc20[] memory);\\n\\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool);\\n\\n  function _setPriceOracle(BasePriceOracle newOracle) external returns (uint256);\\n\\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\\n\\n  function _setCollateralFactor(ICErc20 market, uint256 newCollateralFactorMantissa) external returns (uint256);\\n\\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\\n\\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\\n\\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\\n\\n  function _addRewardsDistributor(address distributor) external returns (uint256);\\n\\n  function getHypotheticalAccountLiquidity(\\n    address account,\\n    address cTokenModify,\\n    uint256 redeemTokens,\\n    uint256 borrowAmount,\\n    uint256 repayAmount\\n  ) external view returns (uint256, uint256, uint256, uint256);\\n\\n  function getMaxRedeemOrBorrow(address account, ICErc20 cToken, bool isBorrow) external view returns (uint256);\\n\\n  /*** Assets You Are In ***/\\n\\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\\n\\n  function exitMarket(address cToken) external returns (uint256);\\n\\n  /*** Policy Hooks ***/\\n\\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\\n\\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\\n\\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\\n\\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\\n\\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view returns (uint256);\\n\\n  function repayBorrowAllowed(\\n    address cToken,\\n    address payer,\\n    address borrower,\\n    uint256 repayAmount\\n  ) external returns (uint256);\\n\\n  function liquidateBorrowAllowed(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    address liquidator,\\n    address borrower,\\n    uint256 repayAmount\\n  ) external returns (uint256);\\n\\n  function seizeAllowed(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint256 seizeTokens\\n  ) external returns (uint256);\\n\\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\\n\\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external;\\n\\n  /*** Liquidity/Liquidation Calculations ***/\\n\\n  function getAccountLiquidity(\\n    address account\\n  ) external view returns (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall);\\n\\n  function liquidateCalculateSeizeTokens(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    uint256 repayAmount\\n  ) external view returns (uint256, uint256);\\n\\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\\n\\n  function _beforeNonReentrant() external;\\n\\n  function _afterNonReentrant() external;\\n\\n  /*** New supply and borrow cap view functions ***/\\n\\n  /**\\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveSupplyCaps(address cToken) external view returns (uint256 supplyCap);\\n\\n  /**\\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveBorrowCaps(address cToken) external view returns (uint256 borrowCap);\\n}\\n\\ninterface ComptrollerStorageInterface {\\n  function admin() external view returns (address);\\n\\n  function adminHasRights() external view returns (bool);\\n\\n  function ionicAdmin() external view returns (address);\\n\\n  function ionicAdminHasRights() external view returns (bool);\\n\\n  function pendingAdmin() external view returns (address);\\n\\n  function oracle() external view returns (BasePriceOracle);\\n\\n  function pauseGuardian() external view returns (address);\\n\\n  function closeFactorMantissa() external view returns (uint256);\\n\\n  function liquidationIncentiveMantissa() external view returns (uint256);\\n\\n  function isUserOfPool(address user) external view returns (bool);\\n\\n  function whitelist(address account) external view returns (bool);\\n\\n  function enforceWhitelist() external view returns (bool);\\n\\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\\n\\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\\n\\n  function suppliers(address account) external view returns (bool);\\n\\n  function cTokensByUnderlying(address) external view returns (address);\\n\\n  /**\\n   * Gets the supply cap of a cToken in the units of the underlying asset.\\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the supply cap. Instead, use\\n   * `effectiveSupplyCaps` to get the correct supply cap.\\n   * @param cToken The address of the cToken.\\n   * @return The supply cap in the units of the underlying asset.\\n   */\\n  function supplyCaps(address cToken) external view returns (uint256);\\n\\n  /**\\n   * Gets the borrow cap of a cToken in the units of the underlying asset.\\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the borrow cap. Instead, use\\n   * `effectiveBorrowCaps` to get the correct borrow cap.\\n   * @param cToken The address of the cToken.\\n   * @return The borrow cap in the units of the underlying asset.\\n   */\\n  function borrowCaps(address cToken) external view returns (uint256);\\n\\n  function markets(address cToken) external view returns (bool, uint256);\\n\\n  function accountAssets(address, uint256) external view returns (address);\\n\\n  function borrowGuardianPaused(address cToken) external view returns (bool);\\n\\n  function mintGuardianPaused(address cToken) external view returns (bool);\\n\\n  function rewardsDistributors(uint256) external view returns (address);\\n}\\n\\ninterface SFSRegister {\\n  function register(address _recipient) external returns (uint256 tokenId);\\n}\\n\\ninterface ComptrollerExtensionInterface {\\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\\n\\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\\n\\n  function getAllMarkets() external view returns (ICErc20[] memory);\\n\\n  function getAllBorrowers() external view returns (address[] memory);\\n\\n  function getAllBorrowersCount() external view returns (uint256);\\n\\n  function getPaginatedBorrowers(\\n    uint256 page,\\n    uint256 pageSize\\n  ) external view returns (uint256 _totalPages, address[] memory _pageOfBorrowers);\\n\\n  function getRewardsDistributors() external view returns (address[] memory);\\n\\n  function getAccruingFlywheels() external view returns (address[] memory);\\n\\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) external;\\n\\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) external;\\n\\n  function _setBorrowCapForCollateralWhitelist(\\n    address cTokenBorrow,\\n    address cTokenCollateral,\\n    address account,\\n    bool whitelisted\\n  ) external;\\n\\n  function isBorrowCapForCollateralWhitelisted(\\n    address cTokenBorrow,\\n    address cTokenCollateral,\\n    address account\\n  ) external view returns (bool);\\n\\n  function _blacklistBorrowingAgainstCollateral(\\n    address cTokenBorrow,\\n    address cTokenCollateral,\\n    bool blacklisted\\n  ) external;\\n\\n  function _blacklistBorrowingAgainstCollateralWhitelist(\\n    address cTokenBorrow,\\n    address cTokenCollateral,\\n    address account,\\n    bool whitelisted\\n  ) external;\\n\\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\\n    address cTokenBorrow,\\n    address cTokenCollateral,\\n    address account\\n  ) external view returns (bool);\\n\\n  function isSupplyCapWhitelisted(address cToken, address account) external view returns (bool);\\n\\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) external;\\n\\n  function isBorrowCapWhitelisted(address cToken, address account) external view returns (bool);\\n\\n  function _removeFlywheel(address flywheelAddress) external returns (bool);\\n\\n  function getWhitelist() external view returns (address[] memory);\\n\\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool);\\n\\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external;\\n\\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external;\\n\\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\\n\\n  function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\\n\\n  function _setMintPaused(ICErc20 cToken, bool state) external returns (bool);\\n\\n  function _setBorrowPaused(ICErc20 cToken, bool state) external returns (bool);\\n\\n  function _setTransferPaused(bool state) external returns (bool);\\n\\n  function _setSeizePaused(bool state) external returns (bool);\\n\\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256);\\n\\n  function getAssetAsCollateralValueCap(\\n    ICErc20 collateral,\\n    ICErc20 cTokenModify,\\n    bool redeeming,\\n    address account\\n  ) external view returns (uint256);\\n\\n  function registerInSFS() external returns (uint256);\\n}\\n\\ninterface ComptrollerPrudentiaCapsExtInterface {\\n  /**\\n   * @notice Retrieves Adrastia Prudentia borrow cap config from storage.\\n   * @return The config.\\n   */\\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\\n\\n  /**\\n   * @notice Retrieves Adrastia Prudentia supply cap config from storage.\\n   * @return The config.\\n   */\\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\\n\\n  /**\\n   * @notice Sets the Adrastia Prudentia supply cap config.\\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native supply caps.\\n   * @param newConfig The new config.\\n   */\\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\\n\\n  /**\\n   * @notice Sets the Adrastia Prudentia supply cap config.\\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native borrow caps.\\n   * @param newConfig The new config.\\n   */\\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\\n}\\n\\ninterface UnitrollerInterface {\\n  function comptrollerImplementation() external view returns (address);\\n\\n  function _upgrade() external;\\n\\n  function _acceptAdmin() external returns (uint256);\\n\\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\\n\\n  function _toggleAdminRights(bool hasRights) external returns (uint256);\\n}\\n\\ninterface IComptrollerExtension is ComptrollerExtensionInterface, ComptrollerStorageInterface {}\\n\\n//interface IComptrollerBase is ComptrollerInterface, ComptrollerStorageInterface {}\\n\\ninterface IonicComptroller is\\n  ComptrollerInterface,\\n  ComptrollerExtensionInterface,\\n  UnitrollerInterface,\\n  ComptrollerStorageInterface\\n{\\n\\n}\\n\\nabstract contract ComptrollerBase is ComptrollerV4Storage {\\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\\n  bool public constant isComptroller = true;\\n\\n  /**\\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveSupplyCaps(address cToken) public view virtual returns (uint256 supplyCap) {\\n    PrudentiaLib.PrudentiaConfig memory capConfig = supplyCapConfig;\\n\\n    // Check if we're using Adrastia Prudentia for the supply cap\\n    if (capConfig.controller != address(0)) {\\n      // We have a controller, so we're using Adrastia Prudentia\\n\\n      address underlyingToken = ICErc20(cToken).underlying();\\n\\n      // Get the supply cap from Adrastia Prudentia\\n      supplyCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\\n\\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\\n      // must scale the supply cap to get the correct amount\\n\\n      int256 scaleByDecimals = 18;\\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\\\"decimals()\\\"));\\n      if (success && data.length == 32) {\\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\\n      }\\n\\n      scaleByDecimals += capConfig.decimalShift;\\n\\n      if (scaleByDecimals >= 0) {\\n        // We're scaling up, so we need to multiply\\n        supplyCap *= 10 ** uint256(scaleByDecimals);\\n      } else {\\n        // We're scaling down, so we need to divide\\n        supplyCap /= 10 ** uint256(-scaleByDecimals);\\n      }\\n    } else {\\n      // We don't have a controller, so we're using the local supply cap\\n\\n      // Get the supply cap from the local supply cap\\n      supplyCap = supplyCaps[cToken];\\n    }\\n  }\\n\\n  /**\\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\\n   * @param cToken The address of the cToken.\\n   */\\n  function effectiveBorrowCaps(address cToken) public view virtual returns (uint256 borrowCap) {\\n    PrudentiaLib.PrudentiaConfig memory capConfig = borrowCapConfig;\\n\\n    // Check if we're using Adrastia Prudentia for the borrow cap\\n    if (capConfig.controller != address(0)) {\\n      // We have a controller, so we're using Adrastia Prudentia\\n\\n      address underlyingToken = ICErc20(cToken).underlying();\\n\\n      // Get the borrow cap from Adrastia Prudentia\\n      borrowCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\\n\\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\\n      // must scale the supply cap to get the correct amount\\n\\n      int256 scaleByDecimals = 18;\\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\\\"decimals()\\\"));\\n      if (success && data.length == 32) {\\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\\n      }\\n\\n      scaleByDecimals += capConfig.decimalShift;\\n\\n      if (scaleByDecimals >= 0) {\\n        // We're scaling up, so we need to multiply\\n        borrowCap *= 10 ** uint256(scaleByDecimals);\\n      } else {\\n        // We're scaling down, so we need to divide\\n        borrowCap /= 10 ** uint256(-scaleByDecimals);\\n      }\\n    } else {\\n      // We don't have a controller, so we're using the local borrow cap\\n      borrowCap = borrowCaps[cToken];\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x7632af3b32bc1fccd14255b6885e74c4d5ac8de5f00fb8ed67186810d286424f\",\"license\":\"UNLICENSED\"},\"contracts/compound/ComptrollerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IFeeDistributor.sol\\\";\\nimport \\\"../oracles/BasePriceOracle.sol\\\";\\nimport { ICErc20 } from \\\"./CTokenInterfaces.sol\\\";\\nimport { PrudentiaLib } from \\\"../adrastia/PrudentiaLib.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract UnitrollerAdminStorage {\\n  /*\\n   * Administrator for Ionic\\n   */\\n  address payable public ionicAdmin;\\n\\n  /**\\n   * @notice Administrator for this contract\\n   */\\n  address public admin;\\n\\n  /**\\n   * @notice Pending administrator for this contract\\n   */\\n  address public pendingAdmin;\\n\\n  /**\\n   * @notice Whether or not the Ionic admin has admin rights\\n   */\\n  bool public ionicAdminHasRights = true;\\n\\n  /**\\n   * @notice Whether or not the admin has admin rights\\n   */\\n  bool public adminHasRights = true;\\n\\n  /**\\n   * @notice Returns a boolean indicating if the sender has admin rights\\n   */\\n  function hasAdminRights() internal view returns (bool) {\\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(ionicAdmin) && ionicAdminHasRights);\\n  }\\n}\\n\\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\\n  /**\\n   * @notice Oracle which gives the price of any given asset\\n   */\\n  BasePriceOracle public oracle;\\n\\n  /**\\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n   */\\n  uint256 public closeFactorMantissa;\\n\\n  /**\\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\\n   */\\n  uint256 public liquidationIncentiveMantissa;\\n\\n  /*\\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\\n   */\\n  uint256 internal maxAssets;\\n\\n  /**\\n   * @notice Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n   */\\n  mapping(address => ICErc20[]) public accountAssets;\\n}\\n\\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\\n  struct Market {\\n    // Whether or not this market is listed\\n    bool isListed;\\n    // Multiplier representing the most one can borrow against their collateral in this market.\\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\\n    // Must be between 0 and 1, and stored as a mantissa.\\n    uint256 collateralFactorMantissa;\\n    // Per-market mapping of \\\"accounts in this asset\\\"\\n    mapping(address => bool) accountMembership;\\n  }\\n\\n  /**\\n   * @notice Official mapping of cTokens -> Market metadata\\n   * @dev Used e.g. to determine if a market is supported\\n   */\\n  mapping(address => Market) public markets;\\n\\n  /// @notice A list of all markets\\n  ICErc20[] public allMarkets;\\n\\n  /**\\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\\n   */\\n  mapping(address => bool) internal borrowers;\\n\\n  /// @notice A list of all borrowers who have entered markets\\n  address[] public allBorrowers;\\n\\n  // Indexes of borrower account addresses in the `allBorrowers` array\\n  mapping(address => uint256) internal borrowerIndexes;\\n\\n  /**\\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\\n   */\\n  mapping(address => bool) public suppliers;\\n\\n  /// @notice All cTokens addresses mapped by their underlying token addresses\\n  mapping(address => ICErc20) public cTokensByUnderlying;\\n\\n  /// @notice Whether or not the supplier whitelist is enforced\\n  bool public enforceWhitelist;\\n\\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\\n  mapping(address => bool) public whitelist;\\n\\n  /// @notice An array of all whitelisted accounts\\n  address[] public whitelistArray;\\n\\n  // Indexes of account addresses in the `whitelistArray` array\\n  mapping(address => uint256) internal whitelistIndexes;\\n\\n  /**\\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n   *  Actions which allow users to remove their own assets cannot be paused.\\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n   */\\n  address public pauseGuardian;\\n  bool public _mintGuardianPaused;\\n  bool public _borrowGuardianPaused;\\n  bool public transferGuardianPaused;\\n  bool public seizeGuardianPaused;\\n  mapping(address => bool) public mintGuardianPaused;\\n  mapping(address => bool) public borrowGuardianPaused;\\n}\\n\\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\n  /// @dev If Adrastia Prudentia is enabled, the values the borrow cap guardian sets are ignored.\\n  address public borrowCapGuardian;\\n\\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveBorrowCaps` instead.\\n  mapping(address => uint256) public borrowCaps;\\n\\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveSupplyCaps` instead.\\n  mapping(address => uint256) public supplyCaps;\\n\\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\\n  address[] public rewardsDistributors;\\n\\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\\n  bool internal _notEntered;\\n\\n  /// @dev Whether or not _notEntered has been initialized\\n  bool internal _notEnteredInitialized;\\n\\n  /// @notice RewardsDistributor to list for claiming, but not to notify of flywheel changes.\\n  address[] public nonAccruingRewardsDistributors;\\n\\n  /// @dev cap for each user's borrows against specific assets - denominated in the borrowed asset\\n  mapping(address => mapping(address => uint256)) public borrowCapForCollateral;\\n\\n  /// @dev blacklist to disallow the borrowing of an asset against specific collateral\\n  mapping(address => mapping(address => bool)) public borrowingAgainstCollateralBlacklist;\\n\\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrowing against specific collateral cap\\n  mapping(address => mapping(address => EnumerableSet.AddressSet)) internal borrowCapForCollateralWhitelist;\\n\\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\\n  mapping(address => mapping(address => EnumerableSet.AddressSet))\\n    internal borrowingAgainstCollateralBlacklistWhitelist;\\n\\n  /// @dev set of whitelisted accounts that are allowed to bypass the supply cap\\n  mapping(address => EnumerableSet.AddressSet) internal supplyCapWhitelist;\\n\\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\\n  mapping(address => EnumerableSet.AddressSet) internal borrowCapWhitelist;\\n}\\n\\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\\n  /// @dev Adrastia Prudentia config for controlling borrow caps.\\n  PrudentiaLib.PrudentiaConfig internal borrowCapConfig;\\n\\n  /// @dev Adrastia Prudentia config for controlling supply caps.\\n  PrudentiaLib.PrudentiaConfig internal supplyCapConfig;\\n}\\n\",\"keccak256\":\"0xa4a8110e666a93c1228c914f1414131e0f3b93385826bb72f6f93d429e514286\",\"license\":\"UNLICENSED\"},\"contracts/compound/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ncontract ComptrollerErrorReporter {\\n  enum Error {\\n    NO_ERROR,\\n    UNAUTHORIZED,\\n    COMPTROLLER_MISMATCH,\\n    INSUFFICIENT_SHORTFALL,\\n    INSUFFICIENT_LIQUIDITY,\\n    INVALID_CLOSE_FACTOR,\\n    INVALID_COLLATERAL_FACTOR,\\n    INVALID_LIQUIDATION_INCENTIVE,\\n    MARKET_NOT_LISTED,\\n    MARKET_ALREADY_LISTED,\\n    MATH_ERROR,\\n    NONZERO_BORROW_BALANCE,\\n    PRICE_ERROR,\\n    REJECTION,\\n    SNAPSHOT_ERROR,\\n    TOO_MANY_ASSETS,\\n    TOO_MUCH_REPAY,\\n    SUPPLIER_NOT_WHITELISTED,\\n    BORROW_BELOW_MIN,\\n    SUPPLY_ABOVE_MAX,\\n    NONZERO_TOTAL_SUPPLY\\n  }\\n\\n  enum FailureInfo {\\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\\n    EXIT_MARKET_BALANCE_OWED,\\n    EXIT_MARKET_REJECTION,\\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\\n    SET_CLOSE_FACTOR_OWNER_CHECK,\\n    SET_CLOSE_FACTOR_VALIDATION,\\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\\n    SET_COLLATERAL_FACTOR_VALIDATION,\\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n    SET_PENDING_ADMIN_OWNER_CHECK,\\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n    SET_PRICE_ORACLE_OWNER_CHECK,\\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\\n    SET_WHITELIST_STATUS_OWNER_CHECK,\\n    SUPPORT_MARKET_EXISTS,\\n    SUPPORT_MARKET_OWNER_CHECK,\\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\\n    UNSUPPORT_MARKET_OWNER_CHECK,\\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\\n    UNSUPPORT_MARKET_IN_USE\\n  }\\n\\n  /**\\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n   **/\\n  event Failure(uint256 error, uint256 info, uint256 detail);\\n\\n  /**\\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n   */\\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\\n    emit Failure(uint256(err), uint256(info), 0);\\n\\n    return uint256(err);\\n  }\\n\\n  /**\\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n   */\\n  function failOpaque(\\n    Error err,\\n    FailureInfo info,\\n    uint256 opaqueError\\n  ) internal returns (uint256) {\\n    emit Failure(uint256(err), uint256(info), opaqueError);\\n\\n    return uint256(err);\\n  }\\n}\\n\\ncontract TokenErrorReporter {\\n  enum Error {\\n    NO_ERROR,\\n    UNAUTHORIZED,\\n    BAD_INPUT,\\n    COMPTROLLER_REJECTION,\\n    COMPTROLLER_CALCULATION_ERROR,\\n    INTEREST_RATE_MODEL_ERROR,\\n    INVALID_ACCOUNT_PAIR,\\n    INVALID_CLOSE_AMOUNT_REQUESTED,\\n    INVALID_COLLATERAL_FACTOR,\\n    MATH_ERROR,\\n    MARKET_NOT_FRESH,\\n    MARKET_NOT_LISTED,\\n    TOKEN_INSUFFICIENT_ALLOWANCE,\\n    TOKEN_INSUFFICIENT_BALANCE,\\n    TOKEN_INSUFFICIENT_CASH,\\n    TOKEN_TRANSFER_IN_FAILED,\\n    TOKEN_TRANSFER_OUT_FAILED,\\n    UTILIZATION_ABOVE_MAX\\n  }\\n\\n  /*\\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\\n   *       This is because FailureInfo grows significantly faster, and\\n   *       the order of Error has some meaning, while the order of FailureInfo\\n   *       is entirely arbitrary.\\n   */\\n  enum FailureInfo {\\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_IONIC_FEES_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n    BORROW_ACCRUE_INTEREST_FAILED,\\n    BORROW_CASH_NOT_AVAILABLE,\\n    BORROW_FRESHNESS_CHECK,\\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n    BORROW_MARKET_NOT_LISTED,\\n    BORROW_COMPTROLLER_REJECTION,\\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\\n    LIQUIDATE_COMPTROLLER_REJECTION,\\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\\n    LIQUIDATE_FRESHNESS_CHECK,\\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\\n    LIQUIDATE_SEIZE_TOO_MUCH,\\n    MINT_ACCRUE_INTEREST_FAILED,\\n    MINT_COMPTROLLER_REJECTION,\\n    MINT_EXCHANGE_CALCULATION_FAILED,\\n    MINT_EXCHANGE_RATE_READ_FAILED,\\n    MINT_FRESHNESS_CHECK,\\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n    MINT_TRANSFER_IN_FAILED,\\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\\n    REDEEM_ACCRUE_INTEREST_FAILED,\\n    REDEEM_COMPTROLLER_REJECTION,\\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\\n    REDEEM_FRESHNESS_CHECK,\\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\\n    WITHDRAW_IONIC_FEES_ACCRUE_INTEREST_FAILED,\\n    WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE,\\n    WITHDRAW_IONIC_FEES_FRESH_CHECK,\\n    WITHDRAW_IONIC_FEES_VALIDATION,\\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\\n    WITHDRAW_ADMIN_FEES_VALIDATION,\\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\\n    REDUCE_RESERVES_ADMIN_CHECK,\\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\\n    REDUCE_RESERVES_FRESH_CHECK,\\n    REDUCE_RESERVES_VALIDATION,\\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_COMPTROLLER_REJECTION,\\n    REPAY_BORROW_FRESHNESS_CHECK,\\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n    SET_COLLATERAL_FACTOR_VALIDATION,\\n    SET_COMPTROLLER_OWNER_CHECK,\\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\\n    SET_PENDING_ADMIN_OWNER_CHECK,\\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\\n    SET_ADMIN_FEE_ADMIN_CHECK,\\n    SET_ADMIN_FEE_FRESH_CHECK,\\n    SET_ADMIN_FEE_BOUNDS_CHECK,\\n    SET_IONIC_FEE_ACCRUE_INTEREST_FAILED,\\n    SET_IONIC_FEE_FRESH_CHECK,\\n    SET_IONIC_FEE_BOUNDS_CHECK,\\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\\n    SET_RESERVE_FACTOR_FRESH_CHECK,\\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\\n    TRANSFER_COMPTROLLER_REJECTION,\\n    TRANSFER_NOT_ALLOWED,\\n    TRANSFER_NOT_ENOUGH,\\n    TRANSFER_TOO_MUCH,\\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\\n    ADD_RESERVES_FRESH_CHECK,\\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\\n  }\\n\\n  /**\\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n   **/\\n  event Failure(uint256 error, uint256 info, uint256 detail);\\n\\n  /**\\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n   */\\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\\n    emit Failure(uint256(err), uint256(info), 0);\\n\\n    return uint256(err);\\n  }\\n\\n  /**\\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n   */\\n  function failOpaque(\\n    Error err,\\n    FailureInfo info,\\n    uint256 opaqueError\\n  ) internal returns (uint256) {\\n    emit Failure(uint256(err), uint256(info), opaqueError);\\n\\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\\n  }\\n}\\n\",\"keccak256\":\"0xad342553cda4d7b7e40678c636a406bc2785be2117a29d9b1cb52e747726745e\",\"license\":\"UNLICENSED\"},\"contracts/compound/Exponential.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath, ExponentialNoError {\\n  /**\\n   * @dev Creates an exponential from numerator and denominator values.\\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n   *            or if `denom` is zero.\\n   */\\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({ mantissa: 0 }));\\n    }\\n\\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({ mantissa: 0 }));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\\n  }\\n\\n  /**\\n   * @dev Adds two exponentials, returning a new exponential.\\n   */\\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({ mantissa: result }));\\n  }\\n\\n  /**\\n   * @dev Subtracts two exponentials, returning a new exponential.\\n   */\\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({ mantissa: result }));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\\n   */\\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({ mantissa: 0 }));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(product));\\n  }\\n\\n  /**\\n   * @dev Divide an Exp by a scalar, returning a new Exp.\\n   */\\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({ mantissa: 0 }));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, returning a new Exp.\\n   */\\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\\n    /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({ mantissa: 0 }));\\n    }\\n    return getExp(numerator, divisor.mantissa);\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n   */\\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(fraction));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials, returning a new exponential.\\n   */\\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({ mantissa: 0 }));\\n    }\\n\\n    // We add half the scale before dividing so that we get rounding instead of truncation.\\n    //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({ mantissa: 0 }));\\n    }\\n\\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n    assert(err2 == MathError.NO_ERROR);\\n\\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n   */\\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\\n  }\\n\\n  /**\\n   * @dev Multiplies three exponentials, returning a new exponential.\\n   */\\n  function mulExp3(\\n    Exp memory a,\\n    Exp memory b,\\n    Exp memory c\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err, Exp memory ab) = mulExp(a, b);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, ab);\\n    }\\n    return mulExp(ab, c);\\n  }\\n\\n  /**\\n   * @dev Divides two exponentials, returning a new exponential.\\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n   */\\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n    return getExp(a.mantissa, b.mantissa);\\n  }\\n}\\n\",\"keccak256\":\"0xf1b6442cbde756ce56dc5507487b1769905147f390fdf88e1d59a66bc3e2161e\",\"license\":\"UNLICENSED\"},\"contracts/compound/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n  uint256 constant expScale = 1e18;\\n  uint256 constant doubleScale = 1e36;\\n  uint256 constant halfExpScale = expScale / 2;\\n  uint256 constant mantissaOne = expScale;\\n\\n  struct Exp {\\n    uint256 mantissa;\\n  }\\n\\n  struct Double {\\n    uint256 mantissa;\\n  }\\n\\n  /**\\n   * @dev Truncates the given exp to a whole number value.\\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n   */\\n  function truncate(Exp memory exp) internal pure returns (uint256) {\\n    // Note: We are not using careful math here as we're performing a division that cannot fail\\n    return exp.mantissa / expScale;\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n    Exp memory product = mul_(a, scalar);\\n    return truncate(product);\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mul_ScalarTruncateAddUInt(\\n    Exp memory a,\\n    uint256 scalar,\\n    uint256 addend\\n  ) internal pure returns (uint256) {\\n    Exp memory product = mul_(a, scalar);\\n    return add_(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Checks if first Exp is less than second Exp.\\n   */\\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa < right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp <= right Exp.\\n   */\\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa <= right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp > right Exp.\\n   */\\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa > right.mantissa;\\n  }\\n\\n  /**\\n   * @dev returns true if Exp is exactly zero\\n   */\\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\\n    return value.mantissa == 0;\\n  }\\n\\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n    require(n < 2**224, errorMessage);\\n    return uint224(n);\\n  }\\n\\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n    require(n < 2**32, errorMessage);\\n    return uint32(n);\\n  }\\n\\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\\n  }\\n\\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\\n  }\\n\\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return add_(a, b, \\\"addition overflow\\\");\\n  }\\n\\n  function add_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, errorMessage);\\n    return c;\\n  }\\n\\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\\n  }\\n\\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\\n  }\\n\\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub_(a, b, \\\"subtraction underflow\\\");\\n  }\\n\\n  function sub_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    return a - b;\\n  }\\n\\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\\n  }\\n\\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: mul_(a.mantissa, b) });\\n  }\\n\\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n    return mul_(a, b.mantissa) / expScale;\\n  }\\n\\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\\n  }\\n\\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n    return Double({ mantissa: mul_(a.mantissa, b) });\\n  }\\n\\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n    return mul_(a, b.mantissa) / doubleScale;\\n  }\\n\\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mul_(a, b, \\\"multiplication overflow\\\");\\n  }\\n\\n  function mul_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    require(c / a == b, errorMessage);\\n    return c;\\n  }\\n\\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\\n  }\\n\\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n    return Exp({ mantissa: div_(a.mantissa, b) });\\n  }\\n\\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n    return div_(mul_(a, expScale), b.mantissa);\\n  }\\n\\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\\n  }\\n\\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n    return Double({ mantissa: div_(a.mantissa, b) });\\n  }\\n\\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n    return div_(mul_(a, doubleScale), b.mantissa);\\n  }\\n\\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div_(a, b, \\\"divide by zero\\\");\\n  }\\n\\n  function div_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    return a / b;\\n  }\\n\\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\\n  }\\n}\\n\",\"keccak256\":\"0xec0df0038026b4e9c272de575121befd31d3a306fec5f157aaf1625fc08cfe69\",\"license\":\"UNLICENSED\"},\"contracts/compound/IFeeDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"../ionic/AuthoritiesRegistry.sol\\\";\\n\\ninterface IFeeDistributor {\\n  function minBorrowEth() external view returns (uint256);\\n\\n  function maxUtilizationRate() external view returns (uint256);\\n\\n  function interestFeeRate() external view returns (uint256);\\n\\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\\n\\n  function latestCErc20Delegate(uint8 delegateType)\\n    external\\n    view\\n    returns (address cErc20Delegate, bytes memory becomeImplementationData);\\n\\n  function latestPluginImplementation(address oldImplementation) external view returns (address);\\n\\n  function getComptrollerExtensions(address comptroller) external view returns (address[] memory);\\n\\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (address[] memory);\\n\\n  function deployCErc20(\\n    uint8 delegateType,\\n    bytes calldata constructorData,\\n    bytes calldata becomeImplData\\n  ) external returns (address);\\n\\n  function canCall(\\n    address pool,\\n    address user,\\n    address target,\\n    bytes4 functionSig\\n  ) external view returns (bool);\\n\\n  function authoritiesRegistry() external view returns (AuthoritiesRegistry);\\n\\n  fallback() external payable;\\n\\n  receive() external payable;\\n}\\n\",\"keccak256\":\"0xa822e2942e6a88851968d5f3bda48709713c84d556031a1dd3db5dfd06121d3e\",\"license\":\"UNLICENSED\"},\"contracts/compound/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Compound's InterestRateModel Interface\\n * @author Compound\\n */\\nabstract contract InterestRateModel {\\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n  bool public constant isInterestRateModel = true;\\n\\n  /**\\n   * @notice Calculates the current borrow interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getBorrowRate(\\n    uint256 cash,\\n    uint256 borrows,\\n    uint256 reserves\\n  ) public view virtual returns (uint256);\\n\\n  /**\\n   * @notice Calculates the current supply interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @param reserveFactorMantissa The current reserve factor the market has\\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getSupplyRate(\\n    uint256 cash,\\n    uint256 borrows,\\n    uint256 reserves,\\n    uint256 reserveFactorMantissa\\n  ) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x587a54b49d48df2cd91583eac93ddde4e2849f79d0441f179bf835e9dffe24e9\",\"license\":\"UNLICENSED\"},\"contracts/compound/Unitroller.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./ComptrollerStorage.sol\\\";\\nimport \\\"./Comptroller.sol\\\";\\nimport { DiamondExtension, DiamondBase, LibDiamond } from \\\"../ionic/DiamondExtension.sol\\\";\\n\\n/**\\n * @title Unitroller\\n * @dev Storage for the comptroller is at this address, while execution is delegated via the Diamond Extensions\\n * CTokens should reference this contract as their comptroller.\\n */\\ncontract Unitroller is ComptrollerV3Storage, ComptrollerErrorReporter, DiamondBase {\\n  /**\\n   * @notice Event emitted when the admin rights are changed\\n   */\\n  event AdminRightsToggled(bool hasRights);\\n\\n  /**\\n   * @notice Emitted when pendingAdmin is changed\\n   */\\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n  /**\\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n   */\\n  event NewAdmin(address oldAdmin, address newAdmin);\\n\\n  constructor(address payable _ionicAdmin) {\\n    admin = msg.sender;\\n    ionicAdmin = _ionicAdmin;\\n  }\\n\\n  /*** Admin Functions ***/\\n\\n  /**\\n   * @notice Toggles admin rights.\\n   * @param hasRights Boolean indicating if the admin is to have rights.\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\\n    }\\n\\n    // Check that rights have not already been set to the desired value\\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\\n\\n    adminHasRights = hasRights;\\n    emit AdminRightsToggled(hasRights);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @param newPendingAdmin New pending admin.\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\\n    if (!hasAdminRights()) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n    }\\n\\n    address oldPendingAdmin = pendingAdmin;\\n    pendingAdmin = newPendingAdmin;\\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n   * @dev Admin function for pending admin to accept role and update admin\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _acceptAdmin() public returns (uint256) {\\n    // Check caller is pendingAdmin and pendingAdmin \\u2260 address(0)\\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n    }\\n\\n    // Save current values for inclusion in log\\n    address oldAdmin = admin;\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    admin = pendingAdmin;\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(oldAdmin, admin);\\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n    return uint256(Error.NO_ERROR);\\n  }\\n\\n  function comptrollerImplementation() public view returns (address) {\\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\\\"_deployMarket(uint8,bytes,bytes,uint256)\\\"))));\\n  }\\n\\n  /**\\n   * @dev upgrades the implementation if necessary\\n   */\\n  function _upgrade() external {\\n    require(msg.sender == address(this) || hasAdminRights(), \\\"!self || !admin\\\");\\n\\n    address currentImplementation = comptrollerImplementation();\\n    address latestComptrollerImplementation = IFeeDistributor(ionicAdmin).latestComptrollerImplementation(\\n      currentImplementation\\n    );\\n\\n    _updateExtensions(latestComptrollerImplementation);\\n\\n    if (currentImplementation != latestComptrollerImplementation) {\\n      // reinitialize\\n      _functionCall(address(this), abi.encodeWithSignature(\\\"_becomeImplementation()\\\"), \\\"!become impl\\\");\\n    }\\n  }\\n\\n  function _functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.call(data);\\n\\n    if (!success) {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n\\n    return returndata;\\n  }\\n\\n  function _updateExtensions(address currentComptroller) internal {\\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getComptrollerExtensions(currentComptroller);\\n    address[] memory currentExtensions = LibDiamond.listExtensions();\\n\\n    // removed the current (old) extensions\\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\\n    }\\n    // add the new extensions\\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\\n    }\\n  }\\n\\n  /**\\n   * @dev register a logic extension\\n   * @param extensionToAdd the extension whose functions are to be added\\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\\n   */\\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\\n    require(hasAdminRights(), \\\"!unauthorized\\\");\\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\\n  }\\n}\\n\",\"keccak256\":\"0xcea89eb6bccd6ab62b57e42d483fd3638a0296ec9aae45d21f80a521004cc9e8\",\"license\":\"UNLICENSED\"},\"contracts/ionic/AddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport { SafeOwnableUpgradeable } from \\\"../ionic/SafeOwnableUpgradeable.sol\\\";\\n\\n/**\\n * @title AddressesProvider\\n * @notice The Addresses Provider serves as a central storage of system internal and external\\n *         contract addresses that change between deploys and across chains\\n * @author Veliko Minkov <veliko@midascapital.xyz>\\n */\\ncontract AddressesProvider is SafeOwnableUpgradeable {\\n  mapping(string => address) private _addresses;\\n  mapping(address => Contract) public plugins;\\n  mapping(address => Contract) public flywheelRewards;\\n  mapping(address => RedemptionStrategy) public redemptionStrategiesConfig;\\n  mapping(address => FundingStrategy) public fundingStrategiesConfig;\\n  JarvisPool[] public jarvisPoolsConfig;\\n  CurveSwapPool[] public curveSwapPoolsConfig;\\n  mapping(address => mapping(address => address)) public balancerPoolForTokens;\\n\\n  /// @dev Initializer to set the admin that can set and change contracts addresses\\n  function initialize(address owner) public initializer {\\n    __SafeOwnable_init(owner);\\n  }\\n\\n  /**\\n   * @dev The contract address and a string that uniquely identifies the contract's interface\\n   */\\n  struct Contract {\\n    address addr;\\n    string contractInterface;\\n  }\\n\\n  struct RedemptionStrategy {\\n    address addr;\\n    string contractInterface;\\n    address outputToken;\\n  }\\n\\n  struct FundingStrategy {\\n    address addr;\\n    string contractInterface;\\n    address inputToken;\\n  }\\n\\n  struct JarvisPool {\\n    address syntheticToken;\\n    address collateralToken;\\n    address liquidityPool;\\n    uint256 expirationTime;\\n  }\\n\\n  struct CurveSwapPool {\\n    address poolAddress;\\n    address[] coins;\\n  }\\n\\n  /**\\n   * @dev sets the address and contract interface ID of the flywheel for the reward token\\n   * @param rewardToken the reward token address\\n   * @param flywheelRewardsModule the flywheel rewards module address\\n   * @param contractInterface a string that uniquely identifies the contract's interface\\n   */\\n  function setFlywheelRewards(\\n    address rewardToken,\\n    address flywheelRewardsModule,\\n    string calldata contractInterface\\n  ) public onlyOwner {\\n    flywheelRewards[rewardToken] = Contract(flywheelRewardsModule, contractInterface);\\n  }\\n\\n  /**\\n   * @dev sets the address and contract interface ID of the ERC4626 plugin for the asset\\n   * @param asset the asset address\\n   * @param plugin the ERC4626 plugin address\\n   * @param contractInterface a string that uniquely identifies the contract's interface\\n   */\\n  function setPlugin(\\n    address asset,\\n    address plugin,\\n    string calldata contractInterface\\n  ) public onlyOwner {\\n    plugins[asset] = Contract(plugin, contractInterface);\\n  }\\n\\n  /**\\n   * @dev sets the address and contract interface ID of the redemption strategy for the asset\\n   * @param asset the asset address\\n   * @param strategy redemption strategy address\\n   * @param contractInterface a string that uniquely identifies the contract's interface\\n   */\\n  function setRedemptionStrategy(\\n    address asset,\\n    address strategy,\\n    string calldata contractInterface,\\n    address outputToken\\n  ) public onlyOwner {\\n    redemptionStrategiesConfig[asset] = RedemptionStrategy(strategy, contractInterface, outputToken);\\n  }\\n\\n  function getRedemptionStrategy(address asset) public view returns (RedemptionStrategy memory) {\\n    return redemptionStrategiesConfig[asset];\\n  }\\n\\n  /**\\n   * @dev sets the address and contract interface ID of the funding strategy for the asset\\n   * @param asset the asset address\\n   * @param strategy funding strategy address\\n   * @param contractInterface a string that uniquely identifies the contract's interface\\n   */\\n  function setFundingStrategy(\\n    address asset,\\n    address strategy,\\n    string calldata contractInterface,\\n    address inputToken\\n  ) public onlyOwner {\\n    fundingStrategiesConfig[asset] = FundingStrategy(strategy, contractInterface, inputToken);\\n  }\\n\\n  function getFundingStrategy(address asset) public view returns (FundingStrategy memory) {\\n    return fundingStrategiesConfig[asset];\\n  }\\n\\n  /**\\n   * @dev configures the Jarvis pool of a Jarvis synthetic token\\n   * @param syntheticToken the synthetic token address\\n   * @param collateralToken the collateral token address\\n   * @param liquidityPool the liquidity pool address\\n   * @param expirationTime the operation expiration time\\n   */\\n  function setJarvisPool(\\n    address syntheticToken,\\n    address collateralToken,\\n    address liquidityPool,\\n    uint256 expirationTime\\n  ) public onlyOwner {\\n    jarvisPoolsConfig.push(JarvisPool(syntheticToken, collateralToken, liquidityPool, expirationTime));\\n  }\\n\\n  function setCurveSwapPool(address poolAddress, address[] calldata coins) public onlyOwner {\\n    curveSwapPoolsConfig.push(CurveSwapPool(poolAddress, coins));\\n  }\\n\\n  /**\\n   * @dev Sets an address for an id replacing the address saved in the addresses map\\n   * @param id The id\\n   * @param newAddress The address to set\\n   */\\n  function setAddress(string calldata id, address newAddress) external onlyOwner {\\n    _addresses[id] = newAddress;\\n  }\\n\\n  /**\\n   * @dev Returns an address by id\\n   * @return The address\\n   */\\n  function getAddress(string calldata id) public view returns (address) {\\n    return _addresses[id];\\n  }\\n\\n  function getCurveSwapPools() public view returns (CurveSwapPool[] memory) {\\n    return curveSwapPoolsConfig;\\n  }\\n\\n  function getJarvisPools() public view returns (JarvisPool[] memory) {\\n    return jarvisPoolsConfig;\\n  }\\n\\n  function setBalancerPoolForTokens(\\n    address inputToken,\\n    address outputToken,\\n    address pool\\n  ) external onlyOwner {\\n    balancerPoolForTokens[inputToken][outputToken] = pool;\\n  }\\n\\n  function getBalancerPoolForTokens(address inputToken, address outputToken) external view returns (address) {\\n    return balancerPoolForTokens[inputToken][outputToken];\\n  }\\n}\\n\",\"keccak256\":\"0xf48e9e8b2150408c1c6b68dd957226c342ba47396da792fdaa0922f539a7e163\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/AuthoritiesRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport { PoolRolesAuthority } from \\\"../ionic/PoolRolesAuthority.sol\\\";\\nimport { SafeOwnableUpgradeable } from \\\"../ionic/SafeOwnableUpgradeable.sol\\\";\\nimport { IonicComptroller } from \\\"../compound/ComptrollerInterface.sol\\\";\\n\\nimport { TransparentUpgradeableProxy } from \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\n\\ncontract AuthoritiesRegistry is SafeOwnableUpgradeable {\\n  mapping(address => PoolRolesAuthority) public poolsAuthorities;\\n  PoolRolesAuthority public poolAuthLogic;\\n  address public leveredPositionsFactory;\\n  bool public noAuthRequired;\\n\\n  function initialize(address _leveredPositionsFactory) public initializer {\\n    __SafeOwnable_init(msg.sender);\\n    leveredPositionsFactory = _leveredPositionsFactory;\\n    poolAuthLogic = new PoolRolesAuthority();\\n  }\\n\\n  function reinitialize(address _leveredPositionsFactory) public onlyOwnerOrAdmin {\\n    leveredPositionsFactory = _leveredPositionsFactory;\\n    poolAuthLogic = new PoolRolesAuthority();\\n    // for Neon the auth is not required\\n    noAuthRequired = block.chainid == 245022934;\\n  }\\n\\n  function createPoolAuthority(address pool) public onlyOwner returns (PoolRolesAuthority auth) {\\n    require(address(poolsAuthorities[pool]) == address(0), \\\"already created\\\");\\n\\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(poolAuthLogic), _getProxyAdmin(), \\\"\\\");\\n    auth = PoolRolesAuthority(address(proxy));\\n    auth.initialize(address(this));\\n    poolsAuthorities[pool] = auth;\\n\\n    auth.openPoolSupplierCapabilities(IonicComptroller(pool));\\n    auth.setUserRole(address(this), auth.REGISTRY_ROLE(), true);\\n    // sets the registry owner as the auth owner\\n    reconfigureAuthority(pool);\\n  }\\n\\n  function reconfigureAuthority(address poolAddress) public {\\n    IonicComptroller pool = IonicComptroller(poolAddress);\\n    PoolRolesAuthority auth = poolsAuthorities[address(pool)];\\n\\n    if (msg.sender != poolAddress || address(auth) != address(0)) {\\n      require(address(auth) != address(0), \\\"no such authority\\\");\\n      require(msg.sender == owner() || msg.sender == poolAddress, \\\"not owner or pool\\\");\\n\\n      auth.configureRegistryCapabilities();\\n      auth.configurePoolSupplierCapabilities(pool);\\n      auth.configurePoolBorrowerCapabilities(pool);\\n      // everyone can be a liquidator\\n      auth.configureOpenPoolLiquidatorCapabilities(pool);\\n      auth.configureLeveredPositionCapabilities(pool);\\n\\n      if (auth.owner() != owner()) {\\n        auth.setOwner(owner());\\n      }\\n    }\\n  }\\n\\n  function canCall(\\n    address pool,\\n    address user,\\n    address target,\\n    bytes4 functionSig\\n  ) external view returns (bool) {\\n    PoolRolesAuthority authorityForPool = poolsAuthorities[pool];\\n    if (address(authorityForPool) == address(0)) {\\n      return noAuthRequired;\\n    } else {\\n      // allow only if an auth exists and it allows the action\\n      return authorityForPool.canCall(user, target, functionSig);\\n    }\\n  }\\n\\n  function setUserRole(\\n    address pool,\\n    address user,\\n    uint8 role,\\n    bool enabled\\n  ) external {\\n    PoolRolesAuthority poolAuth = poolsAuthorities[pool];\\n\\n    require(address(poolAuth) != address(0), \\\"auth does not exist\\\");\\n    require(msg.sender == owner() || msg.sender == leveredPositionsFactory, \\\"not owner or factory\\\");\\n    require(msg.sender != leveredPositionsFactory || role == poolAuth.LEVERED_POSITION_ROLE(), \\\"only lev pos role\\\");\\n\\n    poolAuth.setUserRole(user, role, enabled);\\n  }\\n}\\n\",\"keccak256\":\"0x98fc1f8a735b5759fc7524e3065ae322703d2771e7ec429e1cc9b60a4b1028dd\",\"license\":\"UNLICENSED\"},\"contracts/ionic/DiamondExtension.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\n/**\\n * @notice a base contract for logic extensions that use the diamond pattern storage\\n * to map the functions when looking up the extension contract to delegate to.\\n */\\nabstract contract DiamondExtension {\\n  /**\\n   * @return a list of all the function selectors that this logic extension exposes\\n   */\\n  function _getExtensionFunctions() external pure virtual returns (bytes4[] memory);\\n}\\n\\n// When no function exists for function called\\nerror FunctionNotFound(bytes4 _functionSelector);\\n\\n// When no extension exists for function called\\nerror ExtensionNotFound(bytes4 _functionSelector);\\n\\n// When the function is already added\\nerror FunctionAlreadyAdded(bytes4 _functionSelector, address _currentImpl);\\n\\nabstract contract DiamondBase {\\n  /**\\n   * @dev register a logic extension\\n   * @param extensionToAdd the extension whose functions are to be added\\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\\n   */\\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external virtual;\\n\\n  function _listExtensions() public view returns (address[] memory) {\\n    return LibDiamond.listExtensions();\\n  }\\n\\n  fallback() external {\\n    address extension = LibDiamond.getExtensionForFunction(msg.sig);\\n    if (extension == address(0)) revert FunctionNotFound(msg.sig);\\n    // Execute external function from extension using delegatecall and return any value.\\n    assembly {\\n      // copy function selector and any arguments\\n      calldatacopy(0, 0, calldatasize())\\n      // execute function call using the extension\\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\\n      // get any return value\\n      returndatacopy(0, 0, returndatasize())\\n      // return any return value or error back to the caller\\n      switch result\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * @notice a library to use in a contract, whose logic is extended with diamond extension\\n */\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.extensions.diamond.storage\\\");\\n\\n  struct Function {\\n    address extension;\\n    bytes4 selector;\\n  }\\n\\n  struct LogicStorage {\\n    Function[] functions;\\n    address[] extensions;\\n  }\\n\\n  function getExtensionForFunction(bytes4 msgSig) internal view returns (address) {\\n    return getExtensionForSelector(msgSig, diamondStorage());\\n  }\\n\\n  function diamondStorage() internal pure returns (LogicStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function listExtensions() internal view returns (address[] memory) {\\n    return diamondStorage().extensions;\\n  }\\n\\n  function registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) internal {\\n    if (address(extensionToReplace) != address(0)) {\\n      removeExtension(extensionToReplace);\\n    }\\n    addExtension(extensionToAdd);\\n  }\\n\\n  function removeExtension(DiamondExtension extension) internal {\\n    LogicStorage storage ds = diamondStorage();\\n    // remove all functions of the extension to replace\\n    removeExtensionFunctions(extension);\\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\\n      if (ds.extensions[i] == address(extension)) {\\n        ds.extensions[i] = ds.extensions[ds.extensions.length - 1];\\n        ds.extensions.pop();\\n      }\\n    }\\n  }\\n\\n  function addExtension(DiamondExtension extension) internal {\\n    LogicStorage storage ds = diamondStorage();\\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\\n      require(ds.extensions[i] != address(extension), \\\"extension already added\\\");\\n    }\\n    addExtensionFunctions(extension);\\n    ds.extensions.push(address(extension));\\n  }\\n\\n  function removeExtensionFunctions(DiamondExtension extension) internal {\\n    bytes4[] memory fnsToRemove = extension._getExtensionFunctions();\\n    LogicStorage storage ds = diamondStorage();\\n    for (uint16 i = 0; i < fnsToRemove.length; i++) {\\n      bytes4 selectorToRemove = fnsToRemove[i];\\n      // must never fail\\n      assert(address(extension) == getExtensionForSelector(selectorToRemove, ds));\\n      // swap with the last element in the selectorAtIndex array and remove the last element\\n      uint16 indexToKeep = getIndexForSelector(selectorToRemove, ds);\\n      ds.functions[indexToKeep] = ds.functions[ds.functions.length - 1];\\n      ds.functions.pop();\\n    }\\n  }\\n\\n  function addExtensionFunctions(DiamondExtension extension) internal {\\n    bytes4[] memory fnsToAdd = extension._getExtensionFunctions();\\n    LogicStorage storage ds = diamondStorage();\\n    uint16 functionsCount = uint16(ds.functions.length);\\n    for (uint256 functionsIndex = 0; functionsIndex < fnsToAdd.length; functionsIndex++) {\\n      bytes4 selector = fnsToAdd[functionsIndex];\\n      address oldImplementation = getExtensionForSelector(selector, ds);\\n      if (oldImplementation != address(0)) revert FunctionAlreadyAdded(selector, oldImplementation);\\n      ds.functions.push(Function(address(extension), selector));\\n      functionsCount++;\\n    }\\n  }\\n\\n  function getExtensionForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (address) {\\n    uint256 fnsLen = ds.functions.length;\\n    for (uint256 i = 0; i < fnsLen; i++) {\\n      if (ds.functions[i].selector == selector) return ds.functions[i].extension;\\n    }\\n\\n    return address(0);\\n  }\\n\\n  function getIndexForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (uint16) {\\n    uint16 fnsLen = uint16(ds.functions.length);\\n    for (uint16 i = 0; i < fnsLen; i++) {\\n      if (ds.functions[i].selector == selector) return i;\\n    }\\n\\n    return type(uint16).max;\\n  }\\n}\\n\",\"keccak256\":\"0x6d33291928e3c255f0276fa465dcc5ea88d74a6562241a39ad2e52ae8abaf7bc\",\"license\":\"UNLICENSED\"},\"contracts/ionic/PoolRolesAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport { IonicComptroller, ComptrollerInterface } from \\\"../compound/ComptrollerInterface.sol\\\";\\nimport { ICErc20, CTokenSecondExtensionInterface, CTokenFirstExtensionInterface } from \\\"../compound/CTokenInterfaces.sol\\\";\\n\\nimport { RolesAuthority, Authority } from \\\"solmate/auth/authorities/RolesAuthority.sol\\\";\\n\\nimport \\\"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\\\";\\n\\ncontract PoolRolesAuthority is RolesAuthority, Initializable {\\n  constructor() RolesAuthority(address(0), Authority(address(0))) {\\n    _disableInitializers();\\n  }\\n\\n  function initialize(address _owner) public initializer {\\n    owner = _owner;\\n    authority = this;\\n  }\\n\\n  // up to 256 roles\\n  uint8 public constant REGISTRY_ROLE = 0;\\n  uint8 public constant SUPPLIER_ROLE = 1;\\n  uint8 public constant BORROWER_ROLE = 2;\\n  uint8 public constant LIQUIDATOR_ROLE = 3;\\n  uint8 public constant LEVERED_POSITION_ROLE = 4;\\n\\n  function configureRegistryCapabilities() external requiresAuth {\\n    setRoleCapability(REGISTRY_ROLE, address(this), PoolRolesAuthority.configureRegistryCapabilities.selector, true);\\n    setRoleCapability(\\n      REGISTRY_ROLE,\\n      address(this),\\n      PoolRolesAuthority.configurePoolSupplierCapabilities.selector,\\n      true\\n    );\\n    setRoleCapability(\\n      REGISTRY_ROLE,\\n      address(this),\\n      PoolRolesAuthority.configurePoolBorrowerCapabilities.selector,\\n      true\\n    );\\n    setRoleCapability(\\n      REGISTRY_ROLE,\\n      address(this),\\n      PoolRolesAuthority.configureClosedPoolLiquidatorCapabilities.selector,\\n      true\\n    );\\n    setRoleCapability(\\n      REGISTRY_ROLE,\\n      address(this),\\n      PoolRolesAuthority.configureOpenPoolLiquidatorCapabilities.selector,\\n      true\\n    );\\n    setRoleCapability(\\n      REGISTRY_ROLE,\\n      address(this),\\n      PoolRolesAuthority.configureLeveredPositionCapabilities.selector,\\n      true\\n    );\\n    setRoleCapability(REGISTRY_ROLE, address(this), RolesAuthority.setUserRole.selector, true);\\n  }\\n\\n  function openPoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\\n    _setPublicPoolSupplierCapabilities(pool, true);\\n  }\\n\\n  function closePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\\n    _setPublicPoolSupplierCapabilities(pool, false);\\n  }\\n\\n  function _setPublicPoolSupplierCapabilities(IonicComptroller pool, bool setPublic) internal {\\n    setPublicCapability(address(pool), pool.enterMarkets.selector, setPublic);\\n    setPublicCapability(address(pool), pool.exitMarket.selector, setPublic);\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      bytes4[] memory selectors = getSupplierMarketSelectors();\\n      for (uint256 j = 0; j < selectors.length; j++) {\\n        setPublicCapability(address(allMarkets[i]), selectors[j], setPublic);\\n      }\\n    }\\n  }\\n\\n  function configurePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\\n    _configurePoolSupplierCapabilities(pool, SUPPLIER_ROLE);\\n  }\\n\\n  function getSupplierMarketSelectors() internal pure returns (bytes4[] memory selectors) {\\n    uint8 fnsCount = 6;\\n    selectors = new bytes4[](fnsCount);\\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.mint.selector;\\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeem.selector;\\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeemUnderlying.selector;\\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transfer.selector;\\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transferFrom.selector;\\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.approve.selector;\\n\\n    require(fnsCount == 0, \\\"use the correct array length\\\");\\n    return selectors;\\n  }\\n\\n  function _configurePoolSupplierCapabilities(IonicComptroller pool, uint8 role) internal {\\n    setRoleCapability(role, address(pool), pool.enterMarkets.selector, true);\\n    setRoleCapability(role, address(pool), pool.exitMarket.selector, true);\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      bytes4[] memory selectors = getSupplierMarketSelectors();\\n      for (uint256 j = 0; j < selectors.length; j++) {\\n        setRoleCapability(role, address(allMarkets[i]), selectors[j], true);\\n      }\\n    }\\n  }\\n\\n  function openPoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\\n    _setPublicPoolBorrowerCapabilities(pool, true);\\n  }\\n\\n  function closePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\\n    _setPublicPoolBorrowerCapabilities(pool, false);\\n  }\\n\\n  function _setPublicPoolBorrowerCapabilities(IonicComptroller pool, bool setPublic) internal {\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].borrow.selector, setPublic);\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrow.selector, setPublic);\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, setPublic);\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].flash.selector, setPublic);\\n    }\\n  }\\n\\n  function configurePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\\n    // borrowers have the SUPPLIER_ROLE capabilities by default\\n    _configurePoolSupplierCapabilities(pool, BORROWER_ROLE);\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, true);\\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\\n    }\\n  }\\n\\n  function configureClosedPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, false);\\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\\n    }\\n  }\\n\\n  function configureOpenPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\\n      // TODO this leaves redeeming open for everyone\\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].redeem.selector, true);\\n    }\\n  }\\n\\n  function configureLeveredPositionCapabilities(IonicComptroller pool) external requiresAuth {\\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.enterMarkets.selector, true);\\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.exitMarket.selector, true);\\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\\n    for (uint256 i = 0; i < allMarkets.length; i++) {\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].mint.selector, true);\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeemUnderlying.selector, true);\\n\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1ec824166a7b4b1e67384a25d231d3acab89ef90ff43ff380cbf1715410d9851\",\"license\":\"UNLICENSED\"},\"contracts/ionic/SafeOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\n\\nabstract contract SafeOwnable is Ownable2Step {\\n  function renounceOwnership() public override onlyOwner {\\n    revert(\\\"renounce ownership not allowed\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x197d918d773af5d2d6b0235539ede726a9dd5f5153e4c0356a5700f2d85c836f\",\"license\":\"UNLICENSED\"},\"contracts/ionic/SafeOwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\\\";\\n\\n/**\\n * @dev Ownable extension that requires a two-step process of setting the pending owner and the owner accepting it.\\n * @notice Existing OwnableUpgradeable contracts cannot be upgraded due to the extra storage variable\\n * that will shift the other.\\n */\\nabstract contract SafeOwnableUpgradeable is OwnableUpgradeable {\\n  /**\\n   * @notice Pending owner of this contract\\n   */\\n  address public pendingOwner;\\n\\n  function __SafeOwnable_init(address owner_) internal onlyInitializing {\\n    __Ownable_init();\\n    _transferOwnership(owner_);\\n  }\\n\\n  struct AddressSlot {\\n    address value;\\n  }\\n\\n  modifier onlyOwnerOrAdmin() {\\n    bool isOwner = owner() == _msgSender();\\n    if (!isOwner) {\\n      address admin = _getProxyAdmin();\\n      bool isAdmin = admin == _msgSender();\\n      require(isAdmin, \\\"Ownable: caller is neither the owner nor the admin\\\");\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Emitted when pendingOwner is changed\\n   */\\n  event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\\n\\n  /**\\n   * @notice Emitted when pendingOwner is accepted, which means owner is updated\\n   */\\n  event NewOwner(address oldOwner, address newOwner);\\n\\n  /**\\n   * @notice Begins transfer of owner rights. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\\n   * @dev Owner function to begin change of owner. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\\n   * @param newPendingOwner New pending owner.\\n   */\\n  function _setPendingOwner(address newPendingOwner) public onlyOwner {\\n    // Save current value, if any, for inclusion in log\\n    address oldPendingOwner = pendingOwner;\\n\\n    // Store pendingOwner with value newPendingOwner\\n    pendingOwner = newPendingOwner;\\n\\n    // Emit NewPendingOwner(oldPendingOwner, newPendingOwner)\\n    emit NewPendingOwner(oldPendingOwner, newPendingOwner);\\n  }\\n\\n  /**\\n   * @notice Accepts transfer of owner rights. msg.sender must be pendingOwner\\n   * @dev Owner function for pending owner to accept role and update owner\\n   */\\n  function _acceptOwner() public {\\n    // Check caller is pendingOwner and pendingOwner \\u2260 address(0)\\n    require(msg.sender == pendingOwner, \\\"not the pending owner\\\");\\n\\n    // Save current values for inclusion in log\\n    address oldOwner = owner();\\n    address oldPendingOwner = pendingOwner;\\n\\n    // Store owner with value pendingOwner\\n    _transferOwnership(pendingOwner);\\n\\n    // Clear the pending value\\n    pendingOwner = address(0);\\n\\n    emit NewOwner(oldOwner, pendingOwner);\\n    emit NewPendingOwner(oldPendingOwner, pendingOwner);\\n  }\\n\\n  function renounceOwnership() public override onlyOwner {\\n    // do not remove this overriding fn\\n    revert(\\\"not used anymore\\\");\\n  }\\n\\n  function transferOwnership(address newOwner) public override onlyOwner {\\n    emit NewPendingOwner(pendingOwner, newOwner);\\n    pendingOwner = newOwner;\\n  }\\n\\n  function _getProxyAdmin() internal view returns (address admin) {\\n    bytes32 _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n    AddressSlot storage adminSlot;\\n    assembly {\\n      adminSlot.slot := _ADMIN_SLOT\\n    }\\n    admin = adminSlot.value;\\n  }\\n}\\n\",\"keccak256\":\"0x73f50a022ee86874b63ebd7e418b5948ef2913e32cb80024fe3cd4f17be7f2a5\",\"license\":\"UNLICENSED\"},\"contracts/ionic/strategies/CompoundMarketERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport { IonicERC4626 } from \\\"./IonicERC4626.sol\\\";\\nimport { ICErc20 } from \\\"../../compound/CTokenInterfaces.sol\\\";\\nimport { IonicComptroller } from \\\"../../compound/ComptrollerInterface.sol\\\";\\nimport { OptimizedVaultsRegistry } from \\\"../vault/OptimizedVaultsRegistry.sol\\\";\\nimport { OptimizedAPRVaultBase } from \\\"../vault/OptimizedAPRVaultBase.sol\\\";\\nimport { IonicFlywheel } from \\\"./flywheel/IonicFlywheel.sol\\\";\\nimport { IonicFlywheelLensRouter } from \\\"./flywheel/IonicFlywheelLensRouter.sol\\\";\\n\\nimport { ERC20Upgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ncontract CompoundMarketERC4626 is IonicERC4626 {\\n  ICErc20 public market;\\n  uint256 public blocksPerYear;\\n  OptimizedVaultsRegistry public registry;\\n\\n  event ClaimedVaultRewards(address indexed rewardToken, address indexed vault, uint256 amount);\\n\\n  modifier onlyRegisteredVaults() {\\n    OptimizedAPRVaultBase[] memory vaults = registry.getAllVaults();\\n    bool isMsgSender = false;\\n    for (uint256 i = 0; i < vaults.length; i++) {\\n      if (msg.sender == address(vaults[i])) {\\n        isMsgSender = true;\\n        break;\\n      }\\n    }\\n    require(isMsgSender, \\\"!caller not a vault\\\");\\n    _;\\n  }\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  function initialize(\\n    ICErc20 market_,\\n    uint256 blocksPerYear_,\\n    OptimizedVaultsRegistry registry_\\n  ) public initializer {\\n    __IonicER4626_init(ERC20Upgradeable(market_.underlying()));\\n    market = market_;\\n    blocksPerYear = blocksPerYear_;\\n    registry = registry_;\\n  }\\n\\n  function reinitialize(address registry_) public onlyOwnerOrAdmin {\\n    registry = OptimizedVaultsRegistry(registry_);\\n  }\\n\\n  function lenderName() public view returns (string memory) {\\n    return string(bytes.concat(\\\"Ionic Optimized \\\", bytes(name())));\\n  }\\n\\n  function totalAssets() public view override returns (uint256) {\\n    return market.balanceOfUnderlying(address(this));\\n  }\\n\\n  function balanceOfUnderlying(address account) public view returns (uint256) {\\n    return convertToAssets(balanceOf(account));\\n  }\\n\\n  function afterDeposit(uint256 amount, uint256) internal override onlyRegisteredVaults {\\n    ERC20Upgradeable(asset()).approve(address(market), amount);\\n    require(market.mint(amount) == 0, \\\"deposit to market failed\\\");\\n  }\\n\\n  function beforeWithdraw(uint256 amount, uint256) internal override onlyRegisteredVaults {\\n    require(market.redeemUnderlying(amount) == 0, \\\"redeem from market failed\\\");\\n  }\\n\\n  function aprAfterDeposit(uint256 amount) public view returns (uint256) {\\n    return _rewardsApr() + market.supplyRatePerBlockAfterDeposit(amount) * blocksPerYear;\\n  }\\n\\n  function aprAfterWithdraw(uint256 amount) public view returns (uint256) {\\n    return _rewardsApr() + market.supplyRatePerBlockAfterWithdraw(amount) * blocksPerYear;\\n  }\\n\\n  function emergencyWithdrawAndPause() external override {\\n    require(msg.sender == owner() || msg.sender == address(registry), \\\"not owner or vaults registry\\\");\\n    require(market.redeemUnderlying(type(uint256).max) == 0, \\\"redeem all failed\\\");\\n    _pause();\\n  }\\n\\n  function unpause() external override onlyOwner {\\n    _unpause();\\n  }\\n\\n  /*------------------------------------------------------------\\n                        IGenericLender FNs\\n    ------------------------------------------------------------*/\\n\\n  function rewardsApr() public view returns (uint256) {\\n    return _rewardsApr();\\n  }\\n\\n  /// @notice Returns an estimation of the current Annual Percentage Rate on the lender\\n  function apr() public view returns (uint256) {\\n    return _rewardsApr() + market.supplyRatePerBlock() * blocksPerYear;\\n  }\\n\\n  function _rewardsApr() internal view returns (uint256) {\\n    return uint256(registry.flr().getRewardsAprForMarket(market));\\n  }\\n\\n  /// @notice Returns an estimation of the current Annual Percentage Rate weighted by the assets under\\n  /// management of the lender\\n  function weightedApr() external view returns (uint256) {\\n    return (apr() * totalAssets()) / 1e18;\\n  }\\n\\n  /// @notice Returns an estimation of the hypothetical Annual Percentage Rate weighted by the assets under\\n  /// management of the lender plus the amount, if deposited\\n  function weightedAprAfterDeposit(uint256 amount) public view returns (uint256) {\\n    return (aprAfterDeposit(amount) * (totalAssets() + amount)) / 1e18;\\n  }\\n\\n  /// @notice Withdraws a given amount from lender\\n  /// @param amount The amount the caller wants to withdraw\\n  /// @return Amount actually withdrawn\\n  function withdraw(uint256 amount) public returns (uint256) {\\n    withdraw(amount, msg.sender, msg.sender);\\n    return amount;\\n  }\\n\\n  /// @notice Withdraws as much as possible from the lending platform\\n  /// @return Whether everything was withdrawn or not\\n  function withdrawAll() public returns (bool) {\\n    return withdraw(maxWithdraw(msg.sender), msg.sender, msg.sender) > 0;\\n  }\\n\\n  /// @notice Removes tokens from this Strategy that are not the type of tokens\\n  /// managed by this Strategy. This may be used in case of accidentally\\n  /// sending the wrong kind of token to this Strategy.\\n  ///\\n  /// @param _token The token to transfer out of this poolManager.\\n  /// @param to Address to send the tokens to.\\n  function sweep(address _token, address to) public onlyOwner {\\n    require(_token != asset(), \\\"!asset\\\");\\n\\n    ERC20Upgradeable token = ERC20Upgradeable(_token);\\n    token.transfer(to, token.balanceOf(address(this)));\\n  }\\n\\n  function claimRewards() public onlyRegisteredVaults {\\n    IonicComptroller pool = IonicComptroller(market.comptroller());\\n    address[] memory poolFlywheels = pool.getRewardsDistributors();\\n\\n    for (uint256 j = 0; j < poolFlywheels.length; j++) {\\n      IonicFlywheel flywheel = IonicFlywheel(poolFlywheels[j]);\\n      ERC20 rewardToken = flywheel.rewardToken();\\n\\n      // accrue and claim the rewards\\n      flywheel.accrue(ERC20(address(market)), address(this));\\n      flywheel.claimRewards(address(this));\\n\\n      uint256 totalRewards = rewardToken.balanceOf(address(this));\\n      // avoid rounding errors for too little amounts\\n      if (totalRewards > 1000) {\\n        // the rewards that are in the underlying asset are autocompounded\\n        if (address(rewardToken) == address(asset())) {\\n          afterDeposit(totalRewards, 0);\\n        } else {\\n          // redistribute the claimed rewards among the vaults\\n          OptimizedAPRVaultBase[] memory vaults = registry.getAllVaults();\\n          for (uint256 i = 0; i < vaults.length; i++) {\\n            address vaultAddress = address(vaults[i]);\\n            uint256 vaultSharesInAdapter = balanceOf(vaultAddress);\\n            uint256 vaultShareOfRewards = (vaultSharesInAdapter * totalRewards) / totalSupply();\\n            if (vaultShareOfRewards > 0) {\\n              rewardToken.transfer(vaultAddress, vaultShareOfRewards);\\n              emit ClaimedVaultRewards(address(rewardToken), vaultAddress, vaultShareOfRewards);\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x1d8cb09df9d4afe7dbbcfc0e23fd169fa081c1287a5f66dd6aeb780ac8fd0230\",\"license\":\"UNLICENSED\"},\"contracts/ionic/strategies/IonicERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport { FixedPointMathLib } from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\n\\nimport { PausableUpgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\\\";\\nimport { ERC4626Upgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport { ERC20Upgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport { SafeOwnableUpgradeable } from \\\"../../ionic/SafeOwnableUpgradeable.sol\\\";\\n\\nabstract contract IonicERC4626 is SafeOwnableUpgradeable, PausableUpgradeable, ERC4626Upgradeable {\\n  using FixedPointMathLib for uint256;\\n  using SafeERC20Upgradeable for ERC20Upgradeable;\\n\\n  /* ========== STATE VARIABLES ========== */\\n\\n  uint256 public vaultShareHWM;\\n  uint256 public performanceFee;\\n  address public feeRecipient;\\n\\n  /* ========== EVENTS ========== */\\n\\n  event UpdatedFeeSettings(\\n    uint256 oldPerformanceFee,\\n    uint256 newPerformanceFee,\\n    address oldFeeRecipient,\\n    address newFeeRecipient\\n  );\\n\\n  /* ========== INITIALIZER ========== */\\n\\n  function __IonicER4626_init(ERC20Upgradeable asset_) internal onlyInitializing {\\n    __SafeOwnable_init(msg.sender);\\n    __Pausable_init();\\n    __Context_init();\\n    __ERC20_init(\\n      string(abi.encodePacked(\\\"Ionic \\\", asset_.name(), \\\" Vault\\\")),\\n      string(abi.encodePacked(\\\"mv\\\", asset_.symbol()))\\n    );\\n    __ERC4626_init(asset_);\\n\\n    vaultShareHWM = 10**asset_.decimals();\\n    feeRecipient = msg.sender;\\n  }\\n\\n  function _asset() internal view returns (ERC20Upgradeable) {\\n    return ERC20Upgradeable(super.asset());\\n  }\\n\\n  /* ========== DEPOSIT/WITHDRAW FUNCTIONS ========== */\\n\\n  function deposit(uint256 assets, address receiver) public override whenNotPaused returns (uint256 shares) {\\n    // Check for rounding error since we round down in previewDeposit.\\n    require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n    // Need to transfer before minting or ERC777s could reenter.\\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\\n\\n    _mint(receiver, shares);\\n\\n    emit Deposit(msg.sender, receiver, assets, shares);\\n\\n    afterDeposit(assets, shares);\\n  }\\n\\n  function mint(uint256 shares, address receiver) public override whenNotPaused returns (uint256 assets) {\\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n    // Need to transfer before minting or ERC777s could reenter.\\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\\n\\n    _mint(receiver, shares);\\n\\n    emit Deposit(msg.sender, receiver, assets, shares);\\n\\n    afterDeposit(assets, shares);\\n  }\\n\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256 shares) {\\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n    if (msg.sender != owner) {\\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\\n    }\\n\\n    if (!paused()) {\\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\\n\\n      beforeWithdraw(assets, shares);\\n\\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\\n    }\\n\\n    _burn(owner, shares);\\n\\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n    _asset().safeTransfer(receiver, assets);\\n  }\\n\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256 assets) {\\n    if (msg.sender != owner) {\\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\\n    }\\n\\n    // Check for rounding error since we round down in previewRedeem.\\n    require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n    if (!paused()) {\\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\\n\\n      beforeWithdraw(assets, shares);\\n\\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\\n    }\\n\\n    _burn(owner, shares);\\n\\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n    _asset().safeTransfer(receiver, assets);\\n  }\\n\\n  /* ========== FEE FUNCTIONS ========== */\\n\\n  /**\\n   * @notice Take the performance fee that has accrued since last fee harvest.\\n   * @dev Performance fee is based on a vault share high water mark value. If vault share value has increased above the\\n   *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\\n   */\\n  function takePerformanceFee() external onlyOwner {\\n    require(feeRecipient != address(0), \\\"fee recipient not initialized\\\");\\n\\n    uint256 currentAssets = totalAssets();\\n    uint256 shareValue = convertToAssets(10**_asset().decimals());\\n\\n    require(shareValue > vaultShareHWM, \\\"shareValue !> vaultShareHWM\\\");\\n    // cache value\\n    uint256 supply = totalSupply();\\n\\n    uint256 accruedPerformanceFee = (performanceFee * (shareValue - vaultShareHWM) * supply) / 1e36;\\n    _mint(feeRecipient, accruedPerformanceFee.mulDivDown(supply, (currentAssets - accruedPerformanceFee)));\\n\\n    vaultShareHWM = convertToAssets(10**_asset().decimals());\\n  }\\n\\n  /**\\n   * @notice Transfer accrued fees to rewards manager contract. Caller must be a registered keeper.\\n   * @dev We must make sure that feeRecipient is not address(0) before withdrawing fees\\n   */\\n  function withdrawAccruedFees() external onlyOwner {\\n    redeem(balanceOf(feeRecipient), feeRecipient, feeRecipient);\\n  }\\n\\n  /**\\n   * @notice Update performanceFee and/or feeRecipient\\n   */\\n  function updateFeeSettings(uint256 newPerformanceFee, address newFeeRecipient) external onlyOwner {\\n    emit UpdatedFeeSettings(performanceFee, newPerformanceFee, feeRecipient, newFeeRecipient);\\n\\n    performanceFee = newPerformanceFee;\\n\\n    if (newFeeRecipient != feeRecipient) {\\n      if (feeRecipient != address(0)) {\\n        uint256 oldFees = balanceOf(feeRecipient);\\n\\n        _burn(feeRecipient, oldFees);\\n        _approve(feeRecipient, owner(), 0);\\n        _mint(newFeeRecipient, oldFees);\\n      }\\n\\n      _approve(newFeeRecipient, owner(), type(uint256).max);\\n    }\\n\\n    feeRecipient = newFeeRecipient;\\n  }\\n\\n  /* ========== EMERGENCY FUNCTIONS ========== */\\n\\n  // Should withdraw all funds from the strategy and pause the contract\\n  function emergencyWithdrawAndPause() external virtual;\\n\\n  function unpause() external virtual;\\n\\n  function shutdown(address market) external onlyOwner whenPaused returns (uint256) {\\n    ERC20Upgradeable theAsset = _asset();\\n    uint256 endBalance = theAsset.balanceOf(address(this));\\n    theAsset.transfer(market, endBalance);\\n    return endBalance;\\n  }\\n\\n  /* ========== INTERNAL HOOKS LOGIC ========== */\\n\\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual;\\n\\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual;\\n}\\n\",\"keccak256\":\"0x8837560422fee8bb2cb259fa8b4a9d7311d950e2efa67626fde5d8b189d033bc\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/IFlywheelBooster.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/**\\n @title Balance Booster Module for Flywheel\\n @notice Flywheel is a general framework for managing token incentives.\\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\\n\\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \\n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\\n        \\n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\\n\\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\\n*/\\ninterface IFlywheelBooster {\\n    /**\\n      @notice calculate the boosted supply of a strategy.\\n      @param strategy the strategy to calculate boosted supply of\\n      @return the boosted supply\\n     */\\n    function boostedTotalSupply(ERC20 strategy) external view returns (uint256);\\n\\n    /**\\n      @notice calculate the boosted balance of a user in a given strategy.\\n      @param strategy the strategy to calculate boosted balance of\\n      @param user the user to calculate boosted balance of\\n      @return the boosted balance\\n     */\\n    function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xcdab1b4b5662148d74acc3491a810d263ec509f9f81a267e9f6c1542ba15eabc\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/IIonicFlywheel.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\n\\ninterface IIonicFlywheel {\\n  function isRewardsDistributor() external view returns (bool);\\n\\n  function isFlywheel() external view returns (bool);\\n\\n  function flywheelPreSupplierAction(address market, address supplier) external;\\n\\n  function flywheelPreBorrowerAction(address market, address borrower) external;\\n\\n  function flywheelPreTransferAction(address market, address src, address dst) external;\\n\\n  function compAccrued(address user) external view returns (uint256);\\n\\n  function addMarketForRewards(ERC20 strategy) external;\\n\\n  function marketState(ERC20 strategy) external view returns (uint224 index, uint32 lastUpdatedTimestamp);\\n}\\n\",\"keccak256\":\"0xff22373cdfde4c4b29712375b58b74993647c27dce29c1f25087780e87fd0210\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/IonicFlywheel.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { IonicFlywheelCore } from \\\"./IonicFlywheelCore.sol\\\";\\nimport \\\"./IIonicFlywheel.sol\\\";\\n\\ncontract IonicFlywheel is IonicFlywheelCore, IIonicFlywheel {\\n  bool public constant isRewardsDistributor = true;\\n  bool public constant isFlywheel = true;\\n\\n  function flywheelPreSupplierAction(address market, address supplier) external {\\n    accrue(ERC20(market), supplier);\\n  }\\n\\n  function flywheelPreBorrowerAction(address market, address borrower) external {}\\n\\n  function flywheelPreTransferAction(address market, address src, address dst) external {\\n    accrue(ERC20(market), src, dst);\\n  }\\n\\n  function compAccrued(address user) external view returns (uint256) {\\n    return _rewardsAccrued[user];\\n  }\\n\\n  function addMarketForRewards(ERC20 strategy) external onlyOwner {\\n    _addStrategyForRewards(strategy);\\n  }\\n\\n  // TODO remove\\n  function marketState(ERC20 strategy) external view returns (uint224, uint32) {\\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\\n  }\\n}\\n\",\"keccak256\":\"0x60d8d5a8feaa7c0373d24d6fbca523eb86ba251f5374a8821a6aee63cdc90e0d\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/IonicFlywheelCore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { SafeCastLib } from \\\"solmate/utils/SafeCastLib.sol\\\";\\n\\nimport { IFlywheelRewards } from \\\"./rewards/IFlywheelRewards.sol\\\";\\nimport { IFlywheelBooster } from \\\"./IFlywheelBooster.sol\\\";\\n\\nimport { SafeOwnableUpgradeable } from \\\"../../../ionic/SafeOwnableUpgradeable.sol\\\";\\n\\ncontract IonicFlywheelCore is SafeOwnableUpgradeable {\\n  using SafeTransferLib for ERC20;\\n  using SafeCastLib for uint256;\\n\\n  /// @notice How much rewardsToken will be send to treasury\\n  uint256 public performanceFee;\\n\\n  /// @notice Address that gets rewardsToken accrued by performanceFee\\n  address public feeRecipient;\\n\\n  /// @notice The token to reward\\n  ERC20 public rewardToken;\\n\\n  /// @notice append-only list of strategies added\\n  ERC20[] public allStrategies;\\n\\n  /// @notice the rewards contract for managing streams\\n  IFlywheelRewards public flywheelRewards;\\n\\n  /// @notice optional booster module for calculating virtual balances on strategies\\n  IFlywheelBooster public flywheelBooster;\\n\\n  /// @notice The accrued but not yet transferred rewards for each user\\n  mapping(address => uint256) internal _rewardsAccrued;\\n\\n  /// @notice The strategy index and last updated per strategy\\n  mapping(ERC20 => RewardsState) internal _strategyState;\\n\\n  /// @notice user index per strategy\\n  mapping(ERC20 => mapping(address => uint224)) internal _userIndex;\\n\\n  constructor() {\\n    // prevents the misusage of the implementation contract\\n    _disableInitializers();\\n  }\\n\\n  function initialize(\\n    ERC20 _rewardToken,\\n    IFlywheelRewards _flywheelRewards,\\n    IFlywheelBooster _flywheelBooster,\\n    address _owner\\n  ) public initializer {\\n    __SafeOwnable_init(msg.sender);\\n\\n    rewardToken = _rewardToken;\\n    flywheelRewards = _flywheelRewards;\\n    flywheelBooster = _flywheelBooster;\\n\\n    _transferOwnership(_owner);\\n\\n    performanceFee = 10e16; // 10%\\n    feeRecipient = _owner;\\n  }\\n\\n  /*----------------------------------------------------------------\\n                        ACCRUE/CLAIM LOGIC\\n    ----------------------------------------------------------------*/\\n\\n  /** \\n      @notice Emitted when a user's rewards accrue to a given strategy.\\n      @param strategy the updated rewards strategy\\n      @param user the user of the rewards\\n      @param rewardsDelta how many new rewards accrued to the user\\n      @param rewardsIndex the market index for rewards per token accrued\\n    */\\n  event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\\n\\n  /** \\n      @notice Emitted when a user claims accrued rewards.\\n      @param user the user of the rewards\\n      @param amount the amount of rewards claimed\\n    */\\n  event ClaimRewards(address indexed user, uint256 amount);\\n\\n  /** \\n      @notice accrue rewards for a single user on a strategy\\n      @param strategy the strategy to accrue a user's rewards on\\n      @param user the user to be accrued\\n      @return the cumulative amount of rewards accrued to user (including prior)\\n    */\\n  function accrue(ERC20 strategy, address user) public returns (uint256) {\\n    (uint224 index, uint32 ts) = strategyState(strategy);\\n    RewardsState memory state = RewardsState(index, ts);\\n\\n    if (state.index == 0) return 0;\\n\\n    state = accrueStrategy(strategy, state);\\n    return accrueUser(strategy, user, state);\\n  }\\n\\n  /** \\n      @notice accrue rewards for a two users on a strategy\\n      @param strategy the strategy to accrue a user's rewards on\\n      @param user the first user to be accrued\\n      @param user the second user to be accrued\\n      @return the cumulative amount of rewards accrued to the first user (including prior)\\n      @return the cumulative amount of rewards accrued to the second user (including prior)\\n    */\\n  function accrue(\\n    ERC20 strategy,\\n    address user,\\n    address secondUser\\n  ) public returns (uint256, uint256) {\\n    (uint224 index, uint32 ts) = strategyState(strategy);\\n    RewardsState memory state = RewardsState(index, ts);\\n\\n    if (state.index == 0) return (0, 0);\\n\\n    state = accrueStrategy(strategy, state);\\n    return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\\n  }\\n\\n  /** \\n      @notice claim rewards for a given user\\n      @param user the user claiming rewards\\n      @dev this function is public, and all rewards transfer to the user\\n    */\\n  function claimRewards(address user) external {\\n    uint256 accrued = rewardsAccrued(user);\\n\\n    if (accrued != 0) {\\n      _rewardsAccrued[user] = 0;\\n\\n      rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\\n\\n      emit ClaimRewards(user, accrued);\\n    }\\n  }\\n\\n  /*----------------------------------------------------------------\\n                          ADMIN LOGIC\\n    ----------------------------------------------------------------*/\\n\\n  /** \\n      @notice Emitted when a new strategy is added to flywheel by the admin\\n      @param newStrategy the new added strategy\\n    */\\n  event AddStrategy(address indexed newStrategy);\\n\\n  /// @notice initialize a new strategy\\n  function addStrategyForRewards(ERC20 strategy) external onlyOwner {\\n    _addStrategyForRewards(strategy);\\n  }\\n\\n  function _addStrategyForRewards(ERC20 strategy) internal {\\n    (uint224 index, ) = strategyState(strategy);\\n    require(index == 0, \\\"strategy\\\");\\n    _strategyState[strategy] = RewardsState({\\n      index: (10**rewardToken.decimals()).safeCastTo224(),\\n      lastUpdatedTimestamp: block.timestamp.safeCastTo32()\\n    });\\n\\n    allStrategies.push(strategy);\\n    emit AddStrategy(address(strategy));\\n  }\\n\\n  function getAllStrategies() external view returns (ERC20[] memory) {\\n    return allStrategies;\\n  }\\n\\n  /** \\n      @notice Emitted when the rewards module changes\\n      @param newFlywheelRewards the new rewards module\\n    */\\n  event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\\n\\n  /// @notice swap out the flywheel rewards contract\\n  function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external onlyOwner {\\n    if (address(flywheelRewards) != address(0)) {\\n      uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\\n      if (oldRewardBalance > 0) {\\n        rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\\n      }\\n    }\\n\\n    flywheelRewards = newFlywheelRewards;\\n\\n    emit FlywheelRewardsUpdate(address(newFlywheelRewards));\\n  }\\n\\n  /** \\n      @notice Emitted when the booster module changes\\n      @param newBooster the new booster module\\n    */\\n  event FlywheelBoosterUpdate(address indexed newBooster);\\n\\n  /// @notice swap out the flywheel booster contract\\n  function setBooster(IFlywheelBooster newBooster) external onlyOwner {\\n    flywheelBooster = newBooster;\\n\\n    emit FlywheelBoosterUpdate(address(newBooster));\\n  }\\n\\n  event UpdatedFeeSettings(\\n    uint256 oldPerformanceFee,\\n    uint256 newPerformanceFee,\\n    address oldFeeRecipient,\\n    address newFeeRecipient\\n  );\\n\\n  /**\\n   * @notice Update performanceFee and/or feeRecipient\\n   * @dev Claim rewards first from the previous feeRecipient before changing it\\n   */\\n  function updateFeeSettings(uint256 _performanceFee, address _feeRecipient) external onlyOwner {\\n    _updateFeeSettings(_performanceFee, _feeRecipient);\\n  }\\n\\n  function _updateFeeSettings(uint256 _performanceFee, address _feeRecipient) internal {\\n    emit UpdatedFeeSettings(performanceFee, _performanceFee, feeRecipient, _feeRecipient);\\n\\n    if (feeRecipient != _feeRecipient) {\\n      _rewardsAccrued[_feeRecipient] += rewardsAccrued(feeRecipient);\\n      _rewardsAccrued[feeRecipient] = 0;\\n    }\\n    performanceFee = _performanceFee;\\n    feeRecipient = _feeRecipient;\\n  }\\n\\n  /*----------------------------------------------------------------\\n                    INTERNAL ACCOUNTING LOGIC\\n    ----------------------------------------------------------------*/\\n\\n  struct RewardsState {\\n    /// @notice The strategy's last updated index\\n    uint224 index;\\n    /// @notice The timestamp the index was last updated at\\n    uint32 lastUpdatedTimestamp;\\n  }\\n\\n  /// @notice accumulate global rewards on a strategy\\n  function accrueStrategy(ERC20 strategy, RewardsState memory state)\\n    private\\n    returns (RewardsState memory rewardsState)\\n  {\\n    // calculate accrued rewards through module\\n    uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\\n\\n    rewardsState = state;\\n\\n    if (strategyRewardsAccrued > 0) {\\n      // use the booster or token supply to calculate reward index denominator\\n      uint256 totalTokens = address(flywheelBooster) != address(0)\\n        ? flywheelBooster.boostedTotalSupply(strategy)\\n        : strategy.totalSupply();\\n\\n      // 100% = 100e16\\n      uint256 accruedFees = (strategyRewardsAccrued * performanceFee) / uint224(100e16);\\n\\n      _rewardsAccrued[feeRecipient] += accruedFees;\\n      strategyRewardsAccrued -= accruedFees;\\n\\n      uint224 deltaIndex;\\n\\n      if (totalTokens != 0)\\n        deltaIndex = ((strategyRewardsAccrued * (10**strategy.decimals())) / totalTokens).safeCastTo224();\\n\\n      // accumulate rewards per token onto the index, multiplied by fixed-point factor\\n      rewardsState = RewardsState({\\n        index: state.index + deltaIndex,\\n        lastUpdatedTimestamp: block.timestamp.safeCastTo32()\\n      });\\n      _strategyState[strategy] = rewardsState;\\n    }\\n  }\\n\\n  /// @notice accumulate rewards on a strategy for a specific user\\n  function accrueUser(\\n    ERC20 strategy,\\n    address user,\\n    RewardsState memory state\\n  ) private returns (uint256) {\\n    // load indices\\n    uint224 strategyIndex = state.index;\\n    uint224 supplierIndex = userIndex(strategy, user);\\n\\n    // sync user index to global\\n    _userIndex[strategy][user] = strategyIndex;\\n\\n    // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\\n    // zero balances will have no effect other than syncing to global index\\n    if (supplierIndex == 0) {\\n      supplierIndex = (10**rewardToken.decimals()).safeCastTo224();\\n    }\\n\\n    uint224 deltaIndex = strategyIndex - supplierIndex;\\n    // use the booster or token balance to calculate reward balance multiplier\\n    uint256 supplierTokens = address(flywheelBooster) != address(0)\\n      ? flywheelBooster.boostedBalanceOf(strategy, user)\\n      : strategy.balanceOf(user);\\n\\n    // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\\n    uint256 supplierDelta = (deltaIndex * supplierTokens) / (10**strategy.decimals());\\n    uint256 supplierAccrued = rewardsAccrued(user) + supplierDelta;\\n\\n    _rewardsAccrued[user] = supplierAccrued;\\n\\n    emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\\n\\n    return supplierAccrued;\\n  }\\n\\n  function rewardsAccrued(address user) public view virtual returns (uint256) {\\n    return _rewardsAccrued[user];\\n  }\\n\\n  function userIndex(ERC20 strategy, address user) public view virtual returns (uint224) {\\n    return _userIndex[strategy][user];\\n  }\\n\\n  function strategyState(ERC20 strategy) public view virtual returns (uint224 index, uint32 lastUpdatedTimestamp) {\\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\\n  }\\n\\n  function getRewardsPerSecondPerToken(ERC20 strategy) external view returns (uint256) {\\n    uint256 totalTokens = address(flywheelBooster) != address(0)\\n      ? flywheelBooster.boostedTotalSupply(strategy)\\n      : strategy.totalSupply();\\n    if (totalTokens == 0) return 0;\\n    return (flywheelRewards.getRewardsPerSecond(strategy) * (10 ** strategy.decimals())) / totalTokens;\\n  }\\n}\\n\",\"keccak256\":\"0x49950c93ddeb91e6220ff11195718a97eb7686097b21fc354b904a3d58534348\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/IonicFlywheelLensRouter.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport { IonicFlywheelCore } from \\\"./IonicFlywheelCore.sol\\\";\\nimport { IonicComptroller } from \\\"../../../compound/ComptrollerInterface.sol\\\";\\nimport { ICErc20 } from \\\"../../../compound/CTokenInterfaces.sol\\\";\\nimport { BasePriceOracle } from \\\"../../../oracles/BasePriceOracle.sol\\\";\\nimport { PoolDirectory } from \\\"../../../PoolDirectory.sol\\\";\\n\\ninterface IPriceOracle_IFLR {\\n  function getUnderlyingPrice(ERC20 cToken) external view returns (uint256);\\n\\n  function price(address underlying) external view returns (uint256);\\n}\\n\\ncontract IonicFlywheelLensRouter {\\n  PoolDirectory public fpd;\\n\\n  constructor(PoolDirectory _fpd) {\\n    fpd = _fpd;\\n  }\\n\\n  struct MarketRewardsInfo {\\n    /// @dev comptroller oracle price of market underlying\\n    uint256 underlyingPrice;\\n    ICErc20 market;\\n    RewardsInfo[] rewardsInfo;\\n  }\\n\\n  struct RewardsInfo {\\n    /// @dev rewards in `rewardToken` paid per underlying staked token in `market` per second\\n    uint256 rewardSpeedPerSecondPerToken;\\n    /// @dev comptroller oracle price of reward token\\n    uint256 rewardTokenPrice;\\n    /// @dev APR scaled by 1e18. Calculated as rewardSpeedPerSecondPerToken * rewardTokenPrice * 365.25 days / underlyingPrice\\n    uint256 formattedAPR;\\n    address flywheel;\\n    address rewardToken;\\n  }\\n\\n  function getPoolMarketRewardsInfo(IonicComptroller comptroller) external view returns (MarketRewardsInfo[] memory) {\\n    ICErc20[] memory markets = comptroller.getAllMarkets();\\n    return _getMarketRewardsInfo(markets, comptroller);\\n  }\\n\\n  function getMarketRewardsInfo(ICErc20[] memory markets) external view returns (MarketRewardsInfo[] memory) {\\n    IonicComptroller pool;\\n    for (uint256 i = 0; i < markets.length; i++) {\\n      ICErc20 asMarket = ICErc20(address(markets[i]));\\n      if (address(pool) == address(0)) pool = asMarket.comptroller();\\n      else require(asMarket.comptroller() == pool);\\n    }\\n    return _getMarketRewardsInfo(markets, pool);\\n  }\\n\\n  function _getMarketRewardsInfo(ICErc20[] memory markets, IonicComptroller comptroller)\\n    internal\\n    view\\n    returns (MarketRewardsInfo[] memory)\\n  {\\n    if (address(comptroller) == address(0) || markets.length == 0) return new MarketRewardsInfo[](0);\\n\\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\\n    address[] memory rewardTokens = new address[](flywheels.length);\\n    uint256[] memory rewardTokenPrices = new uint256[](flywheels.length);\\n    BasePriceOracle oracle = comptroller.oracle();\\n\\n    MarketRewardsInfo[] memory infoList = new MarketRewardsInfo[](markets.length);\\n    for (uint256 i = 0; i < markets.length; i++) {\\n      RewardsInfo[] memory rewardsInfo = new RewardsInfo[](flywheels.length);\\n\\n      ERC20 strategy = ERC20(address(markets[i]));\\n      uint256 price = oracle.price(markets[i].underlying()); // scaled to 1e18\\n\\n      if (i == 0) {\\n        for (uint256 j = 0; j < flywheels.length; j++) {\\n          ERC20 rewardToken = IonicFlywheelCore(flywheels[j]).rewardToken();\\n          rewardTokens[j] = address(rewardToken);\\n          rewardTokenPrices[j] = oracle.price(address(rewardToken)); // scaled to 1e18\\n        }\\n      }\\n\\n      for (uint256 j = 0; j < flywheels.length; j++) {\\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\\n\\n        uint256 rewardSpeedPerSecondPerToken = flywheel.getRewardsPerSecondPerToken(strategy);\\n        uint256 apr = getApr(\\n          rewardSpeedPerSecondPerToken,\\n          rewardTokenPrices[j],\\n          price\\n        );\\n\\n        rewardsInfo[j] = RewardsInfo({\\n          rewardSpeedPerSecondPerToken: rewardSpeedPerSecondPerToken, // scaled in 1e18\\n          rewardTokenPrice: rewardTokenPrices[j],\\n          formattedAPR: apr, // scaled in 1e18\\n          flywheel: address(flywheel),\\n          rewardToken: rewardTokens[j]\\n        });\\n      }\\n\\n      infoList[i] = MarketRewardsInfo({ market: markets[i], rewardsInfo: rewardsInfo, underlyingPrice: price });\\n    }\\n\\n    return infoList;\\n  }\\n\\n  function scaleIndexDiff(uint256 indexDiff, uint256 decimals) internal pure returns (uint256) {\\n    return decimals <= 18 ? uint256(indexDiff) * (10**(18 - decimals)) : uint256(indexDiff) / (10**(decimals - 18));\\n  }\\n\\n  function getApr(\\n    uint256 rewardSpeedPerSecondPerToken,\\n    uint256 rewardTokenPrice,\\n    uint256 underlyingPrice\\n  ) internal pure returns (uint256) {\\n    if (rewardSpeedPerSecondPerToken == 0) return 0;\\n    uint256 nativeSpeedPerSecondPerToken = rewardSpeedPerSecondPerToken * rewardTokenPrice; // scaled to 1e36\\n    uint256 nativeSpeedPerYearPerToken = nativeSpeedPerSecondPerToken * 365.25 days; // scaled to 1e36\\n    uint256 assetSpeedPerYearPerToken = nativeSpeedPerYearPerToken / underlyingPrice; // scaled to 1e18\\n\\n    return assetSpeedPerYearPerToken;\\n  }\\n\\n  function getRewardsAprForMarket(ICErc20 market) public view returns (int256 totalMarketRewardsApr) {\\n    IonicComptroller comptroller = market.comptroller();\\n    BasePriceOracle oracle = comptroller.oracle();\\n    uint256 underlyingPrice = oracle.getUnderlyingPrice(market);\\n\\n    ERC20 strategy = ERC20(address(market));\\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\\n    for (uint256 j = 0; j < flywheels.length; j++) {\\n      IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\\n\\n      uint256 rewardSpeedPerSecondPerToken = flywheel.getRewardsPerSecondPerToken(strategy);\\n\\n      uint256 marketApr = getApr(\\n        rewardSpeedPerSecondPerToken,\\n        oracle.price(address(flywheel.rewardToken())),\\n        underlyingPrice\\n      );\\n\\n      totalMarketRewardsApr += int256(marketApr);\\n    }\\n  }\\n\\n  function getUserNetValueDeltaForMarket(\\n    address user,\\n    ICErc20 market,\\n    int256 offchainApr,\\n    int256 blocksPerYear\\n  ) internal returns (int256) {\\n    IonicComptroller comptroller = market.comptroller();\\n    BasePriceOracle oracle = comptroller.oracle();\\n    int256 netApr = getRewardsAprForMarket(market) +\\n      getUserInterestAprForMarket(user, market, blocksPerYear) +\\n      offchainApr;\\n    return (netApr * int256(market.balanceOfUnderlying(user)) * int256(oracle.getUnderlyingPrice(market))) / 1e36;\\n  }\\n\\n  function getUserInterestAprForMarket(\\n    address user,\\n    ICErc20 market,\\n    int256 blocksPerYear\\n  ) internal returns (int256) {\\n    uint256 borrows = market.borrowBalanceCurrent(user);\\n    uint256 supplied = market.balanceOfUnderlying(user);\\n    uint256 supplyRatePerBlock = market.supplyRatePerBlock();\\n    uint256 borrowRatePerBlock = market.borrowRatePerBlock();\\n\\n    IonicComptroller comptroller = market.comptroller();\\n    BasePriceOracle oracle = comptroller.oracle();\\n    uint256 assetPrice = oracle.getUnderlyingPrice(market);\\n    uint256 collateralValue = (supplied * assetPrice) / 1e18;\\n    uint256 borrowsValue = (borrows * assetPrice) / 1e18;\\n\\n    uint256 yieldValuePerBlock = collateralValue * supplyRatePerBlock;\\n    uint256 interestOwedValuePerBlock = borrowsValue * borrowRatePerBlock;\\n\\n    if (collateralValue == 0) return 0;\\n    return ((int256(yieldValuePerBlock) - int256(interestOwedValuePerBlock)) * blocksPerYear) / int256(collateralValue);\\n  }\\n\\n  struct AdjustedUserNetAprVars {\\n    int256 userNetAssetsValue;\\n    int256 userNetValueDelta;\\n    BasePriceOracle oracle;\\n    ICErc20[] markets;\\n    IonicComptroller pool;\\n  }\\n\\n  function getAdjustedUserNetApr(\\n    address user,\\n    int256 blocksPerYear,\\n    address[] memory offchainRewardsAprMarkets,\\n    int256[] memory offchainRewardsAprs\\n  ) public returns (int256) {\\n    AdjustedUserNetAprVars memory vars;\\n\\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\\n      vars.oracle = pool.oracle();\\n      vars.markets = pool.getAllMarkets();\\n      for (uint256 j = 0; j < vars.markets.length; j++) {\\n        int256 offchainRewardsApr = 0;\\n        for (uint256 k = 0; k < offchainRewardsAprMarkets.length; k++) {\\n          if (offchainRewardsAprMarkets[k] == address(vars.markets[j])) offchainRewardsApr = offchainRewardsAprs[k];\\n        }\\n        vars.userNetAssetsValue +=\\n          int256(vars.markets[j].balanceOfUnderlying(user) * vars.oracle.getUnderlyingPrice(vars.markets[j])) /\\n          1e18;\\n        vars.userNetValueDelta += getUserNetValueDeltaForMarket(\\n          user,\\n          vars.markets[j],\\n          offchainRewardsApr,\\n          blocksPerYear\\n        );\\n      }\\n    }\\n\\n    if (vars.userNetAssetsValue == 0) return 0;\\n    else return (vars.userNetValueDelta * 1e18) / vars.userNetAssetsValue;\\n  }\\n\\n  function getUserNetApr(address user, int256 blocksPerYear) external returns (int256) {\\n    address[] memory emptyAddrArray = new address[](0);\\n    int256[] memory emptyIntArray = new int256[](0);\\n    return getAdjustedUserNetApr(user, blocksPerYear, emptyAddrArray, emptyIntArray);\\n  }\\n\\n  function getAllRewardTokens() public view returns (address[] memory uniqueRewardTokens) {\\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\\n\\n    uint256 rewardTokensCounter;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\\n      address[] memory fws = pool.getRewardsDistributors();\\n\\n      rewardTokensCounter += fws.length;\\n    }\\n\\n    address[] memory rewardTokens = new address[](rewardTokensCounter);\\n\\n    uint256 uniqueRewardTokensCounter = 0;\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\\n      address[] memory fws = pool.getRewardsDistributors();\\n\\n      for (uint256 j = 0; j < fws.length; j++) {\\n        address rwToken = address(IonicFlywheelCore(fws[j]).rewardToken());\\n        if (rwToken == address(0)) break;\\n\\n        bool added;\\n        for (uint256 k = 0; k < rewardTokens.length; k++) {\\n          if (rwToken == rewardTokens[k]) {\\n            added = true;\\n            break;\\n          }\\n        }\\n        if (!added) rewardTokens[uniqueRewardTokensCounter++] = rwToken;\\n      }\\n    }\\n\\n    uniqueRewardTokens = new address[](uniqueRewardTokensCounter);\\n    for (uint256 i = 0; i < uniqueRewardTokensCounter; i++) {\\n      uniqueRewardTokens[i] = rewardTokens[i];\\n    }\\n  }\\n\\n  function claimAllRewardTokens(address user) external returns (address[] memory, uint256[] memory) {\\n    address[] memory rewardTokens = getAllRewardTokens();\\n    uint256[] memory rewardsClaimedForToken = new uint256[](rewardTokens.length);\\n\\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\\n      rewardsClaimedForToken[i] = claimRewardsOfRewardToken(user, rewardTokens[i]);\\n    }\\n\\n    return (rewardTokens, rewardsClaimedForToken);\\n  }\\n\\n  function claimRewardsOfRewardToken(address user, address rewardToken) public returns (uint256 rewardsClaimed) {\\n    uint256 balanceBefore = ERC20(rewardToken).balanceOf(user);\\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\\n    for (uint256 i = 0; i < pools.length; i++) {\\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\\n      ERC20[] memory markets;\\n      {\\n        ICErc20[] memory cerc20s = pool.getAllMarkets();\\n        markets = new ERC20[](cerc20s.length);\\n        for (uint256 j = 0; j < cerc20s.length; j++) {\\n          markets[j] = ERC20(address(cerc20s[j]));\\n        }\\n      }\\n\\n      address[] memory flywheelAddresses = pool.getAccruingFlywheels();\\n      for (uint256 k = 0; k < flywheelAddresses.length; k++) {\\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheelAddresses[k]);\\n        if (address(flywheel.rewardToken()) == rewardToken) {\\n          for (uint256 m = 0; m < markets.length; m++) {\\n            flywheel.accrue(markets[m], user);\\n          }\\n          flywheel.claimRewards(user);\\n        }\\n      }\\n    }\\n\\n    uint256 balanceAfter = ERC20(rewardToken).balanceOf(user);\\n    return balanceAfter - balanceBefore;\\n  }\\n\\n  function claimRewardsForMarket(\\n    address user,\\n    ERC20 market,\\n    IonicFlywheelCore[] calldata flywheels,\\n    bool[] calldata accrue\\n  )\\n    external\\n    returns (\\n      IonicFlywheelCore[] memory,\\n      address[] memory rewardTokens,\\n      uint256[] memory rewards\\n    )\\n  {\\n    uint256 size = flywheels.length;\\n    rewards = new uint256[](size);\\n    rewardTokens = new address[](size);\\n\\n    for (uint256 i = 0; i < size; i++) {\\n      uint256 newRewards;\\n      if (accrue[i]) {\\n        newRewards = flywheels[i].accrue(market, user);\\n      } else {\\n        newRewards = flywheels[i].rewardsAccrued(user);\\n      }\\n\\n      // Take the max, because rewards are cumulative.\\n      rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\\n\\n      flywheels[i].claimRewards(user);\\n      rewardTokens[i] = address(flywheels[i].rewardToken());\\n    }\\n\\n    return (flywheels, rewardTokens, rewards);\\n  }\\n\\n  function claimRewardsForPool(address user, IonicComptroller comptroller)\\n    public\\n    returns (\\n      IonicFlywheelCore[] memory,\\n      address[] memory,\\n      uint256[] memory\\n    )\\n  {\\n    ICErc20[] memory cerc20s = comptroller.getAllMarkets();\\n    ERC20[] memory markets = new ERC20[](cerc20s.length);\\n    address[] memory flywheelAddresses = comptroller.getAccruingFlywheels();\\n    IonicFlywheelCore[] memory flywheels = new IonicFlywheelCore[](flywheelAddresses.length);\\n    bool[] memory accrue = new bool[](flywheelAddresses.length);\\n\\n    for (uint256 j = 0; j < flywheelAddresses.length; j++) {\\n      flywheels[j] = IonicFlywheelCore(flywheelAddresses[j]);\\n      accrue[j] = true;\\n    }\\n\\n    for (uint256 j = 0; j < cerc20s.length; j++) {\\n      markets[j] = ERC20(address(cerc20s[j]));\\n    }\\n\\n    return claimRewardsForMarkets(user, markets, flywheels, accrue);\\n  }\\n\\n  function claimRewardsForMarkets(\\n    address user,\\n    ERC20[] memory markets,\\n    IonicFlywheelCore[] memory flywheels,\\n    bool[] memory accrue\\n  )\\n    public\\n    returns (\\n      IonicFlywheelCore[] memory,\\n      address[] memory rewardTokens,\\n      uint256[] memory rewards\\n    )\\n  {\\n    rewards = new uint256[](flywheels.length);\\n    rewardTokens = new address[](flywheels.length);\\n\\n    for (uint256 i = 0; i < flywheels.length; i++) {\\n      for (uint256 j = 0; j < markets.length; j++) {\\n        ERC20 market = markets[j];\\n\\n        uint256 newRewards;\\n        if (accrue[i]) {\\n          newRewards = flywheels[i].accrue(market, user);\\n        } else {\\n          newRewards = flywheels[i].rewardsAccrued(user);\\n        }\\n\\n        // Take the max, because rewards are cumulative.\\n        rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\\n      }\\n\\n      flywheels[i].claimRewards(user);\\n      rewardTokens[i] = address(flywheels[i].rewardToken());\\n    }\\n\\n    return (flywheels, rewardTokens, rewards);\\n  }\\n}\\n\",\"keccak256\":\"0xfb074348c0840708ba8a2a99ae3e05cd03b1963e95009cf70d583ac96c549705\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/strategies/flywheel/rewards/IFlywheelRewards.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {IonicFlywheelCore} from \\\"../IonicFlywheelCore.sol\\\";\\n\\n/**\\n @title Rewards Module for Flywheel\\n @notice Flywheel is a general framework for managing token incentives.\\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\\n\\n         The Rewards module is responsible for:\\n         * determining the ongoing reward amounts to entire strategies (core handles the logic for dividing among users)\\n         * actually holding rewards that are yet to be claimed\\n\\n         The reward stream can follow arbitrary logic as long as the amount of rewards passed to flywheel core has been sent to this contract.\\n\\n         Different module strategies include:\\n         * a static reward rate per second\\n         * a decaying reward rate\\n         * a dynamic just-in-time reward stream\\n         * liquid governance reward delegation (Curve Gauge style)\\n\\n         SECURITY NOTE: The rewards strategy should be smooth and continuous, to prevent gaming the reward distribution by frontrunning.\\n */\\ninterface IFlywheelRewards {\\n    /**\\n     @notice calculate the rewards amount accrued to a strategy since the last update.\\n     @param strategy the strategy to accrue rewards for.\\n     @param lastUpdatedTimestamp the last time rewards were accrued for the strategy.\\n     @return rewards the amount of rewards accrued to the market\\n    */\\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);\\n\\n    /// @notice return the flywheel core address\\n    function flywheel() external view returns (IonicFlywheelCore);\\n\\n    /// @notice return the reward token associated with flywheel core.\\n    function rewardToken() external view returns (ERC20);\\n\\n    function getRewardsPerSecond(ERC20 strategy) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xfbb2a186acfbc21b240cf271e1424c3ab5510b6c5fee9754b11476af5f7c6922\",\"license\":\"AGPL-3.0-only\"},\"contracts/ionic/vault/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport { IERC4626Upgradeable as IERC4626, IERC20Upgradeable as IERC20 } from \\\"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC4626Upgradeable.sol\\\";\\n\\n// Fees are set in 1e18 for 100% (1 BPS = 1e14)\\nstruct VaultFees {\\n  uint64 deposit;\\n  uint64 withdrawal;\\n  uint64 management;\\n  uint64 performance;\\n}\\n\\n/// @notice Init data for a Vault\\nstruct VaultInitParams {\\n  /// @Notice Address of the deposit asset\\n  IERC20 asset;\\n  /// @Notice Address of the adapter used by the vault\\n  IERC4626 adapter;\\n  /// @Notice Fees used by the vault\\n  VaultFees fees;\\n  /// @Notice Address of the recipient of the fees\\n  address feeRecipient;\\n  /// @Notice Maximum amount of assets that can be deposited\\n  uint256 depositLimit;\\n  /// @Notice Owner of the vault (Usually the submitter)\\n  address owner;\\n}\\n\\ninterface IVault is IERC4626 {\\n  // FEE VIEWS\\n\\n  function accruedManagementFee() external view returns (uint256);\\n\\n  function accruedPerformanceFee() external view returns (uint256);\\n\\n  function highWaterMark() external view returns (uint256);\\n\\n  function assetsCheckpoint() external view returns (uint256);\\n\\n  function feesUpdatedAt() external view returns (uint256);\\n\\n  function feeRecipient() external view returns (address);\\n\\n  // USER INTERACTIONS\\n\\n  function deposit(uint256 assets) external returns (uint256);\\n\\n  function mint(uint256 shares) external returns (uint256);\\n\\n  function withdraw(uint256 assets) external returns (uint256);\\n\\n  function redeem(uint256 shares) external returns (uint256);\\n\\n  function takeManagementAndPerformanceFees() external;\\n\\n  // MANAGEMENT FUNCTIONS - STRATEGY\\n\\n  function adapter() external view returns (address);\\n\\n  function proposedAdapter() external view returns (address);\\n\\n  function proposedAdapterTime() external view returns (uint256);\\n\\n  function proposeAdapter(IERC4626 newAdapter) external;\\n\\n  function changeAdapter() external;\\n\\n  // MANAGEMENT FUNCTIONS - FEES\\n\\n  function fees() external view returns (VaultFees memory);\\n\\n  function proposedFees() external view returns (VaultFees memory);\\n\\n  function proposedFeeTime() external view returns (uint256);\\n\\n  function proposeFees(VaultFees memory) external;\\n\\n  function changeFees() external;\\n\\n  function setFeeRecipient(address feeRecipient) external;\\n\\n  // MANAGEMENT FUNCTIONS - OTHER\\n\\n  function quitPeriod() external view returns (uint256);\\n\\n  function setQuitPeriod(uint256 _quitPeriod) external;\\n\\n  function depositLimit() external view returns (uint256);\\n\\n  function setDepositLimit(uint256 _depositLimit) external;\\n\\n  // INITIALIZE\\n\\n  function initialize(\\n    IERC20 asset_,\\n    IERC4626 adapter_,\\n    VaultFees memory fees_,\\n    address feeRecipient_,\\n    uint256 depositLimit_,\\n    address owner\\n  ) external;\\n}\\n\",\"keccak256\":\"0xebd52464c8c17da0dff573bd79369adb53fa58a332ea618f6969344cbeb01a2d\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedAPRVaultBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"../DiamondExtension.sol\\\";\\nimport { OptimizedAPRVaultStorage, VaultFees, AdapterConfig } from \\\"./OptimizedAPRVaultStorage.sol\\\";\\nimport { OptimizedAPRVaultExtension } from \\\"./OptimizedAPRVaultExtension.sol\\\";\\nimport { OptimizedAPRVaultFirstExtension } from \\\"./OptimizedAPRVaultFirstExtension.sol\\\";\\nimport { OptimizedAPRVaultSecondExtension } from \\\"./OptimizedAPRVaultSecondExtension.sol\\\";\\n\\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\n\\n// This contract is not upgradeable, but the storage can be amended for the extensions\\ncontract OptimizedAPRVaultBase is OptimizedAPRVaultStorage, DiamondBase {\\n  /**\\n   * @dev register a logic extension\\n   * @param extensionToAdd the extension whose functions are to be added\\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\\n   */\\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) public override {\\n    require(msg.sender == owner(), \\\"!unauthorized - no admin rights\\\");\\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\\n  }\\n\\n  // TODO can we unify the two extensions interfaces into one?\\n  function asFirstExtension() public view returns (OptimizedAPRVaultFirstExtension) {\\n    return OptimizedAPRVaultFirstExtension(address(this));\\n  }\\n\\n  function asSecondExtension() public view returns (OptimizedAPRVaultSecondExtension) {\\n    return OptimizedAPRVaultSecondExtension(address(this));\\n  }\\n\\n  // delegatecall to self does not work inside a constructor, therefore an initializer is needed\\n  function initialize(OptimizedAPRVaultExtension[] calldata extensions, bytes calldata initData) public onlyOwner {\\n    for (uint256 i; i < extensions.length; i++)\\n      LibDiamond.registerExtension(extensions[i], DiamondExtension(address(0)));\\n\\n    asFirstExtension().initialize(initData);\\n  }\\n\\n  function upgradeVault() public onlyOwner {\\n    address[] memory currentExtensions = LibDiamond.listExtensions();\\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\\n    }\\n\\n    OptimizedAPRVaultExtension[] memory latestExtensions = registry.getLatestVaultExtensions(address(this));\\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\\n      LibDiamond.addExtension(latestExtensions[i]);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x20d3308297d0156d451fd754e275c44490ce5dd92a96983f52e5cc026319e45b\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedAPRVaultExtension.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport { OptimizedAPRVaultStorage } from \\\"./OptimizedAPRVaultStorage.sol\\\";\\nimport { DiamondExtension } from \\\"../DiamondExtension.sol\\\";\\n\\nimport { ERC4626Upgradeable, ContextUpgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport { ReentrancyGuardUpgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport { PausableUpgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\\\";\\nimport { Context } from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nabstract contract OptimizedAPRVaultExtension is\\n  OptimizedAPRVaultStorage,\\n  PausableUpgradeable,\\n  ReentrancyGuardUpgradeable,\\n  ERC4626Upgradeable,\\n  DiamondExtension\\n{\\n  error InvalidVaultFees();\\n  error InvalidFeeRecipient();\\n\\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n          keccak256(bytes(name())),\\n          keccak256(\\\"1\\\"),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  function _msgSender() internal view override(ContextUpgradeable, Context) returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view override(ContextUpgradeable, Context) returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\",\"keccak256\":\"0xf65b2c90534de62e56f3dc73eb5d57557ee1447a85faa206da99bdf48cf29567\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedAPRVaultFirstExtension.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"./OptimizedAPRVaultExtension.sol\\\";\\nimport { OptimizedVaultsRegistry } from \\\"./OptimizedVaultsRegistry.sol\\\";\\nimport { IonicFlywheel } from \\\"../strategies/flywheel/IonicFlywheel.sol\\\";\\nimport { AdapterConfig } from \\\"./OptimizedAPRVaultStorage.sol\\\";\\nimport { VaultFees } from \\\"./IVault.sol\\\";\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { FuseFlywheelDynamicRewards } from \\\"fuse-flywheel/rewards/FuseFlywheelDynamicRewards.sol\\\";\\nimport { IFlywheelRewards } from \\\"../strategies/flywheel/rewards/IFlywheelRewards.sol\\\";\\nimport { IFlywheelBooster } from \\\"../strategies/flywheel/IFlywheelBooster.sol\\\";\\nimport { FlywheelCore } from \\\"flywheel/FlywheelCore.sol\\\";\\n\\nimport { SafeERC20Upgradeable as SafeERC20 } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { TransparentUpgradeableProxy } from \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\nimport { IERC20Upgradeable as IERC20 } from \\\"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC4626Upgradeable.sol\\\";\\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport { MathUpgradeable as Math } from \\\"openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol\\\";\\n\\ncontract OptimizedAPRVaultFirstExtension is OptimizedAPRVaultExtension {\\n  using SafeERC20 for IERC20;\\n  using Math for uint256;\\n\\n  error AssetInvalid();\\n  error InvalidConfig();\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\\n    uint8 fnsCount = 6;\\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\\n    functionSelectors[--fnsCount] = this.initialize.selector;\\n    functionSelectors[--fnsCount] = this.proposeAdapters.selector;\\n    functionSelectors[--fnsCount] = this.getAllFlywheels.selector;\\n    functionSelectors[--fnsCount] = this.addRewardToken.selector;\\n    functionSelectors[--fnsCount] = this.claimRewards.selector;\\n    functionSelectors[--fnsCount] = this.claimRewardsForUser.selector;\\n\\n    require(fnsCount == 0, \\\"use the correct array length\\\");\\n    return functionSelectors;\\n  }\\n\\n  function initialize(bytes calldata data) public initializer {\\n    require(msg.sender == address(this), \\\"!not self call\\\");\\n\\n    (\\n      IERC20 asset_,\\n      AdapterConfig[10] memory adapters_,\\n      uint8 adaptersCount_,\\n      VaultFees memory fees_,\\n      address feeRecipient_,\\n      uint256 depositLimit_,\\n      OptimizedVaultsRegistry registry_,\\n      address flywheelLogic_\\n    ) = abi.decode(\\n        data,\\n        (IERC20, AdapterConfig[10], uint8, VaultFees, address, uint256, OptimizedVaultsRegistry, address)\\n      );\\n\\n    if (address(asset_) == address(0)) revert AssetInvalid();\\n    __ERC4626_init(asset_);\\n\\n    _name = string(bytes.concat(\\\"Ionic Optimized \\\", bytes(IERC20Metadata(address(asset_)).name()), \\\" Vault\\\"));\\n    _symbol = string(bytes.concat(\\\"io-\\\", bytes(IERC20Metadata(address(asset_)).symbol())));\\n    _decimals = IERC20Metadata(address(asset_)).decimals() + DECIMAL_OFFSET; // Asset decimals + decimal offset to combat inflation attacks\\n\\n    depositLimit = depositLimit_;\\n    registry = registry_;\\n    flywheelLogic = flywheelLogic_;\\n    INITIAL_CHAIN_ID = block.chainid;\\n    INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    feesUpdatedAt = block.timestamp;\\n    highWaterMark = 1e9;\\n    quitPeriod = 3 days;\\n\\n    // vault fees\\n    if (fees_.deposit >= 1e18 || fees_.withdrawal >= 1e18 || fees_.management >= 1e18 || fees_.performance >= 1e18)\\n      revert InvalidVaultFees();\\n    fees = fees_;\\n\\n    // fee recipient\\n    if (feeRecipient_ == address(0)) revert InvalidFeeRecipient();\\n    feeRecipient = feeRecipient_;\\n\\n    // adapters config\\n    _verifyAdapterConfig(adapters_, adaptersCount_);\\n    adaptersCount = adaptersCount_;\\n    for (uint8 i; i < adaptersCount_; i++) {\\n      adapters[i] = adapters_[i];\\n      asset_.approve(address(adapters_[i].adapter), type(uint256).max);\\n    }\\n  }\\n\\n  function _verifyAdapterConfig(AdapterConfig[10] memory newAdapters, uint8 adapterCount_) internal view {\\n    if (adapterCount_ == 0 || adapterCount_ > 10) revert InvalidConfig();\\n\\n    uint256 totalAllocation;\\n    for (uint8 i; i < adapterCount_; i++) {\\n      if (newAdapters[i].adapter.asset() != asset()) revert AssetInvalid();\\n\\n      uint256 allocation = uint256(newAdapters[i].allocation);\\n      if (allocation == 0) revert InvalidConfig();\\n\\n      totalAllocation += allocation;\\n    }\\n    if (totalAllocation != 1e18) revert InvalidConfig();\\n  }\\n\\n  /*------------------------------------------------------------\\n                            ADAPTER LOGIC\\n    ------------------------------------------------------------*/\\n\\n  event NewAdaptersProposed(AdapterConfig[10] newAdapter, uint8 adaptersCount, uint256 timestamp);\\n\\n  /**\\n   * @notice Propose a new adapter for this vault. Caller must be Owner.\\n   * @param newAdapters A new ERC4626 that should be used as a yield adapter for this asset.\\n   * @param newAdaptersCount Amount of new adapters.\\n   */\\n  function proposeAdapters(AdapterConfig[10] calldata newAdapters, uint8 newAdaptersCount) external onlyOwner {\\n    _verifyAdapterConfig(newAdapters, newAdaptersCount);\\n\\n    for (uint8 i; i < newAdaptersCount; i++) {\\n      proposedAdapters[i] = newAdapters[i];\\n    }\\n\\n    proposedAdaptersCount = newAdaptersCount;\\n\\n    proposedAdapterTime = block.timestamp;\\n\\n    emit NewAdaptersProposed(newAdapters, proposedAdaptersCount, block.timestamp);\\n  }\\n\\n  function getAllFlywheels() external view returns (IonicFlywheel[] memory allFlywheels) {\\n    allFlywheels = new IonicFlywheel[](rewardTokens.length);\\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\\n      allFlywheels[i] = flywheelForRewardToken[rewardTokens[i]];\\n    }\\n  }\\n\\n  /// @notice claim all token rewards\\n  function claimRewards() public {\\n    _claimRewards(msg.sender);\\n  }\\n\\n  function claimRewardsForUser(address user) public {\\n    _claimRewards(user);\\n  }\\n\\n  function _claimRewards(address user) internal {\\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\\n      IonicFlywheel flywheel = flywheelForRewardToken[rewardTokens[i]];\\n      flywheel.accrue(ERC20(address(this)), user);\\n      flywheel.claimRewards(user);\\n    }\\n  }\\n\\n  function _afterTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal override {\\n    super._afterTokenTransfer(from, to, amount);\\n    for (uint256 i; i < rewardTokens.length; ++i) {\\n      flywheelForRewardToken[rewardTokens[i]].accrue(ERC20(address(this)), from, to);\\n    }\\n  }\\n\\n  function addRewardToken(IERC20 token_) public {\\n    require(msg.sender == owner() || msg.sender == address(this), \\\"!owner or self\\\");\\n    require(address(flywheelForRewardToken[token_]) == address(0), \\\"already added\\\");\\n\\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(flywheelLogic, owner(), \\\"\\\");\\n    IonicFlywheel newFlywheel = IonicFlywheel(address(proxy));\\n\\n    newFlywheel.initialize(\\n      ERC20(address(token_)),\\n      IFlywheelRewards(address(0)),\\n      IFlywheelBooster(address(0)),\\n      address(this)\\n    );\\n    FuseFlywheelDynamicRewards rewardsContract = new FuseFlywheelDynamicRewards(\\n      FlywheelCore(address(newFlywheel)),\\n      1 days\\n    );\\n    newFlywheel.setFlywheelRewards(IFlywheelRewards(address(rewardsContract)));\\n    token_.approve(address(rewardsContract), type(uint256).max);\\n    newFlywheel.updateFeeSettings(0, address(this));\\n    // TODO accept owner\\n    newFlywheel._setPendingOwner(owner());\\n\\n    // lets the vault shareholders accrue\\n    newFlywheel.addStrategyForRewards(ERC20(address(this)));\\n    flywheelForRewardToken[token_] = newFlywheel;\\n    rewardTokens.push(token_);\\n  }\\n}\\n\",\"keccak256\":\"0x3450a94ba164653bf6eb9a6060bff325b3ba00b28c86e945df2c7d3a5506fdd0\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedAPRVaultSecondExtension.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport { SafeERC20Upgradeable as SafeERC20 } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { MathUpgradeable as Math } from \\\"openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol\\\";\\nimport { ERC20Upgradeable } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\\\";\\n\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\n\\nimport { IERC20, VaultFees } from \\\"./IVault.sol\\\";\\nimport { OptimizedAPRVaultExtension } from \\\"./OptimizedAPRVaultExtension.sol\\\";\\nimport { AdapterConfig } from \\\"./OptimizedAPRVaultStorage.sol\\\";\\n\\ncontract OptimizedAPRVaultSecondExtension is OptimizedAPRVaultExtension {\\n  using SafeERC20 for IERC20;\\n  using Math for uint256;\\n\\n  uint64 internal constant _BPS = 1e18;\\n\\n  error InvalidAllocations();\\n  error InvalidReceiver();\\n  error MaxError(uint256 amount);\\n  error IncorrectListLength();\\n  error IncorrectDistribution();\\n  error NotPassedQuitPeriod();\\n\\n  event DepositLimitSet(uint256 depositLimit);\\n  event Harvested(uint256 totalAssets, uint256 aprBefore, uint256 aprAfter);\\n  event EmergencyExitActivated();\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\\n    uint8 fnsCount = 50;\\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\\n    functionSelectors[--fnsCount] = this.name.selector;\\n    functionSelectors[--fnsCount] = this.symbol.selector;\\n    functionSelectors[--fnsCount] = this.decimals.selector;\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"deposit(uint256,address)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"deposit(uint256)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"mint(uint256)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"mint(uint256,address)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"withdraw(uint256)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"withdraw(uint256,address)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"redeem(uint256)\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"redeem(uint256,address)\\\")));\\n    functionSelectors[--fnsCount] = this.totalAssets.selector;\\n    functionSelectors[--fnsCount] = this.previewDeposit.selector;\\n    functionSelectors[--fnsCount] = this.previewMint.selector;\\n    functionSelectors[--fnsCount] = this.previewWithdraw.selector;\\n    functionSelectors[--fnsCount] = this.previewRedeem.selector;\\n    functionSelectors[--fnsCount] = this.maxDeposit.selector;\\n    functionSelectors[--fnsCount] = this.maxMint.selector;\\n    functionSelectors[--fnsCount] = this.maxWithdraw.selector;\\n    functionSelectors[--fnsCount] = this.maxRedeem.selector;\\n    functionSelectors[--fnsCount] = this.setDepositLimit.selector;\\n    functionSelectors[--fnsCount] = this.pause.selector;\\n    functionSelectors[--fnsCount] = this.unpause.selector;\\n    functionSelectors[--fnsCount] = this.lentTotalAssets.selector;\\n    functionSelectors[--fnsCount] = this.estimatedTotalAssets.selector;\\n    functionSelectors[--fnsCount] = this.supplyAPY.selector;\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"estimatedAPR(uint64[])\\\")));\\n    functionSelectors[--fnsCount] = bytes4(keccak256(bytes(\\\"estimatedAPR()\\\")));\\n    functionSelectors[--fnsCount] = this.harvest.selector;\\n    functionSelectors[--fnsCount] = this.DOMAIN_SEPARATOR.selector;\\n    functionSelectors[--fnsCount] = this.permit.selector;\\n    functionSelectors[--fnsCount] = this.accruedManagementFee.selector;\\n    functionSelectors[--fnsCount] = this.accruedPerformanceFee.selector;\\n    functionSelectors[--fnsCount] = this.takeManagementAndPerformanceFees.selector;\\n    functionSelectors[--fnsCount] = this.proposeFees.selector;\\n    functionSelectors[--fnsCount] = this.changeFees.selector;\\n    functionSelectors[--fnsCount] = this.setFeeRecipient.selector;\\n    functionSelectors[--fnsCount] = this.changeAdapters.selector;\\n    functionSelectors[--fnsCount] = this.setQuitPeriod.selector;\\n    functionSelectors[--fnsCount] = this.setEmergencyExit.selector;\\n    functionSelectors[--fnsCount] = this.pullAccruedVaultRewards.selector;\\n\\n    // inherited fns should also be listed\\n    functionSelectors[--fnsCount] = this.balanceOf.selector;\\n    functionSelectors[--fnsCount] = this.transfer.selector;\\n    functionSelectors[--fnsCount] = this.transferFrom.selector;\\n    functionSelectors[--fnsCount] = this.allowance.selector;\\n    functionSelectors[--fnsCount] = this.approve.selector;\\n    functionSelectors[--fnsCount] = this.convertToShares.selector;\\n    functionSelectors[--fnsCount] = this.convertToAssets.selector;\\n    functionSelectors[--fnsCount] = this.totalSupply.selector;\\n    functionSelectors[--fnsCount] = this.asset.selector;\\n\\n    require(fnsCount == 0, \\\"use the correct array length\\\");\\n    return functionSelectors;\\n  }\\n\\n  function name() public view override(ERC20Upgradeable, IERC20Metadata) returns (string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view override(ERC20Upgradeable, IERC20Metadata) returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /*------------------------------------------------------------\\n                      DEPOSIT/WITHDRAWAL LOGIC\\n    ------------------------------------------------------------*/\\n\\n  function deposit(uint256 assets) public returns (uint256) {\\n    return deposit(assets, msg.sender);\\n  }\\n\\n  function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\\n    if (receiver == address(0)) revert InvalidReceiver();\\n    require(assets > 0, \\\"too little assets\\\");\\n    if (assets > maxDeposit(receiver)) revert MaxError(assets);\\n\\n    shares = _convertToShares(assets);\\n    uint256 depositFee = uint256(fees.deposit);\\n    uint256 feeShares = shares.mulDiv(depositFee, 1e18 - depositFee, Math.Rounding.Down);\\n    shares -= feeShares;\\n\\n    if (feeShares > 0) _mint(feeRecipient, feeShares);\\n\\n    _deposit(_msgSender(), receiver, assets, shares);\\n\\n    return shares;\\n  }\\n\\n  function mint(uint256 shares) external returns (uint256) {\\n    return mint(shares, msg.sender);\\n  }\\n\\n  function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\\n    if (receiver == address(0)) revert InvalidReceiver();\\n    if (shares > maxMint(receiver)) revert MaxError(shares);\\n\\n    uint256 depositFee = uint256(fees.deposit);\\n    uint256 feeShares = shares.mulDiv(depositFee, 1e18 - depositFee, Math.Rounding.Down);\\n    assets = _convertToAssets(shares + feeShares);\\n    // don't let it mint shares for 0 assets\\n    require(assets > 0, \\\"too little shares\\\");\\n\\n    if (feeShares > 0) _mint(feeRecipient, feeShares);\\n\\n    _deposit(_msgSender(), receiver, assets, shares);\\n\\n    return assets;\\n  }\\n\\n  function _deposit(\\n    address caller,\\n    address receiver,\\n    uint256 assets,\\n    uint256 shares\\n  ) internal override nonReentrant whenNotPaused {\\n    if (receiver == address(0)) revert InvalidReceiver();\\n\\n    IERC20 asset_ = IERC20(asset());\\n    require(asset_.balanceOf(caller) >= assets, \\\"!insufficient balance\\\");\\n    require(asset_.allowance(caller, address(this)) >= assets, \\\"!insufficient allowance\\\");\\n    asset_.safeTransferFrom(caller, address(this), assets);\\n\\n    // allocate all available assets = caller assets + cash\\n    uint256 assetsToAllocate = asset_.balanceOf(address(this));\\n    for (uint8 i; i < adaptersCount; i++) {\\n      uint256 adapterDeposit = assetsToAllocate.mulDiv(adapters[i].allocation, 1e18, Math.Rounding.Down);\\n      // don't do too small deposits, so that zero shares minting is avoided\\n      if (adapterDeposit > 100) {\\n        adapters[i].adapter.deposit(adapterDeposit, address(this));\\n      }\\n    }\\n\\n    _mint(receiver, shares);\\n\\n    emit Deposit(caller, receiver, assets, shares);\\n  }\\n\\n  function withdraw(uint256 assets) public returns (uint256) {\\n    return withdraw(assets, msg.sender, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Burn shares from `owner` in exchange for `assets` amount of underlying token.\\n   * @param assets Quantity of underlying `asset` token to withdraw.\\n   * @param receiver Receiver of underlying token.\\n   * @param owner Owner of burned vault shares.\\n   * @return shares Quantity of vault shares burned in exchange for `assets`.\\n   */\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256) {\\n    if (receiver == address(0)) revert InvalidReceiver();\\n    require(assets > 0, \\\"too little assets\\\");\\n\\n    uint256 shares = _convertToShares(assets);\\n\\n    uint256 withdrawalFee = uint256(fees.withdrawal);\\n    uint256 feeShares = shares.mulDiv(withdrawalFee, 1e18 - withdrawalFee, Math.Rounding.Down);\\n    shares += feeShares;\\n\\n    if (feeShares > 0) _mint(feeRecipient, feeShares);\\n\\n    _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n    return shares;\\n  }\\n\\n  function redeem(uint256 shares) external returns (uint256) {\\n    return redeem(shares, msg.sender, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Burn exactly `shares` vault shares from `owner` and send underlying `asset` tokens to `receiver`.\\n   * @param shares Quantity of vault shares to exchange for underlying tokens.\\n   * @param receiver Receiver of underlying tokens.\\n   * @param owner Owner of burned vault shares.\\n   * @return assets Quantity of `asset` sent to `receiver`.\\n   */\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256 assets) {\\n    if (receiver == address(0)) revert InvalidReceiver();\\n\\n    uint256 withdrawalFee = uint256(fees.withdrawal);\\n    uint256 feeShares = shares.mulDiv(withdrawalFee, 1e18 - withdrawalFee, Math.Rounding.Down);\\n\\n    assets = _convertToAssets(shares - feeShares);\\n    require(assets > 0, \\\"too little shares\\\");\\n\\n    if (feeShares > 0) _mint(feeRecipient, feeShares);\\n\\n    _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n    return assets;\\n  }\\n\\n  function _withdraw(\\n    address caller,\\n    address receiver,\\n    address owner,\\n    uint256 assets,\\n    uint256 shares\\n  ) internal override nonReentrant {\\n    if (caller != owner) {\\n      _spendAllowance(owner, caller, shares);\\n    }\\n\\n    uint256 totalSupplyBefore = totalSupply();\\n    _burn(owner, shares);\\n\\n    for (uint8 i; i < adaptersCount; i++) {\\n      uint256 vaultAdapterShares = adapters[i].adapter.balanceOf(address(this));\\n      // round up the shares to make sure enough is withdrawn for the transfer\\n      uint256 shareOfAdapterShares = vaultAdapterShares.mulDiv(shares, totalSupplyBefore, Math.Rounding.Up);\\n      adapters[i].adapter.redeem(shareOfAdapterShares, address(this), address(this));\\n    }\\n\\n    // the fresh minted feeShares are backed by the assets left after this transfer\\n    IERC20(asset()).safeTransfer(receiver, assets);\\n\\n    emit Withdraw(caller, receiver, owner, assets, shares);\\n  }\\n\\n  /*------------------------------------------------------------\\n                        ACCOUNTING LOGIC\\n    ------------------------------------------------------------*/\\n\\n  /// @return assets Total amount of underlying `asset` token managed by vault. Delegates to adapter.\\n  function totalAssets() public view override returns (uint256 assets) {\\n    assets = IERC20(asset()).balanceOf(address(this));\\n\\n    // add the assets held in the adapters\\n    for (uint8 i; i < adaptersCount; i++) {\\n      uint256 vaultAdapterShares = adapters[i].adapter.balanceOf(address(this));\\n      assets += adapters[i].adapter.previewRedeem(vaultAdapterShares);\\n    }\\n  }\\n\\n  /**\\n   * @notice Simulate the effects of a deposit at the current block, given current on-chain conditions.\\n   * @param assets Exact amount of underlying `asset` token to deposit\\n   * @return of the vault issued in exchange to the user for `assets`\\n   * @dev This method accounts for issuance of accrued fee shares.\\n   */\\n  function previewDeposit(uint256 assets) public view override returns (uint256) {\\n    uint256 shares = _convertToShares(assets);\\n    uint256 depositFee = uint256(fees.deposit);\\n    uint256 feeShares = shares.mulDiv(depositFee, 1e18 - depositFee, Math.Rounding.Down);\\n    return shares - feeShares;\\n  }\\n\\n  /**\\n   * @notice Simulate the effects of a mint at the current block, given current on-chain conditions.\\n   * @param shares Exact amount of vault shares to mint.\\n   * @return quantity of underlying needed in exchange to mint `shares`.\\n   * @dev This method accounts for issuance of accrued fee shares.\\n   */\\n  function previewMint(uint256 shares) public view override returns (uint256) {\\n    uint256 depositFee = uint256(fees.deposit);\\n    uint256 feeShares = shares.mulDiv(depositFee, 1e18 - depositFee, Math.Rounding.Down);\\n    return _convertToAssets(shares + feeShares);\\n  }\\n\\n  /**\\n   * @notice Simulate the effects of a withdrawal at the current block, given current on-chain conditions.\\n   * @param assets Exact amount of `assets` to withdraw\\n   * @return shares to be burned in exchange for `assets`\\n   * @dev This method accounts for both issuance of fee shares and withdrawal fee.\\n   */\\n  function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\\n    shares = _convertToShares(assets);\\n    uint256 withdrawalFee = uint256(fees.withdrawal);\\n    uint256 feeShares = shares.mulDiv(withdrawalFee, 1e18 - withdrawalFee, Math.Rounding.Down);\\n    shares += feeShares;\\n  }\\n\\n  /**\\n   * @notice Simulate the effects of a redemption at the current block, given current on-chain conditions.\\n   * @param shares Exact amount of `shares` to redeem\\n   * @return quantity of underlying returned in exchange for `shares`.\\n   * @dev This method accounts for both issuance of fee shares and withdrawal fee.\\n   */\\n  function previewRedeem(uint256 shares) public view override returns (uint256) {\\n    if (totalSupply() == 0) return 0;\\n    uint256 withdrawalFee = uint256(fees.withdrawal);\\n    uint256 feeShares = shares.mulDiv(withdrawalFee, 1e18 - withdrawalFee, Math.Rounding.Down);\\n    return _convertToAssets(shares - feeShares);\\n  }\\n\\n  // @notice returns the max amount of shares that match this assets amount\\n  function _convertToShares(uint256 assets) internal view returns (uint256) {\\n    return _convertToShares(assets, Math.Rounding.Down);\\n  }\\n\\n  function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual override returns (uint256) {\\n    uint256 totalSupply_ = totalSupply();\\n    if (totalSupply_ == 0) {\\n      return assets * 10**DECIMAL_OFFSET;\\n    } else {\\n      return (assets + 1).mulDiv(totalSupply_, totalAssets(), rounding);\\n    }\\n  }\\n\\n  // @notice returns the min amount of assets that match this shares amount\\n  function _convertToAssets(uint256 shares) internal view returns (uint256) {\\n    return _convertToAssets(shares, Math.Rounding.Down);\\n  }\\n\\n  function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual override returns (uint256) {\\n    uint256 totalSupply_ = totalSupply();\\n    if (totalSupply_ == 0) {\\n      return shares / 10**DECIMAL_OFFSET;\\n    } else {\\n      return totalAssets().mulDiv(shares, totalSupply_, rounding);\\n    }\\n  }\\n\\n  /*------------------------------------------------------------\\n                DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    ------------------------------------------------------------*/\\n\\n  /// @return Maximum amount of underlying `asset` token that may be deposited for a given address. Delegates to adapters.\\n  function maxDeposit(address) public view override returns (uint256) {\\n    uint256 assets = totalAssets();\\n    uint256 depositLimit_ = depositLimit;\\n    if (paused() || assets >= depositLimit_) return 0;\\n\\n    uint256 maxDeposit_ = depositLimit_;\\n    for (uint8 i; i < adaptersCount; i++) {\\n      uint256 adapterMax = adapters[i].adapter.maxDeposit(address(this));\\n      uint256 scalar = 1e18 / uint256(adapters[i].allocation);\\n\\n      if (adapterMax > type(uint256).max / scalar) {\\n        adapterMax = type(uint256).max;\\n      } else {\\n        adapterMax *= scalar;\\n      }\\n\\n      maxDeposit_ = Math.min(maxDeposit_, adapterMax);\\n    }\\n\\n    return maxDeposit_;\\n  }\\n\\n  /// @return Maximum amount of vault shares that may be minted to given address. Delegates to adapters.\\n  function maxMint(address) public view override returns (uint256) {\\n    uint256 assets = totalAssets();\\n    uint256 depositLimit_ = depositLimit;\\n    if (paused() || assets >= depositLimit_) return 0;\\n\\n    uint256 maxMint_ = depositLimit > type(uint256).max / (totalSupply() + 10**DECIMAL_OFFSET)\\n      ? type(uint256).max\\n      : _convertToShares(depositLimit_);\\n\\n    for (uint8 i; i < adaptersCount; i++) {\\n      uint256 adapterMax = adapters[i].adapter.maxMint(address(this));\\n      uint256 scalar = 1e18 / uint256(adapters[i].allocation);\\n\\n      if (adapterMax > type(uint256).max / scalar) {\\n        adapterMax = type(uint256).max;\\n      } else {\\n        adapterMax *= scalar;\\n      }\\n\\n      maxMint_ = Math.min(maxMint_, adapterMax);\\n    }\\n\\n    return maxMint_;\\n  }\\n\\n  /// @return Maximum amount of underlying `asset` token that can be withdrawn by `caller` address. Delegates to adapters.\\n  function maxWithdraw(address caller) public view override returns (uint256) {\\n    uint256 callerShares = balanceOf(caller);\\n    if (callerShares == 0) {\\n      return 0;\\n    } else {\\n      uint256 callerAssets = previewRedeem(callerShares);\\n      uint256 maxWithdraw_ = totalAssets();\\n      return Math.min(maxWithdraw_, callerAssets);\\n    }\\n  }\\n\\n  /// @return Maximum amount of shares that may be redeemed by `caller` address. Delegates to adapters.\\n  function maxRedeem(address caller) public view override returns (uint256) {\\n    uint256 callerShares = balanceOf(caller);\\n    if (callerShares == 0) {\\n      return 0;\\n    } else {\\n      uint256 maxWithdraw_ = totalAssets();\\n      uint256 maxRedeem_ = previewWithdraw(maxWithdraw_);\\n      return Math.min(maxRedeem_, callerShares);\\n    }\\n  }\\n\\n  /*------------------------------------------------------------\\n                        DEPOSIT LIMIT LOGIC\\n    ------------------------------------------------------------*/\\n\\n  /**\\n   * @notice Sets a limit for deposits in assets. Caller must be Owner.\\n   * @param _depositLimit Maximum amount of assets that can be deposited.\\n   */\\n  function setDepositLimit(uint256 _depositLimit) external onlyOwner {\\n    depositLimit = _depositLimit;\\n\\n    emit DepositLimitSet(_depositLimit);\\n  }\\n\\n  /*------------------------------------------------------------\\n                            PAUSING LOGIC\\n    ------------------------------------------------------------*/\\n\\n  /// @notice Pause deposits. Caller must be Owner.\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /// @notice Unpause deposits. Caller must be Owner.\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  /*-------------------------------------------\\n  -------------------------------------------*/\\n\\n  /// @notice View function to check the total assets lent\\n  function lentTotalAssets() public view returns (uint256) {\\n    uint256 nav;\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      nav += adapters[i].adapter.balanceOfUnderlying(address(this));\\n    }\\n    return nav;\\n  }\\n\\n  /// @notice View function to check the total assets managed by the strategy\\n  function estimatedTotalAssets() public view returns (uint256) {\\n    return lentTotalAssets() + IERC20(asset()).balanceOf(address(this));\\n  }\\n\\n  /// @notice view function to check the hypothetical APY after the deposit of some amount\\n  function supplyAPY(uint256 amount) public view returns (uint256) {\\n    uint256 bal = estimatedTotalAssets();\\n    if (bal == 0 && amount == 0) {\\n      return 0;\\n    }\\n\\n    uint256 weightedAPR;\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      weightedAPR += adapters[i].adapter.weightedAprAfterDeposit(amount);\\n    }\\n\\n    uint8 decimals_ = IERC20Metadata(asset()).decimals();\\n    return (weightedAPR * (10**decimals_)) / (bal + amount);\\n  }\\n\\n  /// @notice Returns the weighted apr of all adapters\\n  /// @dev It's computed by doing: `sum(nav * apr) / totalNav`\\n  function estimatedAPR() public view returns (uint256) {\\n    uint256 bal = estimatedTotalAssets();\\n    if (bal == 0) {\\n      return 0;\\n    }\\n\\n    uint256 weightedAPR;\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      weightedAPR += adapters[i].adapter.weightedApr();\\n    }\\n\\n    uint8 decimals_ = IERC20Metadata(asset()).decimals();\\n    return (weightedAPR * (10**decimals_)) / bal;\\n  }\\n\\n  /// @notice Returns the weighted apr in an hypothetical world where the strategy splits its nav\\n  /// in respect to allocations\\n  /// @param allocations List of allocations (in bps of the nav) that should be allocated to each adapter\\n  function estimatedAPR(uint64[] calldata allocations) public view returns (uint256, int256[] memory) {\\n    if (adaptersCount != allocations.length) revert IncorrectListLength();\\n    uint256 weightedAPRScaled = 0;\\n    int256[] memory adapterAdjustedAmounts = new int256[](adaptersCount);\\n\\n    uint256 bal = estimatedTotalAssets();\\n    if (bal == 0) return (weightedAPRScaled, adapterAdjustedAmounts);\\n\\n    uint256 allocation;\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      allocation += allocations[i];\\n      uint256 futureDeposit = (bal * allocations[i]) / _BPS;\\n\\n      int256 adjustedAmount = int256(futureDeposit) - int256(adapters[i].adapter.balanceOfUnderlying(address(this)));\\n      if (adjustedAmount > 0) {\\n        weightedAPRScaled += futureDeposit * adapters[i].adapter.aprAfterDeposit(uint256(adjustedAmount));\\n      } else {\\n        weightedAPRScaled += futureDeposit * adapters[i].adapter.aprAfterWithdraw(uint256(-adjustedAmount));\\n      }\\n      adapterAdjustedAmounts[i] = adjustedAmount;\\n    }\\n    if (allocation != _BPS) revert InvalidAllocations();\\n\\n    return (weightedAPRScaled / bal, adapterAdjustedAmounts);\\n  }\\n\\n  // =============================== CORE FUNCTIONS ==============================\\n\\n  /// @notice Harvests the Strategy, recognizing any profits or losses and adjusting\\n  /// the Strategy's position.\\n  function harvest(uint64[] calldata adapterAllocationsHint) external {\\n    // do not redeposit if emergencyExit is activated\\n    if (emergencyExit) return;\\n\\n    // We just keep all money in `asset` if we dont have any adapters\\n    if (adaptersCount == 0) return;\\n\\n    uint256 estimatedAprHint;\\n    int256[] memory adapterAdjustedAmounts;\\n    if (adapterAllocationsHint.length != 0)\\n      (estimatedAprHint, adapterAdjustedAmounts) = estimatedAPR(adapterAllocationsHint);\\n\\n    uint256 currentAPR = estimatedAPR();\\n    if (currentAPR < estimatedAprHint) {\\n      // The hint was successful --> we find a better allocation than the current one\\n\\n      // calculate the \\\"delta\\\" - the difference between\\n      // the requested amount to withdraw and the actually withdrawn amount\\n      uint256 deltaWithdraw;\\n      for (uint256 i; i < adaptersCount; ++i) {\\n        if (adapterAdjustedAmounts[i] < 0) {\\n          deltaWithdraw +=\\n            uint256(-adapterAdjustedAmounts[i]) -\\n            adapters[i].adapter.withdraw(uint256(-adapterAdjustedAmounts[i]));\\n        }\\n      }\\n      // TODO deltaWithdraw is always 0 for compound markets deposits\\n\\n      // If the strategy didn't succeed to withdraw the intended funds\\n      if (deltaWithdraw > withdrawalThreshold) revert IncorrectDistribution();\\n\\n      for (uint256 i; i < adaptersCount; ++i) {\\n        if (adapterAdjustedAmounts[i] > 0) {\\n          // As `deltaWithdraw` is less than `withdrawalThreshold` (a dust)\\n          // It is not a problem to compensate on an arbitrary adapter as it will only slightly impact global APR\\n          if (adapterAdjustedAmounts[i] > int256(deltaWithdraw)) {\\n            adapterAdjustedAmounts[i] -= int256(deltaWithdraw);\\n            deltaWithdraw = 0;\\n          } else {\\n            deltaWithdraw -= uint256(adapterAdjustedAmounts[i]);\\n          }\\n          // redeposit through the adapters\\n          adapters[i].adapter.deposit(uint256(adapterAdjustedAmounts[i]), address(this));\\n        }\\n        // record the applied allocation in storage\\n        adapters[i].allocation = adapterAllocationsHint[i];\\n      }\\n    }\\n\\n    emit Harvested(totalAssets(), currentAPR, estimatedAprHint);\\n  }\\n\\n  /*------------------------------------------------------------\\n                            EIP-2612 LOGIC\\n    ------------------------------------------------------------*/\\n\\n  error PermitDeadlineExpired(uint256 deadline);\\n  error InvalidSigner(address signer);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public virtual {\\n    if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\\n\\n    // Unchecked because the only math done is incrementing\\n    // the owner's nonce which cannot realistically overflow.\\n    unchecked {\\n      address recoveredAddress = ecrecover(\\n        keccak256(\\n          abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            DOMAIN_SEPARATOR(),\\n            keccak256(\\n              abi.encode(\\n                keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"),\\n                owner,\\n                spender,\\n                value,\\n                nonces[owner]++,\\n                deadline\\n              )\\n            )\\n          )\\n        ),\\n        v,\\n        r,\\n        s\\n      );\\n\\n      if (recoveredAddress == address(0) || recoveredAddress != owner) revert InvalidSigner(recoveredAddress);\\n\\n      _approve(recoveredAddress, spender, value);\\n    }\\n  }\\n\\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n    return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n  }\\n\\n  /*------------------------------------------------------------\\n                      FEE ACCOUNTING LOGIC\\n  ------------------------------------------------------------*/\\n\\n  /**\\n   * @notice Management fee that has accrued since last fee harvest.\\n   * @return Accrued management fee in underlying `asset` token.\\n   * @dev Management fee is annualized per minute, based on 525,600 minutes per year. Total assets are calculated using\\n   *  the average of their current value and the value at the previous fee harvest checkpoint. This method is similar to\\n   *  calculating a definite integral using the trapezoid rule.\\n   */\\n  function accruedManagementFee() public view returns (uint256) {\\n    uint256 managementFee = fees.management;\\n    return\\n      managementFee > 0\\n        ? managementFee.mulDiv(\\n          totalAssets() * (block.timestamp - feesUpdatedAt),\\n          SECONDS_PER_YEAR,\\n          Math.Rounding.Down\\n        ) / 1e18\\n        : 0;\\n  }\\n\\n  /**\\n   * @notice Performance fee that has accrued since last fee harvest.\\n   * @return Accrued performance fee in underlying `asset` token.\\n   * @dev Performance fee is based on a high water mark value. If vault share value has increased above the\\n   *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\\n   */\\n  function accruedPerformanceFee() public view returns (uint256) {\\n    uint256 highWaterMark_ = highWaterMark;\\n    uint256 shareValue = convertToAssets(1e18);\\n    uint256 performanceFee = fees.performance;\\n\\n    return\\n      performanceFee > 0 && shareValue > highWaterMark_\\n        ? performanceFee.mulDiv((shareValue - highWaterMark_) * totalSupply(), 1e36, Math.Rounding.Down)\\n        : 0;\\n  }\\n\\n  /*------------------------------------------------------------\\n                            FEE LOGIC\\n    ------------------------------------------------------------*/\\n\\n  error InsufficientWithdrawalAmount(uint256 amount);\\n\\n  /// @notice Minimal function to call `takeFees` modifier.\\n  function takeManagementAndPerformanceFees() external takeFees {}\\n\\n  /// @notice Collect management and performance fees and update vault share high water mark.\\n  modifier takeFees() {\\n    uint256 managementFee = accruedManagementFee();\\n    uint256 totalFee = managementFee + accruedPerformanceFee();\\n    uint256 currentAssets = totalAssets();\\n    uint256 shareValue = convertToAssets(1e18);\\n\\n    if (shareValue > highWaterMark) highWaterMark = shareValue;\\n\\n    if (totalFee > 0 && currentAssets > 0) {\\n      uint256 supply = totalSupply();\\n      uint256 feeInShare = supply == 0\\n        ? totalFee\\n        : totalFee.mulDiv(supply, currentAssets - totalFee, Math.Rounding.Down);\\n      _mint(feeRecipient, feeInShare);\\n    }\\n\\n    feesUpdatedAt = block.timestamp;\\n\\n    _;\\n  }\\n\\n  /*------------------------------------------------------------\\n                            RAGE QUIT LOGIC\\n    ------------------------------------------------------------*/\\n\\n  event QuitPeriodSet(uint256 quitPeriod);\\n\\n  error InvalidQuitPeriod();\\n\\n  /**\\n   * @notice Set a quitPeriod for rage quitting after new adapter or fees are proposed. Caller must be Owner.\\n   * @param _quitPeriod Time to rage quit after proposal.\\n   */\\n  function setQuitPeriod(uint256 _quitPeriod) external onlyOwner {\\n    if (block.timestamp < proposedAdapterTime + quitPeriod || block.timestamp < proposedFeeTime + quitPeriod)\\n      revert NotPassedQuitPeriod();\\n    if (_quitPeriod < 1 days || _quitPeriod > 7 days) revert InvalidQuitPeriod();\\n\\n    quitPeriod = _quitPeriod;\\n\\n    emit QuitPeriodSet(quitPeriod);\\n  }\\n\\n  function setEmergencyExit() external {\\n    require(msg.sender == owner() || msg.sender == address(registry), \\\"not registry or owner\\\");\\n\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      adapters[i].adapter.withdrawAll();\\n    }\\n\\n    emergencyExit = true;\\n    _pause();\\n\\n    emit EmergencyExitActivated();\\n  }\\n\\n  /*------------------------------------------------------------\\n                        FEE MANAGEMENT LOGIC\\n    ------------------------------------------------------------*/\\n\\n  event NewFeesProposed(VaultFees newFees, uint256 timestamp);\\n  event ChangedFees(VaultFees oldFees, VaultFees newFees);\\n  event FeeRecipientUpdated(address oldFeeRecipient, address newFeeRecipient);\\n\\n  /**\\n   * @notice Propose new fees for this vault. Caller must be owner.\\n   * @param newFees Fees for depositing, withdrawal, management and performance in 1e18.\\n   * @dev Fees can be 0 but never 1e18 (1e18 = 100%, 1e14 = 1 BPS)\\n   */\\n  function proposeFees(VaultFees calldata newFees) external onlyOwner {\\n    if (\\n      newFees.deposit >= 1e18 || newFees.withdrawal >= 1e18 || newFees.management >= 1e18 || newFees.performance >= 1e18\\n    ) revert InvalidVaultFees();\\n\\n    proposedFees = newFees;\\n    proposedFeeTime = block.timestamp;\\n\\n    emit NewFeesProposed(newFees, block.timestamp);\\n  }\\n\\n  /// @notice Change fees to the previously proposed fees after the quit period has passed.\\n  function changeFees() external {\\n    if (proposedFeeTime == 0 || block.timestamp < proposedFeeTime + quitPeriod) revert NotPassedQuitPeriod();\\n\\n    emit ChangedFees(fees, proposedFees);\\n\\n    fees = proposedFees;\\n    feesUpdatedAt = block.timestamp;\\n\\n    delete proposedFees;\\n    delete proposedFeeTime;\\n  }\\n\\n  /**\\n   * @notice Change `feeRecipient`. Caller must be Owner.\\n   * @param _feeRecipient The new fee recipient.\\n   * @dev Accrued fees wont be transferred to the new feeRecipient.\\n   */\\n  function setFeeRecipient(address _feeRecipient) external onlyOwner {\\n    if (_feeRecipient == address(0)) revert InvalidFeeRecipient();\\n\\n    emit FeeRecipientUpdated(feeRecipient, _feeRecipient);\\n\\n    feeRecipient = _feeRecipient;\\n  }\\n\\n  event ChangedAdapters(\\n    AdapterConfig[10] oldAdapter,\\n    uint8 oldAdaptersCount,\\n    AdapterConfig[10] newAdapter,\\n    uint8 newAdaptersCount\\n  );\\n\\n  /**\\n   * @notice Set a new Adapter for this Vault after the quit period has passed.\\n   * @dev This migration function will remove all assets from the old Vault and move them into the new vault\\n   * @dev Additionally it will zero old allowances and set new ones\\n   * @dev Last we update HWM and assetsCheckpoint for fees to make sure they adjust to the new adapter\\n   */\\n  function changeAdapters() external takeFees {\\n    if (proposedAdapterTime == 0 || block.timestamp < proposedAdapterTime + quitPeriod) revert NotPassedQuitPeriod();\\n\\n    for (uint8 i; i < adaptersCount; i++) {\\n      adapters[i].adapter.redeem(adapters[i].adapter.balanceOf(address(this)), address(this), address(this));\\n\\n      IERC20(asset()).approve(address(adapters[i].adapter), 0);\\n    }\\n\\n    emit ChangedAdapters(adapters, adaptersCount, proposedAdapters, proposedAdaptersCount);\\n\\n    adapters = proposedAdapters;\\n    adaptersCount = proposedAdaptersCount;\\n\\n    uint256 cashAssets_ = IERC20(asset()).balanceOf(address(this));\\n\\n    for (uint8 i; i < adaptersCount; i++) {\\n      IERC20(asset()).approve(address(adapters[i].adapter), type(uint256).max);\\n\\n      adapters[i].adapter.deposit(\\n        cashAssets_.mulDiv(uint256(adapters[i].allocation), 1e18, Math.Rounding.Down),\\n        address(this)\\n      );\\n    }\\n\\n    delete proposedAdapters;\\n    delete proposedAdaptersCount;\\n    delete proposedAdapterTime;\\n  }\\n\\n  function pullAccruedVaultRewards() public {\\n    for (uint256 i; i < adaptersCount; ++i) {\\n      adapters[i].adapter.claimRewards();\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xb9e747ff6da84853821e9518db51b4a2177c6c206d2791b1db5aeda1027d9ed4\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedAPRVaultStorage.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport { VaultFees, IERC20 } from \\\"./IVault.sol\\\";\\nimport { CompoundMarketERC4626 } from \\\"../strategies/CompoundMarketERC4626.sol\\\";\\nimport { OptimizedVaultsRegistry } from \\\"./OptimizedVaultsRegistry.sol\\\";\\nimport { IonicFlywheel } from \\\"../strategies/flywheel/IonicFlywheel.sol\\\";\\nimport { SafeOwnable } from \\\"../../ionic/SafeOwnable.sol\\\";\\n\\nstruct AdapterConfig {\\n  CompoundMarketERC4626 adapter;\\n  uint64 allocation;\\n}\\n\\nabstract contract OptimizedAPRVaultStorage is SafeOwnable {\\n  uint256 internal constant SECONDS_PER_YEAR = 365.25 days;\\n\\n  uint8 public constant DECIMAL_OFFSET = 9;\\n\\n  uint8 internal _decimals;\\n  string internal _name;\\n  string internal _symbol;\\n\\n  uint256 public highWaterMark;\\n  uint256 public assetsCheckpoint;\\n  uint256 public feesUpdatedAt;\\n\\n  VaultFees public fees;\\n  VaultFees public proposedFees;\\n  uint256 public proposedFeeTime;\\n  address public feeRecipient;\\n\\n  AdapterConfig[10] public adapters;\\n  AdapterConfig[10] public proposedAdapters;\\n  uint8 public adaptersCount;\\n  uint8 public proposedAdaptersCount;\\n  uint256 public proposedAdapterTime;\\n\\n  uint256 public quitPeriod;\\n  uint256 public depositLimit;\\n\\n  //  EIP-2612 STORAGE\\n  uint256 internal INITIAL_CHAIN_ID;\\n  bytes32 internal INITIAL_DOMAIN_SEPARATOR;\\n  mapping(address => uint256) public nonces;\\n\\n  // OptimizedAPRVault storage\\n\\n  bool public emergencyExit;\\n  uint256 public withdrawalThreshold;\\n  OptimizedVaultsRegistry public registry;\\n  mapping(IERC20 => IonicFlywheel) public flywheelForRewardToken;\\n  address public flywheelLogic;\\n\\n  IERC20[] public rewardTokens;\\n}\\n\",\"keccak256\":\"0x340d0c48515f5ba15552bca8b9cdecaf7ca1459124bdd30e853dfb8c34413fe3\",\"license\":\"GPL-3.0\"},\"contracts/ionic/vault/OptimizedVaultsRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"../SafeOwnableUpgradeable.sol\\\";\\nimport \\\"./OptimizedAPRVaultBase.sol\\\";\\nimport \\\"./OptimizedAPRVaultExtension.sol\\\";\\nimport \\\"../strategies/CompoundMarketERC4626.sol\\\";\\nimport \\\"../strategies/flywheel/IonicFlywheel.sol\\\";\\nimport \\\"../strategies/flywheel/IonicFlywheelLensRouter.sol\\\";\\nimport { ICErc20 } from \\\"../../compound/CTokenInterfaces.sol\\\";\\n\\nimport { IERC20MetadataUpgradeable as IERC20 } from \\\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\ncontract OptimizedVaultsRegistry is SafeOwnableUpgradeable {\\n  OptimizedAPRVaultBase[] public vaults;\\n  mapping(address => OptimizedAPRVaultExtension[]) internal latestVaultExtensions;\\n  IonicFlywheelLensRouter public flr;\\n\\n  function initialize(IonicFlywheelLensRouter _flr) public initializer {\\n    __SafeOwnable_init(msg.sender);\\n    flr = _flr;\\n  }\\n\\n  function getLatestVaultExtensions(address vault) public view returns (OptimizedAPRVaultExtension[] memory) {\\n    return latestVaultExtensions[vault];\\n  }\\n\\n  function setLatestVaultExtensions(address vault, OptimizedAPRVaultExtension[] calldata extensions) public onlyOwner {\\n    latestVaultExtensions[vault] = extensions;\\n  }\\n\\n  function getAllVaults() public view returns (OptimizedAPRVaultBase[] memory) {\\n    return vaults;\\n  }\\n\\n  function addVault(address vault) public onlyOwner returns (bool) {\\n    for (uint256 i; i < vaults.length; i++) {\\n      if (address(vaults[i]) == vault) {\\n        return false;\\n      }\\n    }\\n    vaults.push(OptimizedAPRVaultBase(vault));\\n    return true;\\n  }\\n\\n  function removeVault(address vault) public onlyOwner returns (bool) {\\n    for (uint256 i; i < vaults.length; i++) {\\n      if (address(vaults[i]) == vault) {\\n        vaults[i] = vaults[vaults.length - 1];\\n        delete vaults[vaults.length - 1];\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  function setEmergencyExit() external onlyOwner {\\n    for (uint256 i; i < vaults.length; ++i) {\\n      uint8 adaptersCount = vaults[i].adaptersCount();\\n      for (uint256 j; j < adaptersCount; ++j) {\\n        (CompoundMarketERC4626 adapter, ) = vaults[i].adapters(j);\\n        try adapter.emergencyWithdrawAndPause() {} catch {}\\n      }\\n      vaults[i].asSecondExtension().setEmergencyExit();\\n    }\\n  }\\n\\n  struct ClaimableRewardsInfo {\\n    address flywheel;\\n    address vault;\\n    address rewardToken;\\n    string rewardTokenName;\\n    string rewardTokenSymbol;\\n    uint8 rewardTokenDecimals;\\n    uint256 rewards;\\n  }\\n\\n  // @notice lens function to list all flywheels for which the account can claim rewards\\n  function getClaimableRewards(address account) external returns (ClaimableRewardsInfo[] memory rewardsData) {\\n    {\\n      uint256 totalFlywheels = 0;\\n      for (uint256 i = 0; i < vaults.length; i++) {\\n        IonicFlywheel[] memory flywheels = vaults[i].asFirstExtension().getAllFlywheels();\\n        totalFlywheels += flywheels.length;\\n      }\\n\\n      rewardsData = new ClaimableRewardsInfo[](totalFlywheels);\\n    }\\n\\n    {\\n      uint256 flywheelsCounter = 0;\\n      for (uint256 i = 0; i < vaults.length; i++) {\\n        OptimizedAPRVaultBase vault = vaults[i];\\n        IonicFlywheel[] memory flywheels = vault.asFirstExtension().getAllFlywheels();\\n        uint256 flywheelsLen = flywheels.length;\\n\\n        for (uint256 j = 0; j < flywheelsLen; j++) {\\n          IonicFlywheel flywheel = flywheels[j];\\n          rewardsData[flywheelsCounter + j].vault = address(vault);\\n          rewardsData[flywheelsCounter + j].flywheel = address(flywheel);\\n          rewardsData[flywheelsCounter + j].rewards = flywheel.accrue(ERC20(address(vault)), account);\\n          ERC20 rewardToken = flywheel.rewardToken();\\n          rewardsData[flywheelsCounter + j].rewardToken = address(rewardToken);\\n          rewardsData[flywheelsCounter + j].rewardTokenName = rewardToken.name();\\n          rewardsData[flywheelsCounter + j].rewardTokenSymbol = rewardToken.symbol();\\n          rewardsData[flywheelsCounter + j].rewardTokenDecimals = rewardToken.decimals();\\n        }\\n        flywheelsCounter += flywheelsLen;\\n      }\\n    }\\n  }\\n\\n  struct AdapterInfo {\\n    address adapter;\\n    uint64 allocation;\\n    address market;\\n    address pool;\\n  }\\n\\n  struct VaultInfo {\\n    address vault;\\n    address asset;\\n    string assetSymbol;\\n    uint8 assetDecimals;\\n    uint256 estimatedTotalAssets;\\n    uint256 apr;\\n    uint256 adaptersCount;\\n    bool isEmergencyStopped;\\n    uint64 performanceFee;\\n    uint64 depositFee;\\n    uint64 withdrawalFee;\\n    uint64 managementFee;\\n    AdapterInfo[] adaptersData;\\n  }\\n\\n  function getVaultsData() public view returns (VaultInfo[] memory vaultsData) {\\n    vaultsData = new VaultInfo[](vaults.length);\\n    for (uint256 i; i < vaults.length; ++i) {\\n      OptimizedAPRVaultSecondExtension vault = vaults[i].asSecondExtension();\\n      uint8 adaptersCount = vaults[i].adaptersCount();\\n      AdapterInfo[] memory adaptersData = new AdapterInfo[](adaptersCount);\\n\\n      for (uint256 j; j < adaptersCount; ++j) {\\n        (CompoundMarketERC4626 adapter, uint64 allocation) = vaults[i].adapters(j);\\n        ICErc20 market = adapter.market();\\n        adaptersData[j].adapter = address(adapter);\\n        adaptersData[j].allocation = allocation;\\n        adaptersData[j].market = address(market);\\n        adaptersData[j].pool = address(market.comptroller());\\n      }\\n\\n      (uint64 performanceFee, uint64 depositFee, uint64 withdrawalFee, uint64 managementFee) = vault.fees();\\n\\n      vaultsData[i] = VaultInfo({\\n        vault: address(vault),\\n        asset: vault.asset(),\\n        assetSymbol: IERC20(vault.asset()).symbol(),\\n        assetDecimals: IERC20(vault.asset()).decimals(),\\n        estimatedTotalAssets: vault.estimatedTotalAssets(),\\n        apr: vault.estimatedAPR(),\\n        adaptersCount: adaptersCount,\\n        isEmergencyStopped: vault.emergencyExit(),\\n        performanceFee: performanceFee,\\n        depositFee: depositFee,\\n        withdrawalFee: withdrawalFee,\\n        managementFee: managementFee,\\n        adaptersData: adaptersData\\n      });\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xacc3c2d7a998302c92790d52876a50ce7673347175879c7b856933e866f179fa\",\"license\":\"GPL-3.0\"},\"contracts/oracles/BasePriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"../compound/CTokenInterfaces.sol\\\";\\n\\n/**\\n * @title BasePriceOracle\\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\\n * @dev Implements the `PriceOracle` interface.\\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\\n */\\ninterface BasePriceOracle {\\n  /**\\n   * @notice Get the price of an underlying asset.\\n   * @param underlying The underlying asset to get the price of.\\n   * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\\n   * Zero means the price is unavailable.\\n   */\\n  function price(address underlying) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the underlying price of a cToken asset\\n   * @param cToken The cToken to get the underlying price of\\n   * @return The underlying asset price mantissa (scaled by 1e18).\\n   *  Zero means the price is unavailable.\\n   */\\n  function getUnderlyingPrice(ICErc20 cToken) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xed2a27a8dc71a4280c0ef19d3165ff237d8066ae782e750b071bb39d12e73404\",\"license\":\"UNLICENSED\"},\"flywheel/FlywheelCore.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Auth, Authority} from \\\"solmate/auth/Auth.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {SafeCastLib} from \\\"solmate/utils/SafeCastLib.sol\\\";\\n\\nimport {IFlywheelRewards} from \\\"./interfaces/IFlywheelRewards.sol\\\";\\nimport {IFlywheelBooster} from \\\"./interfaces/IFlywheelBooster.sol\\\";\\n\\n/**\\n @title Flywheel Core Incentives Manager\\n @notice Flywheel is a general framework for managing token incentives.\\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\\n\\n         The Core contract maintaings three important pieces of state:\\n         * the rewards index which determines how many rewards are owed per token per strategy. User indexes track how far behind the strategy they are to lazily calculate all catch-up rewards.\\n         * the accrued (unclaimed) rewards per user.\\n         * references to the booster and rewards module described below.\\n\\n         Core does not manage any tokens directly. The rewards module maintains token balances, and approves core to pull transfer them to users when they claim.\\n\\n         SECURITY NOTE: For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \\n         Accrue should be called any time tokens are transferred, minted, or burned.\\n */\\ncontract FlywheelCore is Auth {\\n    using SafeTransferLib for ERC20;\\n    using SafeCastLib for uint256;\\n\\n    /// @notice The token to reward\\n    ERC20 public immutable rewardToken;\\n\\n    /// @notice append-only list of strategies added\\n    ERC20[] public allStrategies;\\n\\n    /// @notice the rewards contract for managing streams\\n    IFlywheelRewards public flywheelRewards;\\n\\n    /// @notice optional booster module for calculating virtual balances on strategies\\n    IFlywheelBooster public flywheelBooster;\\n\\n    constructor(\\n        ERC20 _rewardToken,\\n        IFlywheelRewards _flywheelRewards,\\n        IFlywheelBooster _flywheelBooster,\\n        address _owner,\\n        Authority _authority\\n    ) Auth(_owner, _authority) {\\n        rewardToken = _rewardToken;\\n        flywheelRewards = _flywheelRewards;\\n        flywheelBooster = _flywheelBooster;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        ACCRUE/CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /** \\n      @notice Emitted when a user's rewards accrue to a given strategy.\\n      @param strategy the updated rewards strategy\\n      @param user the user of the rewards\\n      @param rewardsDelta how many new rewards accrued to the user\\n      @param rewardsIndex the market index for rewards per token accrued\\n    */\\n    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\\n\\n    /** \\n      @notice Emitted when a user claims accrued rewards.\\n      @param user the user of the rewards\\n      @param amount the amount of rewards claimed\\n    */\\n    event ClaimRewards(address indexed user, uint256 amount);\\n\\n    /// @notice The accrued but not yet transferred rewards for each user\\n    mapping(address => uint256) public rewardsAccrued;\\n\\n    /** \\n      @notice accrue rewards for a single user on a strategy\\n      @param strategy the strategy to accrue a user's rewards on\\n      @param user the user to be accrued\\n      @return the cumulative amount of rewards accrued to user (including prior)\\n    */\\n    function accrue(ERC20 strategy, address user) public returns (uint256) {\\n        RewardsState memory state = strategyState[strategy];\\n\\n        if (state.index == 0) return 0;\\n\\n        state = accrueStrategy(strategy, state);\\n        return accrueUser(strategy, user, state);\\n    }\\n\\n    /** \\n      @notice accrue rewards for a two users on a strategy\\n      @param strategy the strategy to accrue a user's rewards on\\n      @param user the first user to be accrued\\n      @param user the second user to be accrued\\n      @return the cumulative amount of rewards accrued to the first user (including prior)\\n      @return the cumulative amount of rewards accrued to the second user (including prior)\\n    */\\n    function accrue(\\n        ERC20 strategy,\\n        address user,\\n        address secondUser\\n    ) public returns (uint256, uint256) {\\n        RewardsState memory state = strategyState[strategy];\\n\\n        if (state.index == 0) return (0, 0);\\n\\n        state = accrueStrategy(strategy, state);\\n        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\\n    }\\n\\n    /** \\n      @notice claim rewards for a given user\\n      @param user the user claiming rewards\\n      @dev this function is public, and all rewards transfer to the user\\n    */\\n    function claimRewards(address user) external {\\n        uint256 accrued = rewardsAccrued[user];\\n\\n        if (accrued != 0) {\\n            rewardsAccrued[user] = 0;\\n\\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\\n\\n            emit ClaimRewards(user, accrued);\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          ADMIN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /** \\n      @notice Emitted when a new strategy is added to flywheel by the admin\\n      @param newStrategy the new added strategy\\n    */\\n    event AddStrategy(address indexed newStrategy);\\n\\n    /// @notice initialize a new strategy\\n    function addStrategyForRewards(ERC20 strategy) external requiresAuth {\\n        _addStrategyForRewards(strategy);\\n    }\\n\\n    function _addStrategyForRewards(ERC20 strategy) internal {\\n        require(strategyState[strategy].index == 0, \\\"strategy\\\");\\n        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});\\n\\n        allStrategies.push(strategy);\\n        emit AddStrategy(address(strategy));\\n    }\\n\\n    function getAllStrategies() external view returns (ERC20[] memory) {\\n        return allStrategies;\\n    }\\n\\n    /** \\n      @notice Emitted when the rewards module changes\\n      @param newFlywheelRewards the new rewards module\\n    */\\n    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\\n\\n    /// @notice swap out the flywheel rewards contract\\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\\n        if (oldRewardBalance > 0) {\\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\\n        }\\n\\n        flywheelRewards = newFlywheelRewards;\\n\\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\\n    }\\n\\n    /** \\n      @notice Emitted when the booster module changes\\n      @param newBooster the new booster module\\n    */\\n    event FlywheelBoosterUpdate(address indexed newBooster);\\n\\n    /// @notice swap out the flywheel booster contract\\n    function setBooster(IFlywheelBooster newBooster) external requiresAuth {\\n        flywheelBooster = newBooster;\\n\\n        emit FlywheelBoosterUpdate(address(newBooster));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    INTERNAL ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    struct RewardsState {\\n        /// @notice The strategy's last updated index\\n        uint224 index;\\n        /// @notice The timestamp the index was last updated at\\n        uint32 lastUpdatedTimestamp;\\n    }\\n\\n    /// @notice the fixed point factor of flywheel\\n    uint224 public constant ONE = 1e18;\\n\\n    /// @notice The strategy index and last updated per strategy\\n    mapping(ERC20 => RewardsState) public strategyState;\\n\\n    /// @notice user index per strategy\\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\\n\\n    /// @notice accumulate global rewards on a strategy\\n    function accrueStrategy(ERC20 strategy, RewardsState memory state)\\n        private\\n        returns (RewardsState memory rewardsState)\\n    {\\n        // calculate accrued rewards through module\\n        uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\\n\\n        rewardsState = state;\\n        if (strategyRewardsAccrued > 0) {\\n            // use the booster or token supply to calculate reward index denominator\\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\\n                ? flywheelBooster.boostedTotalSupply(strategy)\\n                : strategy.totalSupply();\\n\\n            uint224 deltaIndex;\\n\\n            if (supplyTokens != 0) deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).safeCastTo224();\\n\\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\\n            rewardsState = RewardsState({\\n                index: state.index + deltaIndex,\\n                lastUpdatedTimestamp: block.timestamp.safeCastTo32()\\n            });\\n            strategyState[strategy] = rewardsState;\\n        }\\n    }\\n\\n    /// @notice accumulate rewards on a strategy for a specific user\\n    function accrueUser(\\n        ERC20 strategy,\\n        address user,\\n        RewardsState memory state\\n    ) private returns (uint256) {\\n        // load indices\\n        uint224 strategyIndex = state.index;\\n        uint224 supplierIndex = userIndex[strategy][user];\\n\\n        // sync user index to global\\n        userIndex[strategy][user] = strategyIndex;\\n\\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\\n        // zero balances will have no effect other than syncing to global index\\n        if (supplierIndex == 0) {\\n            supplierIndex = ONE;\\n        }\\n\\n        uint224 deltaIndex = strategyIndex - supplierIndex;\\n        // use the booster or token balance to calculate reward balance multiplier\\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\\n            : strategy.balanceOf(user);\\n\\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\\n\\n        rewardsAccrued[user] = supplierAccrued;\\n\\n        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\\n\\n        return supplierAccrued;\\n    }\\n}\\n\",\"keccak256\":\"0xfa93107e46ed1ad65ab4724b4184f18a8c83b6898116b462dcefea16fb81defa\",\"license\":\"AGPL-3.0-only\"},\"flywheel/interfaces/IFlywheelBooster.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\n\\n/**\\n @title Balance Booster Module for Flywheel\\n @notice Flywheel is a general framework for managing token incentives.\\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\\n\\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \\n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\\n        \\n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\\n\\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\\n*/\\ninterface IFlywheelBooster {\\n    /**\\n      @notice calculate the boosted supply of a strategy.\\n      @param strategy the strategy to calculate boosted supply of\\n      @return the boosted supply\\n     */\\n    function boostedTotalSupply(ERC20 strategy) external view returns (uint256);\\n\\n    /**\\n      @notice calculate the boosted balance of a user in a given strategy.\\n      @param strategy the strategy to calculate boosted balance of\\n      @param user the user to calculate boosted balance of\\n      @return the boosted balance\\n     */\\n    function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xcdab1b4b5662148d74acc3491a810d263ec509f9f81a267e9f6c1542ba15eabc\",\"license\":\"AGPL-3.0-only\"},\"flywheel/interfaces/IFlywheelRewards.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {FlywheelCore} from \\\"../FlywheelCore.sol\\\";\\n\\n/**\\n @title Rewards Module for Flywheel\\n @notice Flywheel is a general framework for managing token incentives.\\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\\n\\n         The Rewards module is responsible for:\\n         * determining the ongoing reward amounts to entire strategies (core handles the logic for dividing among users)\\n         * actually holding rewards that are yet to be claimed\\n\\n         The reward stream can follow arbitrary logic as long as the amount of rewards passed to flywheel core has been sent to this contract.\\n\\n         Different module strategies include:\\n         * a static reward rate per second\\n         * a decaying reward rate\\n         * a dynamic just-in-time reward stream\\n         * liquid governance reward delegation (Curve Gauge style)\\n\\n         SECURITY NOTE: The rewards strategy should be smooth and continuous, to prevent gaming the reward distribution by frontrunning.\\n */\\ninterface IFlywheelRewards {\\n    /**\\n     @notice calculate the rewards amount accrued to a strategy since the last update.\\n     @param strategy the strategy to accrue rewards for.\\n     @param lastUpdatedTimestamp the last time rewards were accrued for the strategy.\\n     @return rewards the amount of rewards accrued to the market\\n    */\\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);\\n\\n    /// @notice return the flywheel core address\\n    function flywheel() external view returns (FlywheelCore);\\n\\n    /// @notice return the reward token associated with flywheel core.\\n    function rewardToken() external view returns (ERC20);\\n}\\n\",\"keccak256\":\"0x6f12992a090498e62226ca77a8f62a27717a12044ff9cc242f73c43f6cb138fd\",\"license\":\"AGPL-3.0-only\"},\"flywheel/rewards/BaseFlywheelRewards.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport {SafeTransferLib, ERC20} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IFlywheelRewards} from \\\"../interfaces/IFlywheelRewards.sol\\\";\\nimport {FlywheelCore} from \\\"../FlywheelCore.sol\\\";\\n\\n/** \\n @title Flywheel Reward Module\\n @notice Determines how many rewards accrue to each strategy globally over a given time period.\\n @dev approves the flywheel core for the reward token to allow balances to be managed by the module but claimed from core.\\n*/\\nabstract contract BaseFlywheelRewards is IFlywheelRewards {\\n    using SafeTransferLib for ERC20;\\n\\n    /// @notice thrown when caller is not the flywheel\\n    error FlywheelError();\\n\\n    /// @notice the reward token paid\\n    ERC20 public immutable override rewardToken;\\n\\n    /// @notice the flywheel core contract\\n    FlywheelCore public immutable override flywheel;\\n\\n    constructor(FlywheelCore _flywheel) {\\n        flywheel = _flywheel;\\n        ERC20 _rewardToken = _flywheel.rewardToken();\\n        rewardToken = _rewardToken;\\n\\n        _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\\n    }\\n\\n    modifier onlyFlywheel() {\\n        if (msg.sender != address(flywheel)) revert FlywheelError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x77eb9c2446ae381549c1c9b346679d9257ba80f86ad3f555d586a57d54fd0bbe\",\"license\":\"AGPL-3.0-only\"},\"flywheel/rewards/FlywheelDynamicRewards.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"./BaseFlywheelRewards.sol\\\";\\nimport {SafeCastLib} from \\\"solmate/utils/SafeCastLib.sol\\\";\\n\\n/** \\n @title Flywheel Dynamic Reward Stream\\n @notice Determines rewards based on a dynamic reward stream.\\n         Rewards are transferred linearly over a \\\"rewards cycle\\\" to prevent gaming the reward distribution. \\n         The reward source can be arbitrary logic, but most common is to \\\"pass through\\\" rewards from some other source.\\n         The getNextCycleRewards() hook should also transfer the next cycle's rewards to this contract to ensure proper accounting.\\n*/\\nabstract contract FlywheelDynamicRewards is BaseFlywheelRewards {\\n    using SafeTransferLib for ERC20;\\n    using SafeCastLib for uint256;\\n\\n    event NewRewardsCycle(uint32 indexed start, uint32 indexed end, uint192 reward);\\n\\n    /// @notice the length of a rewards cycle\\n    uint32 public immutable rewardsCycleLength;\\n\\n    struct RewardsCycle {\\n        uint32 start;\\n        uint32 end;\\n        uint192 reward;\\n    }\\n\\n    mapping(ERC20 => RewardsCycle) public rewardsCycle;\\n\\n    constructor(FlywheelCore _flywheel, uint32 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\\n        rewardsCycleLength = _rewardsCycleLength;\\n    }\\n\\n    /**\\n     @notice calculate and transfer accrued rewards to flywheel core\\n     @param strategy the strategy to accrue rewards for\\n     @return amount the amount of tokens accrued and transferred\\n     */\\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp)\\n        external\\n        override\\n        onlyFlywheel\\n        returns (uint256 amount)\\n    {\\n        RewardsCycle memory cycle = rewardsCycle[strategy];\\n\\n        uint32 timestamp = block.timestamp.safeCastTo32();\\n\\n        uint32 latest = timestamp >= cycle.end ? cycle.end : timestamp;\\n        uint32 earliest = lastUpdatedTimestamp <= cycle.start ? cycle.start : lastUpdatedTimestamp;\\n        if (cycle.end != 0) {\\n            amount = (cycle.reward * (latest - earliest)) / (cycle.end - cycle.start);\\n            assert(amount <= cycle.reward); // should never happen because latest <= cycle.end and earliest >= cycle.start\\n        }\\n        // if cycle has ended, reset cycle and transfer all available\\n        if (timestamp >= cycle.end) {\\n            uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\\n            uint192 rewards = getNextCycleRewards(strategy);\\n\\n            // reset for next cycle\\n            rewardsCycle[strategy] = RewardsCycle({start: timestamp, end: end, reward: rewards});\\n\\n            emit NewRewardsCycle(timestamp, end, rewards);\\n        }\\n    }\\n\\n    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint192);\\n}\\n\",\"keccak256\":\"0x8c44106ef42b90d226f4e59ef322d8127535a99c3fd2a7f34bf94317db3ee86f\",\"license\":\"AGPL-3.0-only\"},\"fuse-flywheel/rewards/FuseFlywheelDynamicRewards.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"flywheel/rewards/FlywheelDynamicRewards.sol\\\";\\n\\n/** \\n @title Fuse Flywheel Dynamic Reward Stream\\n @notice Determines rewards based on reward cycle\\n*/\\ncontract FuseFlywheelDynamicRewards is FlywheelDynamicRewards {\\n    using SafeTransferLib for ERC20;\\n\\n    constructor(FlywheelCore _flywheel, uint32 _cycleLength)\\n        FlywheelDynamicRewards(_flywheel, _cycleLength)\\n    {}\\n\\n    function getNextCycleRewards(ERC20 strategy)\\n        internal\\n        override\\n        returns (uint192)\\n    {\\n        uint256 rewardAmount = rewardToken.balanceOf(address(strategy));\\n        if (rewardAmount != 0) {\\n            rewardToken.safeTransferFrom(\\n                address(strategy),\\n                address(this),\\n                rewardAmount\\n            );\\n        }\\n        return uint192(rewardAmount);\\n    }\\n}\\n\",\"keccak256\":\"0x958607759252e4a53c980c19451370cb5ac1772dc4cf6e73da8133ca12d5373f\",\"license\":\"AGPL-3.0-only\"},\"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/interfaces/IERC4626Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n     * \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0xe3d54e1a1a10fbc86fdfaf9100ba99c9c808588fd20d0c919457b903b5cae61a\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x6c2b54ec184943843041ab77f61988b5060f6f03acbfe92cdc125f95f00891da\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xefe5b03cf4147c27e7e38a1b8ddb3e0dc7f0ba8f6be71627d962fa91c98943dd\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0x17aff86be546601617585e91fd98aad74cf39f1be65d8eb6f93b7f3c30181275\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../../interfaces/IERC4626Upgradeable.sol\\\";\\nimport \\\"../../../utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC4626 \\\"Tokenized Vault Standard\\\" as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\\n *\\n * This extension allows the minting and burning of \\\"shares\\\" (represented using the ERC20 inheritance) in exchange for\\n * underlying \\\"assets\\\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\\n * the ERC20 standard. Any additional extensions included along it would affect the \\\"shares\\\" token represented by this\\n * contract and not the \\\"assets\\\" token which is an independent contract.\\n *\\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\\n *\\n * _Available since v4.7._\\n */\\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\\n    using MathUpgradeable for uint256;\\n\\n    IERC20Upgradeable private _asset;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\\n     */\\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\\n        __ERC4626_init_unchained(asset_);\\n    }\\n\\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\\n        _decimals = success ? assetDecimals : super.decimals();\\n        _asset = asset_;\\n    }\\n\\n    /**\\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\\n     */\\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private returns (bool, uint8) {\\n        (bool success, bytes memory encodedDecimals) = address(asset_).call(\\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\\n        );\\n        if (success && encodedDecimals.length >= 32) {\\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\\n            if (returnedDecimals <= type(uint8).max) {\\n                return (true, uint8(returnedDecimals));\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\\n     * See {IERC20Metadata-decimals}.\\n     */\\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /** @dev See {IERC4626-asset}. */\\n    function asset() public view virtual override returns (address) {\\n        return address(_asset);\\n    }\\n\\n    /** @dev See {IERC4626-totalAssets}. */\\n    function totalAssets() public view virtual override returns (uint256) {\\n        return _asset.balanceOf(address(this));\\n    }\\n\\n    /** @dev See {IERC4626-convertToShares}. */\\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-convertToAssets}. */\\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxDeposit}. */\\n    function maxDeposit(address) public view virtual override returns (uint256) {\\n        return _isVaultCollateralized() ? type(uint256).max : 0;\\n    }\\n\\n    /** @dev See {IERC4626-maxMint}. */\\n    function maxMint(address) public view virtual override returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    /** @dev See {IERC4626-maxWithdraw}. */\\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxRedeem}. */\\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\\n        return balanceOf(owner);\\n    }\\n\\n    /** @dev See {IERC4626-previewDeposit}. */\\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-previewMint}. */\\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewWithdraw}. */\\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewRedeem}. */\\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-deposit}. */\\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\\n        require(assets <= maxDeposit(receiver), \\\"ERC4626: deposit more than max\\\");\\n\\n        uint256 shares = previewDeposit(assets);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-mint}. */\\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\\n        require(shares <= maxMint(receiver), \\\"ERC4626: mint more than max\\\");\\n\\n        uint256 assets = previewMint(shares);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /** @dev See {IERC4626-withdraw}. */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(assets <= maxWithdraw(owner), \\\"ERC4626: withdraw more than max\\\");\\n\\n        uint256 shares = previewWithdraw(assets);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-redeem}. */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(shares <= maxRedeem(owner), \\\"ERC4626: redeem more than max\\\");\\n\\n        uint256 assets = previewRedeem(shares);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\\n     *\\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\\n     * would represent an infinite amount of shares.\\n     */\\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\\n        uint256 supply = totalSupply();\\n        return\\n            (assets == 0 || supply == 0)\\n                ? _initialConvertToShares(assets, rounding)\\n                : assets.mulDiv(supply, totalAssets(), rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\\n     */\\n    function _initialConvertToShares(\\n        uint256 assets,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 shares) {\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\\n     */\\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\\n        uint256 supply = totalSupply();\\n        return\\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\\n     */\\n    function _initialConvertToAssets(\\n        uint256 shares,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 assets) {\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Deposit/mint common workflow.\\n     */\\n    function _deposit(\\n        address caller,\\n        address receiver,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\\n        // assets are transferred and before the shares are minted, which is a valid state.\\n        // slither-disable-next-line reentrancy-no-eth\\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\\n        _mint(receiver, shares);\\n\\n        emit Deposit(caller, receiver, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Withdraw/redeem common workflow.\\n     */\\n    function _withdraw(\\n        address caller,\\n        address receiver,\\n        address owner,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        if (caller != owner) {\\n            _spendAllowance(owner, caller, shares);\\n        }\\n\\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\\n        // shares are burned and after the assets are transferred, which is a valid state.\\n        _burn(owner, shares);\\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\\n\\n        emit Withdraw(caller, receiver, owner, assets, shares);\\n    }\\n\\n    function _isVaultCollateralized() private view returns (bool) {\\n        return totalAssets() > 0 || totalSupply() == 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x82dd1556d6774b8bdaec0fb70d09c9d9cb0d75e9f2ffc183bb09a16b86d7c598\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4586689c55edb37fc3cac296d75d3851b3aee3f378aaa54d8a9258a384fbf541\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0a3b4afc301241e2629ad192fa02e0f8626e3cf38ab6f45342bfd7afbde16ee0\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2Upgradeable {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd4f2e4c252119ec161cc4de7fc6631b0dd840c46e85bf1fc771252924957d5ab\",\"license\":\"MIT\"},\"openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb49137b771712774960cca0acf428499e2aa85f179fe03712e5c06c5a6ab6316\",\"license\":\"MIT\"},\"solmate/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xd5cf8213a40d727af89c93dd359ad68984c123c1a1a93fc9ad7ba62b3436fb75\",\"license\":\"AGPL-3.0-only\"},\"solmate/auth/authorities/RolesAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Auth, Authority} from \\\"../Auth.sol\\\";\\n\\n/// @notice Role based Authority that supports up to 256 roles.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\\ncontract RolesAuthority is Auth, Authority {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\\n\\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\\n\\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ROLE/USER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => bytes32) public getUserRoles;\\n\\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\\n\\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\\n\\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\\n    }\\n\\n    function doesRoleHaveCapability(\\n        uint8 role,\\n        address target,\\n        bytes4 functionSig\\n    ) public view virtual returns (bool) {\\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           AUTHORIZATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) public view virtual override returns (bool) {\\n        return\\n            isCapabilityPublic[target][functionSig] ||\\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                   ROLE CAPABILITY CONFIGURATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setPublicCapability(\\n        address target,\\n        bytes4 functionSig,\\n        bool enabled\\n    ) public virtual requiresAuth {\\n        isCapabilityPublic[target][functionSig] = enabled;\\n\\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\\n    }\\n\\n    function setRoleCapability(\\n        uint8 role,\\n        address target,\\n        bytes4 functionSig,\\n        bool enabled\\n    ) public virtual requiresAuth {\\n        if (enabled) {\\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\\n        } else {\\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\\n        }\\n\\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                       USER ROLE ASSIGNMENT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setUserRole(\\n        address user,\\n        uint8 role,\\n        bool enabled\\n    ) public virtual requiresAuth {\\n        if (enabled) {\\n            getUserRoles[user] |= bytes32(1 << role);\\n        } else {\\n            getUserRoles[user] &= ~bytes32(1 << role);\\n        }\\n\\n        emit UserRoleUpdated(user, role, enabled);\\n    }\\n}\\n\",\"keccak256\":\"0x278247a2c5b0accb60af8d3749e34ab5d4436ee4f35a8fff301aaa25ab690762\",\"license\":\"AGPL-3.0-only\"},\"solmate/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"solmate/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xab8ca9afbb0f7412e1408d4f111b53cc00813bc752236638ad336050ea2188f8\",\"license\":\"AGPL-3.0-only\"},\"solmate/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\\n        require(x < 1 << 16);\\n\\n        y = uint16(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0xb784a14411858036491124e677aecde6d500e695b7a70c74aa8f1001bda2ccab\",\"license\":\"AGPL-3.0-only\"},\"solmate/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61008b565b600180546001600160a01b03191690556100388161003b565b50565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6115788061009a6000396000f3fe608060405234801561001057600080fd5b50600436106101fb5760003560e01c80638787b17a1161011a578063d96880a8116100ad578063e69e24a81161007c578063e69e24a8146104bd578063ecf70858146104d0578063f2fde38b146104d9578063f62f1d53146104ec578063f9828cff14610515576101fb565b8063d96880a814610492578063daa671ac1461049b578063de7d4d6a146104a4578063e30c3978146104ac576101fb565b80639f3d0a48116100e95780639f3d0a4814610464578063a71933a71461046d578063ac11f2121461047f578063b542114c146102bb576101fb565b80638787b17a146103d057806389cd9855146103d95780638da5cb5b146103ec5780639af1d35a146103fd576101fb565b80636333d001116101925780637b103999116101615780637b1039991461036b5780637bb7bed11461037e5780637c7a561b146103915780637ecebe00146103b0576101fb565b80636333d0011461033d578063715018a6146103525780637985fd511461035a57806379ba509714610363576101fb565b806349d4139f116101ce57806349d4139f146102d45780634ef501ac146102dd5780634fa64598146103185780635641ec0314610320576101fb565b80630f25b764146102745780631e8410da146102a4578063338859f6146102bb57806346904840146102c1575b60006102126000356001600160e01b031916610548565b90506001600160a01b03811661024e57604051630a82dd7360e31b81526001600160e01b03196000351660048201526024015b60405180910390fd5b3660008037600080366000845af43d6000803e80801561026d573d6000f35b3d6000fd5b005b602a54610287906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102ad60045481565b60405190815260200161029b565b30610287565b600a54610287906001600160a01b031681565b6102ad60215481565b6102f06102eb366004611104565b610568565b604080516001600160a01b03909316835267ffffffffffffffff90911660208301520161029b565b61027261059a565b60265461032d9060ff1681565b604051901515815260200161029b565b610345610693565b60405161029b919061111d565b6102726106a2565b6102ad60275481565b6102726106f2565b602854610287906001600160a01b031681565b61028761038c366004611104565b61076c565b601f5461039e9060ff1681565b60405160ff909116815260200161029b565b6102ad6103be36600461117f565b60256020526000908152604090205481565b6102ad60205481565b6102726103e73660046111a3565b610796565b6000546001600160a01b0316610287565b6007546104309067ffffffffffffffff80821691600160401b8104821691600160801b8204811691600160c01b90041684565b6040805167ffffffffffffffff9586168152938516602085015291841691830191909152909116606082015260800161029b565b6102ad60065481565b601f5461039e90610100900460ff1681565b6102f061048d366004611104565b6107fe565b6102ad60095481565b6102ad60055481565b61039e600981565b6001546001600160a01b0316610287565b6102726104cb3660046111dc565b61080e565b6102ad60225481565b6102726104e736600461117f565b6108b8565b6102876104fa36600461117f565b6029602052600090815260409020546001600160a01b031681565b6008546104309067ffffffffffffffff80821691600160401b8104821691600160801b8204811691600160c01b90041684565b600061056282600080516020611523833981519152610929565b92915050565b600b81600a811061057857600080fd5b01546001600160a01b0381169150600160a01b900467ffffffffffffffff1682565b6105a26109c4565b60006105ac610a20565b905060005b81518110156105e4576105dc8282815181106105cf576105cf6112a1565b6020026020010151610a92565b6001016105b1565b5060285460405163d9d1764560e01b81523060048201526000916001600160a01b03169063d9d1764590602401600060405180830381865afa15801561062e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106569190810190611322565b905060005b815181101561068e57610686828281518110610679576106796112a1565b6020026020010151610bc1565b60010161065b565b505050565b606061069d610a20565b905090565b6106aa6109c4565b60405162461bcd60e51b815260206004820152601e60248201527f72656e6f756e6365206f776e657273686970206e6f7420616c6c6f77656400006044820152606401610245565b60015433906001600160a01b031681146107605760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610245565b61076981610cb8565b50565b602b818154811061077c57600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b031633146107f05760405162461bcd60e51b815260206004820152601f60248201527f21756e617574686f72697a6564202d206e6f2061646d696e20726967687473006044820152606401610245565b6107fa8282610cd1565b5050565b601581600a811061057857600080fd5b6108166109c4565b60005b8381101561085a57610852858583818110610836576108366112a1565b905060200201602081019061084b919061117f565b6000610cd1565b600101610819565b5060405163439fab9160e01b8152309063439fab919061088090859085906004016113c1565b600060405180830381600087803b15801561089a57600080fd5b505af11580156108ae573d6000803e3d6000fd5b5050505050505050565b6108c06109c4565b600180546001600160a01b0383166001600160a01b031990911681179091556108f16000546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b8054600090815b818110156109b957846001600160e01b031916846000018281548110610958576109586112a1565b600091825260209091200154600160a01b900460e01b6001600160e01b031916036109b157836000018181548110610992576109926112a1565b6000918252602090912001546001600160a01b03169250610562915050565b600101610930565b506000949350505050565b6000546001600160a01b03163314610a1e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610245565b565b6060600080516020611523833981519152600101805480602002602001604051908101604052809291908181526020018280548015610a8857602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610a6a575b5050505050905090565b600080516020611523833981519152610aaa82610cf2565b60005b600182015460ff8216101561068e57826001600160a01b0316826001018260ff1681548110610ade57610ade6112a1565b6000918252602090912001546001600160a01b031603610baf57600180830180549091610b0a91611406565b81548110610b1a57610b1a6112a1565b6000918252602090912001546001830180546001600160a01b039092169160ff8416908110610b4b57610b4b6112a1565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b0316021790555081600101805480610b8c57610b8c611419565b600082815260209020810160001990810180546001600160a01b03191690550190555b80610bb98161142f565b915050610aad565b60008051602061152383398151915260005b600182015460ff82161015610c7857826001600160a01b0316826001018260ff1681548110610c0457610c046112a1565b6000918252602090912001546001600160a01b031603610c665760405162461bcd60e51b815260206004820152601760248201527f657874656e73696f6e20616c72656164792061646465640000000000000000006044820152606401610245565b80610c708161142f565b915050610bd3565b50610c8282610eb7565b6001908101805491820181556000908152602090200180546001600160a01b0319166001600160a01b0392909216919091179055565b600180546001600160a01b031916905561076981611037565b6001600160a01b03811615610ce957610ce981610a92565b6107fa82610bc1565b6000816001600160a01b03166389f8132e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610d32573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d5a919081019061144e565b905060008051602061152383398151915260005b82518161ffff161015610eb1576000838261ffff1681518110610d9357610d936112a1565b60200260200101519050610da78184610929565b6001600160a01b0316856001600160a01b031614610dc757610dc76114eb565b6000610dd38285611087565b84549091508490610de690600190611406565b81548110610df657610df66112a1565b90600052602060002001846000018261ffff1681548110610e1957610e196112a1565b600091825260209091208254910180546001600160a01b039092166001600160a01b031983168117825592546001600160c01b0319909216909217600160a01b9182900463ffffffff169091021790558354849080610e7a57610e7a611419565b600082815260209020810160001990810180546001600160c01b031916905501905550819050610ea981611501565b915050610d6e565b50505050565b6000816001600160a01b03166389f8132e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610ef7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610f1f919081019061144e565b60008051602061152383398151915280549192509060005b8351811015611030576000848281518110610f5457610f546112a1565b602002602001015190506000610f6a8286610929565b90506001600160a01b03811615610faf57604051632c18df3360e01b81526001600160e01b0319831660048201526001600160a01b0382166024820152604401610245565b604080518082019091526001600160a01b0380891682526001600160e01b0319841660208084019182528854600181018a5560008a815291909120935193018054915160e01c600160a01b026001600160c01b031990921693909216929092179190911790558361101f81611501565b94505060019092019150610f379050565b5050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b8054600090815b8161ffff168161ffff1610156110f857846001600160e01b031916846000018261ffff16815481106110c2576110c26112a1565b600091825260209091200154600160a01b900460e01b6001600160e01b031916036110f05791506105629050565b60010161108e565b5061ffff949350505050565b60006020828403121561111657600080fd5b5035919050565b6020808252825182820181905260009190848201906040850190845b8181101561115e5783516001600160a01b031683529284019291840191600101611139565b50909695505050505050565b6001600160a01b038116811461076957600080fd5b60006020828403121561119157600080fd5b813561119c8161116a565b9392505050565b600080604083850312156111b657600080fd5b82356111c18161116a565b915060208301356111d18161116a565b809150509250929050565b600080600080604085870312156111f257600080fd5b843567ffffffffffffffff8082111561120a57600080fd5b818701915087601f83011261121e57600080fd5b81358181111561122d57600080fd5b8860208260051b850101111561124257600080fd5b60209283019650945090860135908082111561125d57600080fd5b818701915087601f83011261127157600080fd5b81358181111561128057600080fd5b88602082850101111561129257600080fd5b95989497505060200194505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156112f6576112f66112b7565b604052919050565b600067ffffffffffffffff821115611318576113186112b7565b5060051b60200190565b6000602080838503121561133557600080fd5b825167ffffffffffffffff81111561134c57600080fd5b8301601f8101851361135d57600080fd5b805161137061136b826112fe565b6112cd565b81815260059190911b8201830190838101908783111561138f57600080fd5b928401925b828410156113b65783516113a78161116a565b82529284019290840190611394565b979650505050505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b634e487b7160e01b600052601160045260246000fd5b81810381811115610562576105626113f0565b634e487b7160e01b600052603160045260246000fd5b600060ff821660ff8103611445576114456113f0565b60010192915050565b6000602080838503121561146157600080fd5b825167ffffffffffffffff81111561147857600080fd5b8301601f8101851361148957600080fd5b805161149761136b826112fe565b81815260059190911b820183019083810190878311156114b657600080fd5b928401925b828410156113b65783516001600160e01b0319811681146114dc5760008081fd5b825292840192908401906114bb565b634e487b7160e01b600052600160045260246000fd5b600061ffff808316818103611518576115186113f0565b600101939250505056fe234c809385eaba7c8e68b2a08341f3988117f4f9fae0fac38df439aa440b2615a264697066735822122012bbbbcca2684f09d4af377240a3d2baccff5b5b317fb4926a0fbcb84570497a64736f6c63430008160033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101fb5760003560e01c80638787b17a1161011a578063d96880a8116100ad578063e69e24a81161007c578063e69e24a8146104bd578063ecf70858146104d0578063f2fde38b146104d9578063f62f1d53146104ec578063f9828cff14610515576101fb565b8063d96880a814610492578063daa671ac1461049b578063de7d4d6a146104a4578063e30c3978146104ac576101fb565b80639f3d0a48116100e95780639f3d0a4814610464578063a71933a71461046d578063ac11f2121461047f578063b542114c146102bb576101fb565b80638787b17a146103d057806389cd9855146103d95780638da5cb5b146103ec5780639af1d35a146103fd576101fb565b80636333d001116101925780637b103999116101615780637b1039991461036b5780637bb7bed11461037e5780637c7a561b146103915780637ecebe00146103b0576101fb565b80636333d0011461033d578063715018a6146103525780637985fd511461035a57806379ba509714610363576101fb565b806349d4139f116101ce57806349d4139f146102d45780634ef501ac146102dd5780634fa64598146103185780635641ec0314610320576101fb565b80630f25b764146102745780631e8410da146102a4578063338859f6146102bb57806346904840146102c1575b60006102126000356001600160e01b031916610548565b90506001600160a01b03811661024e57604051630a82dd7360e31b81526001600160e01b03196000351660048201526024015b60405180910390fd5b3660008037600080366000845af43d6000803e80801561026d573d6000f35b3d6000fd5b005b602a54610287906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102ad60045481565b60405190815260200161029b565b30610287565b600a54610287906001600160a01b031681565b6102ad60215481565b6102f06102eb366004611104565b610568565b604080516001600160a01b03909316835267ffffffffffffffff90911660208301520161029b565b61027261059a565b60265461032d9060ff1681565b604051901515815260200161029b565b610345610693565b60405161029b919061111d565b6102726106a2565b6102ad60275481565b6102726106f2565b602854610287906001600160a01b031681565b61028761038c366004611104565b61076c565b601f5461039e9060ff1681565b60405160ff909116815260200161029b565b6102ad6103be36600461117f565b60256020526000908152604090205481565b6102ad60205481565b6102726103e73660046111a3565b610796565b6000546001600160a01b0316610287565b6007546104309067ffffffffffffffff80821691600160401b8104821691600160801b8204811691600160c01b90041684565b6040805167ffffffffffffffff9586168152938516602085015291841691830191909152909116606082015260800161029b565b6102ad60065481565b601f5461039e90610100900460ff1681565b6102f061048d366004611104565b6107fe565b6102ad60095481565b6102ad60055481565b61039e600981565b6001546001600160a01b0316610287565b6102726104cb3660046111dc565b61080e565b6102ad60225481565b6102726104e736600461117f565b6108b8565b6102876104fa36600461117f565b6029602052600090815260409020546001600160a01b031681565b6008546104309067ffffffffffffffff80821691600160401b8104821691600160801b8204811691600160c01b90041684565b600061056282600080516020611523833981519152610929565b92915050565b600b81600a811061057857600080fd5b01546001600160a01b0381169150600160a01b900467ffffffffffffffff1682565b6105a26109c4565b60006105ac610a20565b905060005b81518110156105e4576105dc8282815181106105cf576105cf6112a1565b6020026020010151610a92565b6001016105b1565b5060285460405163d9d1764560e01b81523060048201526000916001600160a01b03169063d9d1764590602401600060405180830381865afa15801561062e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106569190810190611322565b905060005b815181101561068e57610686828281518110610679576106796112a1565b6020026020010151610bc1565b60010161065b565b505050565b606061069d610a20565b905090565b6106aa6109c4565b60405162461bcd60e51b815260206004820152601e60248201527f72656e6f756e6365206f776e657273686970206e6f7420616c6c6f77656400006044820152606401610245565b60015433906001600160a01b031681146107605760405162461bcd60e51b815260206004820152602960248201527f4f776e61626c6532537465703a2063616c6c6572206973206e6f7420746865206044820152683732bb9037bbb732b960b91b6064820152608401610245565b61076981610cb8565b50565b602b818154811061077c57600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b031633146107f05760405162461bcd60e51b815260206004820152601f60248201527f21756e617574686f72697a6564202d206e6f2061646d696e20726967687473006044820152606401610245565b6107fa8282610cd1565b5050565b601581600a811061057857600080fd5b6108166109c4565b60005b8381101561085a57610852858583818110610836576108366112a1565b905060200201602081019061084b919061117f565b6000610cd1565b600101610819565b5060405163439fab9160e01b8152309063439fab919061088090859085906004016113c1565b600060405180830381600087803b15801561089a57600080fd5b505af11580156108ae573d6000803e3d6000fd5b5050505050505050565b6108c06109c4565b600180546001600160a01b0383166001600160a01b031990911681179091556108f16000546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b8054600090815b818110156109b957846001600160e01b031916846000018281548110610958576109586112a1565b600091825260209091200154600160a01b900460e01b6001600160e01b031916036109b157836000018181548110610992576109926112a1565b6000918252602090912001546001600160a01b03169250610562915050565b600101610930565b506000949350505050565b6000546001600160a01b03163314610a1e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610245565b565b6060600080516020611523833981519152600101805480602002602001604051908101604052809291908181526020018280548015610a8857602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610a6a575b5050505050905090565b600080516020611523833981519152610aaa82610cf2565b60005b600182015460ff8216101561068e57826001600160a01b0316826001018260ff1681548110610ade57610ade6112a1565b6000918252602090912001546001600160a01b031603610baf57600180830180549091610b0a91611406565b81548110610b1a57610b1a6112a1565b6000918252602090912001546001830180546001600160a01b039092169160ff8416908110610b4b57610b4b6112a1565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b0316021790555081600101805480610b8c57610b8c611419565b600082815260209020810160001990810180546001600160a01b03191690550190555b80610bb98161142f565b915050610aad565b60008051602061152383398151915260005b600182015460ff82161015610c7857826001600160a01b0316826001018260ff1681548110610c0457610c046112a1565b6000918252602090912001546001600160a01b031603610c665760405162461bcd60e51b815260206004820152601760248201527f657874656e73696f6e20616c72656164792061646465640000000000000000006044820152606401610245565b80610c708161142f565b915050610bd3565b50610c8282610eb7565b6001908101805491820181556000908152602090200180546001600160a01b0319166001600160a01b0392909216919091179055565b600180546001600160a01b031916905561076981611037565b6001600160a01b03811615610ce957610ce981610a92565b6107fa82610bc1565b6000816001600160a01b03166389f8132e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610d32573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d5a919081019061144e565b905060008051602061152383398151915260005b82518161ffff161015610eb1576000838261ffff1681518110610d9357610d936112a1565b60200260200101519050610da78184610929565b6001600160a01b0316856001600160a01b031614610dc757610dc76114eb565b6000610dd38285611087565b84549091508490610de690600190611406565b81548110610df657610df66112a1565b90600052602060002001846000018261ffff1681548110610e1957610e196112a1565b600091825260209091208254910180546001600160a01b039092166001600160a01b031983168117825592546001600160c01b0319909216909217600160a01b9182900463ffffffff169091021790558354849080610e7a57610e7a611419565b600082815260209020810160001990810180546001600160c01b031916905501905550819050610ea981611501565b915050610d6e565b50505050565b6000816001600160a01b03166389f8132e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610ef7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610f1f919081019061144e565b60008051602061152383398151915280549192509060005b8351811015611030576000848281518110610f5457610f546112a1565b602002602001015190506000610f6a8286610929565b90506001600160a01b03811615610faf57604051632c18df3360e01b81526001600160e01b0319831660048201526001600160a01b0382166024820152604401610245565b604080518082019091526001600160a01b0380891682526001600160e01b0319841660208084019182528854600181018a5560008a815291909120935193018054915160e01c600160a01b026001600160c01b031990921693909216929092179190911790558361101f81611501565b94505060019092019150610f379050565b5050505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b8054600090815b8161ffff168161ffff1610156110f857846001600160e01b031916846000018261ffff16815481106110c2576110c26112a1565b600091825260209091200154600160a01b900460e01b6001600160e01b031916036110f05791506105629050565b60010161108e565b5061ffff949350505050565b60006020828403121561111657600080fd5b5035919050565b6020808252825182820181905260009190848201906040850190845b8181101561115e5783516001600160a01b031683529284019291840191600101611139565b50909695505050505050565b6001600160a01b038116811461076957600080fd5b60006020828403121561119157600080fd5b813561119c8161116a565b9392505050565b600080604083850312156111b657600080fd5b82356111c18161116a565b915060208301356111d18161116a565b809150509250929050565b600080600080604085870312156111f257600080fd5b843567ffffffffffffffff8082111561120a57600080fd5b818701915087601f83011261121e57600080fd5b81358181111561122d57600080fd5b8860208260051b850101111561124257600080fd5b60209283019650945090860135908082111561125d57600080fd5b818701915087601f83011261127157600080fd5b81358181111561128057600080fd5b88602082850101111561129257600080fd5b95989497505060200194505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156112f6576112f66112b7565b604052919050565b600067ffffffffffffffff821115611318576113186112b7565b5060051b60200190565b6000602080838503121561133557600080fd5b825167ffffffffffffffff81111561134c57600080fd5b8301601f8101851361135d57600080fd5b805161137061136b826112fe565b6112cd565b81815260059190911b8201830190838101908783111561138f57600080fd5b928401925b828410156113b65783516113a78161116a565b82529284019290840190611394565b979650505050505050565b60208152816020820152818360408301376000818301604090810191909152601f909201601f19160101919050565b634e487b7160e01b600052601160045260246000fd5b81810381811115610562576105626113f0565b634e487b7160e01b600052603160045260246000fd5b600060ff821660ff8103611445576114456113f0565b60010192915050565b6000602080838503121561146157600080fd5b825167ffffffffffffffff81111561147857600080fd5b8301601f8101851361148957600080fd5b805161149761136b826112fe565b81815260059190911b820183019083810190878311156114b657600080fd5b928401925b828410156113b65783516001600160e01b0319811681146114dc5760008081fd5b825292840192908401906114bb565b634e487b7160e01b600052600160045260246000fd5b600061ffff808316818103611518576115186113f0565b600101939250505056fe234c809385eaba7c8e68b2a08341f3988117f4f9fae0fac38df439aa440b2615a264697066735822122012bbbbcca2684f09d4af377240a3d2baccff5b5b317fb4926a0fbcb84570497a64736f6c63430008160033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_registerExtension(address,address)": {
        "details": "register a logic extension",
        "params": {
          "extensionToAdd": "the extension whose functions are to be added",
          "extensionToReplace": "the extension whose functions are to be removed/replaced"
        }
      },
      "acceptOwnership()": {
        "details": "The new owner accepts the ownership transfer."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "pendingOwner()": {
        "details": "Returns the address of the pending owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 120,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "_pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 58818,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "_decimals",
        "offset": 20,
        "slot": "1",
        "type": "t_uint8"
      },
      {
        "astId": 58820,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "_name",
        "offset": 0,
        "slot": "2",
        "type": "t_string_storage"
      },
      {
        "astId": 58822,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "_symbol",
        "offset": 0,
        "slot": "3",
        "type": "t_string_storage"
      },
      {
        "astId": 58824,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "highWaterMark",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 58826,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "assetsCheckpoint",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 58828,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "feesUpdatedAt",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 58831,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "fees",
        "offset": 0,
        "slot": "7",
        "type": "t_struct(VaultFees)54285_storage"
      },
      {
        "astId": 58834,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "proposedFees",
        "offset": 0,
        "slot": "8",
        "type": "t_struct(VaultFees)54285_storage"
      },
      {
        "astId": 58836,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "proposedFeeTime",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 58838,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "feeRecipient",
        "offset": 0,
        "slot": "10",
        "type": "t_address"
      },
      {
        "astId": 58843,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "adapters",
        "offset": 0,
        "slot": "11",
        "type": "t_array(t_struct(AdapterConfig)58808_storage)10_storage"
      },
      {
        "astId": 58848,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "proposedAdapters",
        "offset": 0,
        "slot": "21",
        "type": "t_array(t_struct(AdapterConfig)58808_storage)10_storage"
      },
      {
        "astId": 58850,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "adaptersCount",
        "offset": 0,
        "slot": "31",
        "type": "t_uint8"
      },
      {
        "astId": 58852,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "proposedAdaptersCount",
        "offset": 1,
        "slot": "31",
        "type": "t_uint8"
      },
      {
        "astId": 58854,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "proposedAdapterTime",
        "offset": 0,
        "slot": "32",
        "type": "t_uint256"
      },
      {
        "astId": 58856,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "quitPeriod",
        "offset": 0,
        "slot": "33",
        "type": "t_uint256"
      },
      {
        "astId": 58858,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "depositLimit",
        "offset": 0,
        "slot": "34",
        "type": "t_uint256"
      },
      {
        "astId": 58860,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "INITIAL_CHAIN_ID",
        "offset": 0,
        "slot": "35",
        "type": "t_uint256"
      },
      {
        "astId": 58862,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "INITIAL_DOMAIN_SEPARATOR",
        "offset": 0,
        "slot": "36",
        "type": "t_bytes32"
      },
      {
        "astId": 58866,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "nonces",
        "offset": 0,
        "slot": "37",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 58868,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "emergencyExit",
        "offset": 0,
        "slot": "38",
        "type": "t_bool"
      },
      {
        "astId": 58870,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "withdrawalThreshold",
        "offset": 0,
        "slot": "39",
        "type": "t_uint256"
      },
      {
        "astId": 58873,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "registry",
        "offset": 0,
        "slot": "40",
        "type": "t_contract(OptimizedVaultsRegistry)59585"
      },
      {
        "astId": 58879,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "flywheelForRewardToken",
        "offset": 0,
        "slot": "41",
        "type": "t_mapping(t_contract(IERC20Upgradeable)179087,t_contract(IonicFlywheel)50256)"
      },
      {
        "astId": 58881,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "flywheelLogic",
        "offset": 0,
        "slot": "42",
        "type": "t_address"
      },
      {
        "astId": 58885,
        "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
        "label": "rewardTokens",
        "offset": 0,
        "slot": "43",
        "type": "t_array(t_contract(IERC20Upgradeable)179087)dyn_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_contract(IERC20Upgradeable)179087)dyn_storage": {
        "base": "t_contract(IERC20Upgradeable)179087",
        "encoding": "dynamic_array",
        "label": "contract IERC20Upgradeable[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(AdapterConfig)58808_storage)10_storage": {
        "base": "t_struct(AdapterConfig)58808_storage",
        "encoding": "inplace",
        "label": "struct AdapterConfig[10]",
        "numberOfBytes": "320"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(CompoundMarketERC4626)48585": {
        "encoding": "inplace",
        "label": "contract CompoundMarketERC4626",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20Upgradeable)179087": {
        "encoding": "inplace",
        "label": "contract IERC20Upgradeable",
        "numberOfBytes": "20"
      },
      "t_contract(IonicFlywheel)50256": {
        "encoding": "inplace",
        "label": "contract IonicFlywheel",
        "numberOfBytes": "20"
      },
      "t_contract(OptimizedVaultsRegistry)59585": {
        "encoding": "inplace",
        "label": "contract OptimizedVaultsRegistry",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(IERC20Upgradeable)179087,t_contract(IonicFlywheel)50256)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20Upgradeable)179087",
        "label": "mapping(contract IERC20Upgradeable => contract IonicFlywheel)",
        "numberOfBytes": "32",
        "value": "t_contract(IonicFlywheel)50256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(AdapterConfig)58808_storage": {
        "encoding": "inplace",
        "label": "struct AdapterConfig",
        "members": [
          {
            "astId": 58805,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "adapter",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(CompoundMarketERC4626)48585"
          },
          {
            "astId": 58807,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "allocation",
            "offset": 20,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(VaultFees)54285_storage": {
        "encoding": "inplace",
        "label": "struct VaultFees",
        "members": [
          {
            "astId": 54278,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "deposit",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 54280,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "withdrawal",
            "offset": 8,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 54282,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "management",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 54284,
            "contract": "contracts/ionic/vault/OptimizedAPRVaultBase.sol:OptimizedAPRVaultBase",
            "label": "performance",
            "offset": 24,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}