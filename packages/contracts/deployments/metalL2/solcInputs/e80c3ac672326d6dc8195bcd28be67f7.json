{
  "language": "Solidity",
  "sources": {
    "@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any (single) token transfer. This includes minting and burning.\n     * See {_beforeConsecutiveTokenTransfer}.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any (single) transfer of tokens. This includes minting and burning.\n     * See {_afterConsecutiveTokenTransfer}.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called before \"consecutive token transfers\" as defined in ERC2309 and implemented in\n     * {ERC721Consecutive}.\n     * Calling conditions are similar to {_beforeTokenTransfer}.\n     */\n    function _beforeConsecutiveTokenTransfer(\n        address from,\n        address to,\n        uint256, /*first*/\n        uint96 size\n    ) internal virtual {\n        if (from != address(0)) {\n            _balances[from] -= size;\n        }\n        if (to != address(0)) {\n            _balances[to] += size;\n        }\n    }\n\n    /**\n     * @dev Hook that is called after \"consecutive token transfers\" as defined in ERC2309 and implemented in\n     * {ERC721Consecutive}.\n     * Calling conditions are similar to {_afterTokenTransfer}.\n     */\n    function _afterConsecutiveTokenTransfer(\n        address, /*from*/\n        address, /*to*/\n        uint256, /*first*/\n        uint96 /*size*/\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2Upgradeable {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "adrastia-periphery/rates/IHistoricalRates.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./RateLibrary.sol\";\n\n/**\n * @title IHistoricalRates\n * @notice An interface that defines a contract that stores historical rates.\n */\ninterface IHistoricalRates {\n    /// @notice Gets an rate for a token at a specific index.\n    /// @param token The address of the token to get the rates for.\n    /// @param index The index of the rate to get, where index 0 contains the latest rate, and the last\n    ///   index contains the oldest rate (uses reverse chronological ordering).\n    /// @return rate The rate for the token at the specified index.\n    function getRateAt(address token, uint256 index) external view returns (RateLibrary.Rate memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(address token, uint256 amount) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @param offset The index of the first rate to get (default: 0).\n    /// @param increment The increment between rates to get (default: 1).\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(\n        address token,\n        uint256 amount,\n        uint256 offset,\n        uint256 increment\n    ) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the number of rates for a token.\n    /// @param token The address of the token to get the number of rates for.\n    /// @return count The number of rates for the token.\n    function getRatesCount(address token) external view returns (uint256);\n\n    /// @notice Gets the capacity of rates for a token.\n    /// @param token The address of the token to get the capacity of rates for.\n    /// @return capacity The capacity of rates for the token.\n    function getRatesCapacity(address token) external view returns (uint256);\n\n    /// @notice Sets the capacity of rates for a token.\n    /// @param token The address of the token to set the capacity of rates for.\n    /// @param amount The new capacity of rates for the token.\n    function setRatesCapacity(address token, uint256 amount) external;\n}\n"
    },
    "adrastia-periphery/rates/RateLibrary.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nlibrary RateLibrary {\n    struct Rate {\n        uint64 target;\n        uint64 current;\n        uint32 timestamp;\n    }\n}\n"
    },
    "contracts/adrastia/PrudentiaLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nlibrary PrudentiaLib {\n  struct PrudentiaConfig {\n    address controller; // Adrastia Prudentia controller address\n    uint8 offset; // Offset for delayed rate activation\n    int8 decimalShift; // Positive values scale the rate up (in powers of 10), negative values scale the rate down\n  }\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint256 c;\n    unchecked {\n      c = a * b;\n    }\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    uint256 c;\n    unchecked {\n      c = a + b;\n    }\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (MathError, uint256) {\n    (MathError err0, uint256 sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n}\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { ComptrollerErrorReporter } from \"./ErrorReporter.sol\";\nimport { Exponential } from \"./Exponential.sol\";\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\nimport { Unitroller } from \"./Unitroller.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\nimport { IIonicFlywheel } from \"../ionic/strategies/flywheel/IIonicFlywheel.sol\";\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerExtensionInterface, ComptrollerBase, ComptrollerInterface } from \"./ComptrollerInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerBase, ComptrollerInterface, ComptrollerErrorReporter, Exponential, DiamondExtension {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(ICErc20 cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(ICErc20 cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(ICErc20 cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(ICErc20 cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(BasePriceOracle oldPriceOracle, BasePriceOracle newPriceOracle);\n\n  /// @notice Emitted when the whitelist enforcement is changed\n  event WhitelistEnforcementChanged(bool enforce);\n\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n  event AddedRewardsDistributor(address rewardsDistributor);\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  // liquidationIncentiveMantissa must be no less than this value\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n  // liquidationIncentiveMantissa must be no greater than this value\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n  modifier isAuthorized() {\n    require(IFeeDistributor(ionicAdmin).canCall(address(this), msg.sender, address(this), msg.sig), \"not authorized\");\n    _;\n  }\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(\n    address cToken\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 supplyCap) {\n    return ComptrollerBase.effectiveSupplyCaps(cToken);\n  }\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(\n    address cToken\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 borrowCap) {\n    return ComptrollerBase.effectiveBorrowCaps(cToken);\n  }\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n   * @param account The address of the account to pull assets for\n   * @return A dynamic list with the assets the account has entered\n   */\n  function getAssetsIn(address account) external view returns (ICErc20[] memory) {\n    ICErc20[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n   * @param account The address of the account to check\n   * @param cToken The cToken to check\n   * @return True if the account is in the asset, otherwise false.\n   */\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n   * @param cTokens The list of addresses of the cToken markets to be enabled\n   * @return Success indicator for whether each corresponding market was entered\n   */\n  function enterMarkets(address[] memory cTokens) public override isAuthorized returns (uint256[] memory) {\n    uint256 len = cTokens.length;\n\n    uint256[] memory results = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      ICErc20 cToken = ICErc20(cTokens[i]);\n\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n   * @param cToken The market to enter\n   * @param borrower The address of the account to modify\n   * @return Success indicator for whether the market was entered\n   */\n  function addToMarketInternal(ICErc20 cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    // Add to allBorrowers\n    if (!borrowers[borrower]) {\n      allBorrowers.push(borrower);\n      borrowers[borrower] = true;\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\n    }\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n   * @dev Sender must not have an outstanding borrow balance in the asset,\n   *  or be providing necessary collateral for an outstanding borrow.\n   * @param cTokenAddress The address of the asset to be removed\n   * @return Whether or not the account successfully exited the market\n   */\n  function exitMarket(address cTokenAddress) external override isAuthorized returns (uint256) {\n    // TODO\n    require(markets[cTokenAddress].isListed, \"!Comptroller:exitMarket\");\n\n    ICErc20 cToken = ICErc20(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"!exitMarket\"); // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[cTokenAddress];\n\n    /* Return true if the sender is not already in the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the accounts list of assets */\n    // load into memory for faster iteration\n    ICErc20[] memory userAssetList = accountAssets[msg.sender];\n    uint256 len = userAssetList.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (userAssetList[i] == ICErc20(cTokenAddress)) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    ICErc20[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    // If the user has exited all markets, remove them from the `allBorrowers` array\n    if (storedList.length == 0) {\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n      allBorrowers.pop(); // Reduce length by 1\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n    }\n\n    emit MarketExited(ICErc20(cTokenAddress), msg.sender);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n   * @param cTokenAddress The market to verify the mint against\n   * @param minter The account which would get the minted tokens\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function mintAllowed(address cTokenAddress, address minter, uint256 mintAmount) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cTokenAddress], \"!mint:paused\");\n\n    // Make sure market is listed\n    if (!markets[cTokenAddress].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure minter is whitelisted\n    if (enforceWhitelist && !whitelist[minter]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    uint256 supplyCap = effectiveSupplyCaps(cTokenAddress);\n\n    // Supply cap of 0 corresponds to unlimited supplying\n    if (supplyCap != 0 && !supplyCapWhitelist[cTokenAddress].contains(minter)) {\n      uint256 totalUnderlyingSupply = ICErc20(cTokenAddress).getTotalUnderlyingSupplied();\n      uint256 whitelistedSuppliersSupply = asComptrollerExtension().getWhitelistedSuppliersSupply(cTokenAddress);\n      uint256 nonWhitelistedTotalSupply;\n      if (whitelistedSuppliersSupply >= totalUnderlyingSupply) nonWhitelistedTotalSupply = 0;\n      else nonWhitelistedTotalSupply = totalUnderlyingSupply - whitelistedSuppliersSupply;\n\n      require(nonWhitelistedTotalSupply + mintAmount < supplyCap, \"!supply cap\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cTokenAddress, minter);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n   * @param cToken The market to verify the redeem against\n   * @param redeemer The account which would redeem the tokens\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external override returns (uint256) {\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, redeemer);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) internal view returns (uint256) {\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      redeemer,\n      ICErc20(cToken),\n      redeemTokens,\n      0,\n      0\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n   * @param cToken Asset being minted\n   * @param minter The address minting the tokens\n   * @param actualMintAmount The amount of the underlying asset being minted\n   * @param mintTokens The number of tokens being minted\n   */\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n    // Add minter to suppliers mapping\n    suppliers[minter] = true;\n\n    // Keep the flywheel moving\n    flywheelPostSupplierAction(cToken, minter);\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n   * @param cToken Asset being redeemed\n   * @param redeemer The address redeeming the tokens\n   * @param redeemAmount The amount of the underlying asset being redeemed\n   * @param redeemTokens The number of tokens being redeemed\n   */\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external override {\n    require(markets[msg.sender].isListed, \"!market\");\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"!zero\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPostSupplierAction(cToken, redeemer);\n  }\n\n  function getMaxRedeemOrBorrow(\n    address account,\n    ICErc20 cTokenModify,\n    bool isBorrow\n  ) external view override returns (uint256) {\n    address cToken = address(cTokenModify);\n    // Accrue interest\n    uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n\n    // Get account liquidity\n    (Error err, , uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      isBorrow ? cTokenModify : ICErc20(address(0)),\n      0,\n      0,\n      0\n    );\n    require(err == Error.NO_ERROR, \"!liquidity\");\n    if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\n\n    // Get max borrow/redeem\n    uint256 maxBorrowOrRedeemAmount;\n\n    if (!isBorrow && !markets[cToken].accountMembership[account]) {\n      // Max redeem = balance of underlying if not used as collateral\n      maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    } else {\n      // Avoid \"stack too deep\" error by separating this logic\n      maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\n\n      // Redeem only: max out at underlying balance\n      if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    }\n\n    // Get max borrow or redeem considering cToken liquidity\n    uint256 cTokenLiquidity = cTokenModify.getCash();\n\n    // Return the minimum of the two maximums\n    return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\n  }\n\n  /**\n   * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\n   */\n  function _getMaxRedeemOrBorrow(\n    uint256 liquidity,\n    ICErc20 cTokenModify,\n    bool isBorrow\n  ) internal view returns (uint256) {\n    if (liquidity == 0) return 0; // No available account liquidity, so no more borrow/redeem\n\n    // Get the normalized price of the asset\n    uint256 conversionFactor = oracle.getUnderlyingPrice(cTokenModify);\n    require(conversionFactor > 0, \"!oracle\");\n\n    // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n    if (!isBorrow) {\n      uint256 collateralFactorMantissa = markets[address(cTokenModify)].collateralFactorMantissa;\n      conversionFactor = (collateralFactorMantissa * conversionFactor) / 1e18;\n    }\n\n    // Get max borrow or redeem considering excess account liquidity\n    return (liquidity * 1e18) / conversionFactor;\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken The market to verify the borrow against\n   * @param borrower The account which would borrow the asset\n   * @param borrowAmount The amount of underlying the account would borrow\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"!borrow:paused\");\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"!ctoken\");\n\n      // attempt to add borrower to the market\n      Error err = addToMarketInternal(ICErc20(msg.sender), borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    // Make sure oracle price is available\n    if (oracle.getUnderlyingPrice(ICErc20(cToken)) == 0) {\n      return uint256(Error.PRICE_ERROR);\n    }\n\n    // Make sure borrower is whitelisted\n    if (enforceWhitelist && !whitelist[borrower]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    uint256 borrowCap = effectiveBorrowCaps(cToken);\n\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0 && !borrowCapWhitelist[cToken].contains(borrower)) {\n      uint256 totalBorrows = ICErc20(cToken).totalBorrowsCurrent();\n      uint256 whitelistedBorrowersBorrows = asComptrollerExtension().getWhitelistedBorrowersBorrows(cToken);\n      uint256 nonWhitelistedTotalBorrows;\n      if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\n      else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\n\n      require(nonWhitelistedTotalBorrows + borrowAmount < borrowCap, \"!borrow:cap\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    // Perform a hypothetical liquidity check to guard against shortfall\n    (uint256 err, , , uint256 shortfall) = this.getHypotheticalAccountLiquidity(borrower, cToken, 0, borrowAmount, 0);\n    if (err != uint256(Error.NO_ERROR)) {\n      return err;\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates borrow the underlying asset of the given market\n   * @param cToken The market to verify the borrow against\n   * @param borrower The account which borrowed the asset\n   */\n  function borrowVerify(address cToken, address borrower) external override {\n    // Keep the flywheel moving\n    flywheelPostBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n   */\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view override returns (uint256) {\n    // Check if min borrow exists\n    uint256 minBorrowEth = IFeeDistributor(ionicAdmin).minBorrowEth();\n\n    if (minBorrowEth > 0) {\n      // Get new underlying borrow balance of account for this cToken\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(ICErc20(cToken));\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\n        Exp({ mantissa: oraclePriceMantissa }),\n        accountBorrowsNew\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      // Check against min borrow\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\n    }\n\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n   * @param cToken The market to verify the repay against\n   * @param payer The account which would repay the asset\n   * @param borrower The account which would borrowed the asset\n   * @param repayAmount The amount of the underlying asset the account would repay\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates that blacklisted balances are updated after borrow repayment\n   * @param cToken The market to verify the repay against\n   * @param payer The account which repayed the asset\n   * @param borrower The account which borrowed the asset\n   * @param repayAmount The amount of the underlying asset the account repayed\n   */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external override {\n    // Keep the flywheel moving\n    flywheelPostBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Make sure markets are listed\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Get borrowers' underlying borrow balance\n    uint256 borrowBalance = ICErc20(cTokenBorrowed).borrowBalanceCurrent(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(ICErc20(cTokenBorrowed))) {\n      require(borrowBalance >= repayAmount, \"!borrow>repay\");\n    } else {\n      /* The borrower must have shortfall in order to be liquidateable */\n      (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n        borrower,\n        ICErc20(address(0)),\n        0,\n        0,\n        0\n      );\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      if (shortfall == 0) {\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n      if (repayAmount > maxClose) {\n        return uint256(Error.TOO_MUCH_REPAY);\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"!seize:paused\");\n\n    // Make sure markets are listed\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure cToken Comptrollers are identical\n    if (ICErc20(cTokenCollateral).comptroller() != ICErc20(cTokenBorrowed).comptroller()) {\n      return uint256(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates that blacklisted balances are updated after seizing of assets\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override {\n    // Keep the flywheel moving\n    flywheelPostTransferAction(cTokenCollateral, borrower, liquidator);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n   * @param cToken The market to verify the transfer against\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"!transfer:paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cToken, src, dst);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n\n  /**\n   * @notice Validates that blacklisted balances are updated after transfering assets\n   * @param cToken The market to verify the transfer against\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   */\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override {\n\n    // Keep the flywheel moving\n    flywheelPostTransferAction(cToken, src, dst);\n  }\n\n  /*** Flywheel Hooks ***/\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving post-mint and post-redeem\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPostSupplierAction(address cToken, address supplier) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostSupplierAction(cToken, supplier);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving post-borrow and post-repay\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPostBorrowerAction(address cToken, address borrower) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(address cToken, address src, address dst) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving post-transfer and post-seize\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPostTransferAction(address cToken, address src, address dst) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostTransferAction(cToken, src, dst);\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n   */\n  struct AccountLiquidityLocalVars {\n    ICErc20 asset;\n    uint256 sumCollateral;\n    uint256 sumBorrowPlusEffects;\n    uint256 cTokenBalance;\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n    uint256 oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n    uint256 borrowCapForCollateral;\n    uint256 borrowedAssetPrice;\n    uint256 assetAsCollateralValueCap;\n  }\n\n  function getAccountLiquidity(address account) public view override returns (uint256, uint256, uint256, uint256) {\n    (\n      Error err,\n      uint256 collateralValue,\n      uint256 liquidity,\n      uint256 shortfall\n    ) = getHypotheticalAccountLiquidityInternal(account, ICErc20(address(0)), 0, 0, 0);\n    return (uint256(err), collateralValue, liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) public view returns (uint256, uint256, uint256, uint256) {\n    (\n      Error err,\n      uint256 collateralValue,\n      uint256 liquidity,\n      uint256 shortfall\n    ) = getHypotheticalAccountLiquidityInternal(\n        account,\n        ICErc20(cTokenModify),\n        redeemTokens,\n        borrowAmount,\n        repayAmount\n      );\n    return (uint256(err), collateralValue, liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code,\n                hypothetical account collateral value,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    ICErc20 cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) internal view returns (Error, uint256, uint256, uint256) {\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n\n    if (address(cTokenModify) != address(0)) {\n      vars.borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\n    }\n\n    // For each asset the account is in\n    for (uint256 i = 0; i < accountAssets[account].length; i++) {\n      vars.asset = accountAssets[account][i];\n\n      {\n        // Read the balances and exchange rate from the cToken\n        uint256 oErr;\n        (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vars.asset.getAccountSnapshot(\n          account\n        );\n        if (oErr != 0) {\n          // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n          return (Error.SNAPSHOT_ERROR, 0, 0, 0);\n        }\n      }\n      {\n        vars.collateralFactor = Exp({ mantissa: markets[address(vars.asset)].collateralFactorMantissa });\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n        // Get the normalized price of the asset\n        vars.oraclePriceMantissa = oracle.getUnderlyingPrice(vars.asset);\n        if (vars.oraclePriceMantissa == 0) {\n          return (Error.PRICE_ERROR, 0, 0, 0);\n        }\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n      }\n      {\n        // Exclude the asset-to-be-borrowed from the liquidity, except for when redeeming\n        vars.assetAsCollateralValueCap = asComptrollerExtension().getAssetAsCollateralValueCap(\n          vars.asset,\n          cTokenModify,\n          redeemTokens > 0,\n          account\n        );\n\n        // accumulate the collateral value to sumCollateral\n        uint256 assetCollateralValue = mul_ScalarTruncate(vars.tokensToDenom, vars.cTokenBalance);\n        if (assetCollateralValue > vars.assetAsCollateralValueCap)\n          assetCollateralValue = vars.assetAsCollateralValueCap;\n        vars.sumCollateral += assetCollateralValue;\n      }\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n        vars.oraclePrice,\n        vars.borrowBalance,\n        vars.sumBorrowPlusEffects\n      );\n\n      // Calculate effects of interacting with cTokenModify\n      if (vars.asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.tokensToDenom,\n          redeemTokens,\n          vars.sumBorrowPlusEffects\n        );\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.oraclePrice,\n          borrowAmount,\n          vars.sumBorrowPlusEffects\n        );\n\n        uint256 repayEffect = mul_ScalarTruncate(vars.oraclePrice, repayAmount);\n        if (repayEffect >= vars.sumBorrowPlusEffects) {\n          vars.sumBorrowPlusEffects = 0;\n        } else {\n          vars.sumBorrowPlusEffects -= repayEffect;\n        }\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, vars.sumCollateral, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n   * @param cTokenBorrowed The address of the borrowed cToken\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view override returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenBorrowed));\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint256(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    ICErc20 collateralCToken = ICErc20(cTokenCollateral);\n    uint256 exchangeRateMantissa = collateralCToken.exchangeRateCurrent();\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    uint256 protocolSeizeShareMantissa = collateralCToken.protocolSeizeShareMantissa();\n    uint256 feeSeizeShareMantissa = collateralCToken.feeSeizeShareMantissa();\n\n    /*\n     * The liquidation penalty includes\n     * - the liquidator incentive\n     * - the protocol fees (Ionic admin fees)\n     * - the market fee\n     */\n    Exp memory totalPenaltyMantissa = add_(\n      add_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: protocolSeizeShareMantissa })),\n      Exp({ mantissa: feeSeizeShareMantissa })\n    );\n\n    numerator = mul_(totalPenaltyMantissa, Exp({ mantissa: priceBorrowedMantissa }));\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n    return (uint256(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Add a RewardsDistributor contracts.\n   * @dev Admin function to add a RewardsDistributor contract\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\n    require(hasAdminRights(), \"!admin\");\n\n    // Check marker method\n    require(IIonicFlywheel(distributor).isRewardsDistributor(), \"!isRewardsDistributor\");\n\n    // Check for existing RewardsDistributor\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) require(distributor != rewardsDistributors[i], \"!added\");\n\n    // Add RewardsDistributor to array\n    rewardsDistributors.push(distributor);\n    emit AddedRewardsDistributor(distributor);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist enforcement for the comptroller\n   * @dev Admin function to set a new whitelist enforcement boolean\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\n    }\n\n    // Check if `enforceWhitelist` already equals `enforce`\n    if (enforceWhitelist == enforce) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    // Set comptroller's `enforceWhitelist` to `enforce`\n    enforceWhitelist = enforce;\n\n    // Emit WhitelistEnforcementChanged(bool enforce);\n    emit WhitelistEnforcementChanged(enforce);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist `statuses` for `suppliers`\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\n    }\n\n    // Set whitelist statuses for suppliers\n    for (uint256 i = 0; i < suppliers.length; i++) {\n      address supplier = suppliers[i];\n\n      if (statuses[i]) {\n        // If not already whitelisted, add to whitelist\n        if (!whitelist[supplier]) {\n          whitelist[supplier] = true;\n          whitelistArray.push(supplier);\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\n        }\n      } else {\n        // If whitelisted, remove from whitelist\n        if (whitelist[supplier]) {\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\n          whitelistArray.pop(); // Reduce length by 1\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n        }\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets a new price oracle for the comptroller\n   * @dev Admin function to set a new price oracle\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPriceOracle(BasePriceOracle newOracle) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    BasePriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the closeFactor used when liquidating borrows\n   * @dev Admin function to set closeFactor\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n    }\n\n    // Check limits\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    // Set pool close factor to new close factor, remember old value\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n\n    // Emit event\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the collateralFactor for a market\n   * @dev Admin function to set per-market collateralFactor\n   * @param cToken The market to set the factor on\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCollateralFactor(ICErc20 cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets liquidationIncentive\n   * @dev Admin function to set liquidationIncentive\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Check de-scaled min <= newLiquidationIncentive <= max\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    // Save current value for use in log\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Add the market to the markets mapping and set it as listed\n   * @dev Admin function to set isListed and add support for the market\n   * @param cToken The address of the market (token) to list\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _supportMarket(ICErc20 cToken) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Is market already listed?\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // Check cToken.comptroller == this\n    require(address(cToken.comptroller()) == address(this), \"!comptroller\");\n\n    // Make sure market is not already listed\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // List market and emit event\n    Market storage market = markets[address(cToken)];\n    market.isListed = true;\n    market.collateralFactorMantissa = 0;\n    allMarkets.push(cToken);\n    cTokensByUnderlying[underlying] = cToken;\n    emit MarketListed(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _deployMarket(\n    uint8 delegateType,\n    bytes calldata constructorData,\n    bytes calldata becomeImplData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Temporarily enable Ionic admin rights for asset deployment (storing the original value)\n    bool oldIonicAdminHasRights = ionicAdminHasRights;\n    ionicAdminHasRights = true;\n\n    // Deploy via Ionic admin\n    ICErc20 cToken = ICErc20(IFeeDistributor(ionicAdmin).deployCErc20(delegateType, constructorData, becomeImplData));\n    // Reset Ionic admin rights to the original value\n    ionicAdminHasRights = oldIonicAdminHasRights;\n    // Support market here in the Comptroller\n    uint256 err = _supportMarket(cToken);\n\n    IFeeDistributor(ionicAdmin).authoritiesRegistry().reconfigureAuthority(address(this));\n\n    // Set collateral factor\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\n  }\n\n  function _becomeImplementation() external {\n    require(msg.sender == address(this), \"!self call\");\n\n    if (!_notEnteredInitialized) {\n      _notEntered = true;\n      _notEnteredInitialized = true;\n    }\n  }\n\n  /*** Helper Functions ***/\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   * @param cToken The market to check if deprecated\n   */\n  function isDeprecated(ICErc20 cToken) public view returns (bool) {\n    return\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\n      borrowGuardianPaused[address(cToken)] == true &&\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.ionicFeeMantissa()) == 1e18;\n  }\n\n  function asComptrollerExtension() internal view returns (ComptrollerExtensionInterface) {\n    return ComptrollerExtensionInterface(address(this));\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 36;\n\n    functionSelectors = new bytes4[](fnsCount);\n\n    functionSelectors[--fnsCount] = this.isDeprecated.selector;\n    functionSelectors[--fnsCount] = this._deployMarket.selector;\n    functionSelectors[--fnsCount] = this.getAssetsIn.selector;\n    functionSelectors[--fnsCount] = this.checkMembership.selector;\n    functionSelectors[--fnsCount] = this._setPriceOracle.selector;\n    functionSelectors[--fnsCount] = this._setCloseFactor.selector;\n    functionSelectors[--fnsCount] = this._setCollateralFactor.selector;\n    functionSelectors[--fnsCount] = this._setLiquidationIncentive.selector;\n    functionSelectors[--fnsCount] = this._setWhitelistEnforcement.selector;\n    functionSelectors[--fnsCount] = this._setWhitelistStatuses.selector;\n    functionSelectors[--fnsCount] = this._addRewardsDistributor.selector;\n    functionSelectors[--fnsCount] = this.getHypotheticalAccountLiquidity.selector;\n    functionSelectors[--fnsCount] = this.getMaxRedeemOrBorrow.selector;\n    functionSelectors[--fnsCount] = this.enterMarkets.selector;\n    functionSelectors[--fnsCount] = this.exitMarket.selector;\n    functionSelectors[--fnsCount] = this.mintAllowed.selector;\n    functionSelectors[--fnsCount] = this.redeemAllowed.selector;\n    functionSelectors[--fnsCount] = this.redeemVerify.selector;\n    functionSelectors[--fnsCount] = this.borrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.borrowWithinLimits.selector;\n    functionSelectors[--fnsCount] = this.repayBorrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.liquidateBorrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.seizeAllowed.selector;\n    functionSelectors[--fnsCount] = this.transferAllowed.selector;\n    functionSelectors[--fnsCount] = this.mintVerify.selector;\n    functionSelectors[--fnsCount] = this.getAccountLiquidity.selector;\n    functionSelectors[--fnsCount] = this.liquidateCalculateSeizeTokens.selector;\n    functionSelectors[--fnsCount] = this._beforeNonReentrant.selector;\n    functionSelectors[--fnsCount] = this._afterNonReentrant.selector;\n    functionSelectors[--fnsCount] = this._becomeImplementation.selector;\n    functionSelectors[--fnsCount] = this.effectiveSupplyCaps.selector;\n    functionSelectors[--fnsCount] = this.effectiveBorrowCaps.selector;\n    functionSelectors[--fnsCount] = this.borrowVerify.selector;\n    functionSelectors[--fnsCount] = this.repayBorrowVerify.selector;\n    functionSelectors[--fnsCount] = this.seizeVerify.selector;\n    functionSelectors[--fnsCount] = this.transferVerify.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  /**\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _beforeNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"!Comptroller:_beforeNonReentrant\");\n    require(_notEntered, \"!reentered\");\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _afterNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"!Comptroller:_afterNonReentrant\");\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerV4Storage } from \"../compound/ComptrollerStorage.sol\";\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\nimport { IHistoricalRates } from \"adrastia-periphery/rates/IHistoricalRates.sol\";\n\ninterface ComptrollerInterface {\n  function isDeprecated(ICErc20 cToken) external view returns (bool);\n\n  function _becomeImplementation() external;\n\n  function _deployMarket(\n    uint8 delegateType,\n    bytes memory constructorData,\n    bytes calldata becomeImplData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256);\n\n  function getAssetsIn(address account) external view returns (ICErc20[] memory);\n\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool);\n\n  function _setPriceOracle(BasePriceOracle newOracle) external returns (uint256);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n  function _setCollateralFactor(ICErc20 market, uint256 newCollateralFactorMantissa) external returns (uint256);\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\n\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\n\n  function _addRewardsDistributor(address distributor) external returns (uint256);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  function getMaxRedeemOrBorrow(address account, ICErc20 cToken, bool isBorrow) external view returns (uint256);\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n  function exitMarket(address cToken) external returns (uint256);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\n\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n  function borrowVerify(address cToken, address borrower) external;\n\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view returns (uint256);\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external;\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n  \n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external;\n\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\n  \n  function transferVerify(address cToken, address src, address dst, uint256 transferTokens) external;\n\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function getAccountLiquidity(\n    address account\n  ) external view returns (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall);\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 repayAmount\n  ) external view returns (uint256, uint256);\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  function _beforeNonReentrant() external;\n\n  function _afterNonReentrant() external;\n\n  /*** New supply and borrow cap view functions ***/\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(address cToken) external view returns (uint256 supplyCap);\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(address cToken) external view returns (uint256 borrowCap);\n}\n\ninterface ComptrollerStorageInterface {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdmin() external view returns (address);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function pendingAdmin() external view returns (address);\n\n  function oracle() external view returns (BasePriceOracle);\n\n  function pauseGuardian() external view returns (address);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function isUserOfPool(address user) external view returns (bool);\n\n  function whitelist(address account) external view returns (bool);\n\n  function enforceWhitelist() external view returns (bool);\n\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\n\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\n\n  function suppliers(address account) external view returns (bool);\n\n  function cTokensByUnderlying(address) external view returns (address);\n\n  /**\n   * Gets the supply cap of a cToken in the units of the underlying asset.\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the supply cap. Instead, use\n   * `effectiveSupplyCaps` to get the correct supply cap.\n   * @param cToken The address of the cToken.\n   * @return The supply cap in the units of the underlying asset.\n   */\n  function supplyCaps(address cToken) external view returns (uint256);\n\n  /**\n   * Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the borrow cap. Instead, use\n   * `effectiveBorrowCaps` to get the correct borrow cap.\n   * @param cToken The address of the cToken.\n   * @return The borrow cap in the units of the underlying asset.\n   */\n  function borrowCaps(address cToken) external view returns (uint256);\n\n  function markets(address cToken) external view returns (bool, uint256);\n\n  function accountAssets(address, uint256) external view returns (address);\n\n  function borrowGuardianPaused(address cToken) external view returns (bool);\n\n  function mintGuardianPaused(address cToken) external view returns (bool);\n\n  function rewardsDistributors(uint256) external view returns (address);\n}\n\ninterface SFSRegister {\n  function register(address _recipient) external returns (uint256 tokenId);\n}\n\ninterface ComptrollerExtensionInterface {\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\n\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\n\n  function getAllMarkets() external view returns (ICErc20[] memory);\n\n  function getAllBorrowers() external view returns (address[] memory);\n\n  function getAllBorrowersCount() external view returns (uint256);\n\n  function getPaginatedBorrowers(\n    uint256 page,\n    uint256 pageSize\n  ) external view returns (uint256 _totalPages, address[] memory _pageOfBorrowers);\n\n  function getRewardsDistributors() external view returns (address[] memory);\n\n  function getAccruingFlywheels() external view returns (address[] memory);\n\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) external;\n\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) external;\n\n  function _setBorrowCapForCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) external;\n\n  function isBorrowCapForCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) external view returns (bool);\n\n  function _blacklistBorrowingAgainstCollateral(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    bool blacklisted\n  ) external;\n\n  function _blacklistBorrowingAgainstCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) external;\n\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) external view returns (bool);\n\n  function isSupplyCapWhitelisted(address cToken, address account) external view returns (bool);\n\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) external;\n\n  function isBorrowCapWhitelisted(address cToken, address account) external view returns (bool);\n\n  function _removeFlywheel(address flywheelAddress) external returns (bool);\n\n  function getWhitelist() external view returns (address[] memory);\n\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool);\n\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external;\n\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external;\n\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\n\n  function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n  function _setMintPaused(ICErc20 cToken, bool state) external returns (bool);\n\n  function _setBorrowPaused(ICErc20 cToken, bool state) external returns (bool);\n\n  function _setTransferPaused(bool state) external returns (bool);\n\n  function _setSeizePaused(bool state) external returns (bool);\n\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256);\n\n  function getAssetAsCollateralValueCap(\n    ICErc20 collateral,\n    ICErc20 cTokenModify,\n    bool redeeming,\n    address account\n  ) external view returns (uint256);\n\n  function registerInSFS() external returns (uint256);\n}\n\ninterface ComptrollerPrudentiaCapsExtInterface {\n  /**\n   * @notice Retrieves Adrastia Prudentia borrow cap config from storage.\n   * @return The config.\n   */\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\n\n  /**\n   * @notice Retrieves Adrastia Prudentia supply cap config from storage.\n   * @return The config.\n   */\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\n\n  /**\n   * @notice Sets the Adrastia Prudentia supply cap config.\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native supply caps.\n   * @param newConfig The new config.\n   */\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\n\n  /**\n   * @notice Sets the Adrastia Prudentia supply cap config.\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native borrow caps.\n   * @param newConfig The new config.\n   */\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\n}\n\ninterface UnitrollerInterface {\n  function comptrollerImplementation() external view returns (address);\n\n  function _upgrade() external;\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _toggleAdminRights(bool hasRights) external returns (uint256);\n}\n\ninterface IComptrollerExtension is ComptrollerExtensionInterface, ComptrollerStorageInterface {}\n\n//interface IComptrollerBase is ComptrollerInterface, ComptrollerStorageInterface {}\n\ninterface IonicComptroller is\n  ComptrollerInterface,\n  ComptrollerExtensionInterface,\n  UnitrollerInterface,\n  ComptrollerStorageInterface\n{\n\n}\n\nabstract contract ComptrollerBase is ComptrollerV4Storage {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(address cToken) public view virtual returns (uint256 supplyCap) {\n    PrudentiaLib.PrudentiaConfig memory capConfig = supplyCapConfig;\n\n    // Check if we're using Adrastia Prudentia for the supply cap\n    if (capConfig.controller != address(0)) {\n      // We have a controller, so we're using Adrastia Prudentia\n\n      address underlyingToken = ICErc20(cToken).underlying();\n\n      // Get the supply cap from Adrastia Prudentia\n      supplyCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\n\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\n      // must scale the supply cap to get the correct amount\n\n      int256 scaleByDecimals = 18;\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\n      if (success && data.length == 32) {\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\n      }\n\n      scaleByDecimals += capConfig.decimalShift;\n\n      if (scaleByDecimals >= 0) {\n        // We're scaling up, so we need to multiply\n        supplyCap *= 10 ** uint256(scaleByDecimals);\n      } else {\n        // We're scaling down, so we need to divide\n        supplyCap /= 10 ** uint256(-scaleByDecimals);\n      }\n    } else {\n      // We don't have a controller, so we're using the local supply cap\n\n      // Get the supply cap from the local supply cap\n      supplyCap = supplyCaps[cToken];\n    }\n  }\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(address cToken) public view virtual returns (uint256 borrowCap) {\n    PrudentiaLib.PrudentiaConfig memory capConfig = borrowCapConfig;\n\n    // Check if we're using Adrastia Prudentia for the borrow cap\n    if (capConfig.controller != address(0)) {\n      // We have a controller, so we're using Adrastia Prudentia\n\n      address underlyingToken = ICErc20(cToken).underlying();\n\n      // Get the borrow cap from Adrastia Prudentia\n      borrowCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\n\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\n      // must scale the supply cap to get the correct amount\n\n      int256 scaleByDecimals = 18;\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\n      if (success && data.length == 32) {\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\n      }\n\n      scaleByDecimals += capConfig.decimalShift;\n\n      if (scaleByDecimals >= 0) {\n        // We're scaling up, so we need to multiply\n        borrowCap *= 10 ** uint256(scaleByDecimals);\n      } else {\n        // We're scaling down, so we need to divide\n        borrowCap /= 10 ** uint256(-scaleByDecimals);\n      }\n    } else {\n      // We don't have a controller, so we're using the local borrow cap\n      borrowCap = borrowCaps[cToken];\n    }\n  }\n}\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFeeDistributor.sol\";\nimport \"../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract UnitrollerAdminStorage {\n  /*\n   * Administrator for Ionic\n   */\n  address payable public ionicAdmin;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Whether or not the Ionic admin has admin rights\n   */\n  bool public ionicAdminHasRights = true;\n\n  /**\n   * @notice Whether or not the admin has admin rights\n   */\n  bool public adminHasRights = true;\n\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(ionicAdmin) && ionicAdminHasRights);\n  }\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  BasePriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /*\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 internal maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => ICErc20[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    // Multiplier representing the most one can borrow against their collateral in this market.\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\n    // Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /// @notice A list of all markets\n  ICErc20[] public allMarkets;\n\n  /**\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\n   */\n  mapping(address => bool) internal borrowers;\n\n  /// @notice A list of all borrowers who have entered markets\n  address[] public allBorrowers;\n\n  // Indexes of borrower account addresses in the `allBorrowers` array\n  mapping(address => uint256) internal borrowerIndexes;\n\n  /**\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n   */\n  mapping(address => bool) public suppliers;\n\n  /// @notice All cTokens addresses mapped by their underlying token addresses\n  mapping(address => ICErc20) public cTokensByUnderlying;\n\n  /// @notice Whether or not the supplier whitelist is enforced\n  bool public enforceWhitelist;\n\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n  mapping(address => bool) public whitelist;\n\n  /// @notice An array of all whitelisted accounts\n  address[] public whitelistArray;\n\n  // Indexes of account addresses in the `whitelistArray` array\n  mapping(address => uint256) internal whitelistIndexes;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  /// @dev If Adrastia Prudentia is enabled, the values the borrow cap guardian sets are ignored.\n  address public borrowCapGuardian;\n\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveBorrowCaps` instead.\n  mapping(address => uint256) public borrowCaps;\n\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveSupplyCaps` instead.\n  mapping(address => uint256) public supplyCaps;\n\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\n  address[] public rewardsDistributors;\n\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n  bool internal _notEntered;\n\n  /// @dev Whether or not _notEntered has been initialized\n  bool internal _notEnteredInitialized;\n\n  /// @notice RewardsDistributor to list for claiming, but not to notify of flywheel changes.\n  address[] public nonAccruingRewardsDistributors;\n\n  /// @dev cap for each user's borrows against specific assets - denominated in the borrowed asset\n  mapping(address => mapping(address => uint256)) public borrowCapForCollateral;\n\n  /// @dev blacklist to disallow the borrowing of an asset against specific collateral\n  mapping(address => mapping(address => bool)) public borrowingAgainstCollateralBlacklist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrowing against specific collateral cap\n  mapping(address => mapping(address => EnumerableSet.AddressSet)) internal borrowCapForCollateralWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\n  mapping(address => mapping(address => EnumerableSet.AddressSet))\n    internal borrowingAgainstCollateralBlacklistWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the supply cap\n  mapping(address => EnumerableSet.AddressSet) internal supplyCapWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\n  mapping(address => EnumerableSet.AddressSet) internal borrowCapWhitelist;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n  /// @dev Adrastia Prudentia config for controlling borrow caps.\n  PrudentiaLib.PrudentiaConfig internal borrowCapConfig;\n\n  /// @dev Adrastia Prudentia config for controlling supply caps.\n  PrudentiaLib.PrudentiaConfig internal supplyCapConfig;\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IonicComptroller } from \"./ComptrollerInterface.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { ComptrollerV3Storage } from \"./ComptrollerStorage.sol\";\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\n\nabstract contract CTokenAdminStorage {\n  /*\n   * Administrator for Ionic\n   */\n  address payable public ionicAdmin;\n}\n\nabstract contract CErc20Storage is CTokenAdminStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  /*\n   * Maximum borrow rate that can ever be applied (.0005% / block)\n   */\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  /*\n   * Maximum fraction of interest that can be set aside for reserves + fees\n   */\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  IonicComptroller public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  /*\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n   */\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for admin fees\n   */\n  uint256 public adminFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for Ionic fees\n   */\n  uint256 public ionicFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total amount of admin fees of the underlying held in this market\n   */\n  uint256 public totalAdminFees;\n\n  /**\n   * @notice Total amount of Ionic fees of the underlying held in this market\n   */\n  uint256 public totalIonicFees;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  /*\n   * Official record of token balances for each account\n   */\n  mapping(address => uint256) internal accountTokens;\n\n  /*\n   * Approved token transfer amounts on behalf of others\n   */\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /*\n   * Mapping of account addresses to outstanding borrow balances\n   */\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /*\n   * Share of seized collateral that is added to reserves\n   */\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n  /*\n   * Share of seized collateral taken as fees\n   */\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\n\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n\n  /**\n   * @notice Addresses Provider\n   */\n  AddressesProvider public ap;\n}\n\nabstract contract CTokenBaseEvents {\n  /* ERC20 */\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the admin fee is changed\n   */\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n  /**\n   * @notice Event emitted when the Ionic fee is changed\n   */\n  event NewIonicFee(uint256 oldIonicFeeMantissa, uint256 newIonicFeeMantissa);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n}\n\nabstract contract CTokenFirstExtensionEvents is CTokenBaseEvents {\n  event Flash(address receiver, uint256 amount);\n}\n\nabstract contract CTokenSecondExtensionEvents is CTokenBaseEvents {\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n}\n\ninterface CTokenFirstExtensionInterface {\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\n\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function exchangeRateCurrent() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function totalBorrowsCurrent() external view returns (uint256);\n\n  function borrowBalanceCurrent(address account) external view returns (uint256);\n\n  function getTotalUnderlyingSupplied() external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external view returns (uint256);\n\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n  function flash(uint256 amount, bytes calldata data) external;\n\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256);\n\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256);\n\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) external view returns (uint256);\n\n  function registerInSFS() external returns (uint256);\n}\n\ninterface CTokenSecondExtensionInterface {\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _withdrawAdminFees(uint256 withdrawAmount) external returns (uint256);\n\n  function _withdrawIonicFees(uint256 withdrawAmount) external returns (uint256);\n\n  function selfTransferOut(address to, uint256 amount) external;\n\n  function selfTransferIn(address from, uint256 amount) external returns (uint256);\n}\n\ninterface CDelegatorInterface {\n  function implementation() external view returns (address);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external;\n\n  /**\n   * @dev upgrades the implementation if necessary\n   */\n  function _upgrade() external;\n}\n\ninterface CDelegateInterface {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes calldata data) external;\n\n  function delegateType() external pure returns (uint8);\n\n  function contractType() external pure returns (string memory);\n}\n\nabstract contract CErc20AdminBase is CErc20Storage {\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\n    return\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\n      (msg.sender == address(ionicAdmin) && comptrollerStorage.ionicAdminHasRights());\n  }\n}\n\nabstract contract CErc20FirstExtensionBase is\n  CErc20AdminBase,\n  CTokenFirstExtensionEvents,\n  CTokenFirstExtensionInterface\n{}\n\nabstract contract CTokenSecondExtensionBase is\n  CErc20AdminBase,\n  CTokenSecondExtensionEvents,\n  CTokenSecondExtensionInterface,\n  CDelegateInterface\n{}\n\nabstract contract CErc20DelegatorBase is CErc20AdminBase, CTokenSecondExtensionEvents, CDelegatorInterface {}\n\ninterface CErc20StorageInterface {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdmin() external view returns (address);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function comptroller() external view returns (IonicComptroller);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function adminFeeMantissa() external view returns (uint256);\n\n  function ionicFeeMantissa() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function feeSeizeShareMantissa() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalAdminFees() external view returns (uint256);\n\n  function totalIonicFees() external view returns (uint256);\n\n  function totalBorrows() external view returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function borrowIndex() external view returns (uint256);\n\n  function interestRateModel() external view returns (address);\n}\n\ninterface CErc20PluginStorageInterface is CErc20StorageInterface {\n  function plugin() external view returns (address);\n}\n\ninterface CErc20PluginRewardsInterface is CErc20PluginStorageInterface {\n  function approve(address, address) external;\n}\n\ninterface ICErc20 is\n  CErc20StorageInterface,\n  CTokenSecondExtensionInterface,\n  CTokenFirstExtensionInterface,\n  CDelegatorInterface,\n  CDelegateInterface\n{}\n\ninterface ICErc20Plugin is CErc20PluginStorageInterface, ICErc20 {\n  function _updatePlugin(address _plugin) external;\n}\n\ninterface ICErc20PluginRewards is CErc20PluginRewardsInterface, ICErc20 {}\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY,\n    SUPPLIER_NOT_WHITELISTED,\n    BORROW_BELOW_MIN,\n    SUPPLY_ABOVE_MAX,\n    NONZERO_TOTAL_SUPPLY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n    SET_WHITELIST_STATUS_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\n    UNSUPPORT_MARKET_OWNER_CHECK,\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\n    UNSUPPORT_MARKET_IN_USE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return uint256(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    BAD_INPUT,\n    COMPTROLLER_REJECTION,\n    COMPTROLLER_CALCULATION_ERROR,\n    INTEREST_RATE_MODEL_ERROR,\n    INVALID_ACCOUNT_PAIR,\n    INVALID_CLOSE_AMOUNT_REQUESTED,\n    INVALID_COLLATERAL_FACTOR,\n    MATH_ERROR,\n    MARKET_NOT_FRESH,\n    MARKET_NOT_LISTED,\n    TOKEN_INSUFFICIENT_ALLOWANCE,\n    TOKEN_INSUFFICIENT_BALANCE,\n    TOKEN_INSUFFICIENT_CASH,\n    TOKEN_TRANSFER_IN_FAILED,\n    TOKEN_TRANSFER_OUT_FAILED,\n    UTILIZATION_ABOVE_MAX\n  }\n\n  /*\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\n   *       This is because FailureInfo grows significantly faster, and\n   *       the order of Error has some meaning, while the order of FailureInfo\n   *       is entirely arbitrary.\n   */\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_IONIC_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    BORROW_ACCRUE_INTEREST_FAILED,\n    BORROW_CASH_NOT_AVAILABLE,\n    BORROW_FRESHNESS_CHECK,\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    BORROW_MARKET_NOT_LISTED,\n    BORROW_COMPTROLLER_REJECTION,\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n    LIQUIDATE_COMPTROLLER_REJECTION,\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n    LIQUIDATE_FRESHNESS_CHECK,\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_SEIZE_TOO_MUCH,\n    MINT_ACCRUE_INTEREST_FAILED,\n    MINT_COMPTROLLER_REJECTION,\n    MINT_EXCHANGE_CALCULATION_FAILED,\n    MINT_EXCHANGE_RATE_READ_FAILED,\n    MINT_FRESHNESS_CHECK,\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    MINT_TRANSFER_IN_FAILED,\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\n    REDEEM_ACCRUE_INTEREST_FAILED,\n    REDEEM_COMPTROLLER_REJECTION,\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\n    REDEEM_FRESHNESS_CHECK,\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n    WITHDRAW_IONIC_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_IONIC_FEES_FRESH_CHECK,\n    WITHDRAW_IONIC_FEES_VALIDATION,\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n    WITHDRAW_ADMIN_FEES_VALIDATION,\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n    REDUCE_RESERVES_ADMIN_CHECK,\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n    REDUCE_RESERVES_FRESH_CHECK,\n    REDUCE_RESERVES_VALIDATION,\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_COMPTROLLER_REJECTION,\n    REPAY_BORROW_FRESHNESS_CHECK,\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COMPTROLLER_OWNER_CHECK,\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n    SET_ADMIN_FEE_ADMIN_CHECK,\n    SET_ADMIN_FEE_FRESH_CHECK,\n    SET_ADMIN_FEE_BOUNDS_CHECK,\n    SET_IONIC_FEE_ACCRUE_INTEREST_FAILED,\n    SET_IONIC_FEE_FRESH_CHECK,\n    SET_IONIC_FEE_BOUNDS_CHECK,\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\n    SET_RESERVE_FACTOR_FRESH_CHECK,\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\n    TRANSFER_COMPTROLLER_REJECTION,\n    TRANSFER_NOT_ALLOWED,\n    TRANSFER_NOT_ENOUGH,\n    TRANSFER_TOO_MUCH,\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n    ADD_RESERVES_FRESH_CHECK,\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\n  }\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  struct Exp {\n    uint256 mantissa;\n  }\n\n  struct Double {\n    uint256 mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n  }\n}\n"
    },
    "contracts/compound/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../ionic/AuthoritiesRegistry.sol\";\n\ninterface IFeeDistributor {\n  function minBorrowEth() external view returns (uint256);\n\n  function maxUtilizationRate() external view returns (uint256);\n\n  function interestFeeRate() external view returns (uint256);\n\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n\n  function latestCErc20Delegate(uint8 delegateType)\n    external\n    view\n    returns (address cErc20Delegate, bytes memory becomeImplementationData);\n\n  function latestPluginImplementation(address oldImplementation) external view returns (address);\n\n  function getComptrollerExtensions(address comptroller) external view returns (address[] memory);\n\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (address[] memory);\n\n  function deployCErc20(\n    uint8 delegateType,\n    bytes calldata constructorData,\n    bytes calldata becomeImplData\n  ) external returns (address);\n\n  function canCall(\n    address pool,\n    address user,\n    address target,\n    bytes4 functionSig\n  ) external view returns (bool);\n\n  function authoritiesRegistry() external view returns (AuthoritiesRegistry);\n\n  fallback() external payable;\n\n  receive() external payable;\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view virtual returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Comptroller.sol\";\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated via the Diamond Extensions\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is ComptrollerV3Storage, ComptrollerErrorReporter, DiamondBase {\n  /**\n   * @notice Event emitted when the admin rights are changed\n   */\n  event AdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  constructor(address payable _ionicAdmin) {\n    admin = msg.sender;\n    ionicAdmin = _ionicAdmin;\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Toggles admin rights.\n   * @param hasRights Boolean indicating if the admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    adminHasRights = hasRights;\n    emit AdminRightsToggled(hasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    address oldPendingAdmin = pendingAdmin;\n    pendingAdmin = newPendingAdmin;\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    admin = pendingAdmin;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function comptrollerImplementation() public view returns (address) {\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\"_deployMarket(uint8,bytes,bytes,uint256)\"))));\n  }\n\n  /**\n   * @dev upgrades the implementation if necessary\n   */\n  function _upgrade() external {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self || !admin\");\n\n    address currentImplementation = comptrollerImplementation();\n    address latestComptrollerImplementation = IFeeDistributor(ionicAdmin).latestComptrollerImplementation(\n      currentImplementation\n    );\n\n    _updateExtensions(latestComptrollerImplementation);\n\n    if (currentImplementation != latestComptrollerImplementation) {\n      // reinitialize\n      _functionCall(address(this), abi.encodeWithSignature(\"_becomeImplementation()\"), \"!become impl\");\n    }\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function _updateExtensions(address currentComptroller) internal {\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getComptrollerExtensions(currentComptroller);\n    address[] memory currentExtensions = LibDiamond.listExtensions();\n\n    // removed the current (old) extensions\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\n    }\n    // add the new extensions\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\n    }\n  }\n\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\n    require(hasAdminRights(), \"!unauthorized\");\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\n  }\n}\n"
    },
    "contracts/ionic/AddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title AddressesProvider\n * @notice The Addresses Provider serves as a central storage of system internal and external\n *         contract addresses that change between deploys and across chains\n * @author Veliko Minkov <veliko@midascapital.xyz>\n */\ncontract AddressesProvider is SafeOwnableUpgradeable {\n  mapping(string => address) private _addresses;\n  mapping(address => Contract) public plugins;\n  mapping(address => Contract) public flywheelRewards;\n  mapping(address => RedemptionStrategy) public redemptionStrategiesConfig;\n  mapping(address => FundingStrategy) public fundingStrategiesConfig;\n  JarvisPool[] public jarvisPoolsConfig;\n  CurveSwapPool[] public curveSwapPoolsConfig;\n  mapping(address => mapping(address => address)) public balancerPoolForTokens;\n\n  /// @dev Initializer to set the admin that can set and change contracts addresses\n  function initialize(address owner) public initializer {\n    __SafeOwnable_init(owner);\n  }\n\n  /**\n   * @dev The contract address and a string that uniquely identifies the contract's interface\n   */\n  struct Contract {\n    address addr;\n    string contractInterface;\n  }\n\n  struct RedemptionStrategy {\n    address addr;\n    string contractInterface;\n    address outputToken;\n  }\n\n  struct FundingStrategy {\n    address addr;\n    string contractInterface;\n    address inputToken;\n  }\n\n  struct JarvisPool {\n    address syntheticToken;\n    address collateralToken;\n    address liquidityPool;\n    uint256 expirationTime;\n  }\n\n  struct CurveSwapPool {\n    address poolAddress;\n    address[] coins;\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the flywheel for the reward token\n   * @param rewardToken the reward token address\n   * @param flywheelRewardsModule the flywheel rewards module address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setFlywheelRewards(\n    address rewardToken,\n    address flywheelRewardsModule,\n    string calldata contractInterface\n  ) public onlyOwner {\n    flywheelRewards[rewardToken] = Contract(flywheelRewardsModule, contractInterface);\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the ERC4626 plugin for the asset\n   * @param asset the asset address\n   * @param plugin the ERC4626 plugin address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setPlugin(\n    address asset,\n    address plugin,\n    string calldata contractInterface\n  ) public onlyOwner {\n    plugins[asset] = Contract(plugin, contractInterface);\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the redemption strategy for the asset\n   * @param asset the asset address\n   * @param strategy redemption strategy address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setRedemptionStrategy(\n    address asset,\n    address strategy,\n    string calldata contractInterface,\n    address outputToken\n  ) public onlyOwner {\n    redemptionStrategiesConfig[asset] = RedemptionStrategy(strategy, contractInterface, outputToken);\n  }\n\n  function getRedemptionStrategy(address asset) public view returns (RedemptionStrategy memory) {\n    return redemptionStrategiesConfig[asset];\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the funding strategy for the asset\n   * @param asset the asset address\n   * @param strategy funding strategy address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setFundingStrategy(\n    address asset,\n    address strategy,\n    string calldata contractInterface,\n    address inputToken\n  ) public onlyOwner {\n    fundingStrategiesConfig[asset] = FundingStrategy(strategy, contractInterface, inputToken);\n  }\n\n  function getFundingStrategy(address asset) public view returns (FundingStrategy memory) {\n    return fundingStrategiesConfig[asset];\n  }\n\n  /**\n   * @dev configures the Jarvis pool of a Jarvis synthetic token\n   * @param syntheticToken the synthetic token address\n   * @param collateralToken the collateral token address\n   * @param liquidityPool the liquidity pool address\n   * @param expirationTime the operation expiration time\n   */\n  function setJarvisPool(\n    address syntheticToken,\n    address collateralToken,\n    address liquidityPool,\n    uint256 expirationTime\n  ) public onlyOwner {\n    jarvisPoolsConfig.push(JarvisPool(syntheticToken, collateralToken, liquidityPool, expirationTime));\n  }\n\n  function setCurveSwapPool(address poolAddress, address[] calldata coins) public onlyOwner {\n    curveSwapPoolsConfig.push(CurveSwapPool(poolAddress, coins));\n  }\n\n  /**\n   * @dev Sets an address for an id replacing the address saved in the addresses map\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(string calldata id, address newAddress) external onlyOwner {\n    _addresses[id] = newAddress;\n  }\n\n  /**\n   * @dev Returns an address by id\n   * @return The address\n   */\n  function getAddress(string calldata id) public view returns (address) {\n    return _addresses[id];\n  }\n\n  function getCurveSwapPools() public view returns (CurveSwapPool[] memory) {\n    return curveSwapPoolsConfig;\n  }\n\n  function getJarvisPools() public view returns (JarvisPool[] memory) {\n    return jarvisPoolsConfig;\n  }\n\n  function setBalancerPoolForTokens(\n    address inputToken,\n    address outputToken,\n    address pool\n  ) external onlyOwner {\n    balancerPoolForTokens[inputToken][outputToken] = pool;\n  }\n\n  function getBalancerPoolForTokens(address inputToken, address outputToken) external view returns (address) {\n    return balancerPoolForTokens[inputToken][outputToken];\n  }\n}\n"
    },
    "contracts/ionic/AuthoritiesRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AuthoritiesRegistry is SafeOwnableUpgradeable {\n  mapping(address => PoolRolesAuthority) public poolsAuthorities;\n  PoolRolesAuthority public poolAuthLogic;\n  address public leveredPositionsFactory;\n  bool public noAuthRequired;\n\n  function initialize(address _leveredPositionsFactory) public initializer {\n    __SafeOwnable_init(msg.sender);\n    leveredPositionsFactory = _leveredPositionsFactory;\n    poolAuthLogic = new PoolRolesAuthority();\n  }\n\n  function reinitialize(address _leveredPositionsFactory) public onlyOwnerOrAdmin {\n    leveredPositionsFactory = _leveredPositionsFactory;\n    poolAuthLogic = new PoolRolesAuthority();\n    // for Neon the auth is not required\n    noAuthRequired = block.chainid == 245022934;\n  }\n\n  function createPoolAuthority(address pool) public onlyOwner returns (PoolRolesAuthority auth) {\n    require(address(poolsAuthorities[pool]) == address(0), \"already created\");\n\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(poolAuthLogic), _getProxyAdmin(), \"\");\n    auth = PoolRolesAuthority(address(proxy));\n    auth.initialize(address(this));\n    poolsAuthorities[pool] = auth;\n\n    auth.openPoolSupplierCapabilities(IonicComptroller(pool));\n    auth.setUserRole(address(this), auth.REGISTRY_ROLE(), true);\n    // sets the registry owner as the auth owner\n    reconfigureAuthority(pool);\n  }\n\n  function reconfigureAuthority(address poolAddress) public {\n    IonicComptroller pool = IonicComptroller(poolAddress);\n    PoolRolesAuthority auth = poolsAuthorities[address(pool)];\n\n    if (msg.sender != poolAddress || address(auth) != address(0)) {\n      require(address(auth) != address(0), \"no such authority\");\n      require(msg.sender == owner() || msg.sender == poolAddress, \"not owner or pool\");\n\n      auth.configureRegistryCapabilities();\n      auth.configurePoolSupplierCapabilities(pool);\n      auth.configurePoolBorrowerCapabilities(pool);\n      // everyone can be a liquidator\n      auth.configureOpenPoolLiquidatorCapabilities(pool);\n      auth.configureLeveredPositionCapabilities(pool);\n\n      if (auth.owner() != owner()) {\n        auth.setOwner(owner());\n      }\n    }\n  }\n\n  function canCall(\n    address pool,\n    address user,\n    address target,\n    bytes4 functionSig\n  ) external view returns (bool) {\n    PoolRolesAuthority authorityForPool = poolsAuthorities[pool];\n    if (address(authorityForPool) == address(0)) {\n      return noAuthRequired;\n    } else {\n      // allow only if an auth exists and it allows the action\n      return authorityForPool.canCall(user, target, functionSig);\n    }\n  }\n\n  function setUserRole(\n    address pool,\n    address user,\n    uint8 role,\n    bool enabled\n  ) external {\n    PoolRolesAuthority poolAuth = poolsAuthorities[pool];\n\n    require(address(poolAuth) != address(0), \"auth does not exist\");\n    require(msg.sender == owner() || msg.sender == leveredPositionsFactory, \"not owner or factory\");\n    require(msg.sender != leveredPositionsFactory || role == poolAuth.LEVERED_POSITION_ROLE(), \"only lev pos role\");\n\n    poolAuth.setUserRole(user, role, enabled);\n  }\n}\n"
    },
    "contracts/ionic/DiamondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @notice a base contract for logic extensions that use the diamond pattern storage\n * to map the functions when looking up the extension contract to delegate to.\n */\nabstract contract DiamondExtension {\n  /**\n   * @return a list of all the function selectors that this logic extension exposes\n   */\n  function _getExtensionFunctions() external pure virtual returns (bytes4[] memory);\n}\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\n// When no extension exists for function called\nerror ExtensionNotFound(bytes4 _functionSelector);\n\n// When the function is already added\nerror FunctionAlreadyAdded(bytes4 _functionSelector, address _currentImpl);\n\nabstract contract DiamondBase {\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external virtual;\n\n  function _listExtensions() public view returns (address[] memory) {\n    return LibDiamond.listExtensions();\n  }\n\n  fallback() external {\n    address extension = LibDiamond.getExtensionForFunction(msg.sig);\n    if (extension == address(0)) revert FunctionNotFound(msg.sig);\n    // Execute external function from extension using delegatecall and return any value.\n    assembly {\n      // copy function selector and any arguments\n      calldatacopy(0, 0, calldatasize())\n      // execute function call using the extension\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\n      // get any return value\n      returndatacopy(0, 0, returndatasize())\n      // return any return value or error back to the caller\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n\n/**\n * @notice a library to use in a contract, whose logic is extended with diamond extension\n */\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.extensions.diamond.storage\");\n\n  struct Function {\n    address extension;\n    bytes4 selector;\n  }\n\n  struct LogicStorage {\n    Function[] functions;\n    address[] extensions;\n  }\n\n  function getExtensionForFunction(bytes4 msgSig) internal view returns (address) {\n    return getExtensionForSelector(msgSig, diamondStorage());\n  }\n\n  function diamondStorage() internal pure returns (LogicStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  function listExtensions() internal view returns (address[] memory) {\n    return diamondStorage().extensions;\n  }\n\n  function registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) internal {\n    if (address(extensionToReplace) != address(0)) {\n      removeExtension(extensionToReplace);\n    }\n    addExtension(extensionToAdd);\n  }\n\n  function removeExtension(DiamondExtension extension) internal {\n    LogicStorage storage ds = diamondStorage();\n    // remove all functions of the extension to replace\n    removeExtensionFunctions(extension);\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\n      if (ds.extensions[i] == address(extension)) {\n        ds.extensions[i] = ds.extensions[ds.extensions.length - 1];\n        ds.extensions.pop();\n      }\n    }\n  }\n\n  function addExtension(DiamondExtension extension) internal {\n    LogicStorage storage ds = diamondStorage();\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\n      require(ds.extensions[i] != address(extension), \"extension already added\");\n    }\n    addExtensionFunctions(extension);\n    ds.extensions.push(address(extension));\n  }\n\n  function removeExtensionFunctions(DiamondExtension extension) internal {\n    bytes4[] memory fnsToRemove = extension._getExtensionFunctions();\n    LogicStorage storage ds = diamondStorage();\n    for (uint16 i = 0; i < fnsToRemove.length; i++) {\n      bytes4 selectorToRemove = fnsToRemove[i];\n      // must never fail\n      assert(address(extension) == getExtensionForSelector(selectorToRemove, ds));\n      // swap with the last element in the selectorAtIndex array and remove the last element\n      uint16 indexToKeep = getIndexForSelector(selectorToRemove, ds);\n      ds.functions[indexToKeep] = ds.functions[ds.functions.length - 1];\n      ds.functions.pop();\n    }\n  }\n\n  function addExtensionFunctions(DiamondExtension extension) internal {\n    bytes4[] memory fnsToAdd = extension._getExtensionFunctions();\n    LogicStorage storage ds = diamondStorage();\n    uint16 functionsCount = uint16(ds.functions.length);\n    for (uint256 functionsIndex = 0; functionsIndex < fnsToAdd.length; functionsIndex++) {\n      bytes4 selector = fnsToAdd[functionsIndex];\n      address oldImplementation = getExtensionForSelector(selector, ds);\n      if (oldImplementation != address(0)) revert FunctionAlreadyAdded(selector, oldImplementation);\n      ds.functions.push(Function(address(extension), selector));\n      functionsCount++;\n    }\n  }\n\n  function getExtensionForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (address) {\n    uint256 fnsLen = ds.functions.length;\n    for (uint256 i = 0; i < fnsLen; i++) {\n      if (ds.functions[i].selector == selector) return ds.functions[i].extension;\n    }\n\n    return address(0);\n  }\n\n  function getIndexForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (uint16) {\n    uint16 fnsLen = uint16(ds.functions.length);\n    for (uint16 i = 0; i < fnsLen; i++) {\n      if (ds.functions[i].selector == selector) return i;\n    }\n\n    return type(uint16).max;\n  }\n}\n"
    },
    "contracts/ionic/PoolRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IonicComptroller, ComptrollerInterface } from \"../compound/ComptrollerInterface.sol\";\nimport { ICErc20, CTokenSecondExtensionInterface, CTokenFirstExtensionInterface } from \"../compound/CTokenInterfaces.sol\";\n\nimport { RolesAuthority, Authority } from \"solmate/auth/authorities/RolesAuthority.sol\";\n\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\ncontract PoolRolesAuthority is RolesAuthority, Initializable {\n  constructor() RolesAuthority(address(0), Authority(address(0))) {\n    _disableInitializers();\n  }\n\n  function initialize(address _owner) public initializer {\n    owner = _owner;\n    authority = this;\n  }\n\n  // up to 256 roles\n  uint8 public constant REGISTRY_ROLE = 0;\n  uint8 public constant SUPPLIER_ROLE = 1;\n  uint8 public constant BORROWER_ROLE = 2;\n  uint8 public constant LIQUIDATOR_ROLE = 3;\n  uint8 public constant LEVERED_POSITION_ROLE = 4;\n\n  function configureRegistryCapabilities() external requiresAuth {\n    setRoleCapability(REGISTRY_ROLE, address(this), PoolRolesAuthority.configureRegistryCapabilities.selector, true);\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configurePoolSupplierCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configurePoolBorrowerCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureClosedPoolLiquidatorCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureOpenPoolLiquidatorCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureLeveredPositionCapabilities.selector,\n      true\n    );\n    setRoleCapability(REGISTRY_ROLE, address(this), RolesAuthority.setUserRole.selector, true);\n  }\n\n  function openPoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolSupplierCapabilities(pool, true);\n  }\n\n  function closePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolSupplierCapabilities(pool, false);\n  }\n\n  function _setPublicPoolSupplierCapabilities(IonicComptroller pool, bool setPublic) internal {\n    setPublicCapability(address(pool), pool.enterMarkets.selector, setPublic);\n    setPublicCapability(address(pool), pool.exitMarket.selector, setPublic);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      bytes4[] memory selectors = getSupplierMarketSelectors();\n      for (uint256 j = 0; j < selectors.length; j++) {\n        setPublicCapability(address(allMarkets[i]), selectors[j], setPublic);\n      }\n    }\n  }\n\n  function configurePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _configurePoolSupplierCapabilities(pool, SUPPLIER_ROLE);\n  }\n\n  function getSupplierMarketSelectors() internal pure returns (bytes4[] memory selectors) {\n    uint8 fnsCount = 6;\n    selectors = new bytes4[](fnsCount);\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.mint.selector;\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeem.selector;\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeemUnderlying.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transfer.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transferFrom.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.approve.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n    return selectors;\n  }\n\n  function _configurePoolSupplierCapabilities(IonicComptroller pool, uint8 role) internal {\n    setRoleCapability(role, address(pool), pool.enterMarkets.selector, true);\n    setRoleCapability(role, address(pool), pool.exitMarket.selector, true);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      bytes4[] memory selectors = getSupplierMarketSelectors();\n      for (uint256 j = 0; j < selectors.length; j++) {\n        setRoleCapability(role, address(allMarkets[i]), selectors[j], true);\n      }\n    }\n  }\n\n  function openPoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolBorrowerCapabilities(pool, true);\n  }\n\n  function closePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolBorrowerCapabilities(pool, false);\n  }\n\n  function _setPublicPoolBorrowerCapabilities(IonicComptroller pool, bool setPublic) internal {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].borrow.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrow.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].flash.selector, setPublic);\n    }\n  }\n\n  function configurePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    // borrowers have the SUPPLIER_ROLE capabilities by default\n    _configurePoolSupplierCapabilities(pool, BORROWER_ROLE);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\n    }\n  }\n\n  function configureClosedPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, false);\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n    }\n  }\n\n  function configureOpenPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\n      // TODO this leaves redeeming open for everyone\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n    }\n  }\n\n  function configureLeveredPositionCapabilities(IonicComptroller pool) external requiresAuth {\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.enterMarkets.selector, true);\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.exitMarket.selector, true);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].mint.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeemUnderlying.selector, true);\n\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\n    }\n  }\n}\n"
    },
    "contracts/ionic/SafeOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\n\n/**\n * @dev Ownable extension that requires a two-step process of setting the pending owner and the owner accepting it.\n * @notice Existing OwnableUpgradeable contracts cannot be upgraded due to the extra storage variable\n * that will shift the other.\n */\nabstract contract SafeOwnableUpgradeable is OwnableUpgradeable {\n  /**\n   * @notice Pending owner of this contract\n   */\n  address public pendingOwner;\n\n  function __SafeOwnable_init(address owner_) internal onlyInitializing {\n    __Ownable_init();\n    _transferOwnership(owner_);\n  }\n\n  struct AddressSlot {\n    address value;\n  }\n\n  modifier onlyOwnerOrAdmin() {\n    bool isOwner = owner() == _msgSender();\n    if (!isOwner) {\n      address admin = _getProxyAdmin();\n      bool isAdmin = admin == _msgSender();\n      require(isAdmin, \"Ownable: caller is neither the owner nor the admin\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Emitted when pendingOwner is changed\n   */\n  event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\n\n  /**\n   * @notice Emitted when pendingOwner is accepted, which means owner is updated\n   */\n  event NewOwner(address oldOwner, address newOwner);\n\n  /**\n   * @notice Begins transfer of owner rights. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\n   * @dev Owner function to begin change of owner. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\n   * @param newPendingOwner New pending owner.\n   */\n  function _setPendingOwner(address newPendingOwner) public onlyOwner {\n    // Save current value, if any, for inclusion in log\n    address oldPendingOwner = pendingOwner;\n\n    // Store pendingOwner with value newPendingOwner\n    pendingOwner = newPendingOwner;\n\n    // Emit NewPendingOwner(oldPendingOwner, newPendingOwner)\n    emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n  }\n\n  /**\n   * @notice Accepts transfer of owner rights. msg.sender must be pendingOwner\n   * @dev Owner function for pending owner to accept role and update owner\n   */\n  function _acceptOwner() public {\n    // Check caller is pendingOwner and pendingOwner  address(0)\n    require(msg.sender == pendingOwner, \"not the pending owner\");\n\n    // Save current values for inclusion in log\n    address oldOwner = owner();\n    address oldPendingOwner = pendingOwner;\n\n    // Store owner with value pendingOwner\n    _transferOwnership(pendingOwner);\n\n    // Clear the pending value\n    pendingOwner = address(0);\n\n    emit NewOwner(oldOwner, pendingOwner);\n    emit NewPendingOwner(oldPendingOwner, pendingOwner);\n  }\n\n  function renounceOwnership() public override onlyOwner {\n    // do not remove this overriding fn\n    revert(\"not used anymore\");\n  }\n\n  function transferOwnership(address newOwner) public override onlyOwner {\n    emit NewPendingOwner(pendingOwner, newOwner);\n    pendingOwner = newOwner;\n  }\n\n  function _getProxyAdmin() internal view returns (address admin) {\n    bytes32 _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    AddressSlot storage adminSlot;\n    assembly {\n      adminSlot.slot := _ADMIN_SLOT\n    }\n    admin = adminSlot.value;\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IIonicFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\ninterface IIonicFlywheel {\n  function isRewardsDistributor() external returns (bool);\n\n  function isFlywheel() external returns (bool);\n\n  function flywheelPreSupplierAction(address market, address supplier) external;\n\n  function flywheelPostSupplierAction(address market, address supplier) external;\n\n  function flywheelPreBorrowerAction(address market, address borrower) external;\n\n  function flywheelPostBorrowerAction(address market, address borrower) external;\n\n  function flywheelPreTransferAction(address market, address src, address dst) external;\n\n  function flywheelPostTransferAction(address market, address src, address dst) external;\n\n  function compAccrued(address user) external view returns (uint256);\n\n  function addMarketForRewards(ERC20 strategy) external;\n\n  function marketState(ERC20 strategy) external view returns (uint224 index, uint32 lastUpdatedTimestamp);\n}\n"
    },
    "contracts/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../compound/CTokenInterfaces.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle {\n  /**\n   * @notice Get the price of an underlying asset.\n   * @param underlying The underlying asset to get the price of.\n   * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n   * Zero means the price is unavailable.\n   */\n  function price(address underlying) external view returns (uint256);\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view returns (uint256);\n}\n"
    },
    "contracts/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\nimport { BasePriceOracle } from \"./BasePriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, BasePriceOracle {\n  /**\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n   */\n  mapping(address => BasePriceOracle) public oracles;\n\n  /**\n   * @dev Default/fallback `PriceOracle`.\n   */\n  BasePriceOracle public defaultOracle;\n\n  /**\n   * @dev The administrator of this `MasterPriceOracle`.\n   */\n  address public admin;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool internal noAdminOverwrite;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n   */\n  mapping(address => BasePriceOracle) public fallbackOracles;\n\n  /**\n   * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  function canAdminOverwrite() external view returns (bool) {\n    return !noAdminOverwrite;\n  }\n\n  /**\n   * @dev Event emitted when `admin` is changed.\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @dev Event emitted when the default oracle is changed.\n   */\n  event NewDefaultOracle(address oldOracle, address newOracle);\n\n  /**\n   * @dev Event emitted when an underlying token's oracle is changed.\n   */\n  event NewOracle(address underlying, address oldOracle, address newOracle);\n\n  /**\n   * @dev  Initialize state variables.\n   * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n   * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n   * @param _defaultOracle The default `PriceOracle` contract to use.\n   * @param _admin The admin who can assign oracles to underlying tokens.\n   * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   * @param _wtoken The Wrapped native asset address\n   */\n  function initialize(\n    address[] memory underlyings,\n    BasePriceOracle[] memory _oracles,\n    BasePriceOracle _defaultOracle,\n    address _admin,\n    bool _canAdminOverwrite,\n    address _wtoken\n  ) external initializer {\n    // Input validation\n    require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\n\n    // Initialize state variables\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      BasePriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, address(0), address(newOracle));\n    }\n\n    defaultOracle = _defaultOracle;\n    admin = _admin;\n    noAdminOverwrite = !_canAdminOverwrite;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @dev Sets `_oracles` for `underlyings`.\n   */\n  function add(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == _oracles.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // Assign oracles to underlying tokens\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      address oldOracle = address(oracles[underlying]);\n      if (noAdminOverwrite)\n        require(\n          oldOracle == address(0),\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n        );\n      BasePriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, oldOracle, address(newOracle));\n    }\n  }\n\n  /**\n   * @dev Sets `_oracles` for `underlyings`.\n   */\n  function addFallbacks(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == _oracles.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // Assign oracles to underlying tokens\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      address oldOracle = address(fallbackOracles[underlying]);\n      if (noAdminOverwrite)\n        require(\n          oldOracle == address(0),\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n        );\n      BasePriceOracle newOracle = _oracles[i];\n      fallbackOracles[underlying] = newOracle;\n      emit NewOracle(underlying, oldOracle, address(newOracle));\n    }\n  }\n\n  /**\n   * @dev Changes the default price oracle\n   */\n  function setDefaultOracle(BasePriceOracle newOracle) external onlyAdmin {\n    BasePriceOracle oldOracle = defaultOracle;\n    defaultOracle = newOracle;\n    emit NewDefaultOracle(address(oldOracle), address(newOracle));\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  /**\n   * @dev Modifier that checks if `msg.sender == admin`.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Sender is not the admin.\");\n    _;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying ERC20 token address\n    address underlying = address(ICErc20(address(cToken)).underlying());\n\n    if (underlying == wtoken) return 1e18;\n\n    BasePriceOracle oracle = oracles[underlying];\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\n\n    if (address(oracle) != address(0)) {\n      try oracle.getUnderlyingPrice(cToken) returns (uint256 underlyingPrice) {\n        if (underlyingPrice == 0) {\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n        } else {\n          return underlyingPrice;\n        }\n      } catch {\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n      }\n    } else {\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n    }\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n\n  /**\n   * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) public view override returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == wtoken) return 1e18;\n\n    // Get underlying price from assigned oracle\n    BasePriceOracle oracle = oracles[underlying];\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\n\n    if (address(oracle) != address(0)) {\n      try oracle.price(underlying) returns (uint256 underlyingPrice) {\n        if (underlyingPrice == 0) {\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n        } else {\n          return underlyingPrice;\n        }\n      } catch {\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n      }\n    } else {\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n    }\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n}\n"
    },
    "contracts/PoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\nimport { Unitroller } from \"./compound/Unitroller.sol\";\nimport \"./ionic/SafeOwnableUpgradeable.sol\";\nimport \"./ionic/DiamondExtension.sol\";\n\n/**\n * @title PoolDirectory\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice PoolDirectory is a directory for Ionic interest rate pools.\n */\ncontract PoolDirectory is SafeOwnableUpgradeable {\n  /**\n   * @dev Initializes a deployer whitelist if desired.\n   * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\n   * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\n   */\n  function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\n    __SafeOwnable_init(msg.sender);\n    enforceDeployerWhitelist = _enforceDeployerWhitelist;\n    for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\n  }\n\n  /**\n   * @dev Struct for a Ionic interest rate pool.\n   */\n  struct Pool {\n    string name;\n    address creator;\n    address comptroller;\n    uint256 blockPosted;\n    uint256 timestampPosted;\n  }\n\n  /**\n   * @dev Array of Ionic interest rate pools.\n   */\n  Pool[] public pools;\n\n  /**\n   * @dev Maps Ethereum accounts to arrays of Ionic pool indexes.\n   */\n  mapping(address => uint256[]) private _poolsByAccount;\n\n  /**\n   * @dev Maps Ionic pool Comptroller addresses to bools indicating if they have been registered via the directory.\n   */\n  mapping(address => bool) public poolExists;\n\n  /**\n   * @dev Emitted when a new Ionic pool is added to the directory.\n   */\n  event PoolRegistered(uint256 index, Pool pool);\n\n  /**\n   * @dev Booleans indicating if the deployer whitelist is enforced.\n   */\n  bool public enforceDeployerWhitelist;\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\n   */\n  mapping(address => bool) public deployerWhitelist;\n\n  /**\n   * @dev Controls if the deployer whitelist is to be enforced.\n   * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\n   */\n  function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\n    enforceDeployerWhitelist = enforce;\n  }\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the deployer whitelist.\n   * @param deployers Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\n    require(deployers.length > 0, \"No deployers supplied.\");\n    for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\n  }\n\n  /**\n   * @dev Adds a new Ionic pool to the directory (without checking msg.sender).\n   * @param name The name of the pool.\n   * @param comptroller The pool's Comptroller proxy contract address.\n   * @return The index of the registered Ionic pool.\n   */\n  function _registerPool(string memory name, address comptroller) internal returns (uint256) {\n    require(!poolExists[comptroller], \"Pool already exists in the directory.\");\n    require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \"Sender is not on deployer whitelist.\");\n    require(bytes(name).length <= 100, \"No pool name supplied.\");\n    Pool memory pool = Pool(name, msg.sender, comptroller, block.number, block.timestamp);\n    pools.push(pool);\n    _poolsByAccount[msg.sender].push(pools.length - 1);\n    poolExists[comptroller] = true;\n    emit PoolRegistered(pools.length - 1, pool);\n    return pools.length - 1;\n  }\n\n  function _deprecatePool(address comptroller) external onlyOwner {\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller == comptroller) {\n        _deprecatePool(i);\n        break;\n      }\n    }\n  }\n\n  function _deprecatePool(uint256 index) public onlyOwner {\n    Pool storage ionicPool = pools[index];\n\n    require(ionicPool.comptroller != address(0), \"pool already deprecated\");\n\n    // swap with the last pool of the creator and delete\n    uint256[] storage creatorPools = _poolsByAccount[ionicPool.creator];\n    for (uint256 i = 0; i < creatorPools.length; i++) {\n      if (creatorPools[i] == index) {\n        creatorPools[i] = creatorPools[creatorPools.length - 1];\n        creatorPools.pop();\n        break;\n      }\n    }\n\n    // leave it to true to deny the re-registering of the same pool\n    poolExists[ionicPool.comptroller] = true;\n\n    // nullify the storage\n    ionicPool.comptroller = address(0);\n    ionicPool.creator = address(0);\n    ionicPool.name = \"\";\n    ionicPool.blockPosted = 0;\n    ionicPool.timestampPosted = 0;\n  }\n\n  /**\n   * @dev Deploys a new Ionic pool and adds to the directory.\n   * @param name The name of the pool.\n   * @param implementation The Comptroller implementation contract address.\n   * @param constructorData Encoded construction data for `Unitroller constructor()`\n   * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n   * @param closeFactor The pool's close factor (scaled by 1e18).\n   * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n   * @param priceOracle The pool's PriceOracle contract address.\n   * @return Index of the registered Ionic pool and the Unitroller proxy address.\n   */\n  function deployPool(\n    string memory name,\n    address implementation,\n    bytes calldata constructorData,\n    bool enforceWhitelist,\n    uint256 closeFactor,\n    uint256 liquidationIncentive,\n    address priceOracle\n  ) external returns (uint256, address) {\n    // Input validation\n    require(implementation != address(0), \"No Comptroller implementation contract address specified.\");\n    require(priceOracle != address(0), \"No PriceOracle contract address specified.\");\n\n    // Deploy Unitroller using msg.sender, name, and block.number as a salt\n    bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode, constructorData);\n    address proxy = Create2Upgradeable.deploy(\n      0,\n      keccak256(abi.encodePacked(msg.sender, name, ++poolsCounter)),\n      unitrollerCreationCode\n    );\n\n    // Setup the pool\n    IonicComptroller comptrollerProxy = IonicComptroller(proxy);\n    // Set up the extensions\n    comptrollerProxy._upgrade();\n\n    // Set pool parameters\n    require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \"Failed to set pool close factor.\");\n    require(\n      comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0,\n      \"Failed to set pool liquidation incentive.\"\n    );\n    require(comptrollerProxy._setPriceOracle(BasePriceOracle(priceOracle)) == 0, \"Failed to set pool price oracle.\");\n\n    // Whitelist\n    if (enforceWhitelist)\n      require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \"Failed to enforce supplier/borrower whitelist.\");\n\n    // Make msg.sender the admin\n    require(comptrollerProxy._setPendingAdmin(msg.sender) == 0, \"Failed to set pending admin on Unitroller.\");\n\n    // Register the pool with this PoolDirectory\n    return (_registerPool(name, proxy), proxy);\n  }\n\n  /**\n   * @notice Returns `ids` and directory information of all non-deprecated Ionic pools.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getActivePools() public view returns (uint256[] memory, Pool[] memory) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) count++;\n    }\n\n    Pool[] memory activePools = new Pool[](count);\n    uint256[] memory poolIds = new uint256[](count);\n\n    uint256 index = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) {\n        poolIds[index] = i;\n        activePools[index] = pools[i];\n        index++;\n      }\n    }\n\n    return (poolIds, activePools);\n  }\n\n  /**\n   * @notice Returns arrays of all Ionic pools' data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getAllPools() public view returns (Pool[] memory) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) count++;\n    }\n\n    Pool[] memory result = new Pool[](count);\n\n    uint256 index = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) {\n        result[index++] = pools[i];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @notice Returns arrays of all public Ionic pool indexes and data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPools() external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory publicPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n\n  /**\n   * @notice Returns arrays of all public Ionic pool indexes and data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPoolsOfUser(address user) external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\n        if (!isUsing) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory poolsOfUser = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\n        if (!isUsing) continue;\n      } catch {}\n\n      indexes[index] = i;\n      poolsOfUser[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, poolsOfUser);\n  }\n\n  /**\n   * @notice Returns arrays of Ionic pool indexes and data created by `account`.\n   */\n  function getPoolsByAccount(address account) external view returns (uint256[] memory, Pool[] memory) {\n    uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\n    Pool[] memory accountPools = new Pool[](_poolsByAccount[account].length);\n    (, Pool[] memory activePools) = getActivePools();\n\n    for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\n      indexes[i] = _poolsByAccount[account][i];\n      accountPools[i] = activePools[_poolsByAccount[account][i]];\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @notice Modify existing Ionic pool name.\n   */\n  function setPoolName(uint256 index, string calldata name) external {\n    IonicComptroller _comptroller = IonicComptroller(pools[index].comptroller);\n    require(\n      (msg.sender == _comptroller.admin() && _comptroller.adminHasRights()) || msg.sender == owner(),\n      \"!permission\"\n    );\n    pools[index].name = name;\n  }\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\n   */\n  mapping(address => bool) public adminWhitelist;\n\n  /**\n   * @dev used as salt for the creation of new pools\n   */\n  uint256 public poolsCounter;\n\n  /**\n   * @dev Event emitted when the admin whitelist is updated.\n   */\n  event AdminWhitelistUpdated(address[] admins, bool status);\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the admin whitelist.\n   * @param admins Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\n    require(admins.length > 0, \"No admins supplied.\");\n    for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\n    emit AdminWhitelistUpdated(admins, status);\n  }\n\n  /**\n   * @notice Returns arrays of all Ionic pool indexes and data with whitelisted admins.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPoolsByVerification(bool whitelistedAdmin) external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.admin() returns (address admin) {\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory publicPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.admin() returns (address admin) {\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n\n  /**\n   * @notice Returns arrays of all verified Ionic pool indexes and data for which the account is whitelisted\n   * @param account who is whitelisted in the returned verified whitelist-enabled pools.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getVerifiedPoolsOfWhitelistedAccount(\n    address account\n  ) external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory accountWhitelistedPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\n      } catch {}\n\n      indexes[index] = i;\n      accountWhitelistedPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, accountWhitelistedPools);\n  }\n}\n"
    },
    "contracts/test/config/BaseTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"forge-std/Vm.sol\";\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport { AddressesProvider } from \"../../ionic/AddressesProvider.sol\";\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\nabstract contract BaseTest is Test {\n  uint128 constant ETHEREUM_MAINNET = 1;\n  uint128 constant BSC_MAINNET = 56;\n  uint128 constant POLYGON_MAINNET = 137;\n  uint128 constant ARBITRUM_ONE = 42161;\n\n  uint128 constant BSC_CHAPEL = 97;\n  uint128 constant NEON_MAINNET = 245022934;\n  uint128 constant LINEA_MAINNET = 59144;\n  uint128 constant ZKEVM_MAINNET = 1101;\n  uint128 constant MODE_MAINNET = 34443;\n  uint128 constant BASE_MAINNET = 8453;\n\n  // taken from ERC1967Upgrade\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  AddressesProvider public ap;\n  ProxyAdmin public dpa;\n\n  mapping(uint128 => uint256) private forkIds;\n\n  constructor() {\n    configureAddressesProvider(0);\n  }\n\n  uint256 constant CRITICAL = 100;\n  uint256 constant NORMAL = 90;\n  uint256 constant LOW = 80;\n\n  modifier importance(uint256 testImportance) {\n    uint256 runLevel = NORMAL;\n\n    try vm.envUint(\"TEST_RUN_LEVEL\") returns (uint256 level) {\n      runLevel = level;\n    } catch {\n      emit log(\"failed to get env param TEST_RUN_LEVEL\");\n    }\n\n    if (testImportance >= runLevel) {\n      _;\n    } else {\n      emit log(\"not running the test\");\n    }\n  }\n\n  modifier debuggingOnly() {\n    try vm.envBool(\"LOCAL_FORGE_ENV\") returns (bool run) {\n      if (run) _;\n    } catch {\n      emit log(\"skipping this test in the CI/CD - add LOCAL_FORGE_ENV=true to your .env file to run locally\");\n    }\n  }\n\n  modifier fork(uint128 chainid) {\n    if (shouldRunForChain(chainid)) {\n      _forkAtBlock(chainid, 0);\n      _;\n    }\n  }\n\n  modifier forkAtBlock(uint128 chainid, uint256 blockNumber) {\n    if (shouldRunForChain(chainid)) {\n      _forkAtBlock(chainid, blockNumber);\n      _;\n    }\n  }\n\n  modifier whenForking() {\n    try vm.activeFork() returns (uint256) {\n      _;\n    } catch {}\n  }\n\n  function shouldRunForChain(uint256 chainid) internal returns (bool) {\n    bool run = true;\n    try vm.envUint(\"TEST_RUN_CHAINID\") returns (uint256 envChainId) {\n      run = envChainId == chainid;\n    } catch {\n      emit log(\"failed to get env param TEST_RUN_CHAINID\");\n    }\n    return run;\n  }\n\n  function _forkAtBlock(uint128 chainid, uint256 blockNumber) internal {\n    if (block.chainid != chainid) {\n      if (blockNumber != 0) {\n        vm.selectFork(getArchiveForkId(chainid));\n        vm.rollFork(blockNumber);\n      } else {\n        vm.selectFork(getForkId(chainid));\n      }\n    }\n    configureAddressesProvider(chainid);\n    afterForkSetUp();\n  }\n\n  function getForkId(uint128 chainid, bool archive) private returns (uint256) {\n    return archive ? getForkId(chainid) : getArchiveForkId(chainid);\n  }\n\n  function getForkId(uint128 chainid) private returns (uint256) {\n    if (forkIds[chainid] == 0) {\n      if (chainid == BSC_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"bsc\")) + 100;\n      } else if (chainid == BSC_CHAPEL) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"bsc_chapel\")) + 100;\n      } else if (chainid == POLYGON_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"polygon\")) + 100;\n      } else if (chainid == NEON_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"neon\")) + 100;\n      } else if (chainid == ARBITRUM_ONE) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"arbitrum\")) + 100;\n      } else if (chainid == ETHEREUM_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"ethereum\")) + 100;\n      } else if (chainid == LINEA_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"linea\")) + 100;\n      } else if (chainid == ZKEVM_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"zkevm\")) + 100;\n      } else if (chainid == MODE_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"mode\")) + 100;\n      } else if (chainid == BASE_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"base\")) + 100;\n      }\n    }\n\n    return forkIds[chainid] - 100;\n  }\n\n  function getArchiveForkId(uint128 chainid) private returns (uint256) {\n    // store the archive rpc urls in the forkIds mapping at an offset\n    uint128 chainidWithOffset = chainid + type(uint64).max;\n    if (forkIds[chainidWithOffset] == 0) {\n      if (chainid == BSC_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"bsc_archive\")) + 100;\n      } else if (chainid == BSC_CHAPEL) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"bsc_chapel_archive\")) + 100;\n      } else if (chainid == POLYGON_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"polygon_archive\")) + 100;\n      } else if (chainid == NEON_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"neon_archive\")) + 100;\n      } else if (chainid == ARBITRUM_ONE) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"arbitrum_archive\")) + 100;\n      } else if (chainid == ETHEREUM_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"ethereum_archive\")) + 100;\n      } else if (chainid == LINEA_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"linea_archive\")) + 100;\n      } else if (chainid == ZKEVM_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"zkevm_archive\")) + 100;\n      } else if (chainid == MODE_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"mode_archive\")) + 100;\n      } else if (chainid == BASE_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"base_archive\")) + 100;\n      }\n    }\n    return forkIds[chainidWithOffset] - 100;\n  }\n\n  function afterForkSetUp() internal virtual {}\n\n  function configureAddressesProvider(uint128 chainid) private {\n    if (chainid == BSC_MAINNET) {\n      ap = AddressesProvider(address(0));\n    } else if (chainid == BSC_CHAPEL) {\n      ap = AddressesProvider(0x3dc8CE9f581e49B9E5304CF580940ad341F64c3f);\n    } else if (block.chainid == POLYGON_MAINNET) {\n      ap = AddressesProvider(0xE31baC0B582AA248c0017F87F24087cEa7A55E26);\n    } else if (chainid == NEON_MAINNET) {\n      ap = AddressesProvider(0xF4C60F6ac6b3AF54044757a1a54D76EEe28244CE);\n    } else if (chainid == ARBITRUM_ONE) {\n      ap = AddressesProvider(0x3B12BA992259Fb3855C4E1D452a754dCa2E276fC);\n    } else if (chainid == LINEA_MAINNET) {\n      ap = AddressesProvider(0x914694DA0bED80e74ef1a28029f016119782C0f1);\n    } else if (chainid == ZKEVM_MAINNET) {\n      ap = AddressesProvider(0x27aA55A3D55959261e119d75256aadAB79aE897C);\n    } else if (chainid == MODE_MAINNET) {\n      ap = AddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n    } else if (chainid == BASE_MAINNET) {\n      ap = AddressesProvider(0xcD4D7c8e2bA627684a9B18F7fe88239341D3ba5c);\n    } else {\n      dpa = new ProxyAdmin();\n      AddressesProvider logic = new AddressesProvider();\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(\n        address(logic),\n        address(dpa),\n        abi.encodeWithSelector(ap.initialize.selector, address(this))\n      );\n      ap = AddressesProvider(address(proxy));\n      ap.setAddress(\"DefaultProxyAdmin\", address(dpa));\n    }\n    dpa = ProxyAdmin(ap.getAddress(\"DefaultProxyAdmin\"));\n    if (ap.owner() == address(0)) {\n      ap.initialize(address(this));\n    }\n    if (ap.getAddress(\"deployer\") == address(0)) {\n      vm.prank(ap.owner());\n      ap.setAddress(\"deployer\", 0x1155b614971f16758C92c4890eD338C9e3ede6b7);\n    }\n  }\n\n  function diff(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a > b) {\n      return a - b;\n    } else {\n      return b - a;\n    }\n  }\n\n  function compareStrings(string memory a, string memory b) public pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function asArray(address value) public pure returns (address[] memory) {\n    address[] memory array = new address[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(address value0, address value1) public pure returns (address[] memory) {\n    address[] memory array = new address[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(\n    address value0,\n    address value1,\n    address value2\n  ) public pure returns (address[] memory) {\n    address[] memory array = new address[](3);\n    array[0] = value0;\n    array[1] = value1;\n    array[2] = value2;\n    return array;\n  }\n\n  function asArray(bool value) public pure returns (bool[] memory) {\n    bool[] memory array = new bool[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(uint256 value0, uint256 value1) public pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(uint256 value) public pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(bytes memory value) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(bytes memory value0, bytes memory value1) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(\n    bytes memory value0,\n    bytes memory value1,\n    bytes memory value2\n  ) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](3);\n    array[0] = value0;\n    array[1] = value1;\n    array[2] = value2;\n    return array;\n  }\n\n  function sqrt(uint256 x) public pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n}\n"
    },
    "contracts/test/veION/contracts/Voter/mocks/MockBribeRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"../../../../../veION/interfaces/IBribeRewards.sol\";\n\ncontract MockBribeRewards is IBribeRewards {\n  function deposit(address lpToken, uint256 amount, uint256 tokenId) external override {\n    emit Deposit(msg.sender, tokenId, amount);\n  }\n\n  function withdraw(address lpToken, uint256 amount, uint256 tokenId) external override {\n    emit Withdraw(msg.sender, tokenId, amount);\n  }\n\n  function notifyRewardAmount(address token, uint256 amount) external override {\n    emit RewardNotification(msg.sender, token, block.timestamp, amount);\n  }\n\n  function getReward(uint256 tokenId, address[] memory tokens) external override {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      emit RewardsClaimed(msg.sender, tokens[i], 0); // Assuming 0 as a placeholder for reward amount\n    }\n  }\n\n  function getPriorBalanceIndex(\n    uint256 tokenId,\n    address lpToken,\n    uint256 timestamp\n  ) external view override returns (uint256) {\n    return 0; // Placeholder return value\n  }\n\n  function getPriorSupplyIndex(uint256 timestamp, address lpToken) external view override returns (uint256) {\n    return 0; // Placeholder return value\n  }\n\n  function earned(address token, uint256 tokenId) external view override returns (uint256) {\n    return 0; // Placeholder return value\n  }\n}\n"
    },
    "contracts/test/veION/contracts/Voter/utils/VoterUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../../../Utils.sol\";\nimport \"../../../../../veION/Voter.sol\";\nimport \"../mocks/MockBribeRewards.sol\";\nimport { IVoter } from \"../../../../../veION/interfaces/IVoter.sol\";\nimport { RewardAccumulator } from \"../../../../../veION/RewardAccumulator.sol\";\n\ncontract VoterTest is veIONTest {\n  Voter voter;\n  LockInfo voterLockInfoSingleLp;\n  LockInfoMultiple voterLockInfoMultiLp;\n  uint256 voterTokenIdSingleLp;\n  uint256 voterTokenIdMultiLp;\n  address user;\n\n  address ethMarket;\n  address btcMarket;\n\n  MockBribeRewards bribeEthSupply;\n  MockBribeRewards bribeEthBorrow;\n  MockBribeRewards bribeBtcSupply;\n  MockBribeRewards bribeBtcBorrow;\n\n  MasterPriceOracle mpo;\n\n  function _setUp() internal virtual override {\n    super._setUp();\n    ethMarket = _generateRandomAddress(1);\n    btcMarket = _generateRandomAddress(2);\n\n    address[] memory _tokens = new address[](2);\n    _tokens[0] = address(modeVelodrome5050IonMode);\n    _tokens[1] = address(modeBalancer8020IonEth);\n\n    MasterPriceOracle _mpo = new MasterPriceOracle();\n    MockERC20 mockIon = new MockERC20(\"Mock ION\", \"mION\", 18);\n    address _rewardToken = address(mockIon);\n    address _ve = address(ve);\n\n    voter = Voter(\n      address(\n        new TransparentUpgradeableProxy(\n          address(new Voter()),\n          address(new ProxyAdmin()),\n          abi.encodeWithSelector(Voter.initialize.selector, _tokens, _mpo, _rewardToken, _ve)\n        )\n      )\n    );\n\n    IVoter.Market[] memory dummyMarkets = new IVoter.Market[](4);\n    dummyMarkets[0] = IVoter.Market(ethMarket, IVoter.MarketSide.Supply);\n    dummyMarkets[1] = IVoter.Market(ethMarket, IVoter.MarketSide.Borrow);\n    dummyMarkets[2] = IVoter.Market(btcMarket, IVoter.MarketSide.Supply);\n    dummyMarkets[3] = IVoter.Market(btcMarket, IVoter.MarketSide.Borrow);\n    voter.addMarkets(dummyMarkets);\n\n    address[] memory marketAddresses = new address[](4);\n    IVoter.MarketSide[] memory marketSides = new IVoter.MarketSide[](4);\n    address[] memory rewardAccumulators = new address[](4);\n    marketAddresses[0] = ethMarket;\n    marketSides[0] = IVoter.MarketSide.Supply;\n    marketAddresses[1] = ethMarket;\n    marketSides[1] = IVoter.MarketSide.Borrow;\n    marketAddresses[2] = btcMarket;\n    marketSides[2] = IVoter.MarketSide.Supply;\n    marketAddresses[3] = btcMarket;\n    marketSides[3] = IVoter.MarketSide.Borrow;\n\n    for (uint i = 0; i < 4; i++) {\n      RewardAccumulator newRewardAccumulator = new RewardAccumulator();\n      rewardAccumulators[i] = address(newRewardAccumulator);\n    }\n\n    voter.setMarketRewardAccumulators(marketAddresses, marketSides, rewardAccumulators);\n\n    bribeEthSupply = new MockBribeRewards();\n    bribeEthBorrow = new MockBribeRewards();\n    bribeBtcSupply = new MockBribeRewards();\n    bribeBtcBorrow = new MockBribeRewards();\n\n    address[] memory rewardAccumulatorsForBribes = new address[](4);\n    address[] memory bribes = new address[](4);\n\n    rewardAccumulatorsForBribes[0] = rewardAccumulators[0];\n    bribes[0] = address(bribeEthSupply);\n    rewardAccumulatorsForBribes[1] = rewardAccumulators[1];\n    bribes[1] = address(bribeEthBorrow);\n    rewardAccumulatorsForBribes[2] = rewardAccumulators[2];\n    bribes[2] = address(bribeBtcSupply);\n    rewardAccumulatorsForBribes[3] = rewardAccumulators[3];\n    bribes[3] = address(bribeBtcBorrow);\n    voter.setBribes(rewardAccumulatorsForBribes, bribes);\n\n    voter.setMaxVotingNum(20);\n    address[] memory lpTokens = new address[](2);\n    lpTokens[0] = address(modeVelodrome5050IonMode);\n    lpTokens[1] = address(modeBalancer8020IonEth);\n\n    voter.setLpTokens(lpTokens);\n    user = address(0x9523);\n    vm.warp(block.timestamp + 10 * 365 days);\n\n    voterLockInfoSingleLp = _createLockInternal(user);\n    voterLockInfoMultiLp = _createLockMultipleInternal(user);\n\n    voterTokenIdSingleLp = voterLockInfoSingleLp.tokenId;\n    voterTokenIdMultiLp = voterLockInfoMultiLp.tokenId;\n\n    IveION(ve).setVoter(address(voter));\n  }\n\n  function afterForkSetUp() internal virtual override {\n    _afterForkSetUpBase();\n\n    ethMarket = 0x49420311B518f3d0c94e897592014de53831cfA3;\n    btcMarket = 0x1De166df671AE6DB4C4C98903df88E8007593748;\n\n    address[] memory _tokens = new address[](1);\n    _tokens[0] = address(0x0FAc819628a7F612AbAc1CaD939768058cc0170c);\n\n    mpo = MasterPriceOracle(0x1D89E5ba287E67AC0046D2218Be5fE1382cE47b4);\n    IERC20 ion = IERC20(0x3eE5e23eEE121094f1cFc0Ccc79d6C809Ebd22e5);\n\n    voter = Voter(\n      address(\n        new TransparentUpgradeableProxy(\n          address(new Voter()),\n          address(new ProxyAdmin()),\n          abi.encodeWithSelector(Voter.initialize.selector, _tokens, mpo, address(ion), address(ve))\n        )\n      )\n    );\n\n    IVoter.Market[] memory markets = new IVoter.Market[](4);\n    markets[0] = IVoter.Market(ethMarket, IVoter.MarketSide.Supply);\n    markets[1] = IVoter.Market(ethMarket, IVoter.MarketSide.Borrow);\n    markets[2] = IVoter.Market(btcMarket, IVoter.MarketSide.Supply);\n    markets[3] = IVoter.Market(btcMarket, IVoter.MarketSide.Borrow);\n    voter.addMarkets(markets);\n\n    address[] memory marketAddresses = new address[](4);\n    IVoter.MarketSide[] memory marketSides = new IVoter.MarketSide[](4);\n    address[] memory rewardAccumulators = new address[](4);\n    marketAddresses[0] = ethMarket;\n    marketSides[0] = IVoter.MarketSide.Supply;\n    marketAddresses[1] = ethMarket;\n    marketSides[1] = IVoter.MarketSide.Borrow;\n    marketAddresses[2] = btcMarket;\n    marketSides[2] = IVoter.MarketSide.Supply;\n    marketAddresses[3] = btcMarket;\n    marketSides[3] = IVoter.MarketSide.Borrow;\n\n    for (uint i = 0; i < 4; i++) {\n      RewardAccumulator newRewardAccumulator = new RewardAccumulator();\n      rewardAccumulators[i] = address(newRewardAccumulator);\n    }\n\n    voter.setMarketRewardAccumulators(marketAddresses, marketSides, rewardAccumulators);\n\n    bribeEthSupply = new MockBribeRewards();\n    bribeEthBorrow = new MockBribeRewards();\n    bribeBtcSupply = new MockBribeRewards();\n    bribeBtcBorrow = new MockBribeRewards();\n    address[] memory rewardAccumulatorsForBribes = new address[](4);\n    address[] memory bribes = new address[](4);\n    rewardAccumulatorsForBribes[0] = rewardAccumulators[0];\n    bribes[0] = address(bribeEthSupply);\n    rewardAccumulatorsForBribes[1] = rewardAccumulators[1];\n    bribes[1] = address(bribeEthBorrow);\n    rewardAccumulatorsForBribes[2] = rewardAccumulators[2];\n    bribes[2] = address(bribeBtcSupply);\n    rewardAccumulatorsForBribes[3] = rewardAccumulators[3];\n    bribes[3] = address(bribeBtcBorrow);\n    voter.setBribes(rewardAccumulatorsForBribes, bribes);\n\n    voter.setMaxVotingNum(20);\n\n    address[] memory lpTokens = new address[](2);\n    lpTokens[0] = address(ionWeth5050lPAero);\n    lpTokens[1] = address(wethAero5050LPAero);\n    voter.setLpTokens(lpTokens);\n\n    IveION(ve).setVoter(address(voter));\n\n    baseTokenIdSingleLp = _lockSingleLPFork(baseUser, REAL_LP_LOCK_AMOUNT);\n  }\n\n  function _vote(address _user, uint256 _tokenId, uint256[] memory weights) internal {\n    address[] memory selectedMarkets = new address[](4);\n    IVoter.MarketSide[] memory selectedSides = new IVoter.MarketSide[](4);\n    uint256[] memory selectedWeights = new uint256[](4);\n\n    selectedMarkets[0] = ethMarket;\n    selectedSides[0] = IVoter.MarketSide.Supply;\n    selectedWeights[0] = weights[0];\n\n    selectedMarkets[1] = btcMarket;\n    selectedSides[1] = IVoter.MarketSide.Supply;\n    selectedWeights[1] = weights[1];\n\n    selectedMarkets[2] = ethMarket;\n    selectedSides[2] = IVoter.MarketSide.Borrow;\n    selectedWeights[2] = weights[2];\n\n    selectedMarkets[3] = btcMarket;\n    selectedSides[3] = IVoter.MarketSide.Borrow;\n    selectedWeights[3] = weights[3];\n\n    vm.prank(_user);\n    voter.vote(_tokenId, selectedMarkets, selectedSides, selectedWeights);\n  }\n}\n"
    },
    "contracts/test/veION/harness/veIONHarness.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport \"../../../veION/veION.sol\";\n\n// This harness contract can be used for testing purposes.\ncontract veIONHarness is veION {\n  constructor(uint256 _minimumLockDuration) {\n    s_minimumLockDuration = _minimumLockDuration;\n  }\n\n  function exposed_calculateBoost(uint256 _duration) external view returns (uint256) {\n    return _calculateBoost(_duration);\n  }\n}\n"
    },
    "contracts/test/veION/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport \"../config/BaseTest.t.sol\";\nimport \"../../veION/veION.sol\";\nimport \"../../veION/veIONFirstExtension.sol\";\nimport \"../../veION/veIONSecondExtension.sol\";\nimport \"../../veION/interfaces/IveION.sol\";\n// import \"../../veION/interfaces/IveIONCore.sol\";\nimport \"../../veION/stake/IStakeStrategy.sol\";\nimport \"../../veION/stake/velo/VeloAeroStakingStrategy.sol\";\nimport \"../../veION/stake/IStakeStrategy.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AddressesProvider } from \"../../ionic/AddressesProvider.sol\";\nimport \"../../veION/stake/velo/VeloAeroStakingStrategy.sol\";\nimport \"../../veION/stake/velo/VeloAeroStakingWallet.sol\";\nimport \"../../veION/stake/velo/IVeloIonModeStaking.sol\";\nimport \"./harness/veIONHarness.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract veIONTest is BaseTest {\n  using Strings for uint256;\n  using Strings for bool;\n  using Strings for address;\n\n  address ve;\n  address veFirstExtension;\n  address veSecondExtension;\n  MockERC20 modeVelodrome5050IonMode;\n  MockERC20 modeBalancer8020IonEth;\n  MockERC20 baseAerodrome5050IonWstEth;\n  MockERC20 baseBalancer8020IonEth;\n  MockERC20 optimismVelodrome5050IonOp;\n  MockERC20 optimismBalancer8020IonEth;\n  IveIONStructsEnumsErrorsEvents.LpTokenType veloLpType;\n  IveIONStructsEnumsErrorsEvents.LpTokenType balancerLpType;\n  VeloAeroStakingWallet veloStakingWalletImplementation;\n  veIONHarness harness;\n\n  address ionMode5050LP;\n  address ionWeth5050lPAero;\n  address wethAero5050LPAero;\n  address veloGauge;\n  VeloAeroStakingStrategy veloIonModeStakingStrategy;\n  VeloAeroStakingStrategy veloWethUsdcStakingStrategy;\n  address stakingWalletInstance;\n  uint256 stakingWalletInstanceBalance;\n\n  address wethUSDC5050LP;\n  address wethUSDCGauge;\n\n  // Base Fork Vars\n  address baseUser;\n  uint256 baseTokenIdSingleLp;\n\n  uint256 internal constant MINT_AMT = 1000 ether;\n  uint256 internal constant WEEK = 1 weeks;\n  uint256 internal constant MAXTIME = 2 * 365 * 86400;\n  uint256 internal constant MINTIME = 180 * 86400;\n  uint256 internal constant EARLY_WITHDRAW_FEE = 0.8e18;\n  uint256 internal constant MINIMUM_LOCK_AMOUNT = 10e18;\n  uint256 internal constant REAL_LP_LOCK_AMOUNT = 10e18;\n\n  function _setUp() internal virtual {\n    ve = address(\n      new TransparentUpgradeableProxy(\n        address(new veION()),\n        address(new ProxyAdmin()),\n        abi.encodeWithSelector(veION.initialize.selector, address(ap))\n      )\n    );\n\n    veFirstExtension = address(new veIONFirstExtension());\n    veSecondExtension = address(new veIONSecondExtension());\n    IveIONCore(ve).setExtensions(veFirstExtension, veSecondExtension);\n\n    modeVelodrome5050IonMode = new MockERC20(\"Mode_Velodrome_5050_ION_MODE\", \"MV5050\", 18);\n    modeBalancer8020IonEth = new MockERC20(\"Mode_Balancer_8020_ION_ETH\", \"MB8020\", 18);\n\n    harness = new veIONHarness(MINTIME);\n\n    address[] memory whitelistedTokens = new address[](2);\n    bool[] memory isWhitelistedTokens = new bool[](2);\n\n    whitelistedTokens[0] = address(modeVelodrome5050IonMode);\n    whitelistedTokens[1] = address(modeBalancer8020IonEth);\n\n    for (uint i = 0; i < 2; i++) {\n      isWhitelistedTokens[i] = true;\n    }\n    IveION(ve).whitelistTokens(whitelistedTokens, isWhitelistedTokens);\n\n    IveION(ve).setLpTokenType(\n      address(modeVelodrome5050IonMode),\n      IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Velodrome_5050_ION_MODE\n    );\n    IveION(ve).setLpTokenType(\n      address(modeBalancer8020IonEth),\n      IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Balancer_8020_ION_ETH\n    );\n\n    veloLpType = IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Velodrome_5050_ION_MODE;\n    balancerLpType = IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Balancer_8020_ION_ETH;\n\n    veloStakingWalletImplementation = new VeloAeroStakingWallet();\n\n    IveION(ve).setMaxEarlyWithdrawFee(EARLY_WITHDRAW_FEE);\n    IveION(ve).setMinimumLockDuration(MINTIME);\n    IveION(ve).setMinimumLockAmount(address(modeVelodrome5050IonMode), MINIMUM_LOCK_AMOUNT);\n    IveION(ve).setMinimumLockAmount(address(modeBalancer8020IonEth), MINIMUM_LOCK_AMOUNT);\n  }\n\n  function _afterForkSetUpMode() internal {\n    ve = address(\n      new TransparentUpgradeableProxy(\n        address(new veION()),\n        address(new ProxyAdmin()),\n        abi.encodeWithSelector(veION.initialize.selector, address(ap))\n      )\n    );\n\n    veFirstExtension = address(new veIONFirstExtension());\n    veSecondExtension = address(new veIONSecondExtension());\n    IveIONCore(ve).setExtensions(veFirstExtension, veSecondExtension);\n\n    ionMode5050LP = 0x690A74d2eC0175a69C0962B309E03021C0b5002E;\n    veloGauge = 0x8EE410cC13948e7e684ebACb36b552e2c2A125fC;\n\n    wethUSDC5050LP = 0x283bA4E204DFcB6381BCBf2cb5d0e765A2B57bC2;\n    wethUSDCGauge = 0x98d34C7b004688F35b67Aa30D4dF5E67113f6B3D;\n\n    veloStakingWalletImplementation = new VeloAeroStakingWallet();\n\n    veloIonModeStakingStrategy = VeloAeroStakingStrategy(\n      address(\n        new TransparentUpgradeableProxy(\n          address(new VeloAeroStakingStrategy()),\n          address(new ProxyAdmin()),\n          abi.encodeWithSelector(\n            VeloAeroStakingStrategy.initialize.selector,\n            address(ve),\n            ionMode5050LP,\n            veloGauge,\n            address(veloStakingWalletImplementation)\n          )\n        )\n      )\n    );\n\n    veloWethUsdcStakingStrategy = VeloAeroStakingStrategy(\n      address(\n        new TransparentUpgradeableProxy(\n          address(new VeloAeroStakingStrategy()),\n          address(new ProxyAdmin()),\n          abi.encodeWithSelector(\n            VeloAeroStakingStrategy.initialize.selector,\n            address(ve),\n            wethUSDC5050LP,\n            wethUSDCGauge,\n            address(veloStakingWalletImplementation)\n          )\n        )\n      )\n    );\n\n    address[] memory whitelistedTokens = new address[](2);\n    bool[] memory isWhitelistedTokens = new bool[](2);\n    whitelistedTokens[0] = ionMode5050LP;\n    isWhitelistedTokens[0] = true;\n    whitelistedTokens[1] = wethUSDC5050LP;\n    isWhitelistedTokens[1] = true;\n\n    IveION(ve).whitelistTokens(whitelistedTokens, isWhitelistedTokens);\n    IveION(ve).setLpTokenType(ionMode5050LP, IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Velodrome_5050_ION_MODE);\n    IveION(ve).setLpTokenType(wethUSDC5050LP, IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Balancer_8020_ION_ETH);\n\n    veloLpType = IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Velodrome_5050_ION_MODE;\n    balancerLpType = IveIONStructsEnumsErrorsEvents.LpTokenType.Mode_Balancer_8020_ION_ETH;\n\n    IveION(ve).setStakeStrategy(veloLpType, IStakeStrategy(veloIonModeStakingStrategy));\n    IveION(ve).setStakeStrategy(balancerLpType, IStakeStrategy(veloWethUsdcStakingStrategy));\n\n    IveION(ve).setMaxEarlyWithdrawFee(EARLY_WITHDRAW_FEE);\n    IveION(ve).setMinimumLockDuration(MINTIME);\n    IveION(ve).setMinimumLockAmount(address(ionMode5050LP), MINIMUM_LOCK_AMOUNT);\n    IveION(ve).setMinimumLockAmount(address(wethUSDC5050LP), MINIMUM_LOCK_AMOUNT);\n  }\n\n  function _afterForkSetUpBase() internal {\n    baseUser = address(0x987);\n    ve = address(\n      new TransparentUpgradeableProxy(\n        address(new veION()),\n        address(new ProxyAdmin()),\n        abi.encodeWithSelector(veION.initialize.selector, address(ap))\n      )\n    );\n\n    veFirstExtension = address(new veIONFirstExtension());\n    veSecondExtension = address(new veIONSecondExtension());\n    IveIONCore(ve).setExtensions(veFirstExtension, veSecondExtension);\n\n    harness = new veIONHarness(MINTIME);\n\n    ionWeth5050lPAero = 0x0FAc819628a7F612AbAc1CaD939768058cc0170c;\n    wethAero5050LPAero = 0x7f670f78B17dEC44d5Ef68a48740b6f8849cc2e6;\n\n    address[] memory whitelistedTokens = new address[](2);\n    bool[] memory isWhitelistedTokens = new bool[](2);\n    whitelistedTokens[0] = ionWeth5050lPAero;\n    isWhitelistedTokens[0] = true;\n    whitelistedTokens[1] = wethAero5050LPAero;\n    isWhitelistedTokens[1] = true;\n\n    IveION(ve).whitelistTokens(whitelistedTokens, isWhitelistedTokens);\n    IveION(ve).setLpTokenType(\n      ionWeth5050lPAero,\n      IveIONStructsEnumsErrorsEvents.LpTokenType.Base_Aerodrome_5050_ION_wstETH\n    );\n    IveION(ve).setLpTokenType(\n      wethAero5050LPAero,\n      IveIONStructsEnumsErrorsEvents.LpTokenType.Base_Balancer_8020_ION_ETH\n    );\n\n    IveION(ve).setMaxEarlyWithdrawFee(EARLY_WITHDRAW_FEE);\n    IveION(ve).setMinimumLockDuration(MINTIME);\n    IveION(ve).setMinimumLockAmount(address(ionWeth5050lPAero), MINIMUM_LOCK_AMOUNT);\n    IveION(ve).setMinimumLockAmount(address(wethAero5050LPAero), MINIMUM_LOCK_AMOUNT);\n  }\n\n  function _lockSingleLPFork(address _user, uint256 _amount) internal returns (uint256) {\n    address whale = 0x9b42e5F8c45222b2715F804968251c747c588fd7;\n    vm.prank(whale);\n    IERC20(ionWeth5050lPAero).transfer(_user, _amount);\n\n    address[] memory tokenAddresses = new address[](1);\n    uint256[] memory tokenAmounts = new uint256[](1);\n    uint256[] memory durations = new uint256[](1);\n    bool[] memory stakeUnderlying = new bool[](1);\n    tokenAddresses[0] = address(ionWeth5050lPAero);\n    tokenAmounts[0] = _amount;\n    durations[0] = 52 weeks;\n    stakeUnderlying[0] = false;\n\n    vm.startPrank(_user);\n    IERC20(ionWeth5050lPAero).approve(address(ve), _amount);\n    uint256 tokenId = IveION(ve).createLock(tokenAddresses, tokenAmounts, durations, stakeUnderlying);\n    vm.stopPrank();\n\n    return tokenId;\n  }\n\n  function _lockMultiLpFork(address _user, uint256 _amountIonWeth, uint256 _amountWethAERO) internal returns (uint256) {\n    address ionWethWhale = 0x9b42e5F8c45222b2715F804968251c747c588fd7;\n    address wethAEROWhale = 0x96a24aB830D4ec8b1F6f04Ceac104F1A3b211a01;\n\n    vm.prank(ionWethWhale);\n    IERC20(ionWeth5050lPAero).transfer(_user, _amountIonWeth);\n    vm.prank(wethAEROWhale);\n    IERC20(wethAero5050LPAero).transfer(_user, _amountWethAERO);\n\n    address[] memory tokenAddresses = new address[](2);\n    uint256[] memory tokenAmounts = new uint256[](2);\n    uint256[] memory durations = new uint256[](2);\n    bool[] memory stakeUnderlying = new bool[](2);\n    tokenAddresses[0] = address(ionWeth5050lPAero);\n    tokenAmounts[0] = _amountIonWeth;\n    durations[0] = 52 weeks;\n    stakeUnderlying[0] = false;\n    tokenAddresses[1] = address(wethAero5050LPAero);\n    tokenAmounts[1] = _amountWethAERO;\n    durations[1] = 52 weeks;\n    stakeUnderlying[1] = false;\n\n    vm.startPrank(_user);\n    IERC20(ionWeth5050lPAero).approve(address(ve), _amountIonWeth);\n    IERC20(wethAero5050LPAero).approve(address(ve), _amountWethAERO);\n    uint256 tokenId = IveION(ve).createLock(tokenAddresses, tokenAmounts, durations, stakeUnderlying);\n    vm.stopPrank();\n\n    return tokenId;\n  }\n\n  function _createLockInternal(address user) internal returns (LockInfo memory) {\n    TestVars memory vars;\n    vars.user = user;\n    vars.amount = MINT_AMT;\n    modeVelodrome5050IonMode.mint(vars.user, vars.amount);\n\n    vm.startPrank(vars.user);\n    modeVelodrome5050IonMode.approve(address(ve), vars.amount);\n    vm.stopPrank();\n\n    vars.tokenAddresses = new address[](1);\n    vars.tokenAddresses[0] = address(modeVelodrome5050IonMode);\n\n    vars.tokenAmounts = new uint256[](1);\n    vars.tokenAmounts[0] = vars.amount;\n\n    vars.durations = new uint256[](1);\n    vars.durations[0] = 52 weeks;\n\n    vm.startPrank(vars.user);\n    uint256 tokenId = IveION(ve).createLock(vars.tokenAddresses, vars.tokenAmounts, vars.durations, new bool[](1));\n    vm.stopPrank();\n\n    return LockInfo(tokenId, vars.tokenAddresses[0], vars.tokenAmounts[0], vars.durations[0]);\n  }\n\n  function _createLockMultipleInternal(address user) internal returns (LockInfoMultiple memory) {\n    TestVars memory vars;\n    vars.user = user;\n\n    vars.amount = MINT_AMT;\n    modeVelodrome5050IonMode.mint(vars.user, vars.amount);\n    modeBalancer8020IonEth.mint(vars.user, vars.amount);\n\n    vm.startPrank(vars.user);\n    modeVelodrome5050IonMode.approve(address(ve), vars.amount);\n    modeBalancer8020IonEth.approve(address(ve), vars.amount);\n    vm.stopPrank();\n\n    vars.tokenAddresses = new address[](2);\n    vars.tokenAddresses[0] = address(modeVelodrome5050IonMode);\n    vars.tokenAddresses[1] = address(modeBalancer8020IonEth);\n\n    vars.tokenAmounts = new uint256[](2);\n    vars.tokenAmounts[0] = vars.amount;\n    vars.tokenAmounts[1] = vars.amount;\n\n    vars.durations = new uint256[](2);\n    vars.durations[0] = 52 weeks;\n    vars.durations[1] = 52 weeks;\n\n    vm.startPrank(vars.user);\n    vars.tokenId = IveION(ve).createLock(vars.tokenAddresses, vars.tokenAmounts, vars.durations, new bool[](2));\n    vm.stopPrank();\n\n    return LockInfoMultiple(vars.tokenId, vars.tokenAddresses, vars.tokenAmounts, vars.durations);\n  }\n\n  function _createLockInternalRealLP(address _user, bool _stakeUnderlying) internal returns (LockInfo memory) {\n    uint256 amountStaked = REAL_LP_LOCK_AMOUNT;\n    address whale = 0x8ff8b21a0736738b25597D32d8f7cf658f39f157;\n    vm.prank(whale);\n    IERC20(ionMode5050LP).transfer(_user, amountStaked);\n\n    address[] memory tokenAddresses = new address[](1);\n    tokenAddresses[0] = address(ionMode5050LP);\n\n    uint256[] memory tokenAmounts = new uint256[](1);\n    tokenAmounts[0] = amountStaked;\n\n    uint256[] memory durations = new uint256[](1);\n    durations[0] = 52 weeks;\n\n    bool[] memory stakeUnderlying = new bool[](1);\n    stakeUnderlying[0] = _stakeUnderlying;\n\n    vm.startPrank(_user);\n    IERC20(ionMode5050LP).approve(address(ve), amountStaked);\n    uint256 tokenId = IveION(ve).createLock(tokenAddresses, tokenAmounts, durations, stakeUnderlying);\n    vm.stopPrank();\n\n    return LockInfo(tokenId, tokenAddresses[0], tokenAmounts[0], durations[0]);\n  }\n\n  function _generateRandomAddress(uint256 seed) internal pure returns (address) {\n    return address(uint160(uint256(keccak256(abi.encodePacked(seed)))));\n  }\n\n  function _logTokens(uint256[] memory tokenIds, address[] memory lpTokens) internal view {\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      for (uint256 j = 0; j < lpTokens.length; j++) {\n        IveIONStructsEnumsErrorsEvents.LockedBalance memory lock = IveION(ve).getUserLock(\n          tokenIds[i],\n          IveION(ve).s_lpType(lpTokens[j])\n        );\n        uint256 tokenId = i + 1;\n        console.log(\n          string(abi.encodePacked(\"Token ID \", tokenId.toString(), \" Locked Token: \", lock.tokenAddress.toHexString()))\n        );\n        console.log(\n          string(abi.encodePacked(\"Token ID \", tokenId.toString(), \" Locked Amount: \", lock.amount.toString()))\n        );\n        console.log(\n          string(\n            abi.encodePacked(\n              \"Token ID \",\n              tokenId.toString(),\n              \" Locked Delegate Amount: \",\n              lock.delegateAmount.toString()\n            )\n          )\n        );\n        console.log(\n          string(abi.encodePacked(\"Token ID \", tokenId.toString(), \" Locked Start: \", lock.start.toString()))\n        );\n        console.log(string(abi.encodePacked(\"Token ID \", tokenId.toString(), \" Locked End: \", lock.end.toString())));\n        console.log(\n          string(\n            abi.encodePacked(\n              \"Token ID \",\n              tokenId.toString(),\n              \" Locked IsPermanent: \",\n              lock.isPermanent ? \"true\" : \"false\"\n            )\n          )\n        );\n        console.log(\n          string(abi.encodePacked(\"Token ID \", tokenId.toString(), \" Locked Boost: \", lock.boost.toString()))\n        );\n        console.log(\"--------------------------------------------------\");\n      }\n      console.log(\"====================================================\");\n    }\n  }\n\n  function _logCumulativeAssetValues(address[] memory users, address[] memory lpTokens) internal view {\n    console.log(\"-----------------------------------------------------------------\");\n    for (uint256 i = 0; i < users.length; i++) {\n      address user = users[i];\n      console.log(\"Cumulative Asset Values for User:\", user);\n      for (uint256 j = 0; j < lpTokens.length; j++) {\n        console.log(\"Token:\", lpTokens[j], \"Value:\", IveION(ve).s_userCumulativeAssetValues(user, lpTokens[j]));\n      }\n      console.log(\"====================================================\");\n    }\n  }\n\n  function _logUnderlyingStake(address[] memory users) internal view {\n    console.log(\"-----------------------------------------------------------------\");\n    for (uint256 i = 0; i < users.length; i++) {\n      address user = users[i];\n      console.log(\"Underlying Stakes For:\", user);\n      address stakingWalletInstanceIonMode = veloIonModeStakingStrategy.userStakingWallet(user);\n      uint256 stakedBalanceIonMode = veloIonModeStakingStrategy.balanceOf(stakingWalletInstanceIonMode);\n\n      address stakingWalletInstanceWethUsdc = veloWethUsdcStakingStrategy.userStakingWallet(user);\n      uint256 stakedBalanceWethUsdc = veloWethUsdcStakingStrategy.balanceOf(stakingWalletInstanceWethUsdc);\n\n      console.log(\"Staked Balance Ion-Mode:\", stakedBalanceIonMode);\n      console.log(\"Staked Balance Weth-Usdc:\", stakedBalanceWethUsdc);\n      console.log(\"====================================================\");\n    }\n  }\n}\n\nstruct TestVars {\n  address user;\n  address user2;\n  uint256 amount;\n  address[] tokenAddresses;\n  uint256[] tokenAmounts;\n  uint256[] durations;\n  bool[] stakeUnderlying;\n  uint256 tokenId;\n  uint256 secondTokenId;\n  uint256 expectedSupply;\n  uint256 userEpoch;\n  uint256 globalEpoch;\n  address lockedBalance_tokenAddress;\n  uint256 lockedBalance_amount;\n  uint256 delegated_lockedBalance_amount;\n  uint256 lockedBalance_start;\n  uint256 lockedBalance_end;\n  bool lockedBalance_isPermanent;\n  uint256 lockedBalance_boost;\n  uint256 userPoint_bias;\n  uint256 userPoint_slope;\n  uint256 userPoint_ts;\n  uint256 userPoint_blk;\n  uint256 userPoint_permanent;\n  uint256 userPoint_permanentDelegate;\n  int128 globalPoint_bias;\n  int128 globalPoint_slope;\n  uint256 globalPoint_ts;\n  uint256 globalPoint_blk;\n  uint256 globalPoint_permanentLockBalance;\n  uint256[] ownerTokenIds;\n  address[] assetsLocked;\n  uint256 tokenId_test;\n  address lockedBalance_tokenAddress_test;\n  uint256 lockedBalance_amount_test;\n  uint256 lockedBalance_duration_test;\n  uint256 lockedBalance_end_test;\n}\n\nstruct LockInfo {\n  uint256 tokenId;\n  address tokenAddress;\n  uint256 tokenAmount;\n  uint256 duration;\n}\n\nstruct LockInfoMultiple {\n  uint256 tokenId;\n  address[] tokenAddresses;\n  uint256[] tokenAmounts;\n  uint256[] durations;\n}\n\nstruct AeroBoostVars {\n  uint256 aeroVoterBoost;\n  address aeroVotingAddress;\n  address ionicPoolAddress;\n  address veAEROAddress;\n  address AERO;\n  uint256 lockAmount;\n  address aeroWhale;\n  uint256 veAeroTokenId;\n  address[] poolVote;\n  uint256[] weights;\n}\n\ninterface IveAERO {\n  /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lockDuration`\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  /// @return TokenId of created veNFT\n  function createLock(uint256 _value, uint256 _lockDuration) external returns (uint256);\n}\n\ninterface IAEROVoter {\n  /// @notice Called by users to vote for pools. Votes distributed proportionally based on weights.\n  ///         Can only vote or deposit into a managed NFT once per epoch.\n  ///         Can only vote for gauges that have not been killed.\n  /// @dev Weights are distributed proportional to the sum of the weights in the array.\n  ///      Throws if length of _poolVote and _weights do not match.\n  /// @param _tokenId     Id of veNFT you are voting with.\n  /// @param _poolVote    Array of pools you are voting for.\n  /// @param _weights     Weights of pools.\n  function vote(uint256 _tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external;\n\n  /// @notice Returns the number of votes for a given veNFT token ID and pool address.\n  /// @param _tokenId The ID of the veNFT.\n  /// @param _pool The address of the pool.\n  /// @return The number of votes for the given token ID and pool.\n  function votes(uint256 _tokenId, address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/veION/BribeRewards.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IBribeRewards } from \"./interfaces/IBribeRewards.sol\";\nimport { IVoter } from \"./interfaces/IVoter.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { IonicTimeLibrary } from \"./libraries/IonicTimeLibrary.sol\";\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\n\n/**\n * @title BribeRewards Contract\n * @notice This contract allows veION to benefit from bribes when voting for various markets\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract BribeRewards is IBribeRewards, ReentrancyGuardUpgradeable, Ownable2StepUpgradeable {\n  using SafeERC20 for IERC20;\n\n  // \n  //                            State Variables                                 \n  // \n  /// @notice Duration of the reward period in seconds\n  uint256 public constant DURATION = 7 days;\n  /// @notice Address of the voter contract\n  address public voter;\n  /// @notice Address of the veION contract\n  address public ve;\n  /// @notice List of reward tokens\n  address[] public rewards;\n\n  // \n  //                                 Mappings                                   \n  // \n  /// @notice Mapping to check if an address is a reward token\n  mapping(address => bool) public isReward;\n  /// @notice Total supply of LP tokens for each reward token\n  mapping(address => uint256) public totalSupply;\n  /// @notice Balance of LP tokens for each tokenId and reward token\n  mapping(uint256 => mapping(address => uint256)) public balanceOf;\n  /// @notice Rewards per epoch for each reward token\n  mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\n  /// @notice Last earned timestamp for each reward token and tokenId\n  mapping(address => mapping(uint256 => uint256)) public lastEarn;\n  /// @notice A record of balance checkpoints for each account, by index\n  mapping(uint256 => mapping(address => mapping(uint256 => Checkpoint))) public checkpoints;\n  /// @notice The number of checkpoints for each account\n  mapping(uint256 => mapping(address => uint256)) public numCheckpoints;\n  /// @notice A record of balance checkpoints for each token, by index\n  mapping(uint256 => mapping(address => SupplyCheckpoint)) public supplyCheckpoints;\n  /// @notice The number of supply checkpoints for each token\n  mapping(address => uint256) public supplyNumCheckpoints;\n  /// @notice Historical prices for each reward token and epoch\n  mapping(address => mapping(uint256 => uint256)) public historicalPrices;\n\n  /**\n   * @notice Modifier to restrict access to only the voter contract\n   * @dev Ensures that the caller is the voter contract\n   */\n  modifier onlyVoter() {\n    require(msg.sender == voter, \"Caller is not the voter\");\n    _;\n  }\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /**\n   * @notice Initializes the BribeRewards contract with the voter and veION addresses\n   * @dev This function is called only once during contract deployment\n   * @param _voter The address of the voter contract\n   * @param _ve The address of the veION contract\n   */\n  function initialize(address _voter, address _ve) public initializer {\n    __ReentrancyGuard_init();\n    __Ownable2Step_init();\n    voter = _voter;\n    ve = _ve;\n  }\n\n  // \n  //                            External Functions                              \n  // \n\n  /// @inheritdoc IBribeRewards\n  function deposit(address lpToken, uint256 amount, uint256 tokenId) external onlyVoter {\n    address sender = msg.sender;\n\n    totalSupply[lpToken] += amount;\n    balanceOf[tokenId][lpToken] += amount;\n\n    _writeCheckpoint(tokenId, lpToken, balanceOf[tokenId][lpToken]);\n    _writeSupplyCheckpoint(lpToken);\n\n    emit Deposit(sender, tokenId, amount);\n  }\n\n  /// @inheritdoc IBribeRewards\n  function withdraw(address lpToken, uint256 amount, uint256 tokenId) external onlyVoter {\n    address sender = msg.sender;\n\n    totalSupply[lpToken] -= amount;\n    balanceOf[tokenId][lpToken] -= amount;\n\n    _writeCheckpoint(tokenId, lpToken, balanceOf[tokenId][lpToken]);\n    _writeSupplyCheckpoint(lpToken);\n\n    emit Withdraw(sender, tokenId, amount);\n  }\n\n  /**\n   * @inheritdoc IBribeRewards\n   * @notice This function can accept any token, regardless of its whitelisting status.\n   * @dev If we were to check the whitelisting status, it could prevent tokens that were initially whitelisted and later de-whitelisted from having their rewards claimed, leading to unclaimable rewards.\n   */\n  function getReward(uint256 tokenId, address[] memory tokens) external nonReentrant onlyVoter {\n    address sender = msg.sender;\n    if (ERC721Upgradeable(ve).ownerOf(tokenId) != sender && sender != voter) revert Unauthorized();\n\n    address _owner = ERC721Upgradeable(ve).ownerOf(tokenId);\n    _getReward(_owner, tokenId, tokens);\n  }\n\n  /// @inheritdoc IBribeRewards\n  function notifyRewardAmount(address token, uint256 amount) external override nonReentrant {\n    address sender = msg.sender;\n\n    if (!isReward[token]) {\n      if (!IVoter(voter).isWhitelistedToken(token)) revert TokenNotWhitelisted();\n      isReward[token] = true;\n      rewards.push(token);\n    }\n\n    _notifyRewardAmount(sender, token, amount);\n  }\n\n  // \n  //                            Internal Functions                              \n  // \n\n  /// @dev used with all getReward implementations\n  function _getReward(address recipient, uint256 tokenId, address[] memory tokens) internal {\n    // check if token whitelisted\n    uint256 _length = tokens.length;\n    for (uint256 i = 0; i < _length; i++) {\n      uint256 _reward = earned(tokens[i], tokenId);\n      lastEarn[tokens[i]][tokenId] = block.timestamp;\n      if (_reward > 0) IERC20(tokens[i]).safeTransfer(recipient, _reward);\n\n      emit RewardsClaimed(recipient, tokens[i], _reward);\n    }\n  }\n\n  /**\n   * @notice Writes a new checkpoint for a token's balance\n   * @param tokenId The ID of the veION token\n   * @param lpToken The LP token address\n   * @param balance The balance to record\n   */\n  function _writeCheckpoint(uint256 tokenId, address lpToken, uint256 balance) internal {\n    uint256 _nCheckPoints = numCheckpoints[tokenId][lpToken];\n    uint256 _timestamp = block.timestamp;\n\n    if (\n      _nCheckPoints > 0 &&\n      IonicTimeLibrary.epochStart(checkpoints[tokenId][lpToken][_nCheckPoints - 1].timestamp) ==\n      IonicTimeLibrary.epochStart(_timestamp)\n    ) {\n      checkpoints[tokenId][lpToken][_nCheckPoints - 1] = Checkpoint(_timestamp, balance);\n    } else {\n      checkpoints[tokenId][lpToken][_nCheckPoints] = Checkpoint(_timestamp, balance);\n      numCheckpoints[tokenId][lpToken] = _nCheckPoints + 1;\n    }\n  }\n\n  /// @notice Writes a new checkpoint for total supply\n  /// @param lpToken The LP token address\n  function _writeSupplyCheckpoint(address lpToken) internal {\n    uint256 _nCheckPoints = supplyNumCheckpoints[lpToken];\n    uint256 _timestamp = block.timestamp;\n\n    if (\n      _nCheckPoints > 0 &&\n      IonicTimeLibrary.epochStart(supplyCheckpoints[_nCheckPoints - 1][lpToken].timestamp) ==\n      IonicTimeLibrary.epochStart(_timestamp)\n    ) {\n      supplyCheckpoints[_nCheckPoints - 1][lpToken] = SupplyCheckpoint(_timestamp, totalSupply[lpToken]);\n    } else {\n      supplyCheckpoints[_nCheckPoints][lpToken] = SupplyCheckpoint(_timestamp, totalSupply[lpToken]);\n      supplyNumCheckpoints[lpToken] = _nCheckPoints + 1;\n    }\n  }\n\n  /// @dev used within all notifyRewardAmount implementations\n  function _notifyRewardAmount(address sender, address token, uint256 amount) internal {\n    if (amount == 0) revert AmountCannotBeZero();\n    IERC20(token).safeTransferFrom(sender, address(this), amount);\n\n    uint256 epochStart = IonicTimeLibrary.epochStart(block.timestamp);\n    tokenRewardsPerEpoch[token][epochStart] += amount;\n\n    emit RewardNotification(sender, token, epochStart, amount);\n  }\n\n  /**\n   * @notice Calculates the ETH value of a token amount at a specific epoch\n   * @param amount The amount of tokens\n   * @param lpToken The LP token address\n   * @param epochTimestamp The timestamp of the epoch\n   * @return The ETH value of the tokens\n   */\n  function _getTokenEthValueAt(\n    uint256 amount,\n    address lpToken,\n    uint256 epochTimestamp\n  ) internal view returns (uint256) {\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\n    if (historicalPrices[lpToken][epochStart] == 0) revert HistoricalPriceNotSet(lpToken, epochStart);\n    uint256 _priceAtTimestamp = historicalPrices[lpToken][epochStart];\n    uint256 ethValue = (amount * _priceAtTimestamp) / 1e18;\n    return ethValue;\n  }\n\n  // \n  //                            Pure/View Functions                             \n  // \n\n  /// @notice Returns the total number of reward tokens\n  /// @return The length of the rewards array\n  function rewardsListLength() external view returns (uint256) {\n    return rewards.length;\n  }\n\n  /// @inheritdoc IBribeRewards\n  function earned(address token, uint256 tokenId) public view returns (uint256) {\n    EarnedVars memory vars;\n    vars.totalReward = 0;\n    address[] memory lpTokens = getAllLpRewardTokens();\n    uint256 lpTokensLength = lpTokens.length;\n    for (uint256 j = 0; j < lpTokensLength; j++) {\n      address lpToken = lpTokens[j];\n\n      if (numCheckpoints[tokenId][lpToken] == 0) {\n        continue;\n      }\n\n      vars.currTs = IonicTimeLibrary.epochStart(lastEarn[token][tokenId]);\n      vars.index = getPriorBalanceIndex(tokenId, lpToken, vars.currTs);\n      Checkpoint memory cp0 = checkpoints[tokenId][lpToken][vars.index];\n\n      vars.currTs = Math.max(vars.currTs, IonicTimeLibrary.epochStart(cp0.timestamp));\n      vars.numEpochs = (IonicTimeLibrary.epochStart(block.timestamp) - vars.currTs) / DURATION;\n\n      if (vars.numEpochs > 0) {\n        for (uint256 i = 0; i < vars.numEpochs; i++) {\n          vars.index = getPriorBalanceIndex(tokenId, lpToken, vars.currTs + DURATION - 1);\n          cp0 = checkpoints[tokenId][lpToken][vars.index];\n          vars.epochBalanceValue = _getTokenEthValueAt(cp0.balanceOf, lpToken, vars.currTs);\n\n          vars.supplyValue = 0;\n          for (uint256 k = 0; k < lpTokensLength; k++) {\n            address currentLpToken = lpTokens[k];\n            uint256 supplyAmount = Math.max(\n              supplyCheckpoints[getPriorSupplyIndex(vars.currTs + DURATION - 1, currentLpToken)][currentLpToken].supply,\n              1\n            );\n            vars.supplyValue += _getTokenEthValueAt(supplyAmount, currentLpToken, vars.currTs);\n          }\n          if (vars.supplyValue > 0) {\n            vars.totalReward += (vars.epochBalanceValue * tokenRewardsPerEpoch[token][vars.currTs]) / vars.supplyValue;\n          }\n          vars.currTs += DURATION;\n        }\n      }\n    }\n\n    return vars.totalReward;\n  }\n\n  /// @notice Gets all LP tokens that can receive rewards\n  /// @return Array of LP token addresses\n  function getAllLpRewardTokens() public view returns (address[] memory) {\n    return IVoter(voter).getAllLpRewardTokens();\n  }\n\n  /**\n   * @notice Sets historical prices for LP tokens at specific epochs\n   * @param epochTimestamp The timestamp of the epoch\n   * @param lpToken The LP token address\n   * @param price The price to set\n   */\n  function setHistoricalPrices(uint256 epochTimestamp, address lpToken, uint256 price) external onlyOwner {\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\n    historicalPrices[lpToken][epochStart] = price;\n    emit HistoricalPriceSet(epochTimestamp, lpToken, price);\n  }\n\n  /**\n   * @notice Gets a specific checkpoint for a token\n   * @param tokenId The ID of the veION token\n   * @param lpToken The LP token address\n   * @param index The index of the checkpoint to retrieve\n   * @return The checkpoint data\n   */\n  function getCheckpoint(uint256 tokenId, address lpToken, uint256 index) external view returns (Checkpoint memory) {\n    return checkpoints[tokenId][lpToken][index];\n  }\n\n  /// @inheritdoc IBribeRewards\n  function getPriorBalanceIndex(uint256 tokenId, address lpToken, uint256 timestamp) public view returns (uint256) {\n    uint256 nCheckpoints = numCheckpoints[tokenId][lpToken];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[tokenId][lpToken][nCheckpoints - 1].timestamp <= timestamp) {\n      return (nCheckpoints - 1);\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[tokenId][lpToken][0].timestamp > timestamp) {\n      return 0;\n    }\n\n    uint256 lower = 0;\n    uint256 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[tokenId][lpToken][center];\n      if (cp.timestamp == timestamp) {\n        return center;\n      } else if (cp.timestamp < timestamp) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return lower;\n  }\n\n  /// @inheritdoc IBribeRewards\n  function getPriorSupplyIndex(uint256 timestamp, address lpToken) public view returns (uint256) {\n    uint256 nCheckpoints = supplyNumCheckpoints[lpToken];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (supplyCheckpoints[nCheckpoints - 1][lpToken].timestamp <= timestamp) {\n      return (nCheckpoints - 1);\n    }\n\n    // Next check implicit zero balance\n    if (supplyCheckpoints[0][lpToken].timestamp > timestamp) {\n      return 0;\n    }\n\n    uint256 lower = 0;\n    uint256 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      SupplyCheckpoint memory cp = supplyCheckpoints[center][lpToken];\n      if (cp.timestamp == timestamp) {\n        return center;\n      } else if (cp.timestamp < timestamp) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return lower;\n  }\n}\n"
    },
    "contracts/veION/interfaces/IBribeRewards.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\ninterface IBribeRewards {\n  /// @notice A checkpoint for marking balance\n  struct Checkpoint {\n    uint256 timestamp;\n    uint256 balanceOf;\n  }\n\n  /// @notice A checkpoint for marking supply\n  struct SupplyCheckpoint {\n    uint256 timestamp;\n    uint256 supply;\n  }\n\n  struct EarnedVars {\n    uint256 totalReward;\n    uint256 reward;\n    uint256 supplyValue;\n    uint256 epochBalanceValue;\n    uint256 currTs;\n    uint256 index;\n    uint256 numEpochs;\n    uint256 overallBalance;\n    uint256 overallSupply;\n    uint256 historicalPrice;\n  }\n\n  error InvalidReward();\n  error Unauthorized();\n  error InvalidGauge();\n  error InvalidEscrowToken();\n  error SingleTokenExpected();\n  error InvalidVotingEscrow();\n  error TokenNotWhitelisted();\n  error AmountCannotBeZero();\n  error HistoricalPriceNotSet(address lpToken, uint256 epochStart);\n\n  event Deposit(address indexed user, uint256 indexed tokenId, uint256 amount);\n  event Withdraw(address indexed user, uint256 indexed tokenId, uint256 amount);\n  event RewardNotification(address indexed user, address indexed rewardToken, uint256 indexed epoch, uint256 amount);\n  event RewardsClaimed(address indexed user, address indexed rewardToken, uint256 amount);\n  event HistoricalPriceSet(uint256 indexed epochTimestamp, address indexed lpToken, uint256 price);\n\n  /// @notice Deposit an amount into the bribe rewards contract for a specific veNFT\n  /// @dev Can only be called internally by authorized entities.\n  /// @param lpToken  Address of the liquidity pool token\n  /// @param amount   Amount to be deposited for the veNFT\n  /// @param tokenId  Unique identifier of the veNFT\n  function deposit(address lpToken, uint256 amount, uint256 tokenId) external;\n\n  /// @notice Withdraw an amount from the bribe rewards contract for a specific veNFT\n  /// @dev Can only be called internally by authorized entities.\n  /// @param lpToken  Address of the liquidity pool token\n  /// @param amount   Amount to be withdrawn for the veNFT\n  /// @param tokenId  Unique identifier of the veNFT\n  function withdraw(address lpToken, uint256 amount, uint256 tokenId) external;\n\n  /// @notice Claim the rewards earned by a veNFT holder\n  /// @param tokenId  Unique identifier of the veNFT\n  /// @param tokens   Array of tokens to claim rewards for\n  function getReward(uint256 tokenId, address[] memory tokens) external;\n\n  /// @notice Notify the contract about new rewards for stakers\n  /// @param token    Address of the reward token\n  /// @param amount   Amount of the reward token to be added\n  function notifyRewardAmount(address token, uint256 amount) external;\n\n  /// @notice Get the prior balance index for a veNFT at a specific timestamp\n  /// @dev Timestamp must be in the past or present.\n  /// @param tokenId      The veNFT token ID to check\n  /// @param lpToken      Address of the liquidity pool token\n  /// @param timestamp    The timestamp to get the balance at\n  /// @return The balance index at the given timestamp\n  function getPriorBalanceIndex(uint256 tokenId, address lpToken, uint256 timestamp) external view returns (uint256);\n\n  /// @notice Get the prior supply index at a specific timestamp\n  /// @dev Timestamp must be in the past or present.\n  /// @param timestamp The timestamp to get the supply index at\n  /// @return The supply index at the given timestamp\n  function getPriorSupplyIndex(uint256 timestamp, address lpToken) external view returns (uint256);\n\n  /// @notice Calculate the rewards earned for a specific token and veNFT\n  /// @param token Address of the reward token\n  /// @param tokenId Unique identifier of the veNFT\n  /// @return Amount of the reward token earned\n  function earned(address token, uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/veION/interfaces/IveION.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../stake/IStakeStrategy.sol\";\nimport \"./IveIONCore.sol\";\nimport \"./IveIONFirstExtension.sol\";\nimport \"./IveIONSecondExtension.sol\";\n\n/// @title IveION Interface\n/// @notice Interface for veION contract\ninterface IveION is IveIONStructsEnumsErrorsEvents, IveIONCore, IveIONFirstExtension, IveIONSecondExtension {\n  // Constants\n  function PRECISION() external view returns (uint256);\n\n  // State Variables\n  function s_tokenId() external view returns (uint256);\n  function s_limitedBoost() external view returns (uint256);\n  function s_limitedBoostActive() external view returns (bool);\n  function s_veAERO() external view returns (address);\n  function s_aeroVoting() external view returns (address);\n  function s_ionicPool() external view returns (address);\n  function s_voter() external view returns (address);\n  function s_aeroVoterBoost() external view returns (uint256);\n  function s_minimumLockDuration() external view returns (uint256);\n  function s_maxEarlyWithdrawFee() external view returns (uint256);\n  function ap() external view returns (address);\n  function implementation() external view returns (address);\n\n  // Mappings\n  function s_minimumLockAmount(LpTokenType lpTokenType) external view returns (uint256);\n  function s_whitelistedToken(address token) external view returns (bool);\n  function s_lpType(address token) external view returns (LpTokenType);\n  function s_canSplit(address user) external view returns (bool);\n  function s_locked(uint256 tokenId, LpTokenType lpTokenType) external view returns (LockedBalance memory);\n  function s_userPointEpoch(uint256 tokenId, LpTokenType lpTokenType) external view returns (uint256);\n  function s_userPointHistory(\n    uint256 tokenId,\n    LpTokenType lpTokenType,\n    uint256 epoch\n  ) external view returns (UserPoint memory);\n  function s_voted(uint256 tokenId) external view returns (bool);\n  function s_supply(LpTokenType lpTokenType) external view returns (uint256);\n  function s_permanentLockBalance(LpTokenType lpTokenType) external view returns (uint256);\n  function s_stakeStrategy(LpTokenType lpTokenType) external view returns (address);\n  function s_underlyingStake(uint256 tokenId, address token) external view returns (uint256);\n  function s_protocolFees(LpTokenType lpTokenType) external view returns (uint256);\n  function s_distributedFees(LpTokenType lpTokenType) external view returns (uint256);\n  function s_delegations(\n    uint256 delegatorTokenId,\n    uint256 delegateeTokenId,\n    LpTokenType lpTokenType\n  ) external view returns (uint256);\n  function s_userCumulativeAssetValues(address user, address token) external view returns (uint256);\n  function s_delegatorsBlocked(uint256 tokenId, address token) external view returns (bool);\n\n  // Openzeppelin functions\n  function transferFrom(address from, address to, uint256 tokenId) external;\n  function ownerOf(uint256 tokenId) external returns (address);\n  function owner() external returns (address);\n  function balanceOf(address owner) external returns (uint256);\n}\n"
    },
    "contracts/veION/interfaces/IveIONCore.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../stake/IStakeStrategy.sol\";\n\n/// @title IveION Interface\n/// @notice Interface for veION contract\ninterface IveIONCore {\n  /**\n   * @notice Creates a new lock for multiple tokens and assigns it to a specified address\n   * @param _tokenAddress Array of token addresses to lock\n   * @param _tokenAmount Array of token amounts to lock\n   * @param _duration Array of lock durations\n   * @param _stakeUnderlying Array of booleans indicating whether to stake underlying tokens\n   * @param _to Address to assign the lock to\n   * @return The ID of the newly created veNFT\n   */\n  function createLockFor(\n    address[] memory _tokenAddress,\n    uint256[] memory _tokenAmount,\n    uint256[] memory _duration,\n    bool[] memory _stakeUnderlying,\n    address _to\n  ) external returns (uint256);\n\n  /**\n   * @notice Creates a new lock for multiple tokens\n   * @param _tokenAddress Array of token addresses to lock\n   * @param _tokenAmount Array of token amounts to lock\n   * @param _duration Array of lock durations\n   * @param _stakeUnderlying Array of booleans indicating whether to stake underlying tokens\n   * @return The ID of the newly created veNFT\n   */\n  function createLock(\n    address[] calldata _tokenAddress,\n    uint256[] calldata _tokenAmount,\n    uint256[] calldata _duration,\n    bool[] memory _stakeUnderlying\n  ) external returns (uint256);\n\n  /**\n   * @notice Increases the amount of tokens locked for a specific veNFT\n   * @param _tokenAddress Address of the token to increase lock amount for\n   * @param _tokenId ID of the veNFT\n   * @param _tokenAmount Amount of tokens to add to the lock\n   * @param _stakeUnderlying Whether to stake the underlying tokens\n   */\n  function increaseAmount(\n    address _tokenAddress,\n    uint256 _tokenId,\n    uint256 _tokenAmount,\n    bool _stakeUnderlying\n  ) external;\n\n  /**\n   * @notice Locks additional asset type for an existing veNFT\n   * @param _tokenAddress Address of the new token to lock\n   * @param _tokenAmount Amount of tokens to lock\n   * @param _tokenId ID of the veNFT\n   * @param _duration Duration of the lock\n   * @param _stakeUnderlying Whether to stake the underlying tokens\n   */\n  function lockAdditionalAsset(\n    address _tokenAddress,\n    uint256 _tokenAmount,\n    uint256 _tokenId,\n    uint256 _duration,\n    bool _stakeUnderlying\n  ) external;\n\n  /**\n   * @notice Increases the lock duration for a specific token in a veNFT\n   * @param _tokenAddress Address of the token\n   * @param _tokenId ID of the veNFT\n   * @param _lockDuration New lock duration to extend to\n   */\n  function increaseUnlockTime(address _tokenAddress, uint256 _tokenId, uint256 _lockDuration) external;\n\n  /**\n   * @notice Delegates voting power from one veNFT to another.\n   * @param fromTokenId The ID of the veNFT from which voting power is delegated.\n   * @param toTokenId The ID of the veNFT to which voting power is delegated.\n   * @param lpToken The address of the LP token associated with the delegation.\n   * @param amount The amount of voting power to delegate.\n   */\n  function delegate(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) external;\n\n  /**\n   * @notice Removes delegatees from a specific veNFT\n   * @param fromTokenId ID of the veNFT from which delegatees are removed\n   * @param toTokenIds Array of veNFT IDs that are delegatees to be removed\n   * @param lpToken Address of the LP token associated with the delegation\n   * @param amounts Array of amounts of voting power to remove from each delegatee\n   */\n  function removeDelegatees(\n    uint256 fromTokenId,\n    uint256[] memory toTokenIds,\n    address lpToken,\n    uint256[] memory amounts\n  ) external;\n\n  /**\n   * @notice Removes delegators from a specific veNFT\n   * @param fromTokenIds Array of veNFT IDs that are delegators to be removed\n   * @param toTokenId ID of the veNFT from which delegators are removed\n   * @param lpToken Address of the LP token associated with the delegation\n   * @param amounts Array of amounts of voting power to remove from each delegator\n   */\n  function removeDelegators(\n    uint256[] memory fromTokenIds,\n    uint256 toTokenId,\n    address lpToken,\n    uint256[] memory amounts\n  ) external;\n\n  /**\n   * @notice Locks a token permanently.\n   * @param _tokenAddress The address of the token to lock.\n   * @param _tokenId The ID of the token to lock.\n   */\n  function lockPermanent(address _tokenAddress, uint256 _tokenId) external;\n\n  /**\n   * @notice Unlocks a permanently locked token.\n   * @param _tokenAddress The address of the token to unlock.\n   * @param _tokenId The ID of the token to unlock.\n   */\n  function unlockPermanent(address _tokenAddress, uint256 _tokenId) external;\n\n  /**\n   * @notice Updates voting status for a veNFT\n   * @param _tokenId ID of the veNFT\n   * @param _voting Voting status\n   */\n  function voting(uint256 _tokenId, bool _voting) external;\n\n  /**\n   * @notice Sets the implementation addresses for the veION contract extensions.\n   * @dev This function can only be called by authorized entities.\n   * @param _veIONFirstExtension The address of the first extension contract.\n   * @param _veIONSecondExtension The address of the second extension contract.\n   */\n  function setExtensions(address _veIONFirstExtension, address _veIONSecondExtension) external;\n}\n\n/// @title IAeroVotingEscrow Interface\n/// @notice Interface for Aero Voting Escrow contract\ninterface IAeroVotingEscrow {\n  /**\n   * @notice Returns the balance of the specified owner.\n   * @param _owner The address of the owner.\n   * @return The balance of the owner.\n   */\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /**\n   * @notice Retrieves the token ID at a specific index for a given owner.\n   * @param _owner The address of the owner.\n   * @param _index The index of the token ID in the owner's list.\n   * @return The token ID at the specified index.\n   */\n  function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256);\n}\n\n/// @title IAeroVoter Interface\n/// @notice Interface for Aero Voter contract\ninterface IAeroVoter {\n  /**\n   * @notice Returns the list of pools voted for by a specific token ID.\n   * @param tokenId The ID of the token.\n   * @return An array of addresses representing the pools voted for.\n   */\n  function poolVote(uint256 tokenId) external view returns (address[] memory);\n\n  /**\n   * @notice Retrieves the weight of a specific pool.\n   * @param pool The address of the pool.\n   * @return The weight of the pool.\n   */\n  function weights(address pool) external view returns (uint256);\n\n  /**\n   * @notice Returns the number of votes a specific token ID has for a given pool.\n   * @param tokenId The ID of the token.\n   * @param pool The address of the pool.\n   * @return The number of votes for the pool.\n   */\n  function votes(uint256 tokenId, address pool) external view returns (uint256);\n}\n\ninterface IAddressesProvider {\n  function getAddress(string calldata id) external view returns (address);\n}\n\ninterface IMasterPriceOracle {\n  function price(address underlying) external view returns (uint256);\n}\n"
    },
    "contracts/veION/interfaces/IveIONFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../stake/IStakeStrategy.sol\";\nimport { IveIONStructsEnumsErrorsEvents } from \"./IveIONStructsEnumsErrorsEvents.sol\";\n\n/// @title IveION Interface First Extensions\n/// @notice Interface for veION contract\ninterface IveIONFirstExtension is IveIONStructsEnumsErrorsEvents {\n  /**\n   * @notice Withdraws tokens associated with a specific token ID.\n   * @param _tokenAddress The address of the token to withdraw.\n   * @param _tokenId The ID of the token to withdraw.\n   */\n  function withdraw(address _tokenAddress, uint256 _tokenId) external;\n\n  /**\n   * @notice Merges two token IDs into one.\n   * @param _from The ID of the token to merge from.\n   * @param _to The ID of the token to merge into.\n   */\n  function merge(uint256 _from, uint256 _to) external;\n\n  /**\n   * @notice Splits a token into two separate tokens.\n   * @param _tokenAddress The address of the token to split.\n   * @param _from The ID of the token to split.\n   * @param _splitAmount The amount to split from the original token.\n   * @return _tokenId1 The ID of the first resulting token.\n   * @return _tokenId2 The ID of the second resulting token.\n   */\n  function split(\n    address _tokenAddress,\n    uint256 _from,\n    uint256 _splitAmount\n  ) external returns (uint256 _tokenId1, uint256 _tokenId2);\n\n  /**\n   * @notice Claims emissions for a specific token.\n   * @param _tokenAddress The address of the token for which to claim emissions.\n   */\n  function claimEmissions(address _tokenAddress) external;\n\n  /**\n   * @notice Allows or blocks delegators for a specific token ID.\n   * @param _tokenId The ID of the token.\n   * @param _tokenAddress The address of the token.\n   * @param _blocked Boolean indicating if delegators are blocked.\n   */\n  function allowDelegators(uint256 _tokenId, address _tokenAddress, bool _blocked) external;\n\n  /**\n   * @notice Retrieves the balance of a specific NFT.\n   * @param _tokenId The ID of the NFT.\n   * @return _assets An array of asset addresses.\n   * @return _balances An array of balances for each asset.\n   * @return _boosts An array of boost values for each asset.\n   */\n  function balanceOfNFT(\n    uint256 _tokenId\n  ) external view returns (address[] memory _assets, uint256[] memory _balances, uint256[] memory _boosts);\n\n  /**\n   * @notice Retrieves the total ETH value of tokens owned by a specific address.\n   * @param _owner The address of the owner.\n   * @return totalValue The total ETH value of the tokens.\n   */\n  function getTotalEthValueOfTokens(address _owner) external view returns (uint256 totalValue);\n}\n"
    },
    "contracts/veION/interfaces/IveIONSecondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../stake/IStakeStrategy.sol\";\nimport { IveIONStructsEnumsErrorsEvents } from \"./IveIONStructsEnumsErrorsEvents.sol\";\n\n/// @title IveION Interface Second Extension\n/// @notice Interface for veION contract\ninterface IveIONSecondExtension is IveIONStructsEnumsErrorsEvents {\n  /**\n   * @notice Whitelists or removes tokens from the whitelist.\n   * @param _tokens An array of token addresses to be whitelisted or removed.\n   * @param _isWhitelisted An array of booleans indicating the whitelist status for each token.\n   */\n  function whitelistTokens(address[] memory _tokens, bool[] memory _isWhitelisted) external;\n\n  /**\n   * @notice Withdraws protocol fees for a specific token to a recipient address.\n   * @param _tokenAddress The address of the token for which protocol fees are to be withdrawn.\n   * @param _recipient The address to which the protocol fees will be sent.\n   */\n  function withdrawProtocolFees(address _tokenAddress, address _recipient) external;\n\n  /**\n   * @notice Withdraws distributed fees for a specific token to a recipient address.\n   * @param _tokenAddress The address of the token for which distributed fees are to be withdrawn.\n   * @param _recipient The address to which the distributed fees will be sent.\n   */\n  function withdrawDistributedFees(address _tokenAddress, address _recipient) external;\n\n  /**\n   * @notice Toggles the ability to split tokens for a specific account.\n   * @param _account The address of the account.\n   * @param _isAllowed Boolean indicating if splitting is allowed.\n   */\n  function toggleSplit(address _account, bool _isAllowed) external;\n\n  /**\n   * @notice Toggles the limited boost feature.\n   * @param _isBoosted Boolean indicating if the boost is active.\n   */\n  function toggleLimitedBoost(bool _isBoosted) external;\n\n  /**\n   * @notice Sets the amount for a limited time boost.\n   * @param _boostAmount The amount of the boost.\n   */\n  function setLimitedTimeBoost(uint256 _boostAmount) external;\n\n  /**\n   * @notice Sets the address of the voter.\n   * @param _voter The address of the voter.\n   */\n  function setVoter(address _voter) external;\n\n  /**\n   * @notice Sets the minimum lock amount for a specific token.\n   * @param _tokenAddress The address of the token.\n   * @param _minimumAmount The minimum amount to lock.\n   */\n  function setMinimumLockAmount(address _tokenAddress, uint256 _minimumAmount) external;\n\n  /**\n   * @notice Sets the minimum lock duration.\n   * @param _minimumLockDuration The minimum duration for locking.\n   */\n  function setMinimumLockDuration(uint256 _minimumLockDuration) external;\n\n  /**\n   * @notice Sets the address of the Ionic Pool.\n   * @param _ionicPool The address of the Ionic Pool.\n   */\n  function setIonicPool(address _ionicPool) external;\n\n  /**\n   * @notice Sets the address of the Aero Voting contract.\n   * @param _aeroVoting The address of the Aero Voting contract.\n   */\n  function setAeroVoting(address _aeroVoting) external;\n\n  /**\n   * @notice Sets the boost amount for Aero Voter.\n   * @param _aeroVoterBoost The boost amount for Aero Voter.\n   */\n  function setAeroVoterBoost(uint256 _aeroVoterBoost) external;\n\n  /**\n   * @notice Sets the maximum early withdrawal fee.\n   * @param _maxEarlyWithdrawFee The maximum fee for early withdrawal.\n   */\n  function setMaxEarlyWithdrawFee(uint256 _maxEarlyWithdrawFee) external;\n\n  /**\n   * @notice Sets the LP token type for a specific token.\n   * @param _token The address of the token.\n   * @param _type The LP token type.\n   */\n  function setLpTokenType(address _token, LpTokenType _type) external;\n\n  /**\n   * @notice Sets the stake strategy for a specific LP token type.\n   * @param _lpType The LP token type.\n   * @param _strategy The stake strategy.\n   */\n  function setStakeStrategy(LpTokenType _lpType, IStakeStrategy _strategy) external;\n\n  /**\n   * @notice Sets the address of the veAERO contract.\n   * @param _veAERO The address of the veAERO contract.\n   */\n  function setVeAERO(address _veAERO) external;\n\n  /**\n   * @notice Retrieves the lock information for a specific user.\n   * @param _tokenId The ID of the token.\n   * @param _lpType The LP token type.\n   * @return A LockedBalance struct containing lock details.\n   */\n  function getUserLock(uint256 _tokenId, LpTokenType _lpType) external view returns (LockedBalance memory);\n\n  /**\n   * @notice Retrieves the token IDs owned by a specific address.\n   * @param _owner The address of the owner.\n   * @return An array of token IDs owned by the address.\n   */\n  function getOwnedTokenIds(address _owner) external view returns (uint256[] memory);\n\n  /**\n   * @notice Retrieves the assets locked for a specific token ID.\n   * @param _tokenId The ID of the token.\n   * @return An array of addresses representing the locked assets.\n   */\n  function getAssetsLocked(uint256 _tokenId) external view returns (address[] memory);\n\n  /**\n   * @notice Retrieves the delegatees for a specific token ID and LP token type.\n   * @param _tokenId The ID of the token.\n   * @param _lpType The LP token type.\n   * @return An array of delegatee IDs.\n   */\n  function getDelegatees(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory);\n\n  /**\n   * @notice Retrieves the delegators for a specific token ID and LP token type.\n   * @param _tokenId The ID of the token.\n   * @param _lpType The LP token type.\n   * @return An array of delegator IDs.\n   */\n  function getDelegators(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory);\n\n  /**\n   * @notice Retrieves the user point for a specific token ID, LP token type, and epoch.\n   * @param _tokenId The ID of the token.\n   * @param _lpType The LP token type.\n   * @param _epoch The epoch number.\n   * @return A UserPoint struct containing user point details.\n   */\n  function getUserPoint(uint256 _tokenId, LpTokenType _lpType, uint256 _epoch) external view returns (UserPoint memory);\n}\n"
    },
    "contracts/veION/interfaces/IveIONStructsEnumsErrorsEvents.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\ninterface IveIONStructsEnumsErrorsEvents {\n  /**\n   * @notice Structure representing a locked balance\n   * @param tokenAddress Address of the token\n   * @param amount Amount of tokens locked\n   * @param delegateAmount Amount of tokens delegated\n   * @param start Start time of the lock\n   * @param end End time of the lock\n   * @param isPermanent Indicates if the lock is permanent\n   * @param boost Boost value for the lock\n   */\n  struct LockedBalance {\n    address tokenAddress;\n    uint256 amount;\n    uint256 delegateAmount;\n    uint256 start;\n    uint256 end;\n    bool isPermanent;\n    uint256 boost;\n  }\n\n  /**\n   * @notice Structure representing a delegation\n   * @param amount Amount of tokens delegated\n   * @param delegatee ID of the delegatee\n   */\n  struct Delegation {\n    uint256 amount;\n    uint256 delegatee;\n  }\n\n  /**\n   * @notice Structure representing a user point\n   * @param bias Bias value\n   * @param slope Slope value, representing -dweight / dt\n   * @param ts Timestamp of the point\n   * @param blk Block number of the point\n   * @param permanent Permanent value\n   * @param permanentDelegate Permanent delegate value\n   */\n  struct UserPoint {\n    uint256 bias;\n    uint256 slope;\n    uint256 ts;\n    uint256 blk;\n    uint256 permanent;\n    uint256 permanentDelegate;\n  }\n\n  /**\n   * @notice Structure representing a global point\n   * @param bias Bias value\n   * @param slope Slope value, representing -dweight / dt\n   * @param ts Timestamp of the point\n   * @param blk Block number of the point\n   * @param permanentLockBalance Permanent lock balance\n   */\n  struct GlobalPoint {\n    int128 bias;\n    int128 slope;\n    uint256 ts;\n    uint256 blk;\n    uint256 permanentLockBalance;\n  }\n\n  /**\n   * @notice Structure representing a checkpoint\n   * @param fromTimestamp Timestamp from which the checkpoint is valid\n   * @param owner Address of the owner\n   * @param delegatedBalance Balance that has been delegated\n   * @param delegatee ID of the delegatee\n   */\n  struct Checkpoint {\n    uint256 fromTimestamp;\n    address owner;\n    uint256 delegatedBalance;\n    uint256 delegatee;\n  }\n\n  /**\n   * @notice Enum representing deposit types\n   */\n  enum DepositType {\n    DEPOSIT_FOR_TYPE,\n    CREATE_LOCK_TYPE,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_UNLOCK_TIME,\n    LOCK_ADDITIONAL\n  }\n\n  /**\n   * @notice Enum representing LP token types\n   */\n  enum LpTokenType {\n    Mode_Velodrome_5050_ION_MODE,\n    Mode_Balancer_8020_ION_ETH,\n    Base_Aerodrome_5050_ION_wstETH,\n    Base_Balancer_8020_ION_ETH,\n    Optimism_Velodrome_5050_ION_OP,\n    Optimism_Balancer_8020_ION_ETH\n  }\n\n  error LockDurationNotInFuture();\n  error ZeroAmount();\n  error LockDurationTooLong();\n  error TokenNotWhitelisted();\n  error NotOwner();\n  error AlreadyVoted();\n  error PermanentLock();\n  error NoLockFound();\n  error LockExpired();\n  error SameNFT();\n  error SplitNotAllowed();\n  error AmountTooBig();\n  error NotPermanentLock();\n  error TokenHasDelegatees();\n  error TokenHasDelegators();\n  error NotVoter();\n  error MinimumNotMet();\n  error ArrayMismatch();\n  error LockDurationTooShort();\n  error DuplicateAsset();\n  error SplitTooSmall();\n  error NotEnoughRemainingAfterSplit();\n  error NoDelegationBetweenTokens(uint256 _tokenId1, uint256 _tokenId2);\n  error NoUnderlyingStake();\n  error NotAcceptingDelegators();\n  error BoostAmountMustBeGreaterThanZero();\n  error InvalidAddress();\n  error MinimumAmountMustBeGreaterThanZero();\n  error MinimumLockDurationMustBeGreaterThanZero();\n  error AeroBoostAmountMustBeGreaterThanZero();\n  error MaxEarlyWithdrawFeeMustBeGreaterThanZero();\n  error InvalidTokenAddress();\n  error InvalidStrategyAddress();\n  error InvalidVeAEROAddress();\n\n  event Deposit(\n    address indexed provider,\n    uint256 indexed tokenId,\n    DepositType indexed depositType,\n    uint256 value,\n    uint256 locktime,\n    uint256 ts\n  );\n  event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\n  event Supply(uint256 prevSupply, uint256 supply);\n  event Delegated(uint256 indexed fromTokenId, uint256 indexed toTokenId, address lpToken, uint256 amount);\n  event DelegationRemoved(uint256 indexed fromTokenId, uint256 indexed toTokenId, address lpToken, uint256 amount);\n  event ProtocolFeesWithdrawn(address indexed tokenAddress, address indexed recipient, uint256 amount);\n  event DistributedFeesWithdrawn(address indexed tokenAddress, address indexed recipient, uint256 amount);\n  event SplitToggle(address indexed account, bool isAllowed);\n  event LimitedBoostToggled(bool isBoosted);\n  event LimitedTimeBoostSet(uint256 boostAmount);\n  event VoterSet(address indexed newVoter);\n  event AeroVotingSet(address indexed newAeroVoting);\n  event AeroVoterBoostSet(uint256 newAeroVoterBoost);\n  event TokensWhitelisted(address[] token, bool[] isWhitelisted);\n  event LpTokenTypeSet(address indexed token, LpTokenType lpTokenType);\n  event VeAEROSet(address indexed veAERO);\n  event StakeStrategySet(LpTokenType indexed lpTokenType, address indexed strategy);\n  event MinimumLockAmountSet(address indexed tokenAddress, uint256 minimumAmount);\n  event MinimumLockDurationSet(uint256 minimumDuration);\n  event IonicPoolSet(address indexed newIonicPool);\n  event SplitCompleted(\n    uint256 indexed fromTokenId,\n    uint256 indexed tokenId1,\n    uint256 indexed tokenId2,\n    uint256 splitAmount,\n    address tokenAddress\n  );\n  event MergeCompleted(\n    uint256 indexed fromTokenId,\n    uint256 indexed toTokenId,\n    address[] assetsLocked,\n    uint256 lengthOfAssets\n  );\n  event EmissionsClaimed(address indexed claimant, address indexed tokenAddress);\n  event MaxEarlyWithdrawFeeSet(uint256 maxEarlyWithdrawFee);\n  event PermanentLockCreated(address indexed tokenAddress, uint256 indexed tokenId, uint256 amount);\n  event PermanentLockRemoved(address indexed tokenAddress, uint256 indexed tokenId, uint256 amount);\n  event Voted(uint256 _tokenId, bool _voting);\n  event DelegatorsBlocked(uint256 indexed _tokenId, address indexed _lpToken, bool _blocked);\n  event Initialized(address indexed addressesProvider);\n  event ExtensionsSet(address indexed _firstExtension, address indexed _secondExtension);\n}\n"
    },
    "contracts/veION/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n/**\n * @title IVoter\n * @notice Interface for the Voter contract, which manages voting and reward distribution.\n */\ninterface IVoter {\n  /// @notice Error thrown when a user has already voted or deposited.\n  error AlreadyVotedOrDeposited();\n\n  /// @notice Error thrown when an action is attempted outside the distribution window.\n  error DistributeWindow();\n\n  /// @notice Error thrown when a reward accumulator does not exist for a given pool.\n  error RewardAccumulatorDoesNotExist(address _pool);\n\n  /// @notice Error thrown when a reward accumulator is not alive.\n  error RewardAccumulatorNotAlive(address _rewardAccumulator);\n\n  /// @notice Error thrown when a market already exists.\n  error MarketAlreadyExists();\n\n  /// @notice Error thrown when the maximum voting number is too low.\n  error MaximumVotingNumberTooLow();\n\n  /// @notice Error thrown when array lengths do not match.\n  error MismatchedArrayLengths();\n\n  /// @notice Error thrown when there are non-zero votes.\n  error NonZeroVotes();\n\n  /// @notice Error thrown when the caller is not the owner.\n  error NotOwner();\n\n  /// @notice Error thrown when an action is attempted outside the distribution window.\n  error NotDistributeWindow();\n\n  /// @notice Error thrown when the caller is not the governor.\n  error NotGovernor();\n\n  /// @notice Error thrown when an NFT is not whitelisted.\n  error NotWhitelistedNFT();\n\n  /// @notice Error thrown when the same value is provided.\n  error SameValue();\n\n  /// @notice Error thrown when there are too many pools.\n  error TooManyPools();\n\n  /// @notice Error thrown when array lengths are unequal.\n  error UnequalLengths();\n\n  /// @notice Error thrown when an address is zero.\n  error ZeroAddress();\n\n  /// @notice Error thrown when the tokens array is empty.\n  error TokensArrayEmpty();\n\n  /// @notice Error thrown when the weight is zero.\n  error ZeroWeight();\n\n  /**\n   * @notice Struct to store vote details.\n   * @param marketVotes Array of market addresses voted for.\n   * @param marketVoteSides Array of market sides voted for.\n   * @param votes Array of vote weights.\n   * @param usedWeight Total weight used in voting.\n   */\n  struct VoteDetails {\n    address[] marketVotes;\n    MarketSide[] marketVoteSides;\n    uint256[] votes;\n    uint256 usedWeight;\n  }\n\n  /**\n   * @notice Struct to store market information.\n   * @param marketAddress Address of the market.\n   * @param side Side of the market (Supply or Borrow).\n   */\n  struct Market {\n    address marketAddress;\n    MarketSide side;\n  }\n\n  /**\n   * @notice Struct to store variables used in voting.\n   * @param totalWeight Total weight available for voting.\n   * @param usedWeight Weight used in voting.\n   * @param market Address of the market.\n   * @param marketSide Side of the market.\n   * @param rewardAccumulator Address of the reward accumulator.\n   * @param marketWeight Weight of the market.\n   * @param bribes Address of the bribes.\n   */\n  struct VoteVars {\n    uint256 totalWeight;\n    uint256 usedWeight;\n    address market;\n    MarketSide marketSide;\n    address rewardAccumulator;\n    uint256 marketWeight;\n    address bribes;\n  }\n\n  /**\n   * @notice Struct to store local variables used in voting.\n   * @param sender Address of the sender.\n   * @param timestamp Timestamp of the vote.\n   * @param votingLPs Array of voting LP addresses.\n   * @param votingLPBalances Array of voting LP balances.\n   * @param boosts Array of boosts.\n   */\n  struct VoteLocalVars {\n    address sender;\n    uint256 timestamp;\n    address[] votingLPs;\n    uint256[] votingLPBalances;\n    uint256[] boosts;\n  }\n\n  /**\n   * @notice Enum to represent the side of a market.\n   */\n  enum MarketSide {\n    Supply,\n    Borrow\n  }\n\n  /**\n   * @notice Event emitted when a vote is cast.\n   * @param voter Address of the voter.\n   * @param pool Address of the pool.\n   * @param tokenId ID of the token.\n   * @param weight Weight of the vote.\n   * @param totalWeight Total weight of the vote.\n   * @param timestamp Timestamp of the vote.\n   */\n  event Voted(\n    address indexed voter,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 weight,\n    uint256 totalWeight,\n    uint256 timestamp\n  );\n\n  /**\n   * @notice Event emitted when a vote is abstained.\n   * @param voter Address of the voter.\n   * @param pool Address of the pool.\n   * @param tokenId ID of the token.\n   * @param weight Weight of the vote.\n   * @param totalWeight Total weight of the vote.\n   * @param timestamp Timestamp of the vote.\n   */\n  event Abstained(\n    address indexed voter,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 weight,\n    uint256 totalWeight,\n    uint256 timestamp\n  );\n\n  /**\n   * @notice Event emitted when a reward is notified.\n   * @param sender Address of the sender.\n   * @param reward Address of the reward.\n   * @param amount Amount of the reward.\n   */\n  event NotifyReward(address indexed sender, address indexed reward, uint256 amount);\n\n  /**\n   * @notice Event emitted when a token is whitelisted.\n   * @param whitelister Address of the whitelister.\n   * @param token Address of the token.\n   * @param _bool Boolean indicating whitelist status.\n   */\n  event WhitelistToken(address indexed whitelister, address indexed token, bool indexed _bool);\n\n  /**\n   * @notice Event emitted when an NFT is whitelisted.\n   * @param whitelister Address of the whitelister.\n   * @param tokenId ID of the token.\n   * @param _bool Boolean indicating whitelist status.\n   */\n  event WhitelistNFT(address indexed whitelister, uint256 indexed tokenId, bool indexed _bool);\n\n  event LpTokensSet(address[] indexed lpTokens);\n  event MpoSet(address indexed mpo);\n  event GovernorSet(address indexed governor);\n  event MarketsAdded(Market[] markets);\n  event MarketRewardAccumulatorsSet(\n    address[] indexed markets,\n    MarketSide[] indexed marketSides,\n    address[] indexed rewardAccumulators\n  );\n  event BribesSet(address[] indexed rewardAccumulators, address[] indexed bribes);\n  event MaxVotingNumSet(uint256 indexed maxVotingNum);\n  event RewardAccumulatorAliveToggled(address indexed market, MarketSide indexed marketSide, bool isAlive);\n  event Initialized(address[] tokens, address mpo, address rewardToken, address ve, address governor);\n  event DistributionTimelockAliveToggled(bool isAlive);\n\n  /**\n   * @notice Get the weight of a market.\n   * @param market Address of the market.\n   * @param marketSide Side of the market.\n   * @param lpToken Address of the LP token.\n   * @return The weight of the market.\n   */\n  function weights(address market, MarketSide marketSide, address lpToken) external view returns (uint256);\n\n  /**\n   * @notice Get the votes for a token.\n   * @param tokenId ID of the token.\n   * @param market Address of the market.\n   * @param marketSide Side of the market.\n   * @param lpToken Address of the LP token.\n   * @return The votes for the token.\n   */\n  function votes(\n    uint256 tokenId,\n    address market,\n    MarketSide marketSide,\n    address lpToken\n  ) external view returns (uint256);\n\n  /**\n   * @notice Get the used weights for a token.\n   * @param tokenId ID of the token.\n   * @param lpToken Address of the LP token.\n   * @return The used weights for the token.\n   */\n  function usedWeights(uint256 tokenId, address lpToken) external view returns (uint256);\n\n  /**\n   * @notice Get the last voted timestamp for a token.\n   * @param tokenId ID of the token.\n   * @return The last voted timestamp for the token.\n   */\n  function lastVoted(uint256 tokenId) external view returns (uint256);\n\n  /**\n   * @notice Check if a token is whitelisted.\n   * @param token Address of the token.\n   * @return True if the token is whitelisted, false otherwise.\n   */\n  function isWhitelistedToken(address token) external view returns (bool);\n\n  /**\n   * @notice Check if an NFT is whitelisted.\n   * @param tokenId ID of the token.\n   * @return True if the NFT is whitelisted, false otherwise.\n   */\n  function isWhitelistedNFT(uint256 tokenId) external view returns (bool);\n\n  /**\n   * @notice Get the address of the ve contract.\n   * @return The address of the ve contract.\n   */\n  function ve() external view returns (address);\n\n  /**\n   * @notice Get the address of the governor.\n   * @return The address of the governor.\n   */\n  function governor() external view returns (address);\n\n  /**\n   * @notice Update voting balances in voting rewards contracts.\n   * @param _tokenId ID of veNFT whose balance you wish to update.\n   */\n  function poke(uint256 _tokenId) external;\n\n  /**\n   * @notice Vote for pools. Votes distributed proportionally based on weights.\n   * @dev Can only vote or deposit into a managed NFT once per epoch.\n   *      Can only vote for gauges that have not been killed.\n   *      Throws if length of _poolVote and _weights do not match.\n   * @param _tokenId ID of veNFT you are voting with.\n   * @param _poolVote Array of pools you are voting for.\n   * @param _marketVoteSide Array of market vote sides you are voting for.\n   * @param _weights Weights of pools.\n   */\n  function vote(\n    uint256 _tokenId,\n    address[] calldata _poolVote,\n    MarketSide[] calldata _marketVoteSide,\n    uint256[] calldata _weights\n  ) external;\n\n  /**\n   * @notice Reset voting state. Required if you wish to make changes to veNFT state.\n   * @dev Cannot reset in the same epoch that you voted in.\n   *      Can vote or deposit into a managed NFT again after reset.\n   * @param _tokenId ID of veNFT that you are resetting.\n   */\n  function reset(uint256 _tokenId) external;\n\n  /**\n   * @notice Distributes rewards to eligible markets.\n   */\n  function distributeRewards() external;\n\n  /**\n   * @notice Claim bribes for a given NFT.\n   * @dev Utility to help batch bribe claims.\n   * @param _bribes Array of BribeVotingReward contracts to collect from.\n   * @param _tokens Array of tokens that are used as bribes.\n   * @param _tokenId ID of veNFT that you wish to claim bribes for.\n   */\n  function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint256 _tokenId) external;\n\n  /**\n   * @notice Whitelist (or unwhitelist) token for use in bribes.\n   * @dev Throws if not called by governor.\n   * @param _token Address of the token.\n   * @param _bool Boolean indicating whitelist status.\n   */\n  function whitelistToken(address _token, bool _bool) external;\n\n  /**\n   * @notice Whitelist (or unwhitelist) token id for voting in last hour prior to epoch flip.\n   * @dev Throws if not called by governor.\n   *      Throws if already whitelisted.\n   * @param _tokenId ID of the token.\n   * @param _bool Boolean indicating whitelist status.\n   */\n  function whitelistNFT(uint256 _tokenId, bool _bool) external;\n\n  /**\n   * @notice Set the LP tokens.\n   * @param _lpTokens Array of LP token addresses.\n   */\n  function setLpTokens(address[] memory _lpTokens) external;\n\n  /**\n   * @notice Set the Master Price Oracle (MPO) address.\n   * @param _mpo Address of the Master Price Oracle.\n   */\n  function setMpo(address _mpo) external;\n\n  /**\n   * @notice Set a new governor.\n   * @param _governor Address of the new governor.\n   */\n  function setGovernor(address _governor) external;\n\n  /**\n   * @notice Add new markets.\n   * @param _markets Array of Market structs to be added.\n   */\n  function addMarkets(Market[] calldata _markets) external;\n\n  /**\n   * @notice Set reward accumulators for markets.\n   * @param _markets Array of market addresses.\n   * @param _marketSides Array of market sides.\n   * @param _rewardAccumulators Array of reward accumulator addresses.\n   */\n  function setMarketRewardAccumulators(\n    address[] calldata _markets,\n    MarketSide[] calldata _marketSides,\n    address[] calldata _rewardAccumulators\n  ) external;\n\n  /**\n   * @notice Set bribes for reward accumulators.\n   * @param _rewardAccumulators Array of reward accumulator addresses.\n   * @param _bribes Array of bribe addresses.\n   */\n  function setBribes(address[] calldata _rewardAccumulators, address[] calldata _bribes) external;\n\n  /**\n   * @notice Set the maximum number of votes.\n   * @param _maxVotingNum Maximum number of votes allowed.\n   */\n  function setMaxVotingNum(uint256 _maxVotingNum) external;\n\n  /**\n   * @notice Toggle the alive status of a reward accumulator.\n   * @param _market Address of the market.\n   * @param _marketSide Side of the market.\n   * @param _isAlive Boolean indicating if the reward accumulator is alive.\n   */\n  function toggleRewardAccumulatorAlive(address _market, MarketSide _marketSide, bool _isAlive) external;\n\n  /**\n   * @notice Toggle the alive status of a timelock on distributing rewards.\n   * @param _isAlive Boolean indicating if the timelock is alive.\n   */\n  function toggleDistributionTimelockAlive(bool _isAlive) external;\n\n  /**\n   * @notice Get the start of the epoch for a given timestamp.\n   * @param _timestamp The timestamp to calculate the epoch start for.\n   * @return The start of the epoch.\n   */\n  function epochStart(uint256 _timestamp) external pure returns (uint256);\n\n  /**\n   * @notice Get the next epoch for a given timestamp.\n   * @param _timestamp The timestamp to calculate the next epoch for.\n   * @return The next epoch.\n   */\n  function epochNext(uint256 _timestamp) external pure returns (uint256);\n\n  /**\n   * @notice Get the start of the voting period for a given timestamp.\n   * @param _timestamp The timestamp to calculate the voting start for.\n   * @return The start of the voting period.\n   */\n  function epochVoteStart(uint256 _timestamp) external pure returns (uint256);\n\n  /**\n   * @notice Get the end of the voting period for a given timestamp.\n   * @param _timestamp The timestamp to calculate the voting end for.\n   * @return The end of the voting period.\n   */\n  function epochVoteEnd(uint256 _timestamp) external pure returns (uint256);\n\n  /**\n   * @notice Get the number of markets.\n   * @return The number of markets.\n   */\n  function marketsLength() external view returns (uint256);\n\n  /**\n   * @notice Get all LP reward tokens.\n   * @return An array of addresses representing all LP reward tokens.\n   */\n  function getAllLpRewardTokens() external view returns (address[] memory);\n\n  /**\n   * @notice Get vote details for a specific token ID and LP asset.\n   * @param _tokenId The ID of the token.\n   * @param _lpAsset The address of the LP asset.\n   * @return A struct containing vote details.\n   */\n  function getVoteDetails(uint256 _tokenId, address _lpAsset) external view returns (VoteDetails memory);\n}\n"
    },
    "contracts/veION/libraries/BalanceLogicLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../interfaces/IveIONStructsEnumsErrorsEvents.sol\";\n\nlibrary BalanceLogicLibrary {\n  uint256 internal constant _WEEK = 1 weeks;\n\n  /// @notice Calculates the voting power for a given NFT at a specific time.\n  /// @dev This function is compatible with the ERC20 `balanceOf` interface for Aragon.\n  ///      It retrieves the last user point before a specified timestamp and computes the voting power at that time.\n  /// @param s_userPointEpoch Mapping of user point epochs for all tokens.\n  /// @param s_userPointHistory Mapping of user point history for all tokens.\n  /// @param _lpType The type of LP token associated with the NFT.\n  /// @param _tokenId The ID of the NFT for which to calculate voting power.\n  /// @param _t The epoch time at which to calculate the voting power.\n  /// @param _isPermanent A boolean indicating if the lock is permanent.\n  /// @return The calculated voting power of the user at the specified time.\n  function balanceOfNFTAt(\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => uint256)) storage s_userPointEpoch,\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => IveIONStructsEnumsErrorsEvents.UserPoint[1000000000]))\n      storage s_userPointHistory,\n    IveIONStructsEnumsErrorsEvents.LpTokenType _lpType,\n    uint256 _tokenId,\n    uint256 _t,\n    bool _isPermanent\n  ) internal view returns (uint256) {\n    uint256 _epoch = getPastUserPointIndex(s_userPointEpoch, s_userPointHistory, _lpType, _tokenId, _t);\n    // epoch 0 is an empty point\n    if (_epoch == 0) return 0;\n    IveIONStructsEnumsErrorsEvents.UserPoint memory lastPoint = s_userPointHistory[_tokenId][_lpType][_epoch];\n    if (_isPermanent) {\n      return lastPoint.permanent + lastPoint.permanentDelegate;\n    } else {\n      uint256 reduction = lastPoint.slope * (_t - lastPoint.ts);\n      if (reduction > lastPoint.bias) {\n        lastPoint.bias = 0;\n      } else {\n        lastPoint.bias -= reduction;\n      }\n      return lastPoint.bias;\n    }\n  }\n\n  /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\n  /// @dev If a user point does not exist prior to the timestamp, this will return 0.\n  /// @param s_userPointEpoch State of all user point epochs\n  /// @param s_userPointHistory State of all user point history\n  /// @param _tokenId .\n  /// @param _timestamp .\n  /// @return User point index\n  function getPastUserPointIndex(\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => uint256)) storage s_userPointEpoch,\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => IveIONStructsEnumsErrorsEvents.UserPoint[1000000000]))\n      storage s_userPointHistory,\n    IveIONStructsEnumsErrorsEvents.LpTokenType _lpType,\n    uint256 _tokenId,\n    uint256 _timestamp\n  ) internal view returns (uint256) {\n    uint256 _userEpoch = s_userPointEpoch[_tokenId][_lpType];\n    if (_userEpoch == 0) return 0;\n    // First check most recent balance\n    if (s_userPointHistory[_tokenId][_lpType][_userEpoch].ts <= _timestamp) return (_userEpoch);\n    // Next check implicit zero balance\n    if (s_userPointHistory[_tokenId][_lpType][1].ts > _timestamp) return 0;\n    uint256 lower = 0;\n    uint256 upper = _userEpoch;\n    while (upper > lower) {\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      IveIONStructsEnumsErrorsEvents.UserPoint storage userPoint = s_userPointHistory[_tokenId][_lpType][center];\n      if (userPoint.ts == _timestamp) {\n        return center;\n      } else if (userPoint.ts < _timestamp) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return lower;\n  }\n}\n"
    },
    "contracts/veION/libraries/IonicTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nlibrary IonicTimeLibrary {\n  uint256 internal constant _WEEK = 7 days;\n\n  /// @dev Returns start of epoch based on current timestamp\n  function epochStart(uint256 timestamp) internal pure returns (uint256) {\n    unchecked {\n      return timestamp - (timestamp % _WEEK);\n    }\n  }\n\n  /// @dev Returns start of next epoch / end of current epoch\n  function epochNext(uint256 timestamp) internal pure returns (uint256) {\n    unchecked {\n      return timestamp - (timestamp % _WEEK) + _WEEK;\n    }\n  }\n\n  /// @dev Returns start of voting window\n  function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\n    unchecked {\n      return timestamp - (timestamp % _WEEK) + 1 hours;\n    }\n  }\n\n  /// @dev Returns end of voting window / beginning of unrestricted voting window\n  function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\n    unchecked {\n      return timestamp - (timestamp % _WEEK) + _WEEK - 12 hours;\n    }\n  }\n}\n"
    },
    "contracts/veION/RewardAccumulator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract RewardAccumulator is Ownable2StepUpgradeable {\n  using SafeERC20 for IERC20;\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  function initialize() external initializer {\n    __Ownable2Step_init();\n  }\n\n  function approve(address _token, address _spender) external onlyOwner {\n    IERC20(_token).safeIncreaseAllowance(_spender, type(uint256).max);\n  }\n}\n"
    },
    "contracts/veION/stake/IStakeStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n/**\n * @title IStakeStrategy\n * @notice Interface for the VeloIonModeStakingModeReward contract.\n */\ninterface IStakeStrategy {\n  /// @notice Emitted when the contract is initialized\n  event Initialized(\n    address indexed escrow,\n    address indexed stakingToken,\n    address indexed stakingContract,\n    address stakingWalletImplementation\n  );\n\n  /// @notice Emitted when tokens are staked\n  event Staked(address indexed from, uint256 amount, address indexed veloWallet);\n\n  /// @notice Emitted when rewards are claimed\n  event Claimed(address indexed from, address indexed veloWallet);\n\n  /// @notice Emitted when tokens are withdrawn\n  event Withdrawn(address indexed owner, address indexed withdrawTo, uint256 amount);\n\n  /// @notice Emitted when staking wallet is transferred\n  event StakingWalletTransferred(address indexed from, address indexed to, uint256 amount);\n\n  /// @notice Emitted when escrow is set\n  event EscrowSet(address indexed newEscrow);\n\n  /// @notice Emitted when staking token is set\n  event StakingTokenSet(address indexed newStakingToken);\n\n  /// @notice Emitted when staking contract is set\n  event StakingContractSet(address indexed newStakingContract);\n\n  /// @notice Emitted when upgradeable beacon is set\n  event UpgradeableBeaconSet(address indexed newBeacon);\n\n  /**\n   * @notice Stakes a specified amount of tokens from a given address.\n   * @param _from The address from which tokens will be staked.\n   * @param _amount The amount of tokens to stake.\n   * @param _data Additional data that might be needed for staking.\n   */\n  function stake(address _from, uint256 _amount, bytes memory _data) external;\n\n  /**\n   * @notice Claims rewards for a given address.\n   * @param _from The address for which to claim rewards.\n   */\n  function claim(address _from) external;\n\n  /**\n   * @notice Withdraws a specified amount of tokens for a given address.\n   * @param _owner The address from which tokens will be withdrawn.\n   * @param _amount The amount of tokens to withdraw.\n   */\n  function withdraw(address _owner, address _withdrawTo, uint256 _amount) external;\n\n  /**\n   * @notice Returns the current reward rate for the staking strategy.\n   * @return The reward rate as a uint256.\n   */\n  function rewardRate() external view returns (uint256);\n\n  /**\n   * @notice Returns the period finish time for the staking strategy.\n   * @return The period finish time as a uint256.\n   */\n  function periodFinish() external view returns (uint256);\n\n  /**\n   * @notice Returns the balance of a specific address.\n   * @param account The address to query the balance of.\n   * @return The balance as a uint256.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @notice Returns the total supply of staked tokens.\n   * @return The total supply as a uint256.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the reward token for the staking strategy.\n   * @return The address of the reward token.\n   */\n  function rewardToken() external view returns (address);\n\n  /**\n   * @notice Returns the address of the staking contract.\n   * @return The address of the staking contract.\n   */\n  function stakingContract() external view returns (address);\n\n  /**\n   * @notice Returns the address of the staking token.\n   * @return The address of the staking token.\n   */\n  function stakingToken() external view returns (address);\n\n  /**\n   * @notice Returns the staking wallet address for a specific user.\n   * @param user The address of the user.\n   * @return The address of the user's staking wallet.\n   */\n  function userStakingWallet(address user) external view returns (address);\n\n  /**\n   * @notice Transfers the staking wallet from one user to another.\n   * @param from The current owner of the staking wallet.\n   * @param to The new owner of the staking wallet.\n   */\n  function transferStakingWallet(address from, address to, uint256 _amount) external;\n\n  /**\n   * @notice Sets the escrow address.\n   * @param _escrow The address of the new escrow.\n   */\n  function setEscrow(address _escrow) external;\n\n  /**\n   * @notice Sets the staking token address.\n   * @param _stakingToken The address of the new staking token.\n   */\n  function setStakingToken(address _stakingToken) external;\n\n  /**\n   * @notice Sets the staking contract address.\n   * @param _stakingContract The address of the new staking contract.\n   */\n  function setStakingContract(address _stakingContract) external;\n\n  /**\n   * @notice Sets the address of the  beacon.\n   * @param _beacon The address of the new beacon contract.\n   */\n  function setUpgradeableBeacon(address _beacon) external;\n}\n"
    },
    "contracts/veION/stake/IStakeWallet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\ninterface IStakeWallet {\n  /// @notice Emitted when tokens are staked\n  event Staked(uint256 amount);\n\n  /// @notice Emitted when rewards are claimed\n  event Claimed(address indexed from, uint256 rewardAmount);\n\n  /// @notice Emitted when tokens are withdrawn\n  event Withdrawn(address indexed withdrawTo, uint256 amount);\n\n  /**\n   * @notice Stakes a specified amount of tokens according to the strategy.\n   * @param amount The amount of tokens to stake.\n   * @param data Additional data required for the staking strategy.\n   */\n  function stake(address from, uint256 amount, bytes memory data) external;\n\n  /**\n   * @notice Claims rewards for the caller.\n   */\n  function claim(address from) external;\n\n  /**\n   * @notice Withdraws a specified amount of staked tokens.\n   * @param withdrawTo The address to withdraw tokens to.\n   * @param amount The amount of tokens to withdraw.\n   */\n  function withdraw(address withdrawTo, uint256 amount) external;\n}\n"
    },
    "contracts/veION/stake/velo/IVeloIonModeStaking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\ninterface IVeloIonModeStaking {\n  event Deposit(address indexed from, address indexed to, uint256 amount);\n  event Withdraw(address indexed from, uint256 amount);\n  event NotifyReward(address indexed from, uint256 amount);\n  event ClaimFees(uint256 claimed0, uint256 claimed1);\n  event ClaimRewards(address indexed from, uint256 amount);\n\n  /// @notice Address of the pool LP token which is deposited (staked) for rewards\n  function stakingToken() external view returns (address);\n\n  /// @notice Address of the token (VELO v2) rewarded to stakers\n  function rewardToken() external view returns (address);\n\n  /// @notice Address of the Converter contract linked to the gauge\n  function feeConverter() external view returns (address);\n\n  /// @notice Address of the staking rewards factory that created this gauge\n  function factory() external view returns (address);\n\n  /// @notice Timestamp end of current rewards period\n  function periodFinish() external view returns (uint256);\n\n  /// @notice Current reward rate of rewardToken to distribute per second\n  function rewardRate() external view returns (uint256);\n\n  /// @notice Most recent timestamp contract has updated state\n  function lastUpdateTime() external view returns (uint256);\n\n  /// @notice Most recent stored value of rewardPerToken\n  function rewardPerTokenStored() external view returns (uint256);\n\n  /// @notice Amount of stakingToken deposited for rewards\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Get the amount of stakingToken deposited by an account\n  function balanceOf(address) external view returns (uint256);\n\n  /// @notice Cached rewardPerTokenStored for an account based on their most recent action\n  function userRewardPerTokenPaid(address) external view returns (uint256);\n\n  /// @notice Cached amount of rewardToken earned for an account\n  function rewards(address) external view returns (uint256);\n\n  /// @notice View to see the rewardRate given the timestamp of the start of the epoch\n  function rewardRateByEpoch(uint256) external view returns (uint256);\n\n  /// @notice Get the current reward rate per unit of stakingToken deposited\n  function rewardPerToken() external view returns (uint256 _rewardPerToken);\n\n  /// @notice Returns the last time the reward was modified or periodFinish if the reward has ended\n  function lastTimeRewardApplicable() external view returns (uint256 _time);\n\n  /// @notice Returns accrued balance to date from last claim / first deposit.\n  function earned(address _account) external view returns (uint256 _earned);\n\n  /// @notice Total amount of rewardToken to distribute for the current rewards period\n  function left() external view returns (uint256 _left);\n\n  /// @notice Claims accrued Fees from Pool and distributes them to the Converter\n  /// @return _claimed0 Amount of Fees claimed in token0\n  /// @return _claimed1 Amount of Fees claimed in token1\n  function claimFees() external returns (uint256 _claimed0, uint256 _claimed1);\n\n  /// @notice Retrieve rewards for an address.\n  /// @dev Throws if not called by same address or voter.\n  /// @param _account .\n  function getReward(address _account) external;\n\n  /// @notice Deposit LP tokens into gauge for msg.sender\n  /// @param _amount .\n  function deposit(uint256 _amount) external;\n\n  /// @notice Deposit LP tokens into gauge for any user\n  /// @param _amount .\n  /// @param _recipient Recipient to give balance to\n  function deposit(uint256 _amount, address _recipient) external;\n\n  /// @notice Withdraw LP tokens for user\n  /// @param _amount .\n  function withdraw(uint256 _amount) external;\n\n  /// @dev Notifies gauge of gauge rewards. Assumes gauge reward tokens is 18 decimals.\n  ///      If not 18 decimals, rewardRate may have rounding issues.\n  function notifyRewardMatch(uint256 amount) external;\n\n  /// @dev Notifies gauge of gauge rewards. Assumes gauge reward tokens is 18 decimals.\n  ///      If not 18 decimals, rewardRate may have rounding issues.\n  function notifyRewardAmount(uint256 amount) external;\n}\n"
    },
    "contracts/veION/stake/velo/VeloAeroStakingStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"../IStakeStrategy.sol\";\nimport \"./VeloAeroStakingWallet.sol\";\nimport \"./IVeloIonModeStaking.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { BeaconProxy } from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport { UpgradeableBeacon } from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\n/**\n * @title VeloAeroStakingStrategy\n * @notice Staking interface for usage in veION when staking Velodrome/Aerodrome style LP.\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract VeloAeroStakingStrategy is IStakeStrategy, Ownable2StepUpgradeable {\n  using SafeERC20 for IERC20;\n\n  /// @notice Address of the escrow responsible for managing staking operations\n  address public escrow;\n  /// @notice Address of the token being staked\n  address public stakingToken;\n  /// @notice Address of the contract where staking operations are executed\n  address public stakingContract;\n  /// @notice Address of beacon contract that manages wallet proxies\n  UpgradeableBeacon public veloAeroBeacon;\n  /// @notice Mapping of user addresses to their respective staking wallet addresses\n  mapping(address => address) public userStakingWallet;\n\n  /// @dev Modifier to restrict function access to only the escrow address\n  modifier onlyEscrow() {\n    require(msg.sender == escrow, \"Not authorized: Only escrow can call this function\");\n    _;\n  }\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /**\n   * @notice Initializes the staking strategy contract with necessary parameters\n   * @dev This function can only be called once due to the initializer modifier\n   * @param _escrow The address of the escrow responsible for staking operations\n   * @param _stakingToken The address of the token to be staked\n   * @param _stakingContract The address of the contract handling staking\n   * @param _stakingWalletImplementation The address of the staking wallet implementation\n   */\n  function initialize(\n    address _escrow,\n    address _stakingToken,\n    address _stakingContract,\n    address _stakingWalletImplementation\n  ) public initializer {\n    __Ownable2Step_init();\n    escrow = _escrow;\n    stakingToken = _stakingToken;\n    stakingContract = _stakingContract;\n\n    veloAeroBeacon = new UpgradeableBeacon(_stakingWalletImplementation);\n    veloAeroBeacon.transferOwnership(msg.sender);\n\n    emit Initialized(_escrow, _stakingToken, _stakingContract, _stakingWalletImplementation);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function stake(address _from, uint256 _amount, bytes memory _data) external override onlyEscrow {\n    IERC20(stakingToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n    address veloWallet = userStakingWallet[_from];\n    if (veloWallet == address(0)) {\n      BeaconProxy newWallet = new BeaconProxy(address(veloAeroBeacon), \"\");\n      veloWallet = address(newWallet);\n      VeloAeroStakingWallet(veloWallet).initialize(IStakeStrategy(address(this)));\n      userStakingWallet[_from] = veloWallet;\n    }\n\n    IERC20(stakingToken).approve(veloWallet, _amount);\n    VeloAeroStakingWallet(veloWallet).stake(_from, _amount, _data);\n    emit Staked(_from, _amount, veloWallet);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function claim(address _from) external onlyEscrow {\n    VeloAeroStakingWallet veloWallet = VeloAeroStakingWallet(userStakingWallet[_from]);\n    veloWallet.claim(_from);\n    emit Claimed(_from, address(veloWallet));\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function withdraw(address _owner, address _withdrawTo, uint256 _amount) external onlyEscrow {\n    VeloAeroStakingWallet veloWallet = VeloAeroStakingWallet(userStakingWallet[_owner]);\n    veloWallet.withdraw(_withdrawTo, _amount);\n    emit Withdrawn(_owner, _withdrawTo, _amount);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function transferStakingWallet(address _from, address _to, uint256 _amount) external onlyEscrow {\n    address fromWallet = userStakingWallet[_from];\n    address toWallet = userStakingWallet[_to];\n\n    if (toWallet == address(0)) {\n      BeaconProxy newWallet = new BeaconProxy(address(veloAeroBeacon), \"\");\n      toWallet = address(newWallet);\n      VeloAeroStakingWallet(toWallet).initialize(IStakeStrategy(address(this)));\n      userStakingWallet[_to] = toWallet;\n    }\n\n    VeloAeroStakingWallet(fromWallet).withdraw(address(this), _amount);\n    IERC20(stakingToken).approve(address(toWallet), _amount);\n    VeloAeroStakingWallet(toWallet).stake(_to, _amount, \"\");\n    emit StakingWalletTransferred(_from, _to, _amount);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function rewardRate() external view override returns (uint256) {\n    return IVeloIonModeStaking(stakingContract).rewardRate();\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function periodFinish() external view override returns (uint256) {\n    return IVeloIonModeStaking(stakingContract).periodFinish();\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function balanceOf(address account) public view override returns (uint256) {\n    return IVeloIonModeStaking(stakingContract).balanceOf(account);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function totalSupply() external view override returns (uint256) {\n    return IVeloIonModeStaking(stakingContract).totalSupply();\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function rewardToken() public view returns (address) {\n    return IVeloIonModeStaking(stakingContract).rewardToken();\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function setEscrow(address _escrow) external onlyOwner {\n    require(_escrow != address(0), \"Invalid address\");\n    escrow = _escrow;\n    emit EscrowSet(_escrow);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function setStakingToken(address _stakingToken) external onlyOwner {\n    require(_stakingToken != address(0), \"Invalid address\");\n    stakingToken = _stakingToken;\n    emit StakingTokenSet(_stakingToken);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function setStakingContract(address _stakingContract) external onlyOwner {\n    require(_stakingContract != address(0), \"Invalid address\");\n    stakingContract = _stakingContract;\n    emit StakingContractSet(_stakingContract);\n  }\n\n  /// @inheritdoc IStakeStrategy\n  function setUpgradeableBeacon(address _beacon) external onlyOwner {\n    require(_beacon != address(0), \"Invalid address\");\n    veloAeroBeacon = UpgradeableBeacon(_beacon);\n    emit UpgradeableBeaconSet(_beacon);\n  }\n}\n"
    },
    "contracts/veION/stake/velo/VeloAeroStakingWallet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { IStakeWallet } from \"../IStakeWallet.sol\";\nimport { IStakeStrategy } from \"../IStakeStrategy.sol\";\nimport { IVeloIonModeStaking } from \"./IVeloIonModeStaking.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Initializable } from \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @title VeloAeroStakingWallet\n * @notice Staking interface for usage in veION when staking Velodrome/Aerodrome style LP.\n * @dev This contract allows staking and claiming rewards with a specific staking strategy.\n * @dev The staking strategy is set during contract deployment and can only be called by the strategy.\n * @dev The contract is designed to be used with the Velodrome/Aerodrome style LP.\n * @author Jourdan Dunkley <jourdan@ionic.money>\n */\ncontract VeloAeroStakingWallet is IStakeWallet, Initializable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  IStakeStrategy public stakeStrategy;\n\n  /// @dev Modifier to restrict function access to only the stake strategy contract\n  modifier onlyStakeStrategy() {\n    require(msg.sender == address(stakeStrategy), \"Not authorized: Only stake strategy can call this function\");\n    _;\n  }\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /**\n   * @notice Initializes the contract with a staking strategy\n   * @dev Can only be called once due to initializer modifier\n   * @param _stakeStrategy The address of the staking strategy contract\n   */\n  function initialize(IStakeStrategy _stakeStrategy) external initializer {\n    stakeStrategy = _stakeStrategy;\n  }\n\n  /// @inheritdoc IStakeWallet\n  function stake(address /* _from */, uint256 _amount, bytes memory /* _data */) external override onlyStakeStrategy {\n    IERC20Upgradeable stakingToken = IERC20Upgradeable(stakeStrategy.stakingToken());\n    IVeloIonModeStaking stakingContract = IVeloIonModeStaking(stakeStrategy.stakingContract());\n\n    stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n    stakingToken.approve(address(stakingContract), _amount);\n    stakingContract.deposit(_amount);\n    emit Staked(_amount);\n  }\n\n  /// @inheritdoc IStakeWallet\n  function claim(address _from) external onlyStakeStrategy {\n    IERC20Upgradeable rewardToken = IERC20Upgradeable(stakeStrategy.rewardToken());\n    IVeloIonModeStaking stakingContract = IVeloIonModeStaking(stakeStrategy.stakingContract());\n\n    stakingContract.getReward(address(this));\n    uint256 rewardAmount = rewardToken.balanceOf(address(this));\n    IERC20Upgradeable(rewardToken).safeTransfer(_from, rewardAmount);\n    emit Claimed(_from, rewardAmount);\n  }\n\n  /// @inheritdoc IStakeWallet\n  function withdraw(address _withdrawTo, uint256 _amount) external onlyStakeStrategy {\n    IERC20Upgradeable stakingToken = IERC20Upgradeable(stakeStrategy.stakingToken());\n    IVeloIonModeStaking stakingContract = IVeloIonModeStaking(stakeStrategy.stakingContract());\n\n    stakingContract.withdraw(_amount);\n    stakingToken.safeTransfer(_withdrawTo, _amount);\n    emit Withdrawn(_withdrawTo, _amount);\n  }\n}\n"
    },
    "contracts/veION/veION.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { IveIONCore, IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVoter } from \"./interfaces/IVoter.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { veIONStorage } from \"./veIONStorage.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\n\n/**\n * @title veION Contract\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract veION is Ownable2StepUpgradeable, ERC721Upgradeable, ReentrancyGuardUpgradeable, veIONStorage, IveIONCore {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20;\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /**\n   * @notice Initializes the veION contract with the given AddressesProvider.\n   * @dev This function is called only once during the contract deployment.\n   * It initializes the Ownable, ERC721, and ReentrancyGuard modules.\n   * @param _ap The AddressesProvider contract used for address management.\n   */\n  function initialize(IAddressesProvider _ap) public initializer {\n    __Ownable2Step_init();\n    __ERC721_init(\"veION\", \"veION\");\n    __ReentrancyGuard_init();\n    ap = _ap;\n    emit Initialized(address(_ap));\n  }\n\n  // \n  //                            External Functions                              \n  // \n\n  /// @inheritdoc IveIONCore\n  function createLockFor(\n    address[] calldata _tokenAddress,\n    uint256[] calldata _tokenAmount,\n    uint256[] calldata _duration,\n    bool[] memory _stakeUnderlying,\n    address _to\n  ) external override nonReentrant returns (uint256) {\n    return _createLock(_tokenAddress, _tokenAmount, _duration, _stakeUnderlying, _to);\n  }\n\n  /// @inheritdoc IveIONCore\n  function createLock(\n    address[] calldata _tokenAddress,\n    uint256[] calldata _tokenAmount,\n    uint256[] calldata _duration,\n    bool[] memory _stakeUnderlying\n  ) external override nonReentrant returns (uint256) {\n    return _createLock(_tokenAddress, _tokenAmount, _duration, _stakeUnderlying, _msgSender());\n  }\n\n  /// @inheritdoc IveIONCore\n  function increaseAmount(\n    address _tokenAddress,\n    uint256 _tokenId,\n    uint256 _tokenAmount,\n    bool _stakeUnderlying\n  ) external nonReentrant {\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\n\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (_tokenAmount == 0) revert ZeroAmount();\n    if (oldLocked.amount == 0) revert NoLockFound();\n    if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent) revert LockExpired();\n\n    if (oldLocked.isPermanent) s_permanentLockBalance[_lpType] += _tokenAmount;\n\n    _depositFor(\n      _tokenAddress,\n      _tokenId,\n      _tokenAmount,\n      0,\n      _stakeUnderlying,\n      oldLocked,\n      DepositType.INCREASE_LOCK_AMOUNT,\n      _lpType,\n      _msgSender()\n    );\n  }\n\n  /// @inheritdoc IveIONCore\n  function lockAdditionalAsset(\n    address _tokenAddress,\n    uint256 _tokenAmount,\n    uint256 _tokenId,\n    uint256 _duration,\n    bool _stakeUnderlying\n  ) external nonReentrant {\n    LpTokenType lpType = s_lpType[_tokenAddress];\n    LockedBalance storage lockedBalance = s_locked[_tokenId][lpType];\n    uint256 unlockTime = ((block.timestamp + _duration) / _WEEK) * _WEEK;\n\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (_tokenAmount == 0) revert ZeroAmount();\n    if (s_voted[_tokenId]) revert AlreadyVoted();\n    if (!s_assetsLocked[_tokenId].add(_tokenAddress)) revert DuplicateAsset();\n    if (_tokenAmount < s_minimumLockAmount[lpType]) revert MinimumNotMet();\n    if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\n    if (_duration < s_minimumLockDuration) revert LockDurationTooShort();\n\n    if (lockedBalance.isPermanent) s_permanentLockBalance[lpType] += _tokenAmount;\n\n    _depositFor(\n      _tokenAddress,\n      _tokenId,\n      _tokenAmount,\n      unlockTime,\n      _stakeUnderlying,\n      lockedBalance,\n      DepositType.LOCK_ADDITIONAL,\n      lpType,\n      _msgSender()\n    );\n  }\n\n  /// @inheritdoc IveIONCore\n  function increaseUnlockTime(address _tokenAddress, uint256 _tokenId, uint256 _lockDuration) external nonReentrant {\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\n    uint256 unlockTime = ((block.timestamp + _lockDuration) / _WEEK) * _WEEK; // Locktime is rounded down to weeks\n\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (oldLocked.isPermanent) revert PermanentLock();\n    if (oldLocked.end <= block.timestamp) revert LockExpired();\n    if (oldLocked.amount <= 0) revert NoLockFound();\n    if (unlockTime <= oldLocked.end) revert LockDurationNotInFuture();\n    if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\n\n    _depositFor(\n      _tokenAddress,\n      _tokenId,\n      0,\n      unlockTime,\n      false,\n      oldLocked,\n      DepositType.INCREASE_UNLOCK_TIME,\n      _lpType,\n      _msgSender()\n    );\n  }\n\n  /// @inheritdoc IveIONCore\n  function delegate(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) external nonReentrant {\n    LpTokenType lpType = s_lpType[lpToken];\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\n\n    if (ownerOf(fromTokenId) != _msgSender()) revert NotOwner();\n    if (amount > fromLocked.amount) revert AmountTooBig();\n    if (!fromLocked.isPermanent) revert NotPermanentLock();\n    if (!toLocked.isPermanent) revert NotPermanentLock();\n    if (s_delegatorsBlocked[toTokenId][lpToken]) revert NotAcceptingDelegators();\n\n    fromLocked.amount -= amount;\n    toLocked.delegateAmount += amount;\n\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\n      s_delegatees[fromTokenId][lpType].add(toTokenId);\n      s_delegators[toTokenId][lpType].add(fromTokenId);\n    }\n\n    s_delegations[fromTokenId][toTokenId][lpType] += amount;\n\n    s_locked[fromTokenId][lpType] = fromLocked;\n    s_locked[toTokenId][lpType] = toLocked;\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\n\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\n\n    emit Delegated(fromTokenId, toTokenId, lpToken, amount);\n  }\n\n  /**\n   * @dev Internal function to remove a delegation between two veNFTs.\n   * @param fromTokenId ID of the veNFT from which delegation is being removed.\n   * @param toTokenId ID of the veNFT to which delegation is being removed.\n   * @param lpToken Address of the LP token associated with the delegation.\n   * @param amount Amount of delegation to remove.\n   */\n  function _removeDelegation(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) internal {\n    LpTokenType lpType = s_lpType[lpToken];\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\n\n    if (ownerOf(fromTokenId) != _msgSender() && ownerOf(toTokenId) != _msgSender()) revert NotOwner();\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) revert NoDelegationBetweenTokens(fromTokenId, toTokenId);\n\n    amount = amount > s_delegations[fromTokenId][toTokenId][lpType]\n      ? s_delegations[fromTokenId][toTokenId][lpType]\n      : amount;\n\n    toLocked.delegateAmount -= amount;\n    fromLocked.amount += amount;\n\n    s_delegations[fromTokenId][toTokenId][lpType] -= amount;\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\n      s_delegatees[fromTokenId][lpType].remove(toTokenId);\n      s_delegators[toTokenId][lpType].remove(fromTokenId);\n    }\n\n    s_locked[toTokenId][lpType] = toLocked;\n    s_locked[fromTokenId][lpType] = fromLocked;\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\n\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\n\n    emit DelegationRemoved(fromTokenId, toTokenId, lpToken, amount);\n  }\n\n  /// @inheritdoc IveIONCore\n  function removeDelegatees(\n    uint256 fromTokenId,\n    uint256[] memory toTokenIds,\n    address lpToken,\n    uint256[] memory amounts\n  ) public nonReentrant {\n    if (toTokenIds.length != amounts.length) revert ArrayMismatch();\n    uint256 toTokenIdsLength = toTokenIds.length;\n    for (uint256 i = 0; i < toTokenIdsLength; i++) {\n      _removeDelegation(fromTokenId, toTokenIds[i], lpToken, amounts[i]);\n    }\n  }\n\n  /// @inheritdoc IveIONCore\n  function removeDelegators(\n    uint256[] memory fromTokenIds,\n    uint256 toTokenId,\n    address lpToken,\n    uint256[] memory amounts\n  ) external nonReentrant {\n    if (fromTokenIds.length != amounts.length) revert ArrayMismatch();\n    uint256 fromTokenIdsLength = fromTokenIds.length;\n    for (uint256 i = 0; i < fromTokenIdsLength; i++) {\n      _removeDelegation(fromTokenIds[i], toTokenId, lpToken, amounts[i]);\n    }\n  }\n\n  /// @inheritdoc IveIONCore\n  function lockPermanent(address _tokenAddress, uint256 _tokenId) external nonReentrant {\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory _newLocked = s_locked[_tokenId][_lpType];\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (_newLocked.isPermanent) revert PermanentLock();\n    if (_newLocked.end <= block.timestamp) revert LockExpired();\n    if (_newLocked.amount <= 0) revert NoLockFound();\n\n    s_permanentLockBalance[_lpType] += _newLocked.amount;\n    _newLocked.end = 0;\n    _newLocked.isPermanent = true;\n    _newLocked.boost = _calculateBoost(_MAXTIME);\n\n    s_locked[_tokenId][_lpType] = _newLocked;\n    _checkpoint(_tokenId, _newLocked, _lpType);\n\n    emit PermanentLockCreated(_tokenAddress, _tokenId, _newLocked.amount);\n  }\n\n  /// @inheritdoc IveIONCore\n  function unlockPermanent(address _tokenAddress, uint256 _tokenId) external nonReentrant {\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory _newLocked = s_locked[_tokenId][_lpType];\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (!_newLocked.isPermanent) revert NotPermanentLock();\n    if (s_delegatees[_tokenId][_lpType].length() != 0) revert TokenHasDelegatees();\n    if (s_delegators[_tokenId][_lpType].length() != 0) revert TokenHasDelegators();\n\n    s_permanentLockBalance[_lpType] -= _newLocked.amount;\n    _newLocked.end = ((block.timestamp + _MAXTIME) / _WEEK) * _WEEK;\n    _newLocked.isPermanent = false;\n\n    s_locked[_tokenId][_lpType] = _newLocked;\n    _checkpoint(_tokenId, _newLocked, _lpType);\n\n    emit PermanentLockRemoved(_tokenAddress, _tokenId, _newLocked.amount);\n  }\n\n  /**\n   * @notice Overrides the _burn function from ERC721 to include additional logic for bridging.\n   * @param tokenId Token ID to burn.\n   */\n  function _burn(uint256 tokenId) internal override {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @notice Hook that is called before any token transfer. This includes minting\n   * and burning. It updates the ownership mappings and handles delegation and\n   * staking logic when transferring tokens between addresses.\n   *\n   * @param from The address which previously owned the token.\n   * @param to The address that will receive the token.\n   * @param tokenId The ID of the token being transferred.\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {\n    super._beforeTokenTransfer(from, to, tokenId);\n\n    if (from != address(0)) s_ownerToTokenIds[from].remove(tokenId);\n    if (to != address(0)) s_ownerToTokenIds[to].add(tokenId);\n\n    if (from != address(0) && to != address(0)) {\n      address[] memory assetsLocked = s_assetsLocked[tokenId].values();\n      uint256 assetsLockedLength = assetsLocked.length;\n      for (uint256 i = 0; i < assetsLockedLength; i++) {\n        address asset = assetsLocked[i];\n        LpTokenType _lpType = s_lpType[asset];\n\n        uint256[] memory delegatees = s_delegatees[tokenId][_lpType].values();\n        uint256[] memory amounts = new uint256[](delegatees.length);\n        uint256 delegateesLength = delegatees.length;\n        for (uint256 j = 0; j < delegateesLength; j++) {\n          amounts[j] = type(uint256).max;\n        }\n\n        if (delegateesLength != 0) {\n          removeDelegatees(tokenId, delegatees, asset, amounts);\n        }\n\n        uint256 amountStaked = s_underlyingStake[tokenId][asset];\n        if (amountStaked != 0) {\n          IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\n          _stakeStrategy.transferStakingWallet(from, to, amountStaked);\n        }\n\n        LockedBalance memory lock = s_locked[tokenId][_lpType];\n        s_userCumulativeAssetValues[from][asset] -= lock.amount;\n        s_userCumulativeAssetValues[to][asset] += lock.amount;\n      }\n    }\n  }\n\n  /// @inheritdoc IveIONCore\n  function voting(uint256 _tokenId, bool _voting) external {\n    if (_msgSender() != s_voter) revert NotVoter();\n    s_voted[_tokenId] = _voting;\n    emit Voted(_tokenId, _voting);\n  }\n\n  // \n  //                            Internal Functions                              \n  // \n\n  struct DepositVars {\n    uint256 supplyBefore;\n    uint256 totalLockTime;\n    LockedBalance newLocked;\n    address from;\n  }\n\n  /**\n   * @notice Deposits tokens for a specific veNFT, updating its locked balance and boost.\n   * @dev This function handles the deposit logic for veNFTs, including updating the locked balance,\n   *      calculating the boost based on the lock duration, and transferring tokens.\n   * @param _tokenAddress The address of the token to deposit.\n   * @param _tokenId The ID of the veNFT to deposit tokens for.\n   * @param _tokenAmount The amount of tokens to deposit.\n   * @param _unlockTime The time at which the lock will expire.\n   * @param _stakeUnderlying A boolean indicating whether to stake the underlying tokens.\n   * @param _oldLocked The previous locked balance of the veNFT.\n   * @param _depositType The type of deposit being made.\n   * @param _lpType The LP token type associated with the deposit.\n   * @param _to The address to which the veNFT is assigned.\n   */\n  function _depositFor(\n    address _tokenAddress,\n    uint256 _tokenId,\n    uint256 _tokenAmount,\n    uint256 _unlockTime,\n    bool _stakeUnderlying,\n    LockedBalance memory _oldLocked,\n    DepositType _depositType,\n    LpTokenType _lpType,\n    address _to\n  ) internal {\n    if (!s_whitelistedToken[_tokenAddress]) revert TokenNotWhitelisted();\n\n    DepositVars memory vars;\n    vars.supplyBefore = s_supply[_lpType];\n    s_supply[_lpType] = vars.supplyBefore + _tokenAmount;\n\n    (\n      vars.newLocked.tokenAddress,\n      vars.newLocked.amount,\n      vars.newLocked.start,\n      vars.newLocked.end,\n      vars.newLocked.isPermanent,\n      vars.newLocked.boost\n    ) = (\n      _oldLocked.tokenAddress,\n      _oldLocked.amount,\n      _oldLocked.start,\n      _oldLocked.end,\n      _oldLocked.isPermanent,\n      _oldLocked.boost\n    );\n\n    vars.newLocked.tokenAddress = _tokenAddress;\n    vars.newLocked.amount += _tokenAmount;\n    if (_unlockTime != 0) {\n      if (vars.newLocked.start == 0) vars.newLocked.start = block.timestamp;\n      vars.newLocked.end = _unlockTime;\n      vars.totalLockTime = vars.newLocked.end - vars.newLocked.start;\n      vars.newLocked.boost = _calculateBoost(vars.totalLockTime);\n    }\n    s_locked[_tokenId][_lpType] = vars.newLocked;\n\n    _checkpoint(_tokenId, vars.newLocked, _lpType);\n\n    vars.from = _msgSender();\n    if (_tokenAmount != 0) {\n      s_userCumulativeAssetValues[ownerOf(_tokenId)][_tokenAddress] += _tokenAmount;\n      IERC20(_tokenAddress).safeTransferFrom(vars.from, address(this), _tokenAmount);\n      (IStakeStrategy _stakeStrategy, bytes memory _stakeData) = _getStakeStrategy(_lpType);\n      if (address(_stakeStrategy) != address(0) && _stakeUnderlying) {\n        _handleTokenStake(_to, _tokenId, _tokenAddress, _tokenAmount, _stakeStrategy, _stakeData);\n      }\n    }\n\n    emit Deposit(_to, _tokenId, _depositType, _tokenAmount, vars.newLocked.end, block.timestamp);\n    emit Supply(vars.supplyBefore, s_supply[_lpType]);\n  }\n\n  /**\n   * @notice Handles the staking of tokens using a specified staking strategy.\n   * @param _to The address to which the stake is attributed.\n   * @param _tokenId The ID of the token being staked.\n   * @param _tokenAddress The address of the token being staked.\n   * @param _tokenAmount The amount of tokens to stake.\n   * @param _stakeStrategy The staking strategy to use.\n   * @param _stakeData Additional data required for staking.\n   */\n  function _handleTokenStake(\n    address _to,\n    uint256 _tokenId,\n    address _tokenAddress,\n    uint256 _tokenAmount,\n    IStakeStrategy _stakeStrategy,\n    bytes memory _stakeData\n  ) internal {\n    IERC20(_tokenAddress).approve(address(_stakeStrategy), _tokenAmount);\n    _stakeStrategy.stake(_to, _tokenAmount, _stakeData);\n    s_underlyingStake[_tokenId][_tokenAddress] += _tokenAmount;\n  }\n\n  /**\n   * @notice Updates the user point history and epoch for a given token and LP token type.\n   * @param _tokenId The ID of the token.\n   * @param _newLocked The new locked balance information.\n   * @param _lpType The LP token type.\n   */\n  function _checkpoint(uint256 _tokenId, LockedBalance memory _newLocked, LpTokenType _lpType) internal {\n    UserPoint memory uNew;\n    uNew.permanent = _newLocked.isPermanent ? _newLocked.amount : 0;\n    uNew.permanentDelegate = _newLocked.isPermanent ? _newLocked.delegateAmount : 0;\n\n    if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n      uNew.slope = _newLocked.amount / _MAXTIME;\n      uNew.bias = uNew.slope * (_newLocked.end - block.timestamp);\n    }\n\n    uNew.ts = block.timestamp;\n    uNew.blk = block.number;\n    uint256 userEpoch = s_userPointEpoch[_tokenId][_lpType];\n    if (userEpoch != 0 && s_userPointHistory[_tokenId][_lpType][userEpoch].ts == block.timestamp) {\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\n    } else {\n      s_userPointEpoch[_tokenId][_lpType] = ++userEpoch;\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\n    }\n  }\n\n  /**\n   * @notice Creates a lock for multiple tokens with specified durations and staking options.\n   * @param _tokenAddress Array of token addresses to lock.\n   * @param _tokenAmount Array of token amounts to lock.\n   * @param _duration Array of durations for each lock.\n   * @param _stakeUnderlying Array of booleans indicating whether to stake the underlying tokens.\n   * @param _to The address to which the lock is attributed.\n   * @return The ID of the newly created lock.\n   */\n  function _createLock(\n    address[] memory _tokenAddress,\n    uint256[] memory _tokenAmount,\n    uint256[] memory _duration,\n    bool[] memory _stakeUnderlying,\n    address _to\n  ) internal returns (uint256) {\n    uint256 _tokenId = ++s_tokenId;\n    uint256 _length = _tokenAddress.length;\n    _safeMint(_to, _tokenId);\n\n    if (\n      _tokenAddress.length != _tokenAmount.length ||\n      _tokenAmount.length != _duration.length ||\n      _duration.length != _stakeUnderlying.length\n    ) {\n      revert ArrayMismatch();\n    }\n\n    for (uint256 i = 0; i < _length; i++) {\n      LpTokenType _lpType = s_lpType[_tokenAddress[i]];\n      uint256 unlockTime = ((block.timestamp + _duration[i]) / _WEEK) * _WEEK;\n\n      if (!s_assetsLocked[_tokenId].add(_tokenAddress[i])) revert DuplicateAsset();\n      if (_tokenAmount[i] == 0) revert ZeroAmount();\n      if (_duration[i] < s_minimumLockDuration) revert LockDurationTooShort();\n      if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\n      if (_tokenAmount[i] < s_minimumLockAmount[_lpType]) revert MinimumNotMet();\n\n      _depositFor(\n        _tokenAddress[i],\n        _tokenId,\n        _tokenAmount[i],\n        unlockTime,\n        _stakeUnderlying[i],\n        s_locked[_tokenId][_lpType],\n        DepositType.CREATE_LOCK_TYPE,\n        _lpType,\n        _to\n      );\n    }\n    return _tokenId;\n  }\n\n  /**\n   * @notice Calculates the boost for a given lock duration.\n   * @param _duration The duration of the lock.\n   * @return The calculated boost value.\n   */\n  function _calculateBoost(uint256 _duration) internal view returns (uint256) {\n    uint256 minDuration = s_minimumLockDuration;\n    uint256 maxDuration = _MAXTIME;\n    uint256 minBoost = 1e18;\n    uint256 maxBoost = 2e18;\n\n    if (_duration <= minDuration) {\n      return minBoost;\n    } else if (_duration >= maxDuration) {\n      return maxBoost;\n    } else {\n      return minBoost + ((_duration - minDuration) * (maxBoost - minBoost)) / (maxDuration - minDuration);\n    }\n  }\n\n  /**\n   * @notice Retrieves the staking strategy and data for a given LP token type.\n   * @param _lpType The LP token type.\n   * @return _stakeStrategy The staking strategy for the LP token type.\n   * @return _stakeData The staking data for the LP token type.\n   */\n  function _getStakeStrategy(\n    LpTokenType _lpType\n  ) internal view returns (IStakeStrategy _stakeStrategy, bytes memory _stakeData) {\n    IStakeStrategy strategy = s_stakeStrategy[_lpType];\n    return (strategy, \"\");\n  }\n\n  /// @inheritdoc IveIONCore\n  function setExtensions(address _veIONFirstExtension, address _veIONSecondExtension) external onlyOwner {\n    require(_veIONFirstExtension != address(0), \"Invalid First Extension Address\");\n    require(_veIONSecondExtension != address(0), \"Invalid Second Extension Address\");\n    require(_veIONFirstExtension != _veIONSecondExtension, \"Submitted Identical Addresses\");\n    veIONFirstExtension = _veIONFirstExtension;\n    veIONSecondExtension = _veIONSecondExtension;\n    emit ExtensionsSet(_veIONFirstExtension, _veIONSecondExtension);\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external {\n    address impl = veIONFirstExtension;\n    require(impl != address(0), \"Implementation not set\");\n\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n\n      let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/veION/veIONFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVoter } from \"./interfaces/IVoter.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { veIONStorage } from \"./veIONStorage.sol\";\nimport { BalanceLogicLibrary } from \"./libraries/BalanceLogicLibrary.sol\";\nimport { IveIONFirstExtension } from \"./interfaces/IveIONFirstExtension.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\n\n/**\n * @title veION Contract First Extensions\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract veIONFirstExtension is\n  Ownable2StepUpgradeable,\n  ERC721Upgradeable,\n  ReentrancyGuardUpgradeable,\n  veIONStorage,\n  IveIONFirstExtension\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20;\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  // \n  //                            External Functions                              \n  // \n\n  /// @inheritdoc IveIONFirstExtension\n  function withdraw(address _tokenAddress, uint256 _tokenId) external nonReentrant {\n    address sender = _msgSender();\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\n\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    if (s_voted[_tokenId]) revert AlreadyVoted();\n    if (oldLocked.isPermanent) revert PermanentLock();\n    if (!s_whitelistedToken[_tokenAddress]) revert TokenNotWhitelisted();\n    if (oldLocked.amount == 0 || !s_assetsLocked[_tokenId].contains(_tokenAddress)) revert NoLockFound();\n\n    uint256 value = oldLocked.amount;\n    s_userCumulativeAssetValues[sender][_tokenAddress] -= value;\n    uint256 fee = 0;\n\n    if (block.timestamp < oldLocked.end) {\n      uint256 daysLocked = ((oldLocked.end - oldLocked.start) * 1e18) / 1 days;\n      uint256 daysLeft = ((oldLocked.end - block.timestamp) * 1e18) / 1 days;\n      uint256 timeFactor = (daysLeft * 1e18) / daysLocked;\n      uint256 veLPLocked = s_supply[_lpType];\n      uint256 LPInCirculation = IERC20(_tokenAddress).totalSupply();\n      uint256 ratioFactor = 1e18 - (veLPLocked * 1e18) / LPInCirculation;\n      fee = (timeFactor * ratioFactor * oldLocked.boost) / 1e36;\n      if (fee > s_maxEarlyWithdrawFee) fee = s_maxEarlyWithdrawFee;\n      fee = (value * fee) / 1e18;\n      value -= fee;\n\n      uint256 feeToDistribute = (fee * 75) / 100;\n      uint256 feeToProtocol = fee - feeToDistribute;\n      s_protocolFees[_lpType] += feeToProtocol;\n      s_distributedFees[_lpType] += feeToDistribute;\n    }\n\n    s_locked[_tokenId][_lpType] = LockedBalance(address(0), 0, 0, 0, 0, false, 0);\n    s_assetsLocked[_tokenId].remove(_tokenAddress);\n    uint256 supplyBefore = s_supply[_lpType];\n\n    uint256 amountStaked = s_underlyingStake[_tokenId][_tokenAddress];\n    if (amountStaked != 0) {\n      (IStakeStrategy _stakeStrategy, ) = _getStakeStrategy(_lpType);\n      if (address(_stakeStrategy) != address(0)) {\n        _handleTokenWithdrawStake(sender, address(this), _tokenId, _tokenAddress, amountStaked, _stakeStrategy);\n      }\n    }\n\n    s_supply[_lpType] = supplyBefore - oldLocked.amount;\n    _checkpoint(_tokenId, LockedBalance(address(0), 0, 0, 0, 0, false, 0), _lpType);\n\n    // Check if all LP types for this token have zero balance\n    bool shouldBurn = true;\n    address[] memory lockedAssets = s_assetsLocked[_tokenId].values();\n    uint256 lockedAssetsLength = lockedAssets.length;\n    for (uint256 i = 0; i < lockedAssetsLength; i++) {\n      LpTokenType assetLpType = s_lpType[lockedAssets[i]];\n      if (s_locked[_tokenId][assetLpType].amount > 0) {\n        shouldBurn = false;\n        break;\n      }\n    }\n\n    if (shouldBurn) _burn(_tokenId);\n\n    IERC20(_tokenAddress).safeTransfer(sender, value);\n    emit Withdraw(sender, _tokenId, value, block.timestamp);\n    emit Supply(supplyBefore, supplyBefore - oldLocked.amount);\n  }\n\n  /// @inheritdoc IveIONFirstExtension\n  function merge(uint256 _from, uint256 _to) external nonReentrant {\n    if (_from == _to) revert SameNFT();\n    if (s_voted[_from] || s_voted[_to]) revert AlreadyVoted();\n    if (ownerOf(_from) != _msgSender()) revert NotOwner();\n    if (ownerOf(_to) != _msgSender()) revert NotOwner();\n\n    address[] memory assetsLocked = s_assetsLocked[_from].values();\n    uint256 assetsLockedLength = assetsLocked.length;\n    for (uint256 i = 0; i < assetsLockedLength; i++) {\n      address asset = assetsLocked[i];\n      LpTokenType lpType = s_lpType[asset];\n\n      LockedBalance memory oldLockedTo = s_locked[_to][lpType];\n      LockedBalance memory oldLockedFrom = s_locked[_from][lpType];\n\n      if (oldLockedTo.end != 0 && oldLockedTo.end <= block.timestamp) revert LockExpired();\n      if (oldLockedFrom.end != 0 && oldLockedFrom.end <= block.timestamp) revert LockExpired();\n      if (oldLockedFrom.isPermanent) revert PermanentLock();\n      if (oldLockedTo.isPermanent) revert PermanentLock();\n\n      LockedBalance memory newLockedTo;\n\n      newLockedTo.tokenAddress = asset;\n      newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\n      newLockedTo.start = oldLockedTo.start < oldLockedFrom.start && oldLockedTo.start != 0\n        ? oldLockedTo.start\n        : oldLockedFrom.start;\n      newLockedTo.end = oldLockedTo.end > oldLockedFrom.end ? oldLockedTo.end : oldLockedFrom.end;\n      newLockedTo.boost = _calculateBoost(newLockedTo.end - newLockedTo.start);\n\n      s_locked[_from][lpType] = LockedBalance(address(0), 0, 0, 0, 0, false, 0);\n      _checkpoint(_from, LockedBalance(address(0), 0, 0, 0, 0, false, 0), lpType);\n      s_locked[_to][lpType] = newLockedTo;\n      _checkpoint(_to, newLockedTo, lpType);\n\n      s_assetsLocked[_from].remove(asset);\n      if (!s_assetsLocked[_to].contains(asset)) {\n        s_assetsLocked[_to].add(asset);\n      }\n\n      if (s_underlyingStake[_from][asset] != 0) {\n        s_underlyingStake[_to][asset] += s_underlyingStake[_from][asset];\n        s_underlyingStake[_from][asset] = 0;\n      }\n    }\n    _burn(_from);\n    emit MergeCompleted(_from, _to, assetsLocked, assetsLocked.length);\n  }\n\n  /// @inheritdoc IveIONFirstExtension\n  function split(\n    address _tokenAddress,\n    uint256 _from,\n    uint256 _splitAmount\n  ) external nonReentrant returns (uint256 _tokenId1, uint256 _tokenId2) {\n    address ownerFrom = _ownerOf(_from);\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    LockedBalance memory oldLocked = s_locked[_from][_lpType];\n    uint256 minimumLockAmount = s_minimumLockAmount[_lpType];\n\n    if (s_voted[_from]) revert AlreadyVoted();\n    if (!s_canSplit[ownerFrom] && !s_canSplit[address(0)]) revert SplitNotAllowed();\n    if (ownerFrom != _msgSender()) revert NotOwner();\n    if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent) revert LockExpired();\n    if (_splitAmount >= oldLocked.amount) revert AmountTooBig();\n    if (_splitAmount < minimumLockAmount) revert SplitTooSmall();\n    if (oldLocked.amount - _splitAmount < minimumLockAmount) revert NotEnoughRemainingAfterSplit();\n\n    LockedBalance memory oldLockedTemp = oldLocked;\n\n    oldLocked.amount -= _splitAmount;\n    s_locked[_from][_lpType] = oldLocked;\n    _checkpoint(_from, oldLocked, _lpType);\n\n    LockedBalance memory splitLocked = oldLockedTemp;\n    splitLocked.amount = _splitAmount;\n    _tokenId2 = _createSplitVE(ownerFrom, splitLocked, _lpType, _tokenAddress);\n    _tokenId1 = _from;\n\n    if (s_underlyingStake[_from][_tokenAddress] != 0) {\n      s_underlyingStake[_from][_tokenAddress] -= _splitAmount;\n      s_underlyingStake[_tokenId2][_tokenAddress] = _splitAmount;\n    }\n\n    emit SplitCompleted(_from, _tokenId1, _tokenId2, _splitAmount, _tokenAddress);\n  }\n\n  /// @inheritdoc IveIONFirstExtension\n  function claimEmissions(address _tokenAddress) external nonReentrant {\n    LpTokenType _lpType = s_lpType[_tokenAddress];\n    IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\n    if (_stakeStrategy.userStakingWallet(_msgSender()) == address(0)) revert NoUnderlyingStake();\n    _stakeStrategy.claim(_msgSender());\n    emit EmissionsClaimed(_msgSender(), _tokenAddress);\n  }\n\n  /**\n   * @notice Overrides the _burn function from ERC721 to include additional logic for bridging.\n   * @param tokenId Token ID to burn.\n   */\n  function _burn(uint256 tokenId) internal override {\n    super._burn(tokenId);\n  }\n\n  /**\n   * @notice Hook that is called before any token transfer. This includes minting\n   * and burning. It updates the ownership mappings and handles delegation and\n   * staking logic when transferring tokens between addresses.\n   *\n   * @param from The address which previously owned the token.\n   * @param to The address that will receive the token.\n   * @param tokenId The ID of the token being transferred.\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {\n    super._beforeTokenTransfer(from, to, tokenId);\n\n    if (from != address(0)) s_ownerToTokenIds[from].remove(tokenId);\n    if (to != address(0)) s_ownerToTokenIds[to].add(tokenId);\n\n    if (from != address(0) && to != address(0)) {\n      address[] memory assetsLocked = s_assetsLocked[tokenId].values();\n      uint256 assetsLockedLength = assetsLocked.length;\n      for (uint256 i = 0; i < assetsLockedLength; i++) {\n        address asset = assetsLocked[i];\n        LpTokenType _lpType = s_lpType[asset];\n\n        uint256[] memory delegatees = s_delegatees[tokenId][_lpType].values();\n        uint256[] memory amounts = new uint256[](delegatees.length);\n        uint256 delegateesLength = delegatees.length;\n        for (uint256 j = 0; j < delegateesLength; j++) {\n          amounts[j] = type(uint256).max;\n        }\n\n        if (delegateesLength != 0) {\n          removeDelegatees(tokenId, delegatees, asset, amounts);\n        }\n\n        uint256 amountStaked = s_underlyingStake[tokenId][asset];\n        if (amountStaked != 0) {\n          IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\n          _stakeStrategy.transferStakingWallet(from, to, amountStaked);\n        }\n\n        LockedBalance memory lock = s_locked[tokenId][_lpType];\n        s_userCumulativeAssetValues[from][asset] -= lock.amount;\n        s_userCumulativeAssetValues[to][asset] += lock.amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function to remove a delegation between two veNFTs.\n   * @param fromTokenId ID of the veNFT from which delegation is being removed.\n   * @param toTokenId ID of the veNFT to which delegation is being removed.\n   * @param lpToken Address of the LP token associated with the delegation.\n   * @param amount Amount of delegation to remove.\n   */\n  function _removeDelegation(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) internal {\n    LpTokenType lpType = s_lpType[lpToken];\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\n\n    if (ownerOf(fromTokenId) != _msgSender() && ownerOf(toTokenId) != _msgSender()) revert NotOwner();\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) revert NoDelegationBetweenTokens(fromTokenId, toTokenId);\n\n    amount = amount > s_delegations[fromTokenId][toTokenId][lpType]\n      ? s_delegations[fromTokenId][toTokenId][lpType]\n      : amount;\n\n    toLocked.delegateAmount -= amount;\n    fromLocked.amount += amount;\n\n    s_delegations[fromTokenId][toTokenId][lpType] -= amount;\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\n      s_delegatees[fromTokenId][lpType].remove(toTokenId);\n      s_delegators[toTokenId][lpType].remove(fromTokenId);\n    }\n\n    s_locked[toTokenId][lpType] = toLocked;\n    s_locked[fromTokenId][lpType] = fromLocked;\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\n\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\n\n    emit DelegationRemoved(fromTokenId, toTokenId, lpToken, amount);\n  }\n\n  /**\n   * @notice Removes delegatees from a specific veNFT\n   * @param fromTokenId ID of the veNFT from which delegatees are removed\n   * @param toTokenIds Array of veNFT IDs that are delegatees to be removed\n   * @param lpToken Address of the LP token associated with the delegation\n   * @param amounts Array of amounts of voting power to remove from each delegatee\n   */\n  function removeDelegatees(\n    uint256 fromTokenId,\n    uint256[] memory toTokenIds,\n    address lpToken,\n    uint256[] memory amounts\n  ) public nonReentrant {\n    if (toTokenIds.length != amounts.length) revert ArrayMismatch();\n    uint256 toTokenIdsLength = toTokenIds.length;\n    for (uint256 i = 0; i < toTokenIdsLength; i++) {\n      _removeDelegation(fromTokenId, toTokenIds[i], lpToken, amounts[i]);\n    }\n  }\n\n  /// @inheritdoc IveIONFirstExtension\n  function allowDelegators(uint256 _tokenId, address _tokenAddress, bool _blocked) external nonReentrant {\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    s_delegatorsBlocked[_tokenId][_tokenAddress] = _blocked;\n    emit DelegatorsBlocked(_tokenId, _tokenAddress, _blocked);\n  }\n\n  // \n  //                            Internal Functions                              \n  // \n\n  /**\n   * @notice Handles the withdrawal of staked tokens using a specified staking strategy.\n   * @param _owner The address of the owner of the stake.\n   * @param _withdrawTo The address to which the withdrawn tokens are sent.\n   * @param _tokenId The ID of the token being withdrawn.\n   * @param _tokenAddress The address of the token being withdrawn.\n   * @param _tokenAmount The amount of tokens to withdraw.\n   * @param _stakeStrategy The staking strategy to use for withdrawal.\n   */\n  function _handleTokenWithdrawStake(\n    address _owner,\n    address _withdrawTo,\n    uint256 _tokenId,\n    address _tokenAddress,\n    uint256 _tokenAmount,\n    IStakeStrategy _stakeStrategy\n  ) internal {\n    _stakeStrategy.claim(_owner);\n    _stakeStrategy.withdraw(_owner, _withdrawTo, _tokenAmount);\n    s_underlyingStake[_tokenId][_tokenAddress] -= _tokenAmount;\n  }\n\n  /**\n   * @notice Updates the user point history and epoch for a given token and LP token type.\n   * @param _tokenId The ID of the token.\n   * @param _newLocked The new locked balance information.\n   * @param _lpType The LP token type.\n   */\n  function _checkpoint(uint256 _tokenId, LockedBalance memory _newLocked, LpTokenType _lpType) internal {\n    UserPoint memory uNew;\n    uNew.permanent = _newLocked.isPermanent ? _newLocked.amount : 0;\n    uNew.permanentDelegate = _newLocked.isPermanent ? _newLocked.delegateAmount : 0;\n\n    if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\n      uNew.slope = _newLocked.amount / _MAXTIME;\n      uNew.bias = uNew.slope * (_newLocked.end - block.timestamp);\n    }\n\n    uNew.ts = block.timestamp;\n    uNew.blk = block.number;\n    uint256 userEpoch = s_userPointEpoch[_tokenId][_lpType];\n    if (userEpoch != 0 && s_userPointHistory[_tokenId][_lpType][userEpoch].ts == block.timestamp) {\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\n    } else {\n      s_userPointEpoch[_tokenId][_lpType] = ++userEpoch;\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\n    }\n  }\n\n  /**\n   * @notice Calculates the boost for a given lock duration.\n   * @param _duration The duration of the lock.\n   * @return The calculated boost value.\n   */\n  function _calculateBoost(uint256 _duration) internal view returns (uint256) {\n    uint256 minDuration = s_minimumLockDuration;\n    uint256 maxDuration = _MAXTIME;\n    uint256 minBoost = 1e18;\n    uint256 maxBoost = 2e18;\n\n    if (_duration <= minDuration) {\n      return minBoost;\n    } else if (_duration >= maxDuration) {\n      return maxBoost;\n    } else {\n      return minBoost + ((_duration - minDuration) * (maxBoost - minBoost)) / (maxDuration - minDuration);\n    }\n  }\n\n  /**\n   * @notice Creates a new split veNFT with specified locked balance and LP token type.\n   * @param _to The address to which the new veNFT is attributed.\n   * @param _newLocked The locked balance information for the new veNFT.\n   * @param _lpType The LP token type.\n   * @param _tokenAddress The address of the token being locked.\n   * @return _tokenId The ID of the newly created veNFT.\n   */\n  function _createSplitVE(\n    address _to,\n    LockedBalance memory _newLocked,\n    LpTokenType _lpType,\n    address _tokenAddress\n  ) private returns (uint256 _tokenId) {\n    _tokenId = ++s_tokenId;\n    _safeMint(_to, _tokenId);\n    s_locked[_tokenId][_lpType] = _newLocked;\n    s_assetsLocked[_tokenId].add(_tokenAddress);\n    _checkpoint(_tokenId, _newLocked, _lpType);\n  }\n\n  /**\n   * @notice Retrieves the staking strategy and data for a given LP token type.\n   * @param _lpType The LP token type.\n   * @return _stakeStrategy The staking strategy for the LP token type.\n   * @return _stakeData The staking data for the LP token type.\n   */\n  function _getStakeStrategy(\n    LpTokenType _lpType\n  ) internal view returns (IStakeStrategy _stakeStrategy, bytes memory _stakeData) {\n    IStakeStrategy strategy = s_stakeStrategy[_lpType];\n    return (strategy, \"\");\n  }\n\n  /**\n   * @notice Calculates the total boost for a given token ID and LP token type.\n   * @param _tokenId The ID of the token.\n   * @param _lpType The LP token type.\n   * @return The total boost value.\n   */\n  function _getTotalBoost(uint256 _tokenId, LpTokenType _lpType) internal view returns (uint256) {\n    uint256 totalBoost = s_locked[_tokenId][_lpType].boost;\n    if (s_limitedBoostActive) totalBoost += s_limitedBoost;\n    if (s_veAERO == address(0)) return totalBoost;\n\n    address _owner = ownerOf(_tokenId);\n    IAeroVoter aeroVoter = IAeroVoter(s_aeroVoting);\n    IAeroVotingEscrow veAERO = IAeroVotingEscrow(s_veAERO);\n    uint256 _balance = veAERO.balanceOf(_owner);\n    for (uint256 i = 0; i < _balance; i++) {\n      uint256 veAeroTokenId = veAERO.ownerToNFTokenIdList(_owner, i);\n      uint256 weightToVoteRatio = (aeroVoter.votes(veAeroTokenId, s_ionicPool) * 1e18) / aeroVoter.weights(s_ionicPool);\n      totalBoost += (s_aeroVoterBoost * weightToVoteRatio) / 1e18;\n    }\n\n    return totalBoost;\n  }\n\n  /**\n   * @notice Retrieves the ETH price of a given token.\n   * @dev Uses the MasterPriceOracle to fetch the price.\n   * @param _token The address of the token for which the ETH price is requested.\n   * @return The ETH price of the specified token.\n   */\n  function _getEthPrice(address _token) internal view returns (uint256) {\n    IMasterPriceOracle mpo = IMasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    return mpo.price(_token);\n  }\n\n  // // \n  // //                            View Functions                                  \n  // // \n\n  /// @inheritdoc IveIONFirstExtension\n  function balanceOfNFT(\n    uint256 _tokenId\n  ) public view returns (address[] memory _assets, uint256[] memory _balances, uint256[] memory _boosts) {\n    address[] memory assetsLocked = s_assetsLocked[_tokenId].values();\n\n    _assets = new address[](assetsLocked.length);\n    _balances = new uint256[](assetsLocked.length);\n    _boosts = new uint256[](assetsLocked.length);\n    uint256 assetsLockedLength = assetsLocked.length;\n    for (uint256 i = 0; i < assetsLockedLength; i++) {\n      address asset = assetsLocked[i];\n      LpTokenType lpType = s_lpType[asset];\n      LockedBalance memory lockedBalance = s_locked[_tokenId][lpType];\n      _boosts[i] = _getTotalBoost(_tokenId, lpType);\n      _assets[i] = asset;\n      _balances[i] = BalanceLogicLibrary.balanceOfNFTAt(\n        s_userPointEpoch,\n        s_userPointHistory,\n        lpType,\n        _tokenId,\n        block.timestamp,\n        lockedBalance.isPermanent\n      );\n    }\n\n    return (_assets, _balances, _boosts);\n  }\n\n  /// @inheritdoc IveIONFirstExtension\n  function getTotalEthValueOfTokens(address _owner) external view returns (uint256 totalValue) {\n    IVoter voter = IVoter(s_voter);\n    address[] memory lpTokens = voter.getAllLpRewardTokens();\n    uint256 lpTokensLength = lpTokens.length;\n    for (uint256 i = 0; i < lpTokensLength; i++) {\n      uint256 ethValue = (s_userCumulativeAssetValues[_owner][lpTokens[i]] * _getEthPrice(lpTokens[i])) / PRECISION;\n      totalValue += ethValue;\n    }\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external {\n    address impl = veIONSecondExtension;\n    require(impl != address(0), \"Implementation not set\");\n\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n\n      let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/veION/veIONSecondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IVoter } from \"./interfaces/IVoter.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\nimport { veIONStorage } from \"./veIONStorage.sol\";\nimport { BalanceLogicLibrary } from \"./libraries/BalanceLogicLibrary.sol\";\nimport { IveIONSecondExtension } from \"./interfaces/IveIONSecondExtension.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\n\n/**\n * @title veION Contract Second Extension\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract veIONSecondExtension is\n  Ownable2StepUpgradeable,\n  ERC721Upgradeable,\n  ReentrancyGuardUpgradeable,\n  veIONStorage,\n  IveIONSecondExtension\n{\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20 for IERC20;\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function whitelistTokens(address[] memory _tokens, bool[] memory _isWhitelisted) external onlyOwner {\n    require(_tokens.length == _isWhitelisted.length, \"Unequal Arrays\");\n    for (uint256 i; i < _tokens.length; i++) s_whitelistedToken[_tokens[i]] = _isWhitelisted[i];\n    emit TokensWhitelisted(_tokens, _isWhitelisted);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function withdrawProtocolFees(address _tokenAddress, address _recipient) external onlyOwner {\n    LpTokenType lpType = s_lpType[_tokenAddress];\n    uint256 protocolFees = s_protocolFees[lpType];\n    require(protocolFees > 0, \"No protocol fees available\");\n    s_protocolFees[lpType] = 0;\n    IERC20(_tokenAddress).safeTransfer(_recipient, protocolFees);\n    emit ProtocolFeesWithdrawn(_tokenAddress, _recipient, protocolFees);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function withdrawDistributedFees(address _tokenAddress, address _recipient) external onlyOwner {\n    LpTokenType lpType = s_lpType[_tokenAddress];\n    uint256 distributedFees = s_distributedFees[lpType];\n    require(distributedFees > 0, \"No distributed fees available\");\n    s_distributedFees[lpType] = 0;\n    IERC20(_tokenAddress).safeTransfer(_recipient, distributedFees);\n    emit DistributedFeesWithdrawn(_tokenAddress, _recipient, distributedFees);\n  }\n\n  // \n  //                            Setter Functions                                \n  // \n\n  /// @inheritdoc IveIONSecondExtension\n  function toggleSplit(address _account, bool _isAllowed) external onlyOwner {\n    s_canSplit[_account] = _isAllowed;\n    emit SplitToggle(_account, _isAllowed);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function toggleLimitedBoost(bool _isBoosted) external onlyOwner {\n    s_limitedBoostActive = _isBoosted;\n    emit LimitedBoostToggled(_isBoosted);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setLimitedTimeBoost(uint256 _boostAmount) external onlyOwner {\n    if (_boostAmount <= 0) revert BoostAmountMustBeGreaterThanZero();\n    s_limitedBoost = _boostAmount;\n    emit LimitedTimeBoostSet(_boostAmount);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setVoter(address _voter) external onlyOwner {\n    if (address(_voter) == address(0)) revert InvalidAddress();\n    s_voter = _voter;\n    emit VoterSet(_voter);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setMinimumLockAmount(address _tokenAddress, uint256 _minimumAmount) external onlyOwner {\n    if (_minimumAmount <= 0) revert MinimumAmountMustBeGreaterThanZero();\n    LpTokenType lpType = s_lpType[_tokenAddress];\n    s_minimumLockAmount[lpType] = _minimumAmount;\n    emit MinimumLockAmountSet(_tokenAddress, _minimumAmount);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setMinimumLockDuration(uint256 _minimumLockDuration) external onlyOwner {\n    if (_minimumLockDuration <= 0) revert MinimumLockDurationMustBeGreaterThanZero();\n    s_minimumLockDuration = _minimumLockDuration;\n    emit MinimumLockDurationSet(_minimumLockDuration);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setIonicPool(address _ionicPool) external onlyOwner {\n    if (address(_ionicPool) == address(0)) revert InvalidAddress();\n    s_ionicPool = _ionicPool;\n    emit IonicPoolSet(_ionicPool);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setAeroVoting(address _aeroVoting) external onlyOwner {\n    if (address(_aeroVoting) == address(0)) revert InvalidAddress();\n    s_aeroVoting = _aeroVoting;\n    emit AeroVotingSet(_aeroVoting);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setAeroVoterBoost(uint256 _aeroVoterBoost) external onlyOwner {\n    if (_aeroVoterBoost <= 0) revert AeroBoostAmountMustBeGreaterThanZero();\n    s_aeroVoterBoost = _aeroVoterBoost;\n    emit AeroVoterBoostSet(_aeroVoterBoost);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setMaxEarlyWithdrawFee(uint256 _maxEarlyWithdrawFee) external onlyOwner {\n    if (_maxEarlyWithdrawFee <= 0) revert MaxEarlyWithdrawFeeMustBeGreaterThanZero();\n    s_maxEarlyWithdrawFee = _maxEarlyWithdrawFee;\n    emit MaxEarlyWithdrawFeeSet(_maxEarlyWithdrawFee);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setLpTokenType(address _token, LpTokenType _type) external onlyOwner {\n    if (_token == address(0)) revert InvalidTokenAddress();\n    s_lpType[_token] = _type;\n    emit LpTokenTypeSet(_token, _type);\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setStakeStrategy(LpTokenType _lpType, IStakeStrategy _strategy) external onlyOwner {\n    if (address(_strategy) == address(0)) revert InvalidStrategyAddress();\n    s_stakeStrategy[_lpType] = IStakeStrategy(_strategy);\n    emit StakeStrategySet(_lpType, address(_strategy));\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function setVeAERO(address _veAERO) external onlyOwner {\n    if (_veAERO == address(0)) revert InvalidVeAEROAddress();\n    s_veAERO = _veAERO;\n    emit VeAEROSet(_veAERO);\n  }\n\n  // \n  //                            View Functions                                  \n  // \n\n  /// @inheritdoc IveIONSecondExtension\n  function getUserLock(uint256 _tokenId, LpTokenType _lpType) external view returns (LockedBalance memory) {\n    return s_locked[_tokenId][_lpType];\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function getOwnedTokenIds(address _owner) external view returns (uint256[] memory) {\n    return s_ownerToTokenIds[_owner].values();\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function getAssetsLocked(uint256 _tokenId) external view returns (address[] memory) {\n    return s_assetsLocked[_tokenId].values();\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function getDelegatees(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory) {\n    return s_delegatees[_tokenId][_lpType].values();\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function getDelegators(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory) {\n    return s_delegators[_tokenId][_lpType].values();\n  }\n\n  /// @inheritdoc IveIONSecondExtension\n  function getUserPoint(\n    uint256 _tokenId,\n    LpTokenType _lpType,\n    uint256 _epoch\n  ) external view returns (UserPoint memory) {\n    return s_userPointHistory[_tokenId][_lpType][_epoch];\n  }\n}\n"
    },
    "contracts/veION/veIONStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { IveIONStructsEnumsErrorsEvents } from \"./interfaces/IveIONStructsEnumsErrorsEvents.sol\";\n\nabstract contract veIONStorage is IveIONStructsEnumsErrorsEvents {\n  // \n  //                                 Constants                                  \n  // \n  /// @notice Represents the duration of one week in seconds.\n  uint256 internal constant _WEEK = 1 weeks;\n  /// @notice Represents the maximum lock time in seconds (2 years).\n  uint256 internal constant _MAXTIME = 2 * 365 * 86400;\n  /// @notice Precision used for calculations, set to 1e18.\n  uint256 public constant PRECISION = 1e18;\n\n  // \n  //                              State Variables                               \n  // \n  /// @notice The current token ID counter.\n  uint256 public s_tokenId;\n  /// @notice The amount of limited boost available.\n  uint256 public s_limitedBoost;\n  /// @notice Indicates whether the limited boost is active.\n  bool public s_limitedBoostActive;\n  /// @notice Address of the veAERO contract.\n  address public s_veAERO;\n  /// @notice Address of the AeroVoting contract.\n  address public s_aeroVoting;\n  /// @notice Address of the Ionic Pool.\n  address public s_ionicPool;\n  /// @notice Address of the voter contract.\n  address public s_voter;\n  /// @notice The boost amount for AeroVoter.\n  uint256 public s_aeroVoterBoost;\n  /// @notice The minimum duration for locking.\n  uint256 public s_minimumLockDuration;\n  /// @notice The maximum fee for early withdrawal.\n  uint256 public s_maxEarlyWithdrawFee;\n  /// @notice The AddressesProvider contract used for address management.\n  IAddressesProvider public ap;\n  /// @notice The address of the logic contract for the veION first extension.\n  address public veIONFirstExtension;\n  /// @notice The address of the logic contract for the veION second extension.\n  address public veIONSecondExtension;\n\n  // \n  //                                 Mappings                                   \n  // \n  /// @dev Maps LP token types to their minimum lock amounts.\n  mapping(LpTokenType => uint256) public s_minimumLockAmount;\n  /// @dev Maps token addresses to their whitelist status.\n  mapping(address => bool) public s_whitelistedToken;\n  /// @dev Maps token addresses to their corresponding LP token types.\n  mapping(address => LpTokenType) public s_lpType;\n  /// @dev Maps user addresses to their ability to split.\n  mapping(address => bool) public s_canSplit;\n  /// @dev Maps token IDs and LP token types to their locked balances.\n  mapping(uint256 => mapping(LpTokenType => LockedBalance)) public s_locked;\n  /// @dev Maps token IDs and LP token types to user epochs.\n  mapping(uint256 => mapping(LpTokenType => uint256)) public s_userPointEpoch;\n  /// @dev Maps token IDs and LP token types to user point history.\n  mapping(uint256 => mapping(LpTokenType => UserPoint[1000000000])) public s_userPointHistory;\n  /// @dev Maps token IDs to sets of locked asset addresses.\n  mapping(uint256 => EnumerableSet.AddressSet) internal s_assetsLocked;\n  /// @dev Maps token IDs to their voting status.\n  mapping(uint256 => bool) public s_voted;\n  /// @dev Maps LP token types to their total supply.\n  mapping(LpTokenType => uint256) public s_supply;\n  /// @dev Maps LP token types to their permanent lock balances.\n  mapping(LpTokenType => uint256) public s_permanentLockBalance;\n  /// @dev Maps LP token types to their underlying stake strategies.\n  mapping(LpTokenType => IStakeStrategy) public s_stakeStrategy;\n  /// @dev Maps token IDs and LP token addresses to their underlying stake amounts.\n  mapping(uint256 => mapping(address => uint256)) public s_underlyingStake;\n  /// @dev Maps LP token types to their protocol fees.\n  mapping(LpTokenType => uint256) public s_protocolFees;\n  /// @dev Maps LP token types to their distributed fees.\n  mapping(LpTokenType => uint256) public s_distributedFees;\n  /// @dev Maps delegators, delegatees, and LP token types to delegation amounts.\n  mapping(uint256 => mapping(uint256 => mapping(LpTokenType => uint256))) public s_delegations;\n  /// @dev Maps token IDs and LP token types to sets of delegatees.\n  mapping(uint256 => mapping(LpTokenType => EnumerableSet.UintSet)) internal s_delegatees;\n  /// @dev Maps token IDs and LP token types to sets of delegators.\n  mapping(uint256 => mapping(LpTokenType => EnumerableSet.UintSet)) internal s_delegators;\n  /// @dev Maps owner addresses to sets of token IDs they own.\n  mapping(address => EnumerableSet.UintSet) internal s_ownerToTokenIds;\n  /// @dev Maps user addresses and token addresses to cumulative asset values.\n  mapping(address => mapping(address => uint256)) public s_userCumulativeAssetValues;\n  /// @dev Maps token Id and lp onto delegator permissioning.\n  mapping(uint256 => mapping(address => bool)) public s_delegatorsBlocked;\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/veION/Voter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { IVoter } from \"./interfaces/IVoter.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IonicTimeLibrary } from \"./libraries/IonicTimeLibrary.sol\";\nimport { IveION } from \"./interfaces/IveION.sol\";\nimport { IBribeRewards } from \"./interfaces/IBribeRewards.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\n/**\n * @title Voter Contract\n * @notice This contract allows veION holders to vote for various markets\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\n */\ncontract Voter is IVoter, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n  using SafeERC20 for IERC20;\n\n  // \n  //                            State Variables                                 \n  // \n  ///@notice The ve token that governs these contracts\n  address public ve;\n  ///@notice Base token of ve contract\n  address internal rewardToken;\n  ///@notice Standard OZ IGovernor using ve for vote weights\n  address public governor;\n  ///@notice Master Price Oracle instance\n  MasterPriceOracle public mpo;\n  ///@notice List of LP tokens\n  address[] public lpTokens;\n  ///@notice Total Voting Weights for each address\n  mapping(address => uint256) public totalWeight;\n  ///@notice Maximum number of markets one voter can vote for at once\n  uint256 public maxVotingNum;\n  ///@notice Minimum value for maxVotingNum\n  uint256 internal constant MIN_MAXVOTINGNUM = 10;\n  ///@notice All markets viable for incentives\n  Market[] public markets;\n\n  // \n  //                                 Mappings                                   \n  // \n  ///@notice Mapping from Reward Accumulator to Bribes Voting Reward\n  mapping(address => address) public rewardAccumulatorToBribe;\n  ///@notice Mapping from Market to Market Side to LP Asset to weights\n  mapping(address => mapping(MarketSide => mapping(address => uint256))) public weights;\n  ///@notice Mapping from NFT to Pool to LP Asset to Votes\n  mapping(uint256 => mapping(address => mapping(MarketSide => mapping(address => uint256)))) public votes;\n  ///@notice Mapping from NFT to Pool to LP Asset to Base Weights\n  mapping(uint256 => mapping(address => mapping(MarketSide => mapping(address => uint256)))) public baseWeights;\n  ///@notice Mapping from NFT to List of markets voted for by NFT\n  mapping(uint256 => mapping(address => address[])) public marketVote;\n  ///@notice Mapping from NFT to List of market vote sides voted for by NFT\n  mapping(uint256 => mapping(address => MarketSide[])) public marketVoteSide;\n  ///@notice Mapping from NFT to Total voting weight of NFT\n  mapping(uint256 => mapping(address => uint256)) public usedWeights;\n  ///@notice Mapping from NFT to Timestamp of last vote (ensures single vote per epoch)\n  mapping(uint256 => uint256) public lastVoted;\n  ///@notice Mapping from Token to Whitelisted status\n  mapping(address => bool) public isWhitelistedToken;\n  ///@notice Mapping from TokenId to Whitelisted status\n  mapping(uint256 => bool) public isWhitelistedNFT;\n  ///@notice Mapping from Reward Accumulator to Liveness status\n  mapping(address => bool) public isAlive;\n  ///@notice Mapping from Market to Market Side to Reward Accumulator\n  mapping(address => mapping(MarketSide => address)) public marketToRewardAccumulators;\n\n  bool distributionTimelockAlive;\n\n  // \n  //                                Modifiers                                   \n  // \n  /**\n   * @notice Modifier to ensure that the function is called only in a new epoch since the last vote.\n   * @dev Reverts if the current epoch start time is less than or equal to the last voted timestamp for the given token ID.\n   *      Also reverts if the current time is within the vote distribution window.\n   * @param _tokenId The ID of the veNFT to check the last voted timestamp.\n   */\n  modifier onlyNewEpoch(uint256 _tokenId) {\n    if (IonicTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert AlreadyVotedOrDeposited();\n    if (block.timestamp <= IonicTimeLibrary.epochVoteStart(block.timestamp)) revert DistributeWindow();\n    _;\n  }\n\n  /**\n   * @notice Modifier to ensure that the function is called only by the governance address.\n   * @dev Reverts if the caller is not the current governor.\n   */\n  modifier onlyGovernance() {\n    if (msg.sender != governor) revert NotGovernor();\n    _;\n  }\n\n  constructor() {\n    _disableInitializers(); // Locks the implementation contract from being initialized\n  }\n\n  /**\n   * @notice Initializes the Voter contract with the specified parameters.\n   * @dev Requires initialization with at least one reward token.\n   * @param _tokens An array of token addresses to be whitelisted.\n   * @param _mpo The MasterPriceOracle contract address.\n   * @param _rewardToken The address of the reward token.\n   * @param _ve The address of the veION contract.\n   * @custom:reverts TokensArrayEmpty if the _tokens array is empty.\n   */\n  function initialize(\n    address[] calldata _tokens,\n    MasterPriceOracle _mpo,\n    address _rewardToken,\n    address _ve\n  ) external initializer {\n    __Ownable2Step_init();\n    __ReentrancyGuard_init();\n    uint256 _length = _tokens.length;\n    if (_length == 0) revert TokensArrayEmpty();\n    for (uint256 i = 0; i < _length; i++) {\n      _whitelistToken(_tokens[i], true);\n    }\n    mpo = _mpo;\n    rewardToken = _rewardToken;\n    ve = _ve;\n    governor = msg.sender;\n\n    emit Initialized(_tokens, address(_mpo), _rewardToken, _ve, governor);\n  }\n\n  // \n  //                            External Functions                              \n  // \n\n  /// @inheritdoc IVoter\n  function vote(\n    uint256 _tokenId,\n    address[] calldata _marketVote,\n    MarketSide[] calldata _marketVoteSide,\n    uint256[] calldata _weights\n  ) external nonReentrant onlyNewEpoch(_tokenId) {\n    VoteLocalVars memory vars;\n    vars.sender = msg.sender;\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != vars.sender) revert NotOwner();\n    if (\n      _marketVote.length != _marketVoteSide.length ||\n      _marketVoteSide.length != _weights.length ||\n      _weights.length != _marketVote.length\n    ) revert UnequalLengths();\n    if (_marketVote.length > maxVotingNum) revert TooManyPools();\n    vars.timestamp = block.timestamp;\n    if ((vars.timestamp > IonicTimeLibrary.epochVoteEnd(vars.timestamp)) && !isWhitelistedNFT[_tokenId])\n      revert NotWhitelistedNFT();\n    uint256 totalVoteWeight = 0;\n\n    for (uint256 i = 0; i < _marketVote.length; i++) {\n      totalVoteWeight += _weights[i];\n    }\n    for (uint256 i = 0; i < lpTokens.length; i++) {\n      _reset(_tokenId, lpTokens[i]);\n    }\n\n    lastVoted[_tokenId] = vars.timestamp;\n    (vars.votingLPs, vars.votingLPBalances, vars.boosts) = IveION(ve).balanceOfNFT(_tokenId);\n    for (uint256 j = 0; j < vars.votingLPs.length; j++) {\n      _vote(\n        _tokenId,\n        vars.votingLPs[j],\n        (vars.votingLPBalances[j] * vars.boosts[j]) / 1e18,\n        _marketVote,\n        _marketVoteSide,\n        _weights,\n        totalVoteWeight\n      );\n    }\n  }\n\n  /// @inheritdoc IVoter\n  function poke(uint256 _tokenId) external nonReentrant {\n    if (block.timestamp <= IonicTimeLibrary.epochVoteStart(block.timestamp)) revert DistributeWindow();\n    (address[] memory _votingLPs, uint256[] memory _votingLPBalances, uint256[] memory _boosts) = IveION(ve)\n      .balanceOfNFT(_tokenId);\n\n    for (uint256 i = 0; i < _votingLPs.length; i++) {\n      uint256 effectiveBalance = (_votingLPBalances[i] * _boosts[i]) / 1e18;\n      _poke(_tokenId, lpTokens[i], effectiveBalance);\n    }\n  }\n\n  /// @inheritdoc IVoter\n  function reset(uint256 _tokenId) public nonReentrant onlyNewEpoch(_tokenId) {\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != msg.sender) revert NotOwner();\n    for (uint256 i = 0; i < lpTokens.length; i++) {\n      _reset(_tokenId, lpTokens[i]);\n    }\n  }\n\n  /// @inheritdoc IVoter\n  function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint256 _tokenId) external nonReentrant {\n    if (_bribes.length != _tokens.length) revert UnequalLengths();\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != _msgSender()) revert NotOwner();\n    uint256 _length = _bribes.length;\n    for (uint256 i = 0; i < _length; i++) {\n      IBribeRewards(_bribes[i]).getReward(_tokenId, _tokens[i]);\n    }\n  }\n\n  // \n  //                            Admin External Functions                        \n  // \n\n  /// @inheritdoc IVoter\n  function distributeRewards() external onlyGovernance {\n    if (distributionTimelockAlive && block.timestamp <= IonicTimeLibrary.epochVoteEnd(block.timestamp)) revert NotDistributeWindow();\n    uint256 _reward = IERC20(rewardToken).balanceOf(address(this));\n    uint256 _totalLPValueETH = _calculateTotalLPValue();\n    for (uint256 i = 0; i < markets.length; i++) {\n      uint256 _marketWeightETH = _calculateMarketLPValue(markets[i].marketAddress, markets[i].side);\n      if (_marketWeightETH > 0) {\n        IERC20(rewardToken).safeTransfer(\n          marketToRewardAccumulators[markets[i].marketAddress][markets[i].side],\n          (_reward * _marketWeightETH) / _totalLPValueETH\n        );\n      }\n    }\n  }\n\n  /// @inheritdoc IVoter\n  function whitelistToken(address _token, bool _bool) external onlyGovernance {\n    _whitelistToken(_token, _bool);\n  }\n\n  /// @inheritdoc IVoter\n  function whitelistNFT(uint256 _tokenId, bool _bool) external onlyGovernance {\n    address _sender = msg.sender;\n    isWhitelistedNFT[_tokenId] = _bool;\n    emit WhitelistNFT(_sender, _tokenId, _bool);\n  }\n\n  // \n  //                            Internal Functions                              \n  // \n\n  /**\n   * @notice Internal function to handle voting logic for a given token ID and voting asset.\n   * @param _tokenId The ID of the token used for voting.\n   * @param _votingAsset The address of the asset being used for voting.\n   * @param _votingAssetBalance The balance of the voting asset.\n   * @param _marketVote An array of market addresses to vote for.\n   * @param _marketVoteSide An array of market sides corresponding to the markets.\n   * @param _weights An array of weights for each market.\n   * @param totalVoteWeight The total weight of the vote.\n   */\n  function _vote(\n    uint256 _tokenId,\n    address _votingAsset,\n    uint256 _votingAssetBalance,\n    address[] memory _marketVote,\n    MarketSide[] memory _marketVoteSide,\n    uint256[] memory _weights,\n    uint256 totalVoteWeight\n  ) internal {\n    VoteVars memory vars;\n    uint256 marketVoteLength = _marketVote.length;\n    for (uint256 i = 0; i < marketVoteLength; i++) {\n      vars.market = _marketVote[i];\n      vars.marketSide = _marketVoteSide[i];\n      vars.rewardAccumulator = marketToRewardAccumulators[vars.market][vars.marketSide];\n      vars.bribes = rewardAccumulatorToBribe[vars.rewardAccumulator];\n      if (_weights[i] == 0) revert ZeroWeight();\n      if (vars.rewardAccumulator == address(0)) revert RewardAccumulatorDoesNotExist(vars.market);\n      if (!isAlive[vars.rewardAccumulator]) revert RewardAccumulatorNotAlive(vars.rewardAccumulator);\n\n      vars.marketWeight = (_weights[i] * _votingAssetBalance) / totalVoteWeight;\n      if (votes[_tokenId][vars.market][vars.marketSide][_votingAsset] != 0) revert NonZeroVotes();\n\n      marketVote[_tokenId][_votingAsset].push(vars.market);\n      marketVoteSide[_tokenId][_votingAsset].push(vars.marketSide);\n\n      weights[vars.market][vars.marketSide][_votingAsset] += vars.marketWeight;\n      votes[_tokenId][vars.market][vars.marketSide][_votingAsset] += vars.marketWeight;\n      baseWeights[_tokenId][vars.market][vars.marketSide][_votingAsset] = _weights[i];\n      IBribeRewards(vars.bribes).deposit(_votingAsset, uint256(vars.marketWeight), _tokenId);\n      vars.usedWeight += vars.marketWeight;\n      vars.totalWeight += vars.marketWeight;\n      emit Voted(\n        msg.sender,\n        vars.market,\n        _tokenId,\n        vars.marketWeight,\n        weights[vars.market][vars.marketSide][_votingAsset],\n        block.timestamp\n      );\n    }\n    IveION(ve).voting(_tokenId, true);\n    totalWeight[_votingAsset] += uint256(vars.totalWeight);\n    usedWeights[_tokenId][_votingAsset] = uint256(vars.usedWeight);\n  }\n\n  /**\n   * @notice Internal function to update voting balances for a given token ID and voting asset.\n   * @param _tokenId The ID of the token whose voting balance is being updated.\n   * @param _votingAsset The address of the asset being used for voting.\n   * @param _votingAssetBalance The balance of the voting asset.\n   */\n  function _poke(uint256 _tokenId, address _votingAsset, uint256 _votingAssetBalance) internal {\n    address[] memory _marketVote = marketVote[_tokenId][_votingAsset];\n    MarketSide[] memory _marketVoteSide = marketVoteSide[_tokenId][_votingAsset];\n    uint256 _marketCnt = _marketVote.length;\n    uint256[] memory _weights = new uint256[](_marketCnt);\n    uint256 totalVoteWeight = 0;\n\n    for (uint256 i = 0; i < _marketCnt; i++) {\n      _weights[i] = baseWeights[_tokenId][_marketVote[i]][_marketVoteSide[i]][_votingAsset];\n    }\n\n    for (uint256 i = 0; i < _marketVote.length; i++) {\n      totalVoteWeight += _weights[i];\n    }\n\n    _reset(_tokenId, _votingAsset);\n    _vote(_tokenId, _votingAsset, _votingAssetBalance, _marketVote, _marketVoteSide, _weights, totalVoteWeight);\n  }\n\n  /**\n   * @notice Internal function to reset voting state for a given token ID and voting asset.\n   * @param _tokenId The ID of the token whose voting state is being reset.\n   * @param _votingAsset The address of the asset being used for voting.\n   */\n  function _reset(uint256 _tokenId, address _votingAsset) internal {\n    address[] storage _marketVote = marketVote[_tokenId][_votingAsset];\n    MarketSide[] storage _marketVoteSide = marketVoteSide[_tokenId][_votingAsset];\n    uint256 _marketVoteCnt = _marketVote.length;\n\n    for (uint256 i = 0; i < _marketVoteCnt; i++) {\n      address _market = _marketVote[i];\n      MarketSide _marketSide = _marketVoteSide[i];\n\n      uint256 _votes = votes[_tokenId][_market][_marketSide][_votingAsset];\n      if (_votes != 0) {\n        weights[_market][_marketSide][_votingAsset] -= _votes;\n        delete votes[_tokenId][_market][_marketSide][_votingAsset];\n        IBribeRewards(rewardAccumulatorToBribe[marketToRewardAccumulators[_market][_marketSide]]).withdraw(\n          _votingAsset,\n          uint256(_votes),\n          _tokenId\n        );\n        totalWeight[_votingAsset] -= _votes;\n        emit Abstained(\n          msg.sender,\n          _market,\n          _tokenId,\n          _votes,\n          weights[_market][_marketSide][_votingAsset],\n          block.timestamp\n        );\n      }\n    }\n    usedWeights[_tokenId][_votingAsset] = 0;\n    delete marketVote[_tokenId][_votingAsset];\n    delete marketVoteSide[_tokenId][_votingAsset];\n    IveION(ve).voting(_tokenId, false);\n  }\n\n  /**\n   * @notice Internal function to whitelist or unwhitelist a token for use in bribes.\n   * @param _token The address of the token to be whitelisted or unwhitelisted.\n   * @param _bool Boolean indicating whether to whitelist (true) or unwhitelist (false) the token.\n   */\n  function _whitelistToken(address _token, bool _bool) internal {\n    isWhitelistedToken[_token] = _bool;\n    emit WhitelistToken(msg.sender, _token, _bool);\n  }\n\n  /**\n   * @notice Internal function to calculate the ETH value of a given amount of LP tokens.\n   * @param amount The amount of LP tokens.\n   * @param lpToken The address of the LP token.\n   * @return The ETH value of the given amount of LP tokens.\n   */\n  function _getTokenEthValue(uint256 amount, address lpToken) internal view returns (uint256) {\n    uint256 tokenPriceInEth = mpo.price(lpToken); // Fetch price of 1 lpToken in ETH\n    uint256 ethValue = amount * tokenPriceInEth;\n    return ethValue;\n  }\n\n  /**\n   * @notice Internal function to calculate the total ETH value of all LP tokens in the markets.\n   * @return _totalLPValueETH The total ETH value of all LP tokens.\n   */\n  function _calculateTotalLPValue() internal view returns (uint256 _totalLPValueETH) {\n    uint256 marketLength = markets.length;\n    for (uint256 i = 0; i < marketLength; i++)\n      _totalLPValueETH += _calculateMarketLPValue(markets[i].marketAddress, markets[i].side);\n  }\n\n  /**\n   * @notice Internal function to calculate the ETH value of LP tokens for a specific market.\n   * @param _market The address of the market.\n   * @param _marketSide The side of the market.\n   * @return _marketLPValueETH The ETH value of LP tokens for the specified market.\n   */\n  function _calculateMarketLPValue(\n    address _market,\n    MarketSide _marketSide\n  ) internal view returns (uint256 _marketLPValueETH) {\n    uint256 lpTokensLength = lpTokens.length;\n    for (uint256 i = 0; i < lpTokensLength; i++) {\n      uint256 _lpAmount = weights[_market][_marketSide][lpTokens[i]];\n      uint256 tokenEthValue = _getTokenEthValue(_lpAmount, lpTokens[i]);\n      _marketLPValueETH += tokenEthValue;\n    }\n  }\n\n  /**\n   * @notice Internal function to check if a market exists.\n   * @param _marketAddress The address of the market.\n   * @param _marketSide The side of the market.\n   * @return True if the market exists, false otherwise.\n   */\n  function _marketExists(address _marketAddress, MarketSide _marketSide) internal view returns (bool) {\n    uint256 marketLength = markets.length;\n    for (uint256 j = 0; j < marketLength; j++) {\n      if (markets[j].marketAddress == _marketAddress && markets[j].side == _marketSide) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // \n  //                            Setter Functions                                \n  // \n\n  /// @inheritdoc IVoter\n  function setLpTokens(address[] memory _lpTokens) external onlyOwner {\n    require(_lpTokens.length != 0, \"LpTokens array cannot be empty\");\n    lpTokens = _lpTokens;\n    emit LpTokensSet(_lpTokens);\n  }\n\n  /// @inheritdoc IVoter\n  function setMpo(address _mpo) external onlyOwner {\n    if (_mpo == address(0)) revert ZeroAddress();\n    mpo = MasterPriceOracle(_mpo);\n    emit MpoSet(_mpo);\n  }\n\n  /// @inheritdoc IVoter\n  function setGovernor(address _governor) public onlyOwner {\n    if (_governor == address(0)) revert ZeroAddress();\n    governor = _governor;\n    emit GovernorSet(_governor);\n  }\n\n  /// @inheritdoc IVoter\n  function addMarkets(Market[] calldata _markets) external onlyGovernance {\n    for (uint256 i = 0; i < _markets.length; i++) {\n      Market memory newMarket = _markets[i];\n      if (_marketExists(newMarket.marketAddress, newMarket.side)) revert MarketAlreadyExists();\n      markets.push(newMarket);\n    }\n    emit MarketsAdded(_markets);\n  }\n\n  /// @inheritdoc IVoter\n  function setMarketRewardAccumulators(\n    address[] calldata _markets,\n    MarketSide[] calldata _marketSides,\n    address[] calldata _rewardAccumulators\n  ) external onlyGovernance {\n    uint256 _length = _markets.length;\n    if (_marketSides.length != _length) revert MismatchedArrayLengths();\n    if (_rewardAccumulators.length != _length) revert MismatchedArrayLengths();\n    for (uint256 i = 0; i < _length; i++) {\n      marketToRewardAccumulators[_markets[i]][_marketSides[i]] = _rewardAccumulators[i];\n      isAlive[_rewardAccumulators[i]] = true;\n    }\n    emit MarketRewardAccumulatorsSet(_markets, _marketSides, _rewardAccumulators);\n  }\n\n  /// @inheritdoc IVoter\n  function setBribes(address[] calldata _rewardAccumulators, address[] calldata _bribes) external onlyGovernance {\n    uint256 _length = _bribes.length;\n    if (_rewardAccumulators.length != _length) revert MismatchedArrayLengths();\n    for (uint256 i = 0; i < _length; i++) {\n      rewardAccumulatorToBribe[_rewardAccumulators[i]] = _bribes[i];\n    }\n    emit BribesSet(_rewardAccumulators, _bribes);\n  }\n\n  /// @inheritdoc IVoter\n  function setMaxVotingNum(uint256 _maxVotingNum) external onlyGovernance {\n    if (_maxVotingNum < MIN_MAXVOTINGNUM) revert MaximumVotingNumberTooLow();\n    if (_maxVotingNum == maxVotingNum) revert SameValue();\n    maxVotingNum = _maxVotingNum;\n    emit MaxVotingNumSet(_maxVotingNum);\n  }\n\n  /// @inheritdoc IVoter\n  function toggleRewardAccumulatorAlive(\n    address _market,\n    MarketSide _marketSide,\n    bool _isAlive\n  ) external onlyGovernance {\n    address _rewardAccumulator = marketToRewardAccumulators[_market][_marketSide];\n    if (_rewardAccumulator == address(0)) revert RewardAccumulatorDoesNotExist(_market);\n    isAlive[_rewardAccumulator] = _isAlive;\n    emit RewardAccumulatorAliveToggled(_market, _marketSide, _isAlive);\n  }\n\n  /// @inheritdoc IVoter\n  function toggleDistributionTimelockAlive(bool _isAlive) external onlyGovernance {\n    distributionTimelockAlive = _isAlive;\n    emit DistributionTimelockAliveToggled(_isAlive);\n  }\n\n  // \n  //                            Pure/View Functions                             \n  // \n\n  /// @inheritdoc IVoter\n  function epochStart(uint256 _timestamp) external pure returns (uint256) {\n    return IonicTimeLibrary.epochStart(_timestamp);\n  }\n\n  /// @inheritdoc IVoter\n  function epochNext(uint256 _timestamp) external pure returns (uint256) {\n    return IonicTimeLibrary.epochNext(_timestamp);\n  }\n\n  /// @inheritdoc IVoter\n  function epochVoteStart(uint256 _timestamp) external pure returns (uint256) {\n    return IonicTimeLibrary.epochVoteStart(_timestamp);\n  }\n\n  /// @inheritdoc IVoter\n  function epochVoteEnd(uint256 _timestamp) external pure returns (uint256) {\n    return IonicTimeLibrary.epochVoteEnd(_timestamp);\n  }\n\n  /// @inheritdoc IVoter\n  function marketsLength() external view returns (uint256) {\n    return markets.length;\n  }\n\n  /// @inheritdoc IVoter\n  function getAllLpRewardTokens() external view returns (address[] memory) {\n    return lpTokens;\n  }\n\n  /// @inheritdoc IVoter\n  function getVoteDetails(uint256 _tokenId, address _lpAsset) external view returns (VoteDetails memory) {\n    uint256 length = marketVote[_tokenId][_lpAsset].length;\n    address[] memory _marketVotes = new address[](length);\n    MarketSide[] memory _marketVoteSides = new MarketSide[](length);\n    uint256[] memory _votes = new uint256[](length);\n\n    for (uint256 i = 0; i < length; i++) {\n      _marketVotes[i] = marketVote[_tokenId][_lpAsset][i];\n      _marketVoteSides[i] = marketVoteSide[_tokenId][_lpAsset][i];\n      _votes[i] = votes[_tokenId][_marketVotes[i]][_marketVoteSides[i]][_lpAsset];\n    }\n\n    uint256 _usedWeight = usedWeights[_tokenId][_lpAsset];\n\n    return\n      VoteDetails({\n        marketVotes: _marketVotes,\n        marketVoteSides: _marketVoteSides,\n        votes: _votes,\n        usedWeight: _usedWeight\n      });\n  }\n}\n"
    },
    "contracts/veION/VoterLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"../PoolDirectory.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { ComptrollerExtensionInterface } from \"../compound/ComptrollerInterface.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\n\ncontract VoterLens is Initializable, Ownable2StepUpgradeable {\n  struct BribeInfo {\n    address market;\n    address bribeSupply;\n    address bribeBorrow;\n  }\n\n  struct IncentiveInfo {\n    address market;\n    address bribeSupply;\n    address[] rewardsSupply;\n    uint256[] rewardsSupplyAmounts;\n    uint256[] rewardsSupplyETHValues;\n    address bribeBorrow;\n    address[] rewardsBorrow;\n    uint256[] rewardsBorrowAmounts;\n    uint256[] rewardsBorrowETHValues;\n  }\n\n  address voter;\n  PoolDirectory poolDirectory;\n  IMasterPriceOracle mpo;\n  uint256 constant PRECISION = 1e18;\n\n  function initialize(address _voter, PoolDirectory _poolDirectory) public initializer {\n    voter = _voter;\n    poolDirectory = _poolDirectory;\n    __Ownable2Step_init();\n  }\n\n  function getAllBribes() public view returns (BribeInfo[] memory _bribeInfo) {\n    uint256 count = 0;\n    uint256 totalMarketsLength = 0;\n    (, PoolDirectory.Pool[] memory activePools) = poolDirectory.getActivePools();\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      ComptrollerExtensionInterface comptroller = ComptrollerExtensionInterface(activePools[i].comptroller);\n      ICErc20[] memory markets = comptroller.getAllMarkets();\n      totalMarketsLength += markets.length;\n    }\n\n    _bribeInfo = new BribeInfo[](totalMarketsLength);\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      ComptrollerExtensionInterface comptroller = ComptrollerExtensionInterface(activePools[i].comptroller);\n      ICErc20[] memory markets = comptroller.getAllMarkets();\n\n      for (uint256 j = 0; j < markets.length; j++) {\n        address rewardAccumulatorSupply = IVoterView(voter).marketToRewardAccumulators(\n          address(markets[j]),\n          IVoter.MarketSide.Supply\n        );\n        address rewardAccumulatorBorrow = IVoterView(voter).marketToRewardAccumulators(\n          address(markets[j]),\n          IVoter.MarketSide.Borrow\n        );\n\n        address bribeSupply = IVoterView(voter).rewardAccumulatorToBribe(rewardAccumulatorSupply);\n        address bribeBorrow = IVoterView(voter).rewardAccumulatorToBribe(rewardAccumulatorBorrow);\n\n        _bribeInfo[count] = BribeInfo({\n          market: address(markets[j]),\n          bribeSupply: bribeSupply,\n          bribeBorrow: bribeBorrow\n        });\n        count++;\n      }\n    }\n  }\n\n  function getAllIncentivesForBribes() external view returns (IncentiveInfo[] memory _incentiveInfo) {\n    BribeInfo[] memory _bribeInfo = getAllBribes();\n    _incentiveInfo = new IncentiveInfo[](_bribeInfo.length);\n    for (uint256 i; i < _bribeInfo.length; i++) {\n      _incentiveInfo[i].market = _bribeInfo[i].market;\n      if (_bribeInfo[i].bribeSupply != address(0)) {\n        _incentiveInfo[i].bribeSupply = _bribeInfo[i].bribeSupply;\n        uint256 supplyRewardsLength = IBribeRewardsView(_bribeInfo[i].bribeSupply).rewardsListLength();\n        _incentiveInfo[i].rewardsSupply = new address[](supplyRewardsLength);\n        _incentiveInfo[i].rewardsSupplyAmounts = new uint256[](supplyRewardsLength);\n        _incentiveInfo[i].rewardsSupplyETHValues = new uint256[](supplyRewardsLength);\n        for (uint256 j; j < supplyRewardsLength; j++) {\n          _incentiveInfo[i].rewardsSupply[j] = IBribeRewardsView(_bribeInfo[i].bribeSupply).rewards(j);\n          _incentiveInfo[i].rewardsSupplyAmounts[j] = ERC20(_incentiveInfo[i].rewardsSupply[j]).balanceOf(\n            _bribeInfo[i].bribeSupply\n          );\n\n          uint256 tokenPrice = mpo.price(_incentiveInfo[i].rewardsSupply[j]);\n\n          if (tokenPrice != 0) {\n            uint256 decimals = ERC20(_incentiveInfo[i].rewardsSupply[j]).decimals();\n            _incentiveInfo[i].rewardsSupplyETHValues[j] =\n              (_incentiveInfo[i].rewardsSupplyAmounts[j] * 10 ** (18 - decimals) * tokenPrice) /\n              PRECISION;\n          }\n        }\n      }\n\n      if (_bribeInfo[i].bribeBorrow != address(0)) {\n        _incentiveInfo[i].bribeBorrow = _bribeInfo[i].bribeBorrow;\n        uint256 borrowRewardsLength = IBribeRewardsView(_bribeInfo[i].bribeBorrow).rewardsListLength();\n        _incentiveInfo[i].rewardsBorrow = new address[](borrowRewardsLength);\n        _incentiveInfo[i].rewardsBorrowAmounts = new uint256[](borrowRewardsLength);\n        _incentiveInfo[i].rewardsBorrowETHValues = new uint256[](borrowRewardsLength);\n        for (uint256 j; j < borrowRewardsLength; j++) {\n          _incentiveInfo[i].rewardsBorrow[j] = IBribeRewardsView(_bribeInfo[i].bribeBorrow).rewards(j);\n          _incentiveInfo[i].rewardsBorrowAmounts[j] = ERC20(_incentiveInfo[i].rewardsBorrow[j]).balanceOf(\n            _bribeInfo[i].bribeBorrow\n          );\n\n          uint256 tokenPrice = mpo.price(_incentiveInfo[i].rewardsBorrow[j]);\n\n          if (tokenPrice != 0) {\n            uint256 decimals = (ERC20(_incentiveInfo[i].rewardsBorrow[j])).decimals();\n            _incentiveInfo[i].rewardsBorrowETHValues[j] =\n              (_incentiveInfo[i].rewardsBorrowAmounts[j] * 10 ** (18 - decimals) * tokenPrice) /\n              PRECISION;\n          }\n        }\n      }\n    }\n  }\n\n  function setMasterPriceOracle(address _masterPriceOracle) external onlyOwner {\n    mpo = IMasterPriceOracle(_masterPriceOracle);\n  }\n}\n\ninterface IVoterView {\n  function rewardAccumulatorToBribe(address rewardAccumulator) external view returns (address);\n  function marketToRewardAccumulators(address market, IVoter.MarketSide marketSide) external view returns (address);\n}\n\ninterface IBribeRewardsView {\n  function rewards(uint256 index) external view returns (address);\n  function rewardsListLength() external view returns (uint256);\n}\n\ninterface IMasterPriceOracle {\n  function price(address underlying) external view returns (uint256);\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    },
    "forge-std/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "forge-std/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "forge-std/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "forge-std/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "forge-std/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "forge-std/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "forge-std/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "forge-std/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "forge-std/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "forge-std/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n//  ABOUT\n// Standard Library's default Test\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n//  BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n//  TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "solmate/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "solmate/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "solmate/test/utils/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "solmate/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}