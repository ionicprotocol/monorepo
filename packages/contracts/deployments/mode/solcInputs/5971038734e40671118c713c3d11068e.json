{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPyth.sol\";\nimport \"./PythErrors.sol\";\n\nabstract contract AbstractPyth is IPyth {\n    /// @notice Returns the price feed with given id.\n    /// @dev Reverts if the price does not exist.\n    /// @param id The Pyth Price Feed ID of which to fetch the PriceFeed.\n    function queryPriceFeed(\n        bytes32 id\n    ) public view virtual returns (PythStructs.PriceFeed memory priceFeed);\n\n    /// @notice Returns true if a price feed with the given id exists.\n    /// @param id The Pyth Price Feed ID of which to check its existence.\n    function priceFeedExists(\n        bytes32 id\n    ) public view virtual returns (bool exists);\n\n    function getValidTimePeriod()\n        public\n        view\n        virtual\n        override\n        returns (uint validTimePeriod);\n\n    function getPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getEmaPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getEmaPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.price;\n    }\n\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.emaPrice;\n    }\n\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getEmaPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function diff(uint x, uint y) internal pure returns (uint) {\n        if (x > y) {\n            return x - y;\n        } else {\n            return y - x;\n        }\n    }\n\n    // Access modifier is overridden to public to be able to call it locally.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable virtual override;\n\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable virtual override {\n        if (priceIds.length != publishTimes.length)\n            revert PythErrors.InvalidArgument();\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            if (\n                !priceFeedExists(priceIds[i]) ||\n                queryPriceFeed(priceIds[i]).price.publishTime < publishTimes[i]\n            ) {\n                updatePriceFeeds(updateData);\n                return;\n            }\n        }\n\n        revert PythErrors.NoFreshUpdate();\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/MockPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./AbstractPyth.sol\";\nimport \"./PythStructs.sol\";\nimport \"./PythErrors.sol\";\n\ncontract MockPyth is AbstractPyth {\n    mapping(bytes32 => PythStructs.PriceFeed) priceFeeds;\n    uint64 sequenceNumber;\n\n    uint singleUpdateFeeInWei;\n    uint validTimePeriod;\n\n    constructor(uint _validTimePeriod, uint _singleUpdateFeeInWei) {\n        singleUpdateFeeInWei = _singleUpdateFeeInWei;\n        validTimePeriod = _validTimePeriod;\n    }\n\n    function queryPriceFeed(\n        bytes32 id\n    ) public view override returns (PythStructs.PriceFeed memory priceFeed) {\n        if (priceFeeds[id].id == 0) revert PythErrors.PriceFeedNotFound();\n        return priceFeeds[id];\n    }\n\n    function priceFeedExists(bytes32 id) public view override returns (bool) {\n        return (priceFeeds[id].id != 0);\n    }\n\n    function getValidTimePeriod() public view override returns (uint) {\n        return validTimePeriod;\n    }\n\n    // Takes an array of encoded price feeds and stores them.\n    // You can create this data either by calling createPriceFeedData or\n    // by using web3.js or ethers abi utilities.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable override {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        // Chain ID is id of the source chain that the price update comes from. Since it is just a mock contract\n        // We set it to 1.\n        uint16 chainId = 1;\n\n        for (uint i = 0; i < updateData.length; i++) {\n            PythStructs.PriceFeed memory priceFeed = abi.decode(\n                updateData[i],\n                (PythStructs.PriceFeed)\n            );\n\n            uint lastPublishTime = priceFeeds[priceFeed.id].price.publishTime;\n\n            if (lastPublishTime < priceFeed.price.publishTime) {\n                // Price information is more recent than the existing price information.\n                priceFeeds[priceFeed.id] = priceFeed;\n                emit PriceFeedUpdate(\n                    priceFeed.id,\n                    uint64(lastPublishTime),\n                    priceFeed.price.price,\n                    priceFeed.price.conf\n                );\n            }\n        }\n\n        // In the real contract, the input of this function contains multiple batches that each contain multiple prices.\n        // This event is emitted when a batch is processed. In this mock contract we consider there is only one batch of prices.\n        // Each batch has (chainId, sequenceNumber) as it's unique identifier. Here chainId is set to 1 and an increasing sequence number is used.\n        emit BatchPriceFeedUpdate(chainId, sequenceNumber);\n        sequenceNumber += 1;\n    }\n\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) public view override returns (uint feeAmount) {\n        return singleUpdateFeeInWei * updateData.length;\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable override returns (PythStructs.PriceFeed[] memory feeds) {\n        uint requiredFee = getUpdateFee(updateData);\n        if (msg.value < requiredFee) revert PythErrors.InsufficientFee();\n\n        feeds = new PythStructs.PriceFeed[](priceIds.length);\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            for (uint j = 0; j < updateData.length; j++) {\n                feeds[i] = abi.decode(updateData[j], (PythStructs.PriceFeed));\n\n                if (feeds[i].id == priceIds[i]) {\n                    uint publishTime = feeds[i].price.publishTime;\n                    if (\n                        minPublishTime <= publishTime &&\n                        publishTime <= maxPublishTime\n                    ) {\n                        break;\n                    } else {\n                        feeds[i].id = 0;\n                    }\n                }\n            }\n\n            if (feeds[i].id != priceIds[i])\n                revert PythErrors.PriceFeedNotFoundWithinRange();\n        }\n    }\n\n    function createPriceFeedUpdateData(\n        bytes32 id,\n        int64 price,\n        uint64 conf,\n        int32 expo,\n        int64 emaPrice,\n        uint64 emaConf,\n        uint64 publishTime\n    ) public pure returns (bytes memory priceFeedData) {\n        PythStructs.PriceFeed memory priceFeed;\n\n        priceFeed.id = id;\n\n        priceFeed.price.price = price;\n        priceFeed.price.conf = conf;\n        priceFeed.price.expo = expo;\n        priceFeed.price.publishTime = publishTime;\n\n        priceFeed.emaPrice.price = emaPrice;\n        priceFeed.emaPrice.conf = emaConf;\n        priceFeed.emaPrice.expo = expo;\n        priceFeed.emaPrice.publishTime = publishTime;\n\n        priceFeedData = abi.encode(priceFeed);\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary PythErrors {\n    // Function arguments are invalid (e.g., the arguments lengths mismatch)\n    error InvalidArgument();\n    // Update data is coming from an invalid data source.\n    error InvalidUpdateDataSource();\n    // Update data is invalid (e.g., deserialization error)\n    error InvalidUpdateData();\n    // Insufficient fee is paid to the method.\n    error InsufficientFee();\n    // There is no fresh update, whereas expected fresh updates.\n    error NoFreshUpdate();\n    // There is no price feed found within the given range or it does not exists.\n    error PriceFeedNotFoundWithinRange();\n    // Price feed not found or it is not pushed on-chain yet.\n    error PriceFeedNotFound();\n    // Requested price is stale.\n    error StalePrice();\n    // Given message is not a valid Wormhole VAA.\n    error InvalidWormholeVaa();\n    // Governance message is invalid (e.g., deserialization error).\n    error InvalidGovernanceMessage();\n    // Governance message is not for this contract.\n    error InvalidGovernanceTarget();\n    // Governance message is coming from an invalid data source.\n    error InvalidGovernanceDataSource();\n    // Governance message is old.\n    error OldGovernanceMessage();\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "adrastia-periphery/rates/IHistoricalRates.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./RateLibrary.sol\";\n\n/**\n * @title IHistoricalRates\n * @notice An interface that defines a contract that stores historical rates.\n */\ninterface IHistoricalRates {\n    /// @notice Gets an rate for a token at a specific index.\n    /// @param token The address of the token to get the rates for.\n    /// @param index The index of the rate to get, where index 0 contains the latest rate, and the last\n    ///   index contains the oldest rate (uses reverse chronological ordering).\n    /// @return rate The rate for the token at the specified index.\n    function getRateAt(address token, uint256 index) external view returns (RateLibrary.Rate memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(address token, uint256 amount) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @param offset The index of the first rate to get (default: 0).\n    /// @param increment The increment between rates to get (default: 1).\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(\n        address token,\n        uint256 amount,\n        uint256 offset,\n        uint256 increment\n    ) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the number of rates for a token.\n    /// @param token The address of the token to get the number of rates for.\n    /// @return count The number of rates for the token.\n    function getRatesCount(address token) external view returns (uint256);\n\n    /// @notice Gets the capacity of rates for a token.\n    /// @param token The address of the token to get the capacity of rates for.\n    /// @return capacity The capacity of rates for the token.\n    function getRatesCapacity(address token) external view returns (uint256);\n\n    /// @notice Sets the capacity of rates for a token.\n    /// @param token The address of the token to set the capacity of rates for.\n    /// @param amount The new capacity of rates for the token.\n    function setRatesCapacity(address token, uint256 amount) external;\n}\n"
    },
    "adrastia-periphery/rates/IRateComputer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\n/**\n * @title IRateComputer\n * @notice An interface that defines a contract that computes rates.\n */\ninterface IRateComputer {\n    /// @notice Computes the rate for a token.\n    /// @param token The address of the token to compute the rate for.\n    /// @return rate The rate for the token.\n    function computeRate(address token) external view returns (uint64);\n}\n"
    },
    "adrastia-periphery/rates/RateLibrary.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nlibrary RateLibrary {\n    struct Rate {\n        uint64 target;\n        uint64 current;\n        uint32 timestamp;\n    }\n}\n"
    },
    "contracts/adrastia/PrudentiaLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nlibrary PrudentiaLib {\n  struct PrudentiaConfig {\n    address controller; // Adrastia Prudentia controller address\n    uint8 offset; // Offset for delayed rate activation\n    int8 decimalShift; // Positive values scale the rate up (in powers of 10), negative values scale the rate down\n  }\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint256 c;\n    unchecked {\n      c = a * b;\n    }\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    uint256 c;\n    unchecked {\n      c = a + b;\n    }\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (MathError, uint256) {\n    (MathError err0, uint256 sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n}\n"
    },
    "contracts/compound/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CErc20 {\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 3;\n\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\n\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\n      functionSelectors[i] = superFunctionSelectors[i];\n    }\n\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.contractType.selector;\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.delegateType.selector;\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this._becomeImplementation.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   */\n  function _becomeImplementation(bytes memory) public virtual override {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self || !admin\");\n  }\n\n  function delegateType() public pure virtual override returns (uint8) {\n    return 1;\n  }\n\n  function contractType() external pure virtual override returns (string memory) {\n    return \"CErc20Delegate\";\n  }\n}\n"
    },
    "contracts/compound/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"../ionic/DiamondExtension.sol\";\nimport { CErc20DelegatorBase, CDelegateInterface } from \"./CTokenInterfaces.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CErc20DelegatorBase, DiamondBase {\n  /**\n   * @notice Emitted when implementation is changed\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param ionicAdmin_ The FeeDistributor contract address.\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   */\n  constructor(\n    address underlying_,\n    IonicComptroller comptroller_,\n    address payable ionicAdmin_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) {\n    require(msg.sender == ionicAdmin_, \"!admin\");\n    uint8 decimals_ = EIP20Interface(underlying_).decimals();\n    {\n      ionicAdmin = ionicAdmin_;\n\n      // Set initial exchange rate\n      initialExchangeRateMantissa = 0.2e18;\n\n      // Set the comptroller\n      comptroller = comptroller_;\n\n      // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n      accrualBlockNumber = block.number;\n      borrowIndex = 1e18;\n\n      // Set the interest rate model (depends on block number / borrow index)\n      require(interestRateModel_.isInterestRateModel(), \"!notIrm\");\n      interestRateModel = interestRateModel_;\n      emit NewMarketInterestRateModel(InterestRateModel(address(0)), interestRateModel_);\n\n      name = name_;\n      symbol = symbol_;\n      decimals = decimals_;\n\n      // Set reserve factor\n      // Check newReserveFactor  maxReserveFactor\n      require(\n        reserveFactorMantissa_ + adminFeeMantissa + ionicFeeMantissa <= reserveFactorPlusFeesMaxMantissa,\n        \"!rf:set\"\n      );\n      reserveFactorMantissa = reserveFactorMantissa_;\n      emit NewReserveFactor(0, reserveFactorMantissa_);\n\n      // Set admin fee\n      // Sanitize adminFeeMantissa_\n      if (adminFeeMantissa_ == type(uint256).max) adminFeeMantissa_ = adminFeeMantissa;\n      // Get latest Ionic fee\n      uint256 newIonicFeeMantissa = IFeeDistributor(ionicAdmin).interestFeeRate();\n      require(\n        reserveFactorMantissa + adminFeeMantissa_ + newIonicFeeMantissa <= reserveFactorPlusFeesMaxMantissa,\n        \"!adminFee:set\"\n      );\n      adminFeeMantissa = adminFeeMantissa_;\n      emit NewAdminFee(0, adminFeeMantissa_);\n      ionicFeeMantissa = newIonicFeeMantissa;\n      emit NewIonicFee(0, newIonicFeeMantissa);\n\n      // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n      _notEntered = true;\n    }\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  function implementation() public view returns (address) {\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\"delegateType()\"))));\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external override {\n    // Check admin rights\n    require(hasAdminRights(), \"!admin\");\n\n    // Set implementation\n    _setImplementationInternal(implementation_, becomeImplementationData);\n  }\n\n  /**\n   * @dev upgrades the implementation if necessary\n   */\n  function _upgrade() external override {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self or admin\");\n\n    (bool success, bytes memory data) = address(this).staticcall(abi.encodeWithSignature(\"delegateType()\"));\n    require(success, \"no delegate type\");\n\n    uint8 currentDelegateType = abi.decode(data, (uint8));\n    (address latestCErc20Delegate, bytes memory becomeImplementationData) = IFeeDistributor(ionicAdmin)\n      .latestCErc20Delegate(currentDelegateType);\n\n    address currentDelegate = implementation();\n    if (currentDelegate != latestCErc20Delegate) {\n      _setImplementationInternal(latestCErc20Delegate, becomeImplementationData);\n    } else {\n      // only update the extensions without reinitializing with becomeImplementationData\n      _updateExtensions(currentDelegate);\n    }\n  }\n\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\n    require(msg.sender == address(ionicAdmin), \"!unauthorized\");\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\n  }\n\n  /**\n   * @dev Internal function to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationInternal(address implementation_, bytes memory becomeImplementationData) internal {\n    address delegateBefore = implementation();\n    _updateExtensions(implementation_);\n\n    _functionCall(\n      address(this),\n      abi.encodeWithSelector(CDelegateInterface._becomeImplementation.selector, becomeImplementationData),\n      \"!become impl\"\n    );\n\n    emit NewImplementation(delegateBefore, implementation_);\n  }\n\n  function _updateExtensions(address newDelegate) internal {\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getCErc20DelegateExtensions(newDelegate);\n    address[] memory currentExtensions = LibDiamond.listExtensions();\n\n    // removed the current (old) extensions\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\n    }\n    // add the new extensions\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\n    }\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n}\n"
    },
    "contracts/compound/CErc20PluginDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CErc20Delegate.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./IERC4626.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\n/**\n * @title Rari's CErc20Plugin's Contract\n * @notice CToken which outsources token logic to a plugin\n * @author Joey Santoro\n *\n * CErc20PluginDelegate deposits and withdraws from a plugin contract\n * It is also capable of delegating reward functionality to a PluginRewardsDistributor\n */\ncontract CErc20PluginDelegate is CErc20Delegate {\n  event NewPluginImplementation(address oldImpl, address newImpl);\n\n  /**\n   * @notice Plugin address\n   */\n  IERC4626 public plugin;\n\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 2;\n\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\n\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\n      functionSelectors[i] = superFunctionSelectors[i];\n    }\n\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.plugin.selector;\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this._updatePlugin.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n\n  /**\n   * @notice Delegate interface to become the implementation\n   * @param data The encoded arguments for becoming\n   */\n  function _becomeImplementation(bytes memory data) public virtual override {\n    require(msg.sender == address(this) || hasAdminRights(), \"only self and admins can call _becomeImplementation\");\n\n    address _plugin = abi.decode(data, (address));\n\n    if (_plugin == address(0) && address(plugin) != address(0)) {\n      // if no new plugin address is given, use the latest implementation\n      _plugin = IFeeDistributor(ionicAdmin).latestPluginImplementation(address(plugin));\n    }\n\n    if (_plugin != address(0) && _plugin != address(plugin)) {\n      _updatePlugin(_plugin);\n    }\n  }\n\n  /**\n   * @notice Update the plugin implementation to a whitelisted implementation\n   * @param _plugin The address of the plugin implementation to use\n   */\n  function _updatePlugin(address _plugin) public {\n    require(msg.sender == address(this) || hasAdminRights(), \"only self and admins can call _updatePlugin\");\n\n    address oldImplementation = address(plugin) != address(0) ? address(plugin) : _plugin;\n\n    if (address(plugin) != address(0) && plugin.balanceOf(address(this)) != 0) {\n      plugin.redeem(plugin.balanceOf(address(this)), address(this), address(this));\n    }\n\n    plugin = IERC4626(_plugin);\n\n    EIP20Interface(underlying).approve(_plugin, type(uint256).max);\n\n    uint256 amount = EIP20Interface(underlying).balanceOf(address(this));\n    if (amount != 0) {\n      deposit(amount);\n    }\n\n    emit NewPluginImplementation(oldImplementation, _plugin);\n  }\n\n  /*** CToken Overrides ***/\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of the plugin in terms of the underlying\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashInternal() internal view override returns (uint256) {\n    return plugin.previewRedeem(plugin.balanceOf(address(this)));\n  }\n\n  /**\n   * @notice Transfer the underlying to the cToken and trigger a deposit\n   * @param from Address to transfer funds from\n   * @param amount Amount of underlying to transfer\n   * @return The actual amount that is transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Perform the EIP-20 transfer in\n    require(EIP20Interface(underlying).transferFrom(from, address(this), amount), \"send\");\n\n    deposit(amount);\n    return amount;\n  }\n\n  function deposit(uint256 amount) internal {\n    plugin.deposit(amount, address(this));\n  }\n\n  /**\n   * @notice Transfer the underlying from plugin to destination\n   * @param to Address to transfer funds to\n   * @param amount Amount of underlying to transfer\n   */\n  function doTransferOut(address to, uint256 amount) internal override {\n    plugin.withdraw(amount, to, address(this));\n  }\n\n  function delegateType() public pure virtual override returns (uint8) {\n    return 2;\n  }\n\n  function contractType() external pure virtual override returns (string memory) {\n    return \"CErc20PluginDelegate\";\n  }\n}\n"
    },
    "contracts/compound/CErc20PluginRewardsDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CErc20PluginDelegate.sol\";\n\ncontract CErc20PluginRewardsDelegate is CErc20PluginDelegate {\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 2;\n\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\n\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\n      functionSelectors[i] = superFunctionSelectors[i];\n    }\n\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.claim.selector;\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.approve.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n\n  /// @notice A reward token claim function\n  /// to be overridden for use cases where rewardToken needs to be pulled in\n  function claim() external {}\n\n  /// @notice token approval function\n  function approve(address _token, address _spender) external {\n    require(hasAdminRights(), \"!admin\");\n    require(_token != underlying && _token != address(plugin), \"!token\");\n\n    EIP20Interface(_token).approve(_spender, type(uint256).max);\n  }\n\n  function delegateType() public pure virtual override returns (uint8) {\n    return 4;\n  }\n\n  function contractType() external pure override returns (string memory) {\n    return \"CErc20PluginRewardsDelegate\";\n  }\n}\n"
    },
    "contracts/compound/CErc20RewardsDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CErc20Delegate.sol\";\nimport \"./EIP20Interface.sol\";\n\ncontract CErc20RewardsDelegate is CErc20Delegate {\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 2;\n\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\n\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\n      functionSelectors[i] = superFunctionSelectors[i];\n    }\n\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.claim.selector;\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.approve.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n  \n  /// @notice A reward token claim function\n  /// to be overridden for use cases where rewardToken needs to be pulled in\n  function claim() external {}\n\n  /// @notice token approval function\n  function approve(address _token, address _spender) external {\n    require(hasAdminRights(), \"!admin\");\n    require(_token != underlying, \"!underlying\");\n\n    EIP20Interface(_token).approve(_spender, type(uint256).max);\n  }\n\n  function delegateType() public pure virtual override returns (uint8) {\n    return 3;\n  }\n\n  function contractType() external pure override returns (string memory) {\n    return \"CErc20RewardsDelegate\";\n  }\n}\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { ComptrollerErrorReporter } from \"./ErrorReporter.sol\";\nimport { Exponential } from \"./Exponential.sol\";\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\nimport { Unitroller } from \"./Unitroller.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\nimport { IIonicFlywheel } from \"../ionic/strategies/flywheel/IIonicFlywheel.sol\";\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerExtensionInterface, ComptrollerBase, ComptrollerInterface } from \"./ComptrollerInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerBase, ComptrollerInterface, ComptrollerErrorReporter, Exponential, DiamondExtension {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(ICErc20 cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(ICErc20 cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(ICErc20 cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(ICErc20 cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(BasePriceOracle oldPriceOracle, BasePriceOracle newPriceOracle);\n\n  /// @notice Emitted when the whitelist enforcement is changed\n  event WhitelistEnforcementChanged(bool enforce);\n\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n  event AddedRewardsDistributor(address rewardsDistributor);\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  // liquidationIncentiveMantissa must be no less than this value\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n  // liquidationIncentiveMantissa must be no greater than this value\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n  modifier isAuthorized() {\n    require(IFeeDistributor(ionicAdmin).canCall(address(this), msg.sender, address(this), msg.sig), \"not authorized\");\n    _;\n  }\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(\n    address cToken\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 supplyCap) {\n    return ComptrollerBase.effectiveSupplyCaps(cToken);\n  }\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(\n    address cToken\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 borrowCap) {\n    return ComptrollerBase.effectiveBorrowCaps(cToken);\n  }\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n   * @param account The address of the account to pull assets for\n   * @return A dynamic list with the assets the account has entered\n   */\n  function getAssetsIn(address account) external view returns (ICErc20[] memory) {\n    ICErc20[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n   * @param account The address of the account to check\n   * @param cToken The cToken to check\n   * @return True if the account is in the asset, otherwise false.\n   */\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n   * @param cTokens The list of addresses of the cToken markets to be enabled\n   * @return Success indicator for whether each corresponding market was entered\n   */\n  function enterMarkets(address[] memory cTokens) public override isAuthorized returns (uint256[] memory) {\n    uint256 len = cTokens.length;\n\n    uint256[] memory results = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      ICErc20 cToken = ICErc20(cTokens[i]);\n\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n   * @param cToken The market to enter\n   * @param borrower The address of the account to modify\n   * @return Success indicator for whether the market was entered\n   */\n  function addToMarketInternal(ICErc20 cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    // Add to allBorrowers\n    if (!borrowers[borrower]) {\n      allBorrowers.push(borrower);\n      borrowers[borrower] = true;\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\n    }\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n   * @dev Sender must not have an outstanding borrow balance in the asset,\n   *  or be providing necessary collateral for an outstanding borrow.\n   * @param cTokenAddress The address of the asset to be removed\n   * @return Whether or not the account successfully exited the market\n   */\n  function exitMarket(address cTokenAddress) external override isAuthorized returns (uint256) {\n    // TODO\n    require(markets[cTokenAddress].isListed, \"!Comptroller:exitMarket\");\n\n    ICErc20 cToken = ICErc20(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"!exitMarket\"); // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[cTokenAddress];\n\n    /* Return true if the sender is not already in the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the accounts list of assets */\n    // load into memory for faster iteration\n    ICErc20[] memory userAssetList = accountAssets[msg.sender];\n    uint256 len = userAssetList.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (userAssetList[i] == ICErc20(cTokenAddress)) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    ICErc20[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    // If the user has exited all markets, remove them from the `allBorrowers` array\n    if (storedList.length == 0) {\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n      allBorrowers.pop(); // Reduce length by 1\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n    }\n\n    emit MarketExited(ICErc20(cTokenAddress), msg.sender);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n   * @param cTokenAddress The market to verify the mint against\n   * @param minter The account which would get the minted tokens\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function mintAllowed(address cTokenAddress, address minter, uint256 mintAmount) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cTokenAddress], \"!mint:paused\");\n\n    // Make sure market is listed\n    if (!markets[cTokenAddress].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure minter is whitelisted\n    if (enforceWhitelist && !whitelist[minter]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    uint256 supplyCap = effectiveSupplyCaps(cTokenAddress);\n\n    // Supply cap of 0 corresponds to unlimited supplying\n    if (supplyCap != 0 && !supplyCapWhitelist[cTokenAddress].contains(minter)) {\n      uint256 totalUnderlyingSupply = ICErc20(cTokenAddress).getTotalUnderlyingSupplied();\n      uint256 whitelistedSuppliersSupply = asComptrollerExtension().getWhitelistedSuppliersSupply(cTokenAddress);\n      uint256 nonWhitelistedTotalSupply;\n      if (whitelistedSuppliersSupply >= totalUnderlyingSupply) nonWhitelistedTotalSupply = 0;\n      else nonWhitelistedTotalSupply = totalUnderlyingSupply - whitelistedSuppliersSupply;\n\n      require(nonWhitelistedTotalSupply + mintAmount < supplyCap, \"!supply cap\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cTokenAddress, minter);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n   * @param cToken The market to verify the redeem against\n   * @param redeemer The account which would redeem the tokens\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external override returns (uint256) {\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, redeemer);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) internal view returns (uint256) {\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      redeemer,\n      ICErc20(cToken),\n      redeemTokens,\n      0,\n      0\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n   * @param cToken Asset being minted\n   * @param minter The address minting the tokens\n   * @param actualMintAmount The amount of the underlying asset being minted\n   * @param mintTokens The number of tokens being minted\n   */\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\n    // Add minter to suppliers mapping\n    suppliers[minter] = true;\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n   * @param cToken Asset being redeemed\n   * @param redeemer The address redeeming the tokens\n   * @param redeemAmount The amount of the underlying asset being redeemed\n   * @param redeemTokens The number of tokens being redeemed\n   */\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external override {\n    require(markets[msg.sender].isListed, \"!market\");\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"!zero\");\n    }\n  }\n\n  function getMaxRedeemOrBorrow(\n    address account,\n    ICErc20 cTokenModify,\n    bool isBorrow\n  ) external view override returns (uint256) {\n    address cToken = address(cTokenModify);\n    // Accrue interest\n    uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n\n    // Get account liquidity\n    (Error err, , uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      isBorrow ? cTokenModify : ICErc20(address(0)),\n      0,\n      0,\n      0\n    );\n    require(err == Error.NO_ERROR, \"!liquidity\");\n    if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\n\n    // Get max borrow/redeem\n    uint256 maxBorrowOrRedeemAmount;\n\n    if (!isBorrow && !markets[cToken].accountMembership[account]) {\n      // Max redeem = balance of underlying if not used as collateral\n      maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    } else {\n      // Avoid \"stack too deep\" error by separating this logic\n      maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\n\n      // Redeem only: max out at underlying balance\n      if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    }\n\n    // Get max borrow or redeem considering cToken liquidity\n    uint256 cTokenLiquidity = cTokenModify.getCash();\n\n    // Return the minimum of the two maximums\n    return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\n  }\n\n  /**\n   * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\n   */\n  function _getMaxRedeemOrBorrow(\n    uint256 liquidity,\n    ICErc20 cTokenModify,\n    bool isBorrow\n  ) internal view returns (uint256) {\n    if (liquidity == 0) return 0; // No available account liquidity, so no more borrow/redeem\n\n    // Get the normalized price of the asset\n    uint256 conversionFactor = oracle.getUnderlyingPrice(cTokenModify);\n    require(conversionFactor > 0, \"!oracle\");\n\n    // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n    if (!isBorrow) {\n      uint256 collateralFactorMantissa = markets[address(cTokenModify)].collateralFactorMantissa;\n      conversionFactor = (collateralFactorMantissa * conversionFactor) / 1e18;\n    }\n\n    // Get max borrow or redeem considering excess account liquidity\n    return (liquidity * 1e18) / conversionFactor;\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken The market to verify the borrow against\n   * @param borrower The account which would borrow the asset\n   * @param borrowAmount The amount of underlying the account would borrow\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"!borrow:paused\");\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"!ctoken\");\n\n      // attempt to add borrower to the market\n      Error err = addToMarketInternal(ICErc20(msg.sender), borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    // Make sure oracle price is available\n    if (oracle.getUnderlyingPrice(ICErc20(cToken)) == 0) {\n      return uint256(Error.PRICE_ERROR);\n    }\n\n    // Make sure borrower is whitelisted\n    if (enforceWhitelist && !whitelist[borrower]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    uint256 borrowCap = effectiveBorrowCaps(cToken);\n\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0 && !borrowCapWhitelist[cToken].contains(borrower)) {\n      uint256 totalBorrows = ICErc20(cToken).totalBorrowsCurrent();\n      uint256 whitelistedBorrowersBorrows = asComptrollerExtension().getWhitelistedBorrowersBorrows(cToken);\n      uint256 nonWhitelistedTotalBorrows;\n      if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\n      else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\n\n      require(nonWhitelistedTotalBorrows + borrowAmount < borrowCap, \"!borrow:cap\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    // Perform a hypothetical liquidity check to guard against shortfall\n    (uint256 err, , , uint256 shortfall) = this.getHypotheticalAccountLiquidity(borrower, cToken, 0, borrowAmount, 0);\n    if (err != uint256(Error.NO_ERROR)) {\n      return err;\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n   */\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view override returns (uint256) {\n    // Check if min borrow exists\n    uint256 minBorrowEth = IFeeDistributor(ionicAdmin).minBorrowEth();\n\n    if (minBorrowEth > 0) {\n      // Get new underlying borrow balance of account for this cToken\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(ICErc20(cToken));\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\n        Exp({ mantissa: oraclePriceMantissa }),\n        accountBorrowsNew\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      // Check against min borrow\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\n    }\n\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n   * @param cToken The market to verify the repay against\n   * @param payer The account which would repay the asset\n   * @param borrower The account which would borrowed the asset\n   * @param repayAmount The amount of the underlying asset the account would repay\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Make sure markets are listed\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Get borrowers' underlying borrow balance\n    uint256 borrowBalance = ICErc20(cTokenBorrowed).borrowBalanceCurrent(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(ICErc20(cTokenBorrowed))) {\n      require(borrowBalance >= repayAmount, \"!borrow>repay\");\n    } else {\n      /* The borrower must have shortfall in order to be liquidateable */\n      (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n        borrower,\n        ICErc20(address(0)),\n        0,\n        0,\n        0\n      );\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      if (shortfall == 0) {\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n      if (repayAmount > maxClose) {\n        return uint256(Error.TOO_MUCH_REPAY);\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"!seize:paused\");\n\n    // Make sure markets are listed\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure cToken Comptrollers are identical\n    if (ICErc20(cTokenCollateral).comptroller() != ICErc20(cTokenBorrowed).comptroller()) {\n      return uint256(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n   * @param cToken The market to verify the transfer against\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"!transfer:paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cToken, src, dst);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Flywheel Hooks ***/\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(address cToken, address src, address dst) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n   */\n  struct AccountLiquidityLocalVars {\n    ICErc20 asset;\n    uint256 sumCollateral;\n    uint256 sumBorrowPlusEffects;\n    uint256 cTokenBalance;\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n    uint256 oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n    uint256 borrowCapForCollateral;\n    uint256 borrowedAssetPrice;\n    uint256 assetAsCollateralValueCap;\n  }\n\n  function getAccountLiquidity(address account) public view override returns (uint256, uint256, uint256, uint256) {\n    (\n      Error err,\n      uint256 collateralValue,\n      uint256 liquidity,\n      uint256 shortfall\n    ) = getHypotheticalAccountLiquidityInternal(account, ICErc20(address(0)), 0, 0, 0);\n    return (uint256(err), collateralValue, liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) public view returns (uint256, uint256, uint256, uint256) {\n    (\n      Error err,\n      uint256 collateralValue,\n      uint256 liquidity,\n      uint256 shortfall\n    ) = getHypotheticalAccountLiquidityInternal(\n        account,\n        ICErc20(cTokenModify),\n        redeemTokens,\n        borrowAmount,\n        repayAmount\n      );\n    return (uint256(err), collateralValue, liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code,\n                hypothetical account collateral value,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    ICErc20 cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) internal view returns (Error, uint256, uint256, uint256) {\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n\n    if (address(cTokenModify) != address(0)) {\n      vars.borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\n    }\n\n    // For each asset the account is in\n    for (uint256 i = 0; i < accountAssets[account].length; i++) {\n      vars.asset = accountAssets[account][i];\n\n      {\n        // Read the balances and exchange rate from the cToken\n        uint256 oErr;\n        (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vars.asset.getAccountSnapshot(\n          account\n        );\n        if (oErr != 0) {\n          // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n          return (Error.SNAPSHOT_ERROR, 0, 0, 0);\n        }\n      }\n      {\n        vars.collateralFactor = Exp({ mantissa: markets[address(vars.asset)].collateralFactorMantissa });\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n        // Get the normalized price of the asset\n        vars.oraclePriceMantissa = oracle.getUnderlyingPrice(vars.asset);\n        if (vars.oraclePriceMantissa == 0) {\n          return (Error.PRICE_ERROR, 0, 0, 0);\n        }\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n      }\n      {\n        // Exclude the asset-to-be-borrowed from the liquidity, except for when redeeming\n        vars.assetAsCollateralValueCap = asComptrollerExtension().getAssetAsCollateralValueCap(\n          vars.asset,\n          cTokenModify,\n          redeemTokens > 0,\n          account\n        );\n\n        // accumulate the collateral value to sumCollateral\n        uint256 assetCollateralValue = mul_ScalarTruncate(vars.tokensToDenom, vars.cTokenBalance);\n        if (assetCollateralValue > vars.assetAsCollateralValueCap)\n          assetCollateralValue = vars.assetAsCollateralValueCap;\n        vars.sumCollateral += assetCollateralValue;\n      }\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n        vars.oraclePrice,\n        vars.borrowBalance,\n        vars.sumBorrowPlusEffects\n      );\n\n      // Calculate effects of interacting with cTokenModify\n      if (vars.asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.tokensToDenom,\n          redeemTokens,\n          vars.sumBorrowPlusEffects\n        );\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.oraclePrice,\n          borrowAmount,\n          vars.sumBorrowPlusEffects\n        );\n\n        uint256 repayEffect = mul_ScalarTruncate(vars.oraclePrice, repayAmount);\n        if (repayEffect >= vars.sumBorrowPlusEffects) {\n          vars.sumBorrowPlusEffects = 0;\n        } else {\n          vars.sumBorrowPlusEffects -= repayEffect;\n        }\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, vars.sumCollateral, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n   * @param cTokenBorrowed The address of the borrowed cToken\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view override returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenBorrowed));\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint256(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    ICErc20 collateralCToken = ICErc20(cTokenCollateral);\n    uint256 exchangeRateMantissa = collateralCToken.exchangeRateCurrent();\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    uint256 protocolSeizeShareMantissa = collateralCToken.protocolSeizeShareMantissa();\n    uint256 feeSeizeShareMantissa = collateralCToken.feeSeizeShareMantissa();\n\n    /*\n     * The liquidation penalty includes\n     * - the liquidator incentive\n     * - the protocol fees (Ionic admin fees)\n     * - the market fee\n     */\n    Exp memory totalPenaltyMantissa = add_(\n      add_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: protocolSeizeShareMantissa })),\n      Exp({ mantissa: feeSeizeShareMantissa })\n    );\n\n    numerator = mul_(totalPenaltyMantissa, Exp({ mantissa: priceBorrowedMantissa }));\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n    return (uint256(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Add a RewardsDistributor contracts.\n   * @dev Admin function to add a RewardsDistributor contract\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\n    require(hasAdminRights(), \"!admin\");\n\n    // Check marker method\n    require(IIonicFlywheel(distributor).isRewardsDistributor(), \"!isRewardsDistributor\");\n\n    // Check for existing RewardsDistributor\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) require(distributor != rewardsDistributors[i], \"!added\");\n\n    // Add RewardsDistributor to array\n    rewardsDistributors.push(distributor);\n    emit AddedRewardsDistributor(distributor);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist enforcement for the comptroller\n   * @dev Admin function to set a new whitelist enforcement boolean\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\n    }\n\n    // Check if `enforceWhitelist` already equals `enforce`\n    if (enforceWhitelist == enforce) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    // Set comptroller's `enforceWhitelist` to `enforce`\n    enforceWhitelist = enforce;\n\n    // Emit WhitelistEnforcementChanged(bool enforce);\n    emit WhitelistEnforcementChanged(enforce);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist `statuses` for `suppliers`\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\n    }\n\n    // Set whitelist statuses for suppliers\n    for (uint256 i = 0; i < suppliers.length; i++) {\n      address supplier = suppliers[i];\n\n      if (statuses[i]) {\n        // If not already whitelisted, add to whitelist\n        if (!whitelist[supplier]) {\n          whitelist[supplier] = true;\n          whitelistArray.push(supplier);\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\n        }\n      } else {\n        // If whitelisted, remove from whitelist\n        if (whitelist[supplier]) {\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\n          whitelistArray.pop(); // Reduce length by 1\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n        }\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets a new price oracle for the comptroller\n   * @dev Admin function to set a new price oracle\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPriceOracle(BasePriceOracle newOracle) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    BasePriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the closeFactor used when liquidating borrows\n   * @dev Admin function to set closeFactor\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n    }\n\n    // Check limits\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    // Set pool close factor to new close factor, remember old value\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n\n    // Emit event\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the collateralFactor for a market\n   * @dev Admin function to set per-market collateralFactor\n   * @param cToken The market to set the factor on\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCollateralFactor(ICErc20 cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets liquidationIncentive\n   * @dev Admin function to set liquidationIncentive\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Check de-scaled min <= newLiquidationIncentive <= max\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    // Save current value for use in log\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Add the market to the markets mapping and set it as listed\n   * @dev Admin function to set isListed and add support for the market\n   * @param cToken The address of the market (token) to list\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _supportMarket(ICErc20 cToken) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Is market already listed?\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // Check cToken.comptroller == this\n    require(address(cToken.comptroller()) == address(this), \"!comptroller\");\n\n    // Make sure market is not already listed\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // List market and emit event\n    Market storage market = markets[address(cToken)];\n    market.isListed = true;\n    market.collateralFactorMantissa = 0;\n    allMarkets.push(cToken);\n    cTokensByUnderlying[underlying] = cToken;\n    emit MarketListed(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _deployMarket(\n    uint8 delegateType,\n    bytes calldata constructorData,\n    bytes calldata becomeImplData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Temporarily enable Ionic admin rights for asset deployment (storing the original value)\n    bool oldIonicAdminHasRights = ionicAdminHasRights;\n    ionicAdminHasRights = true;\n\n    // Deploy via Ionic admin\n    ICErc20 cToken = ICErc20(IFeeDistributor(ionicAdmin).deployCErc20(delegateType, constructorData, becomeImplData));\n    // Reset Ionic admin rights to the original value\n    ionicAdminHasRights = oldIonicAdminHasRights;\n    // Support market here in the Comptroller\n    uint256 err = _supportMarket(cToken);\n\n    IFeeDistributor(ionicAdmin).authoritiesRegistry().reconfigureAuthority(address(this));\n\n    // Set collateral factor\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\n  }\n\n  function _becomeImplementation() external {\n    require(msg.sender == address(this), \"!self call\");\n\n    if (!_notEnteredInitialized) {\n      _notEntered = true;\n      _notEnteredInitialized = true;\n    }\n  }\n\n  /*** Helper Functions ***/\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   * @param cToken The market to check if deprecated\n   */\n  function isDeprecated(ICErc20 cToken) public view returns (bool) {\n    return\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\n      borrowGuardianPaused[address(cToken)] == true &&\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.ionicFeeMantissa()) == 1e18;\n  }\n\n  function asComptrollerExtension() internal view returns (ComptrollerExtensionInterface) {\n    return ComptrollerExtensionInterface(address(this));\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory functionSelectors) {\n    uint8 fnsCount = 32;\n\n    functionSelectors = new bytes4[](fnsCount);\n\n    functionSelectors[--fnsCount] = this.isDeprecated.selector;\n    functionSelectors[--fnsCount] = this._deployMarket.selector;\n    functionSelectors[--fnsCount] = this.getAssetsIn.selector;\n    functionSelectors[--fnsCount] = this.checkMembership.selector;\n    functionSelectors[--fnsCount] = this._setPriceOracle.selector;\n    functionSelectors[--fnsCount] = this._setCloseFactor.selector;\n    functionSelectors[--fnsCount] = this._setCollateralFactor.selector;\n    functionSelectors[--fnsCount] = this._setLiquidationIncentive.selector;\n    functionSelectors[--fnsCount] = this._setWhitelistEnforcement.selector;\n    functionSelectors[--fnsCount] = this._setWhitelistStatuses.selector;\n    functionSelectors[--fnsCount] = this._addRewardsDistributor.selector;\n    functionSelectors[--fnsCount] = this.getHypotheticalAccountLiquidity.selector;\n    functionSelectors[--fnsCount] = this.getMaxRedeemOrBorrow.selector;\n    functionSelectors[--fnsCount] = this.enterMarkets.selector;\n    functionSelectors[--fnsCount] = this.exitMarket.selector;\n    functionSelectors[--fnsCount] = this.mintAllowed.selector;\n    functionSelectors[--fnsCount] = this.redeemAllowed.selector;\n    functionSelectors[--fnsCount] = this.redeemVerify.selector;\n    functionSelectors[--fnsCount] = this.borrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.borrowWithinLimits.selector;\n    functionSelectors[--fnsCount] = this.repayBorrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.liquidateBorrowAllowed.selector;\n    functionSelectors[--fnsCount] = this.seizeAllowed.selector;\n    functionSelectors[--fnsCount] = this.transferAllowed.selector;\n    functionSelectors[--fnsCount] = this.mintVerify.selector;\n    functionSelectors[--fnsCount] = this.getAccountLiquidity.selector;\n    functionSelectors[--fnsCount] = this.liquidateCalculateSeizeTokens.selector;\n    functionSelectors[--fnsCount] = this._beforeNonReentrant.selector;\n    functionSelectors[--fnsCount] = this._afterNonReentrant.selector;\n    functionSelectors[--fnsCount] = this._becomeImplementation.selector;\n    functionSelectors[--fnsCount] = this.effectiveSupplyCaps.selector;\n    functionSelectors[--fnsCount] = this.effectiveBorrowCaps.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n  }\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  /**\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _beforeNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"!Comptroller:_beforeNonReentrant\");\n    require(_notEntered, \"!reentered\");\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _afterNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"!Comptroller:_afterNonReentrant\");\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/compound/ComptrollerFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerErrorReporter } from \"../compound/ErrorReporter.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { ComptrollerExtensionInterface, ComptrollerBase, SFSRegister } from \"./ComptrollerInterface.sol\";\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract ComptrollerFirstExtension is\n  DiamondExtension,\n  ComptrollerBase,\n  ComptrollerExtensionInterface,\n  ComptrollerErrorReporter\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @notice Emitted when supply cap for a cToken is changed\n  event NewSupplyCap(ICErc20 indexed cToken, uint256 newSupplyCap);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(ICErc20 indexed cToken, uint256 newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  /// @notice Emitted when an action is paused globally\n  event ActionPaused(string action, bool pauseState);\n\n  /// @notice Emitted when an action is paused on a market\n  event MarketActionPaused(ICErc20 cToken, string action, bool pauseState);\n\n  /// @notice Emitted when an admin unsupports a market\n  event MarketUnlisted(ICErc20 cToken);\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 33;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.addNonAccruingFlywheel.selector;\n    functionSelectors[--fnsCount] = this._setMarketSupplyCaps.selector;\n    functionSelectors[--fnsCount] = this._setMarketBorrowCaps.selector;\n    functionSelectors[--fnsCount] = this._setBorrowCapForCollateralWhitelist.selector;\n    functionSelectors[--fnsCount] = this._blacklistBorrowingAgainstCollateralWhitelist.selector;\n    functionSelectors[--fnsCount] = this._supplyCapWhitelist.selector;\n    functionSelectors[--fnsCount] = this._borrowCapWhitelist.selector;\n    functionSelectors[--fnsCount] = this._setBorrowCapGuardian.selector;\n    functionSelectors[--fnsCount] = this._setPauseGuardian.selector;\n    functionSelectors[--fnsCount] = this._setMintPaused.selector;\n    functionSelectors[--fnsCount] = this._setBorrowPaused.selector;\n    functionSelectors[--fnsCount] = this._setTransferPaused.selector;\n    functionSelectors[--fnsCount] = this._setSeizePaused.selector;\n    functionSelectors[--fnsCount] = this._unsupportMarket.selector;\n    functionSelectors[--fnsCount] = this.getAllMarkets.selector;\n    functionSelectors[--fnsCount] = this.getAllBorrowers.selector;\n    functionSelectors[--fnsCount] = this.getAllBorrowersCount.selector;\n    functionSelectors[--fnsCount] = this.getPaginatedBorrowers.selector;\n    functionSelectors[--fnsCount] = this.getWhitelist.selector;\n    functionSelectors[--fnsCount] = this.getRewardsDistributors.selector;\n    functionSelectors[--fnsCount] = this.isUserOfPool.selector;\n    functionSelectors[--fnsCount] = this.getAccruingFlywheels.selector;\n    functionSelectors[--fnsCount] = this._removeFlywheel.selector;\n    functionSelectors[--fnsCount] = this._setBorrowCapForCollateral.selector;\n    functionSelectors[--fnsCount] = this._blacklistBorrowingAgainstCollateral.selector;\n    functionSelectors[--fnsCount] = this.isBorrowCapForCollateralWhitelisted.selector;\n    functionSelectors[--fnsCount] = this.isBlacklistBorrowingAgainstCollateralWhitelisted.selector;\n    functionSelectors[--fnsCount] = this.isSupplyCapWhitelisted.selector;\n    functionSelectors[--fnsCount] = this.isBorrowCapWhitelisted.selector;\n    functionSelectors[--fnsCount] = this.getWhitelistedSuppliersSupply.selector;\n    functionSelectors[--fnsCount] = this.getWhitelistedBorrowersBorrows.selector;\n    functionSelectors[--fnsCount] = this.getAssetAsCollateralValueCap.selector;\n    functionSelectors[--fnsCount] = this.registerInSFS.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  /**\n   * @notice Returns true if the accruing flyhwheel was found and replaced\n   * @dev Adds a flywheel to the non-accruing list and if already in the accruing, removes it from that list\n   * @param flywheelAddress The address of the flywheel to add to the non-accruing\n   */\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool) {\n    require(hasAdminRights(), \"!admin\");\n    require(flywheelAddress != address(0), \"!flywheel\");\n\n    for (uint256 i = 0; i < nonAccruingRewardsDistributors.length; i++) {\n      require(flywheelAddress != nonAccruingRewardsDistributors[i], \"!alreadyadded\");\n    }\n\n    // add it to the non-accruing\n    nonAccruingRewardsDistributors.push(flywheelAddress);\n\n    // remove it from the accruing\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) {\n      if (flywheelAddress == rewardsDistributors[i]) {\n        rewardsDistributors[i] = rewardsDistributors[rewardsDistributors.length - 1];\n        rewardsDistributors.pop();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function getAssetAsCollateralValueCap(\n    ICErc20 collateral,\n    ICErc20 cTokenModify,\n    bool redeeming,\n    address account\n  ) external view returns (uint256) {\n    if (address(collateral) == address(cTokenModify) && !redeeming) {\n      // the collateral asset counts as 0 liquidity when borrowed\n      return 0;\n    }\n\n    uint256 assetAsCollateralValueCap = type(uint256).max;\n    if (address(cTokenModify) != address(0)) {\n      // if the borrowed asset is blacklisted against this collateral & account is not whitelisted\n      if (\n        borrowingAgainstCollateralBlacklist[address(cTokenModify)][address(collateral)] &&\n        !borrowingAgainstCollateralBlacklistWhitelist[address(cTokenModify)][address(collateral)].contains(account)\n      ) {\n        assetAsCollateralValueCap = 0;\n      } else {\n        // for each user the value of this kind of collateral is capped regardless of the amount borrowed\n        // denominated in the borrowed asset\n        uint256 borrowCapForCollateral = borrowCapForCollateral[address(cTokenModify)][address(collateral)];\n        // check if set to any value & account is not whitelisted\n        if (\n          borrowCapForCollateral != 0 &&\n          !borrowCapForCollateralWhitelist[address(cTokenModify)][address(collateral)].contains(account)\n        ) {\n          uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\n          // this asset usage as collateral is capped at the native value of the borrow cap\n          assetAsCollateralValueCap = (borrowCapForCollateral * borrowedAssetPrice) / 1e18;\n        }\n      }\n    }\n\n    uint256 supplyCap = effectiveSupplyCaps(address(collateral));\n\n    // if there is any supply cap, don't allow donations to the market/plugin to go around it\n    if (supplyCap > 0 && !supplyCapWhitelist[address(collateral)].contains(account)) {\n      uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateral);\n      uint256 supplyCapValue = (supplyCap * collateralAssetPrice) / 1e18;\n      supplyCapValue = (supplyCapValue * markets[address(collateral)].collateralFactorMantissa) / 1e18;\n      if (supplyCapValue < assetAsCollateralValueCap) assetAsCollateralValueCap = supplyCapValue;\n    }\n\n    return assetAsCollateralValueCap;\n  }\n\n  /**\n   * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n   * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n   * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n   */\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numSupplyCaps = newSupplyCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numSupplyCaps, \"!input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n      emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n   * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n   * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n   */\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numBorrowCaps = newBorrowCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"!input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to change the Borrow Cap Guardian\n   * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n   */\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n    require(msg.sender == admin, \"!admin\");\n\n    // Save current value for inclusion in log\n    address oldBorrowCapGuardian = borrowCapGuardian;\n\n    // Store borrowCapGuardian with value newBorrowCapGuardian\n    borrowCapGuardian = newBorrowCapGuardian;\n\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n  }\n\n  /**\n   * @notice Admin function to change the Pause Guardian\n   * @param newPauseGuardian The address of the new Pause Guardian\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n    }\n\n    // Save current value for inclusion in log\n    address oldPauseGuardian = pauseGuardian;\n\n    // Store pauseGuardian with value newPauseGuardian\n    pauseGuardian = newPauseGuardian;\n\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function _setMintPaused(ICErc20 cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"!market\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\n    require(hasAdminRights() || state == true, \"!admin\");\n\n    mintGuardianPaused[address(cToken)] = state;\n    emit MarketActionPaused(cToken, \"Mint\", state);\n    return state;\n  }\n\n  function _setBorrowPaused(ICErc20 cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"!market\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\n    require(hasAdminRights() || state == true, \"!admin\");\n\n    borrowGuardianPaused[address(cToken)] = state;\n    emit MarketActionPaused(cToken, \"Borrow\", state);\n    return state;\n  }\n\n  function _setTransferPaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\n    require(hasAdminRights() || state == true, \"!admin\");\n\n    transferGuardianPaused = state;\n    emit ActionPaused(\"Transfer\", state);\n    return state;\n  }\n\n  function _setSeizePaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\n    require(hasAdminRights() || state == true, \"!admin\");\n\n    seizeGuardianPaused = state;\n    emit ActionPaused(\"Seize\", state);\n    return state;\n  }\n\n  /**\n   * @notice Removed a market from the markets mapping and sets it as unlisted\n   * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n   * @param cToken The address of the market (token) to unlist\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256) {\n    // Check admin rights\n    if (!hasAdminRights()) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n    // Check if market is already unlisted\n    if (!markets[address(cToken)].isListed)\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n    // Check if market is in use\n    if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n    // Unlist market\n    delete markets[address(cToken)];\n\n    /* Delete cToken from allMarkets */\n    // load into memory for faster iteration\n    ICErc20[] memory _allMarkets = allMarkets;\n    uint256 len = _allMarkets.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (_allMarkets[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n    allMarkets.pop();\n\n    cTokensByUnderlying[ICErc20(address(cToken)).underlying()] = ICErc20(address(0));\n    emit MarketUnlisted(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) public {\n    require(hasAdminRights(), \"!admin\");\n    borrowCapForCollateral[cTokenBorrow][cTokenCollateral] = borrowCap;\n  }\n\n  function _setBorrowCapForCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) public {\n    require(hasAdminRights(), \"!admin\");\n\n    if (whitelisted) borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].add(account);\n    else borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].remove(account);\n  }\n\n  function isBorrowCapForCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) public view returns (bool) {\n    return borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].contains(account);\n  }\n\n  function _blacklistBorrowingAgainstCollateral(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    bool blacklisted\n  ) public {\n    require(hasAdminRights(), \"!admin\");\n    borrowingAgainstCollateralBlacklist[cTokenBorrow][cTokenCollateral] = blacklisted;\n  }\n\n  function _blacklistBorrowingAgainstCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) public {\n    require(hasAdminRights(), \"!admin\");\n\n    if (whitelisted) borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].add(account);\n    else borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].remove(account);\n  }\n\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) public view returns (bool) {\n    return borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].contains(account);\n  }\n\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) public {\n    require(hasAdminRights(), \"!admin\");\n\n    if (whitelisted) supplyCapWhitelist[cToken].add(account);\n    else supplyCapWhitelist[cToken].remove(account);\n  }\n\n  function isSupplyCapWhitelisted(address cToken, address account) public view returns (bool) {\n    return supplyCapWhitelist[cToken].contains(account);\n  }\n\n  function getWhitelistedSuppliersSupply(address cToken) public view returns (uint256 supplied) {\n    address[] memory whitelistedSuppliers = supplyCapWhitelist[cToken].values();\n    for (uint256 i = 0; i < whitelistedSuppliers.length; i++) {\n      supplied += ICErc20(cToken).balanceOfUnderlying(whitelistedSuppliers[i]);\n    }\n  }\n\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) public {\n    require(hasAdminRights(), \"!admin\");\n\n    if (whitelisted) borrowCapWhitelist[cToken].add(account);\n    else borrowCapWhitelist[cToken].remove(account);\n  }\n\n  function isBorrowCapWhitelisted(address cToken, address account) public view returns (bool) {\n    return borrowCapWhitelist[cToken].contains(account);\n  }\n\n  function getWhitelistedBorrowersBorrows(address cToken) public view returns (uint256 borrowed) {\n    address[] memory whitelistedBorrowers = borrowCapWhitelist[cToken].values();\n    for (uint256 i = 0; i < whitelistedBorrowers.length; i++) {\n      borrowed += ICErc20(cToken).borrowBalanceCurrent(whitelistedBorrowers[i]);\n    }\n  }\n\n  /**\n   * @notice Return all of the markets\n   * @dev The automatic getter may be used to access an individual market.\n   * @return The list of market addresses\n   */\n  function getAllMarkets() public view returns (ICErc20[] memory) {\n    return allMarkets;\n  }\n\n  /**\n   * @notice Return all of the borrowers\n   * @dev The automatic getter may be used to access an individual borrower.\n   * @return The list of borrower account addresses\n   */\n  function getAllBorrowers() public view returns (address[] memory) {\n    return allBorrowers;\n  }\n\n  function getAllBorrowersCount() public view returns (uint256) {\n    return allBorrowers.length;\n  }\n\n  function getPaginatedBorrowers(\n    uint256 page,\n    uint256 pageSize\n  ) public view returns (uint256 _totalPages, address[] memory _pageOfBorrowers) {\n    uint256 allBorrowersCount = allBorrowers.length;\n    if (allBorrowersCount == 0) {\n      return (0, new address[](0));\n    }\n\n    if (pageSize == 0) pageSize = 300;\n    uint256 currentPageSize = pageSize;\n    uint256 sizeOfPageFromRemainder = allBorrowersCount % pageSize;\n\n    _totalPages = allBorrowersCount / pageSize;\n    if (sizeOfPageFromRemainder > 0) {\n      _totalPages++;\n      if (page + 1 == _totalPages) {\n        currentPageSize = sizeOfPageFromRemainder;\n      }\n    }\n\n    if (page + 1 > _totalPages) {\n      return (_totalPages, new address[](0));\n    }\n\n    uint256 offset = page * pageSize;\n    _pageOfBorrowers = new address[](currentPageSize);\n    for (uint256 i = 0; i < currentPageSize; i++) {\n      _pageOfBorrowers[i] = allBorrowers[i + offset];\n    }\n  }\n\n  /**\n   * @notice Return all of the whitelist\n   * @dev The automatic getter may be used to access an individual whitelist status.\n   * @return The list of borrower account addresses\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    return whitelistArray;\n  }\n\n  /**\n   * @notice Returns an array of all accruing and non-accruing flywheels\n   */\n  function getRewardsDistributors() external view returns (address[] memory) {\n    address[] memory allFlywheels = new address[](rewardsDistributors.length + nonAccruingRewardsDistributors.length);\n\n    uint8 i = 0;\n    while (i < rewardsDistributors.length) {\n      allFlywheels[i] = rewardsDistributors[i];\n      i++;\n    }\n    uint8 j = 0;\n    while (j < nonAccruingRewardsDistributors.length) {\n      allFlywheels[i + j] = nonAccruingRewardsDistributors[j];\n      j++;\n    }\n\n    return allFlywheels;\n  }\n\n  function getAccruingFlywheels() external view returns (address[] memory) {\n    return rewardsDistributors;\n  }\n\n  /**\n   * @dev Removes a flywheel from the accruing or non-accruing array\n   * @param flywheelAddress The address of the flywheel to remove from the accruing or non-accruing array\n   * @return true if the flywheel was found and removed\n   */\n  function _removeFlywheel(address flywheelAddress) external returns (bool) {\n    require(hasAdminRights(), \"!admin\");\n    require(flywheelAddress != address(0), \"!flywheel\");\n\n    // remove it from the accruing\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) {\n      if (flywheelAddress == rewardsDistributors[i]) {\n        rewardsDistributors[i] = rewardsDistributors[rewardsDistributors.length - 1];\n        rewardsDistributors.pop();\n        return true;\n      }\n    }\n\n    // or remove it from the non-accruing\n    for (uint256 i = 0; i < nonAccruingRewardsDistributors.length; i++) {\n      if (flywheelAddress == nonAccruingRewardsDistributors[i]) {\n        nonAccruingRewardsDistributors[i] = nonAccruingRewardsDistributors[nonAccruingRewardsDistributors.length - 1];\n        nonAccruingRewardsDistributors.pop();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isUserOfPool(address user) external view returns (bool) {\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      address marketAddress = address(allMarkets[i]);\n      if (markets[marketAddress].accountMembership[user]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function registerInSFS() external returns (uint256) {\n    require(hasAdminRights(), \"!admin\");\n    SFSRegister sfsContract = SFSRegister(0x8680CEaBcb9b56913c519c069Add6Bc3494B7020);\n\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      allMarkets[i].registerInSFS();\n    }\n\n    return sfsContract.register(0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2);\n  }\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerV4Storage } from \"../compound/ComptrollerStorage.sol\";\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\nimport { IHistoricalRates } from \"adrastia-periphery/rates/IHistoricalRates.sol\";\n\ninterface ComptrollerInterface {\n  function isDeprecated(ICErc20 cToken) external view returns (bool);\n\n  function _becomeImplementation() external;\n\n  function _deployMarket(\n    uint8 delegateType,\n    bytes memory constructorData,\n    bytes calldata becomeImplData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256);\n\n  function getAssetsIn(address account) external view returns (ICErc20[] memory);\n\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool);\n\n  function _setPriceOracle(BasePriceOracle newOracle) external returns (uint256);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n  function _setCollateralFactor(ICErc20 market, uint256 newCollateralFactorMantissa) external returns (uint256);\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\n\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\n\n  function _addRewardsDistributor(address distributor) external returns (uint256);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  function getMaxRedeemOrBorrow(address account, ICErc20 cToken, bool isBorrow) external view returns (uint256);\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n  function exitMarket(address cToken) external returns (uint256);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\n\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\n\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\n\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\n\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view returns (uint256);\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\n\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function getAccountLiquidity(\n    address account\n  ) external view returns (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall);\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 repayAmount\n  ) external view returns (uint256, uint256);\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  function _beforeNonReentrant() external;\n\n  function _afterNonReentrant() external;\n\n  /*** New supply and borrow cap view functions ***/\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(address cToken) external view returns (uint256 supplyCap);\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(address cToken) external view returns (uint256 borrowCap);\n}\n\ninterface ComptrollerStorageInterface {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdmin() external view returns (address);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function pendingAdmin() external view returns (address);\n\n  function oracle() external view returns (BasePriceOracle);\n\n  function pauseGuardian() external view returns (address);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function isUserOfPool(address user) external view returns (bool);\n\n  function whitelist(address account) external view returns (bool);\n\n  function enforceWhitelist() external view returns (bool);\n\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\n\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\n\n  function suppliers(address account) external view returns (bool);\n\n  function cTokensByUnderlying(address) external view returns (address);\n\n  /**\n   * Gets the supply cap of a cToken in the units of the underlying asset.\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the supply cap. Instead, use\n   * `effectiveSupplyCaps` to get the correct supply cap.\n   * @param cToken The address of the cToken.\n   * @return The supply cap in the units of the underlying asset.\n   */\n  function supplyCaps(address cToken) external view returns (uint256);\n\n  /**\n   * Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the borrow cap. Instead, use\n   * `effectiveBorrowCaps` to get the correct borrow cap.\n   * @param cToken The address of the cToken.\n   * @return The borrow cap in the units of the underlying asset.\n   */\n  function borrowCaps(address cToken) external view returns (uint256);\n\n  function markets(address cToken) external view returns (bool, uint256);\n\n  function accountAssets(address, uint256) external view returns (address);\n\n  function borrowGuardianPaused(address cToken) external view returns (bool);\n\n  function mintGuardianPaused(address cToken) external view returns (bool);\n\n  function rewardsDistributors(uint256) external view returns (address);\n}\n\ninterface SFSRegister {\n  function register(address _recipient) external returns (uint256 tokenId);\n}\n\ninterface ComptrollerExtensionInterface {\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\n\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\n\n  function getAllMarkets() external view returns (ICErc20[] memory);\n\n  function getAllBorrowers() external view returns (address[] memory);\n\n  function getAllBorrowersCount() external view returns (uint256);\n\n  function getPaginatedBorrowers(\n    uint256 page,\n    uint256 pageSize\n  ) external view returns (uint256 _totalPages, address[] memory _pageOfBorrowers);\n\n  function getRewardsDistributors() external view returns (address[] memory);\n\n  function getAccruingFlywheels() external view returns (address[] memory);\n\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) external;\n\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) external;\n\n  function _setBorrowCapForCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) external;\n\n  function isBorrowCapForCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) external view returns (bool);\n\n  function _blacklistBorrowingAgainstCollateral(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    bool blacklisted\n  ) external;\n\n  function _blacklistBorrowingAgainstCollateralWhitelist(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account,\n    bool whitelisted\n  ) external;\n\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\n    address cTokenBorrow,\n    address cTokenCollateral,\n    address account\n  ) external view returns (bool);\n\n  function isSupplyCapWhitelisted(address cToken, address account) external view returns (bool);\n\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) external;\n\n  function isBorrowCapWhitelisted(address cToken, address account) external view returns (bool);\n\n  function _removeFlywheel(address flywheelAddress) external returns (bool);\n\n  function getWhitelist() external view returns (address[] memory);\n\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool);\n\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external;\n\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external;\n\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\n\n  function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\n\n  function _setMintPaused(ICErc20 cToken, bool state) external returns (bool);\n\n  function _setBorrowPaused(ICErc20 cToken, bool state) external returns (bool);\n\n  function _setTransferPaused(bool state) external returns (bool);\n\n  function _setSeizePaused(bool state) external returns (bool);\n\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256);\n\n  function getAssetAsCollateralValueCap(\n    ICErc20 collateral,\n    ICErc20 cTokenModify,\n    bool redeeming,\n    address account\n  ) external view returns (uint256);\n\n  function registerInSFS() external returns (uint256);\n}\n\ninterface ComptrollerPrudentiaCapsExtInterface {\n  /**\n   * @notice Retrieves Adrastia Prudentia borrow cap config from storage.\n   * @return The config.\n   */\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\n\n  /**\n   * @notice Retrieves Adrastia Prudentia supply cap config from storage.\n   * @return The config.\n   */\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\n\n  /**\n   * @notice Sets the Adrastia Prudentia supply cap config.\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native supply caps.\n   * @param newConfig The new config.\n   */\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\n\n  /**\n   * @notice Sets the Adrastia Prudentia supply cap config.\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native borrow caps.\n   * @param newConfig The new config.\n   */\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\n}\n\ninterface UnitrollerInterface {\n  function comptrollerImplementation() external view returns (address);\n\n  function _upgrade() external;\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _toggleAdminRights(bool hasRights) external returns (uint256);\n}\n\ninterface IComptrollerExtension is ComptrollerExtensionInterface, ComptrollerStorageInterface {}\n\n//interface IComptrollerBase is ComptrollerInterface, ComptrollerStorageInterface {}\n\ninterface IonicComptroller is\n  ComptrollerInterface,\n  ComptrollerExtensionInterface,\n  UnitrollerInterface,\n  ComptrollerStorageInterface\n{\n\n}\n\nabstract contract ComptrollerBase is ComptrollerV4Storage {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /**\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveSupplyCaps(address cToken) public view virtual returns (uint256 supplyCap) {\n    PrudentiaLib.PrudentiaConfig memory capConfig = supplyCapConfig;\n\n    // Check if we're using Adrastia Prudentia for the supply cap\n    if (capConfig.controller != address(0)) {\n      // We have a controller, so we're using Adrastia Prudentia\n\n      address underlyingToken = ICErc20(cToken).underlying();\n\n      // Get the supply cap from Adrastia Prudentia\n      supplyCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\n\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\n      // must scale the supply cap to get the correct amount\n\n      int256 scaleByDecimals = 18;\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\n      if (success && data.length == 32) {\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\n      }\n\n      scaleByDecimals += capConfig.decimalShift;\n\n      if (scaleByDecimals >= 0) {\n        // We're scaling up, so we need to multiply\n        supplyCap *= 10 ** uint256(scaleByDecimals);\n      } else {\n        // We're scaling down, so we need to divide\n        supplyCap /= 10 ** uint256(-scaleByDecimals);\n      }\n    } else {\n      // We don't have a controller, so we're using the local supply cap\n\n      // Get the supply cap from the local supply cap\n      supplyCap = supplyCaps[cToken];\n    }\n  }\n\n  /**\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\n   * @param cToken The address of the cToken.\n   */\n  function effectiveBorrowCaps(address cToken) public view virtual returns (uint256 borrowCap) {\n    PrudentiaLib.PrudentiaConfig memory capConfig = borrowCapConfig;\n\n    // Check if we're using Adrastia Prudentia for the borrow cap\n    if (capConfig.controller != address(0)) {\n      // We have a controller, so we're using Adrastia Prudentia\n\n      address underlyingToken = ICErc20(cToken).underlying();\n\n      // Get the borrow cap from Adrastia Prudentia\n      borrowCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\n\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\n      // must scale the supply cap to get the correct amount\n\n      int256 scaleByDecimals = 18;\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\n      if (success && data.length == 32) {\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\n      }\n\n      scaleByDecimals += capConfig.decimalShift;\n\n      if (scaleByDecimals >= 0) {\n        // We're scaling up, so we need to multiply\n        borrowCap *= 10 ** uint256(scaleByDecimals);\n      } else {\n        // We're scaling down, so we need to divide\n        borrowCap /= 10 ** uint256(-scaleByDecimals);\n      }\n    } else {\n      // We don't have a controller, so we're using the local borrow cap\n      borrowCap = borrowCaps[cToken];\n    }\n  }\n}\n"
    },
    "contracts/compound/ComptrollerPrudentiaCapsExt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { ComptrollerPrudentiaCapsExtInterface, ComptrollerBase } from \"./ComptrollerInterface.sol\";\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\n\n/**\n * @title ComptrollerPrudentiaCapsExt\n * @author Tyler Loewen (TRILEZ SOFTWARE INC. dba. Adrastia)\n * @notice A diamond extension that allows the Comptroller to use Adrastia Prudentia to control supply and borrow caps.\n */\ncontract ComptrollerPrudentiaCapsExt is DiamondExtension, ComptrollerBase, ComptrollerPrudentiaCapsExtInterface {\n  /**\n   * @notice Emitted when the Adrastia Prudentia supply cap config is changed.\n   * @param oldConfig The old config.\n   * @param newConfig The new config.\n   */\n  event NewSupplyCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\n\n  /**\n   * @notice Emitted when the Adrastia Prudentia borrow cap config is changed.\n   * @param oldConfig The old config.\n   * @param newConfig The new config.\n   */\n  event NewBorrowCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\n\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\n\n    PrudentiaLib.PrudentiaConfig memory oldConfig = supplyCapConfig;\n    supplyCapConfig = newConfig;\n\n    emit NewSupplyCapConfig(oldConfig, newConfig);\n  }\n\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\n\n    PrudentiaLib.PrudentiaConfig memory oldConfig = borrowCapConfig;\n    borrowCapConfig = newConfig;\n\n    emit NewBorrowCapConfig(oldConfig, newConfig);\n  }\n\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory) {\n    return borrowCapConfig;\n  }\n\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory) {\n    return supplyCapConfig;\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 4;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this._setSupplyCapConfig.selector;\n    functionSelectors[--fnsCount] = this._setBorrowCapConfig.selector;\n    functionSelectors[--fnsCount] = this.getBorrowCapConfig.selector;\n    functionSelectors[--fnsCount] = this.getSupplyCapConfig.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n}\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFeeDistributor.sol\";\nimport \"../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract UnitrollerAdminStorage {\n  /*\n   * Administrator for Ionic\n   */\n  address payable public ionicAdmin;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Whether or not the Ionic admin has admin rights\n   */\n  bool public ionicAdminHasRights = true;\n\n  /**\n   * @notice Whether or not the admin has admin rights\n   */\n  bool public adminHasRights = true;\n\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(ionicAdmin) && ionicAdminHasRights);\n  }\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  BasePriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /*\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 internal maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => ICErc20[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    // Multiplier representing the most one can borrow against their collateral in this market.\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\n    // Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /// @notice A list of all markets\n  ICErc20[] public allMarkets;\n\n  /**\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\n   */\n  mapping(address => bool) internal borrowers;\n\n  /// @notice A list of all borrowers who have entered markets\n  address[] public allBorrowers;\n\n  // Indexes of borrower account addresses in the `allBorrowers` array\n  mapping(address => uint256) internal borrowerIndexes;\n\n  /**\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n   */\n  mapping(address => bool) public suppliers;\n\n  /// @notice All cTokens addresses mapped by their underlying token addresses\n  mapping(address => ICErc20) public cTokensByUnderlying;\n\n  /// @notice Whether or not the supplier whitelist is enforced\n  bool public enforceWhitelist;\n\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n  mapping(address => bool) public whitelist;\n\n  /// @notice An array of all whitelisted accounts\n  address[] public whitelistArray;\n\n  // Indexes of account addresses in the `whitelistArray` array\n  mapping(address => uint256) internal whitelistIndexes;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  /// @dev If Adrastia Prudentia is enabled, the values the borrow cap guardian sets are ignored.\n  address public borrowCapGuardian;\n\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveBorrowCaps` instead.\n  mapping(address => uint256) public borrowCaps;\n\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveSupplyCaps` instead.\n  mapping(address => uint256) public supplyCaps;\n\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\n  address[] public rewardsDistributors;\n\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n  bool internal _notEntered;\n\n  /// @dev Whether or not _notEntered has been initialized\n  bool internal _notEnteredInitialized;\n\n  /// @notice RewardsDistributor to list for claiming, but not to notify of flywheel changes.\n  address[] public nonAccruingRewardsDistributors;\n\n  /// @dev cap for each user's borrows against specific assets - denominated in the borrowed asset\n  mapping(address => mapping(address => uint256)) public borrowCapForCollateral;\n\n  /// @dev blacklist to disallow the borrowing of an asset against specific collateral\n  mapping(address => mapping(address => bool)) public borrowingAgainstCollateralBlacklist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrowing against specific collateral cap\n  mapping(address => mapping(address => EnumerableSet.AddressSet)) internal borrowCapForCollateralWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\n  mapping(address => mapping(address => EnumerableSet.AddressSet))\n    internal borrowingAgainstCollateralBlacklistWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the supply cap\n  mapping(address => EnumerableSet.AddressSet) internal supplyCapWhitelist;\n\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\n  mapping(address => EnumerableSet.AddressSet) internal borrowCapWhitelist;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n  /// @dev Adrastia Prudentia config for controlling borrow caps.\n  PrudentiaLib.PrudentiaConfig internal borrowCapConfig;\n\n  /// @dev Adrastia Prudentia config for controlling supply caps.\n  PrudentiaLib.PrudentiaConfig internal supplyCapConfig;\n}\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IonicComptroller } from \"./ComptrollerInterface.sol\";\nimport { CTokenSecondExtensionBase, ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { TokenErrorReporter } from \"./ErrorReporter.sol\";\nimport { Exponential } from \"./Exponential.sol\";\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { ComptrollerV3Storage } from \"./ComptrollerStorage.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\nimport { DiamondExtension, LibDiamond } from \"../ionic/DiamondExtension.sol\";\nimport { PoolLens } from \"../PoolLens.sol\";\nimport { IonicUniV3Liquidator } from \"../IonicUniV3Liquidator.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\nabstract contract CErc20 is CTokenSecondExtensionBase, TokenErrorReporter, Exponential, DiamondExtension {\n  modifier isAuthorized() {\n    require(\n      IFeeDistributor(ionicAdmin).canCall(address(comptroller), msg.sender, address(this), msg.sig),\n      \"not authorized\"\n    );\n    _;\n  }\n\n  modifier isMinHFThresholdExceeded(address borrower) {\n    PoolLens lens = PoolLens(ap.getAddress(\"PoolLens\"));\n    IonicUniV3Liquidator liquidator = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n\n    if (lens.getHealthFactor(borrower, comptroller) > liquidator.healthFactorThreshold()) {\n      require(msg.sender == address(liquidator), \"Health factor not low enough for non-permissioned liquidations\");\n      _;\n    } else {\n      _;\n    }\n  }\n\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 13;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.mint.selector;\n    functionSelectors[--fnsCount] = this.redeem.selector;\n    functionSelectors[--fnsCount] = this.redeemUnderlying.selector;\n    functionSelectors[--fnsCount] = this.borrow.selector;\n    functionSelectors[--fnsCount] = this.repayBorrow.selector;\n    functionSelectors[--fnsCount] = this.repayBorrowBehalf.selector;\n    functionSelectors[--fnsCount] = this.liquidateBorrow.selector;\n    functionSelectors[--fnsCount] = this.getCash.selector;\n    functionSelectors[--fnsCount] = this.seize.selector;\n    functionSelectors[--fnsCount] = this.selfTransferOut.selector;\n    functionSelectors[--fnsCount] = this.selfTransferIn.selector;\n    functionSelectors[--fnsCount] = this._withdrawIonicFees.selector;\n    functionSelectors[--fnsCount] = this._withdrawAdminFees.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override isAuthorized returns (uint256) {\n    (uint256 err, ) = mintInternal(mintAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override isAuthorized returns (uint256) {\n    return redeemInternal(redeemTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override isAuthorized returns (uint256) {\n    return redeemUnderlyingInternal(redeemAmount);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override isAuthorized returns (uint256) {\n    return borrowInternal(borrowAmount);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override isAuthorized returns (uint256) {\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override isAuthorized returns (uint256) {\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external override isAuthorized isMinHFThresholdExceeded(borrower) returns (uint256) {\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return err;\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    return getCashInternal();\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override nonReentrant(true) returns (uint256) {\n    return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n  }\n\n  function selfTransferOut(address to, uint256 amount) external override {\n    require(msg.sender == address(this), \"!self\");\n    doTransferOut(to, amount);\n  }\n\n  function selfTransferIn(address from, uint256 amount) external override returns (uint256) {\n    require(msg.sender == address(this), \"!self\");\n    return doTransferIn(from, amount);\n  }\n\n  /**\n   * @notice Accrues interest and reduces Ionic fees by transferring to Ionic\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawIonicFees(uint256 withdrawAmount) external override nonReentrant(false) returns (uint256) {\n    asCTokenExtension().accrueInterest();\n\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_IONIC_FEES_FRESH_CHECK);\n    }\n\n    if (getCashInternal() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    if (withdrawAmount > totalIonicFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_IONIC_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    uint256 totalIonicFeesNew = totalIonicFees - withdrawAmount;\n    totalIonicFees = totalIonicFeesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(address(ionicAdmin), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces admin fees by transferring to admin\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawAdminFees(uint256 withdrawAmount) external override nonReentrant(false) returns (uint256) {\n    asCTokenExtension().accrueInterest();\n\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashInternal() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    if (withdrawAmount > totalAdminFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n    totalAdminFees = totalAdminFees - withdrawAmount;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(ComptrollerV3Storage(address(comptroller)).admin(), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashInternal() internal view virtual returns (uint256) {\n    return EIP20Interface(underlying).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\n    uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20Interface.transferFrom.selector, from, address(this), amount),\n      \"TOKEN_TRANSFER_IN_FAILED\"\n    );\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n    require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address to, uint256 amount) internal virtual {\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20Interface.transfer.selector, to, amount),\n      \"TOKEN_TRANSFER_OUT_FAILED\"\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n    bytes memory returndata = _functionCall(underlying, data, errorMessage);\n    if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    asCTokenExtension().accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    return mintFresh(msg.sender, mintAmount);\n  }\n\n  struct MintLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 mintTokens;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n    uint256 actualMintAmount;\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintFresh(address minter, uint256 mintAmount) internal returns (uint256, uint256) {\n    /* Fail if mint not allowed */\n    uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != block.number) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n    }\n\n    MintLocalVars memory vars;\n\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\n\n    // Check max supply\n    // unused function\n    /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    // mintTokens is rounded down here - correct\n    (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n      vars.actualMintAmount,\n      Exp({ mantissa: vars.exchangeRateMantissa })\n    );\n    require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n    require(vars.mintTokens > 0, \"MINT_ZERO_CTOKENS_REJECTED\");\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     */\n    vars.totalSupplyNew = totalSupply + vars.mintTokens;\n\n    vars.accountTokensNew = accountTokens[minter] + vars.mintTokens;\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[minter] = vars.accountTokensNew;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n    emit Transfer(address(this), minter, vars.mintTokens);\n\n    /* We call the defense hook */\n    comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n    return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant(false) returns (uint256) {\n    asCTokenExtension().accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant(false) returns (uint256) {\n    asCTokenExtension().accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, 0, redeemAmount);\n  }\n\n  struct RedeemLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 redeemTokens;\n    uint256 redeemAmount;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n  }\n\n  function divRoundUp(uint256 x, uint256 y) internal pure returns (uint256 res) {\n    res = (x * 1e18) / y;\n    if (x % y != 0) res += 1;\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemFresh(\n    address redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal returns (uint256) {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"!redeem tokens or amount\");\n\n    RedeemLocalVars memory vars;\n\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\n\n    if (redeemTokensIn > 0) {\n      // don't allow dust tokens/assets to be left after\n      if (totalSupply - redeemTokensIn < 5000) redeemTokensIn = totalSupply;\n\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n        Exp({ mantissa: vars.exchangeRateMantissa }),\n        redeemTokensIn\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      if (redeemAmountIn == type(uint256).max) {\n        redeemAmountIn = comptroller.getMaxRedeemOrBorrow(redeemer, ICErc20(address(this)), false);\n      }\n\n      // don't allow dust tokens/assets to be left after\n      uint256 totalUnderlyingSupplied = asCTokenExtension().getTotalUnderlyingSupplied();\n      if (totalUnderlyingSupplied - redeemAmountIn < 1000) redeemAmountIn = totalUnderlyingSupplied;\n\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n\n      vars.redeemTokens = divRoundUp(redeemAmountIn, vars.exchangeRateMantissa);\n\n      // don't allow dust tokens/assets to be left after\n      if (totalSupply - vars.redeemTokens < 1000) vars.redeemTokens = totalSupply;\n\n      vars.redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashInternal() < vars.redeemAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant(false) returns (uint256) {\n    asCTokenExtension().accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    return borrowFresh(msg.sender, borrowAmount);\n  }\n\n  struct BorrowLocalVars {\n    MathError mathErr;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowFresh(address borrower, uint256 borrowAmount) internal returns (uint256) {\n    /* Fail if borrow not allowed */\n    uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    uint256 cashPrior = getCashInternal();\n\n    if (cashPrior < borrowAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n    }\n\n    BorrowLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowsNew = accountBorrows + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    vars.accountBorrows = asCTokenExtension().borrowBalanceCurrent(borrower);\n\n    (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(\n          Error.MATH_ERROR,\n          FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n          uint256(vars.mathErr)\n        );\n    }\n\n    // Check min borrow for this user for this asset\n    allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    asCTokenExtension().accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n    internal\n    nonReentrant(false)\n    returns (uint256, uint256)\n  {\n    asCTokenExtension().accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  struct RepayBorrowLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 repayAmount;\n    uint256 borrowerIndex;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n    uint256 actualRepayAmount;\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of undelrying tokens being returned\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) internal returns (uint256, uint256) {\n    /* Fail if repayBorrow not allowed */\n    uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != block.number) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n    }\n\n    RepayBorrowLocalVars memory vars;\n\n    /* We remember the original borrowerIndex for verification purposes */\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    vars.accountBorrows = asCTokenExtension().borrowBalanceCurrent(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    if (repayAmount == type(uint256).max) {\n      vars.repayAmount = vars.accountBorrows;\n    } else {\n      vars.repayAmount = repayAmount;\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n    return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) internal nonReentrant(false) returns (uint256, uint256) {\n    asCTokenExtension().accrueInterest();\n    ICErc20(cTokenCollateral).accrueInterest();\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) internal returns (uint256, uint256) {\n    /* Fail if liquidate not allowed */\n    uint256 allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      cTokenCollateral,\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != block.number) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (CErc20(cTokenCollateral).accrualBlockNumber() != block.number) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint256).max) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n    }\n\n    /* Fail if repayBorrow fails */\n    (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n    if (repayBorrowError != uint256(Error.NO_ERROR)) {\n      return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n      address(this),\n      cTokenCollateral,\n      actualRepayAmount\n    );\n    require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(ICErc20(cTokenCollateral).balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    uint256 seizeError;\n    if (cTokenCollateral == address(this)) {\n      seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      seizeError = CErc20(cTokenCollateral).seize(liquidator, borrower, seizeTokens);\n    }\n\n    /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n    require(seizeError == uint256(Error.NO_ERROR), \"!seize\");\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, cTokenCollateral, seizeTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.liquidateBorrowVerify(address(this), cTokenCollateral, liquidator, borrower, actualRepayAmount, seizeTokens);\n\n    return (uint256(Error.NO_ERROR), actualRepayAmount);\n  }\n\n  struct SeizeInternalLocalVars {\n    MathError mathErr;\n    uint256 borrowerTokensNew;\n    uint256 liquidatorTokensNew;\n    uint256 liquidatorSeizeTokens;\n    uint256 protocolSeizeTokens;\n    uint256 protocolSeizeAmount;\n    uint256 exchangeRateMantissa;\n    uint256 totalReservesNew;\n    uint256 totalIonicFeeNew;\n    uint256 totalSupplyNew;\n    uint256 feeSeizeTokens;\n    uint256 feeSeizeAmount;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) internal returns (uint256) {\n    /* Fail if seize not allowed */\n    uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n    }\n\n    SeizeInternalLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n    vars.feeSeizeTokens = mul_(seizeTokens, Exp({ mantissa: feeSeizeShareMantissa }));\n    vars.liquidatorSeizeTokens = seizeTokens - vars.protocolSeizeTokens - vars.feeSeizeTokens;\n\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\n\n    vars.protocolSeizeAmount = mul_ScalarTruncate(\n      Exp({ mantissa: vars.exchangeRateMantissa }),\n      vars.protocolSeizeTokens\n    );\n    vars.feeSeizeAmount = mul_ScalarTruncate(Exp({ mantissa: vars.exchangeRateMantissa }), vars.feeSeizeTokens);\n\n    vars.totalReservesNew = totalReserves + vars.protocolSeizeAmount;\n    vars.totalSupplyNew = totalSupply - vars.protocolSeizeTokens - vars.feeSeizeTokens;\n    vars.totalIonicFeeNew = totalIonicFees + vars.feeSeizeAmount;\n\n    (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    totalReserves = vars.totalReservesNew;\n    totalSupply = vars.totalSupplyNew;\n    totalIonicFees = vars.totalIonicFeeNew;\n\n    accountTokens[borrower] = vars.borrowerTokensNew;\n    accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n    emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function asCTokenExtension() internal view returns (ICErc20) {\n    return ICErc20(address(this));\n  }\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant(bool localOnly) {\n    _beforeNonReentrant(localOnly);\n    _;\n    _afterNonReentrant(localOnly);\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n   */\n  function _beforeNonReentrant(bool localOnly) private {\n    require(_notEntered, \"re-entered\");\n    if (!localOnly) comptroller._beforeNonReentrant();\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n   */\n  function _afterNonReentrant(bool localOnly) private {\n    _notEntered = true; // get a gas-refund post-Istanbul\n    if (!localOnly) comptroller._afterNonReentrant();\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n}\n"
    },
    "contracts/compound/CTokenFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { IFlashLoanReceiver } from \"../ionic/IFlashLoanReceiver.sol\";\nimport { CErc20FirstExtensionBase, CTokenFirstExtensionInterface, ICErc20 } from \"./CTokenInterfaces.sol\";\nimport { SFSRegister } from \"./ComptrollerInterface.sol\";\nimport { TokenErrorReporter } from \"./ErrorReporter.sol\";\nimport { Exponential } from \"./Exponential.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\nimport { Multicall } from \"../utils/Multicall.sol\";\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\n\ncontract CTokenFirstExtension is\n  CErc20FirstExtensionBase,\n  TokenErrorReporter,\n  Exponential,\n  DiamondExtension,\n  Multicall\n{\n  modifier isAuthorized() {\n    require(\n      IFeeDistributor(ionicAdmin).canCall(address(comptroller), msg.sender, address(this), msg.sig),\n      \"not authorized\"\n    );\n    _;\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 25;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.transfer.selector;\n    functionSelectors[--fnsCount] = this.transferFrom.selector;\n    functionSelectors[--fnsCount] = this.allowance.selector;\n    functionSelectors[--fnsCount] = this.approve.selector;\n    functionSelectors[--fnsCount] = this.balanceOf.selector;\n    functionSelectors[--fnsCount] = this._setAdminFee.selector;\n    functionSelectors[--fnsCount] = this._setInterestRateModel.selector;\n    functionSelectors[--fnsCount] = this._setNameAndSymbol.selector;\n    functionSelectors[--fnsCount] = this._setAddressesProvider.selector;\n    functionSelectors[--fnsCount] = this._setReserveFactor.selector;\n    functionSelectors[--fnsCount] = this.supplyRatePerBlock.selector;\n    functionSelectors[--fnsCount] = this.borrowRatePerBlock.selector;\n    functionSelectors[--fnsCount] = this.exchangeRateCurrent.selector;\n    functionSelectors[--fnsCount] = this.accrueInterest.selector;\n    functionSelectors[--fnsCount] = this.totalBorrowsCurrent.selector;\n    functionSelectors[--fnsCount] = this.balanceOfUnderlying.selector;\n    functionSelectors[--fnsCount] = this.multicall.selector;\n    functionSelectors[--fnsCount] = this.supplyRatePerBlockAfterDeposit.selector;\n    functionSelectors[--fnsCount] = this.supplyRatePerBlockAfterWithdraw.selector;\n    functionSelectors[--fnsCount] = this.borrowRatePerBlockAfterBorrow.selector;\n    functionSelectors[--fnsCount] = this.getTotalUnderlyingSupplied.selector;\n    functionSelectors[--fnsCount] = this.flash.selector;\n    functionSelectors[--fnsCount] = this.getAccountSnapshot.selector;\n    functionSelectors[--fnsCount] = this.borrowBalanceCurrent.selector;\n    functionSelectors[--fnsCount] = this.registerInSFS.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  function getTotalUnderlyingSupplied() public view override returns (uint256) {\n    // (totalCash + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees))\n    return asCToken().getCash() + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees);\n  }\n\n  /* ERC20 fns */\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint256 tokens\n  ) internal returns (uint256) {\n    /* Fail if transfer not allowed */\n    uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint256 startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint256).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    MathError mathErr;\n    uint256 allowanceNew;\n    uint256 srcTokensNew;\n    uint256 dstTokensNew;\n\n    (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n    }\n\n    (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint256).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) public override nonReentrant(false) isAuthorized returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) public override nonReentrant(false) isAuthorized returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) public override isAuthorized returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) public view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) public view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice updates the cToken ERC20 name and symbol\n   * @dev Admin function to update the cToken ERC20 name and symbol\n   * @param _name the new ERC20 token name to use\n   * @param _symbol the new ERC20 token symbol to use\n   */\n  function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n    // Check caller is admin\n    require(hasAdminRights(), \"!admin\");\n\n    // Set ERC20 name and symbol\n    name = _name;\n    symbol = _symbol;\n  }\n\n  function _setAddressesProvider(address _ap) external {\n    // Check caller is admin\n    require(hasAdminRights(), \"!admin\");\n\n    ap = AddressesProvider(_ap);\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) public override nonReentrant(false) returns (uint256) {\n    accrueInterest();\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n    }\n\n    // Check newReserveFactor  maxReserveFactor\n    if (newReserveFactorMantissa + adminFeeMantissa + ionicFeeMantissa > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n    }\n\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n   * @dev Admin function to accrue interest and set a new admin fee\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setAdminFee(uint256 newAdminFeeMantissa) public override nonReentrant(false) returns (uint256) {\n    accrueInterest();\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);\n    }\n\n    // Sanitize newAdminFeeMantissa\n    if (newAdminFeeMantissa == type(uint256).max) newAdminFeeMantissa = adminFeeMantissa;\n\n    // Get latest Ionic fee\n    uint256 newIonicFeeMantissa = IFeeDistributor(ionicAdmin).interestFeeRate();\n\n    // Check reserveFactorMantissa + newAdminFeeMantissa + newIonicFeeMantissa  reserveFactorPlusFeesMaxMantissa\n    if (reserveFactorMantissa + newAdminFeeMantissa + newIonicFeeMantissa > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n    }\n\n    // If setting admin fee\n    if (adminFeeMantissa != newAdminFeeMantissa) {\n      // Check caller is admin\n      if (!hasAdminRights()) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);\n      }\n\n      // Set admin fee\n      uint256 oldAdminFeeMantissa = adminFeeMantissa;\n      adminFeeMantissa = newAdminFeeMantissa;\n\n      // Emit event\n      emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n    }\n\n    // If setting Ionic fee\n    if (ionicFeeMantissa != newIonicFeeMantissa) {\n      // Set Ionic fee\n      uint256 oldIonicFeeMantissa = ionicFeeMantissa;\n      ionicFeeMantissa = newIonicFeeMantissa;\n\n      // Emit event\n      emit NewIonicFee(oldIonicFeeMantissa, newIonicFeeMantissa);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel)\n    public\n    override\n    nonReentrant(false)\n    returns (uint256)\n  {\n    accrueInterest();\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n    }\n\n    if (accrualBlockNumber != block.number) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n    }\n\n    require(newInterestRateModel.isInterestRateModel(), \"!notIrm\");\n\n    InterestRateModel oldInterestRateModel = interestRateModel;\n    interestRateModel = newInterestRateModel;\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() public view override returns (uint256) {\n    return\n      interestRateModel.getBorrowRate(\n        asCToken().getCash(),\n        totalBorrows,\n        totalReserves + totalAdminFees + totalIonicFees\n      );\n  }\n\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) public view returns (uint256) {\n    uint256 cash = asCToken().getCash();\n    require(cash >= borrowAmount, \"market cash not enough\");\n\n    return\n      interestRateModel.getBorrowRate(\n        cash - borrowAmount,\n        totalBorrows + borrowAmount,\n        totalReserves + totalAdminFees + totalIonicFees\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() public view override returns (uint256) {\n    return\n      interestRateModel.getSupplyRate(\n        asCToken().getCash(),\n        totalBorrows,\n        totalReserves + totalAdminFees + totalIonicFees,\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\n      );\n  }\n\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256) {\n    return\n      interestRateModel.getSupplyRate(\n        asCToken().getCash() + mintAmount,\n        totalBorrows,\n        totalReserves + totalAdminFees + totalIonicFees,\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\n      );\n  }\n\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256) {\n    uint256 cash = asCToken().getCash();\n    require(cash >= withdrawAmount, \"market cash not enough\");\n    return\n      interestRateModel.getSupplyRate(\n        cash - withdrawAmount,\n        totalBorrows,\n        totalReserves + totalAdminFees + totalIonicFees,\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\n      );\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public view override returns (uint256) {\n    if (block.number == accrualBlockNumber) {\n      return\n        _exchangeRateHypothetical(\n          totalSupply,\n          initialExchangeRateMantissa,\n          asCToken().getCash(),\n          totalBorrows,\n          totalReserves,\n          totalAdminFees,\n          totalIonicFees\n        );\n    } else {\n      uint256 cashPrior = asCToken().getCash();\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\n\n      return\n        _exchangeRateHypothetical(\n          accrual.totalSupply,\n          initialExchangeRateMantissa,\n          cashPrior,\n          accrual.totalBorrows,\n          accrual.totalReserves,\n          accrual.totalAdminFees,\n          accrual.totalIonicFees\n        );\n    }\n  }\n\n  function _exchangeRateHypothetical(\n    uint256 _totalSupply,\n    uint256 _initialExchangeRateMantissa,\n    uint256 _totalCash,\n    uint256 _totalBorrows,\n    uint256 _totalReserves,\n    uint256 _totalAdminFees,\n    uint256 _totalIonicFees\n  ) internal pure returns (uint256) {\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return _initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees)) / totalSupply\n       */\n      uint256 cashPlusBorrowsMinusReserves;\n      Exp memory exchangeRate;\n      MathError mathErr;\n\n      (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n        _totalCash,\n        _totalBorrows,\n        _totalReserves + _totalAdminFees + _totalIonicFees\n      );\n      require(mathErr == MathError.NO_ERROR, \"!addThenSubUInt overflow check failed\");\n\n      (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n      require(mathErr == MathError.NO_ERROR, \"!getExp overflow check failed\");\n\n      return exchangeRate.mantissa;\n    }\n  }\n\n  struct InterestAccrual {\n    uint256 accrualBlockNumber;\n    uint256 borrowIndex;\n    uint256 totalSupply;\n    uint256 totalBorrows;\n    uint256 totalReserves;\n    uint256 totalIonicFees;\n    uint256 totalAdminFees;\n    uint256 interestAccumulated;\n  }\n\n  function _accrueInterestHypothetical(uint256 blockNumber, uint256 cashPrior)\n    internal\n    view\n    returns (InterestAccrual memory accrual)\n  {\n    uint256 totalFees = totalAdminFees + totalIonicFees;\n    uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, totalReserves + totalFees);\n    if (borrowRateMantissa > borrowRateMaxMantissa) {\n      if (cashPrior > totalFees) revert(\"!borrowRate\");\n      else borrowRateMantissa = borrowRateMaxMantissa;\n    }\n    (MathError mathErr, uint256 blockDelta) = subUInt(blockNumber, accrualBlockNumber);\n    require(mathErr == MathError.NO_ERROR, \"!blockDelta\");\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  totalIonicFeesNew = interestAccumulated * ionicFee + totalIonicFees\n     *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    accrual.accrualBlockNumber = blockNumber;\n    accrual.totalSupply = totalSupply;\n    Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n    accrual.interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n    accrual.totalBorrows = accrual.interestAccumulated + totalBorrows;\n    accrual.totalReserves = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: reserveFactorMantissa }),\n      accrual.interestAccumulated,\n      totalReserves\n    );\n    accrual.totalIonicFees = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: ionicFeeMantissa }),\n      accrual.interestAccumulated,\n      totalIonicFees\n    );\n    accrual.totalAdminFees = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: adminFeeMantissa }),\n      accrual.interestAccumulated,\n      totalAdminFees\n    );\n    accrual.borrowIndex = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = block.number;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumber == currentBlockNumber) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    uint256 cashPrior = asCToken().getCash();\n    InterestAccrual memory accrual = _accrueInterestHypothetical(currentBlockNumber, cashPrior);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = accrual.borrowIndex;\n    totalBorrows = accrual.totalBorrows;\n    totalReserves = accrual.totalReserves;\n    totalIonicFees = accrual.totalIonicFees;\n    totalAdminFees = accrual.totalAdminFees;\n    emit AccrueInterest(cashPrior, accrual.interestAccumulated, borrowIndex, totalBorrows);\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external view override returns (uint256) {\n    if (accrualBlockNumber == block.number) {\n      return totalBorrows;\n    } else {\n      uint256 cashPrior = asCToken().getCash();\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\n      return accrual.totalBorrows;\n    }\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account)\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 cTokenBalance = accountTokens[account];\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n\n    borrowBalance = borrowBalanceCurrent(account);\n\n    exchangeRateMantissa = exchangeRateCurrent();\n\n    return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n  }\n\n  /**\n   * @notice calculate the borrowIndex and the account's borrow balance using the fresh borrowIndex\n   * @param account The address whose balance should be calculated after recalculating the borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) public view override returns (uint256) {\n    uint256 _borrowIndex;\n    if (accrualBlockNumber == block.number) {\n      _borrowIndex = borrowIndex;\n    } else {\n      uint256 cashPrior = asCToken().getCash();\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\n      _borrowIndex = accrual.borrowIndex;\n    }\n\n    /* Note: we do not assert that the market is up to date */\n    MathError mathErr;\n    uint256 principalTimesIndex;\n    uint256 result;\n\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, _borrowIndex);\n    require(mathErr == MathError.NO_ERROR, \"!mulUInt overflow check failed\");\n\n    (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n    require(mathErr == MathError.NO_ERROR, \"!divUInt overflow check failed\");\n\n    return result;\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external view override returns (uint256) {\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n    (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n    require(mErr == MathError.NO_ERROR, \"!balance\");\n    return balance;\n  }\n\n  function flash(uint256 amount, bytes calldata data) public override isAuthorized {\n    accrueInterest();\n\n    totalBorrows += amount;\n    asCToken().selfTransferOut(msg.sender, amount);\n\n    IFlashLoanReceiver(msg.sender).receiveFlashLoan(underlying, amount, data);\n\n    asCToken().selfTransferIn(msg.sender, amount);\n    totalBorrows -= amount;\n\n    emit Flash(msg.sender, amount);\n  }\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant(bool localOnly) {\n    _beforeNonReentrant(localOnly);\n    _;\n    _afterNonReentrant(localOnly);\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n   */\n  function _beforeNonReentrant(bool localOnly) private {\n    require(_notEntered, \"re-entered\");\n    if (!localOnly) comptroller._beforeNonReentrant();\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n   */\n  function _afterNonReentrant(bool localOnly) private {\n    _notEntered = true; // get a gas-refund post-Istanbul\n    if (!localOnly) comptroller._afterNonReentrant();\n  }\n\n  function asCToken() internal view returns (ICErc20) {\n    return ICErc20(address(this));\n  }\n\n  function multicall(bytes[] calldata data)\n    public\n    payable\n    override(CTokenFirstExtensionInterface, Multicall)\n    returns (bytes[] memory results)\n  {\n    return Multicall.multicall(data);\n  }\n\n  function registerInSFS() external returns (uint256) {\n    require(hasAdminRights() || msg.sender == address(comptroller), \"!admin\");\n    SFSRegister sfsContract = SFSRegister(0x8680CEaBcb9b56913c519c069Add6Bc3494B7020);\n    return sfsContract.register(0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2);\n  }\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IonicComptroller } from \"./ComptrollerInterface.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { ComptrollerV3Storage } from \"./ComptrollerStorage.sol\";\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\n\nabstract contract CTokenAdminStorage {\n  /*\n   * Administrator for Ionic\n   */\n  address payable public ionicAdmin;\n}\n\nabstract contract CErc20Storage is CTokenAdminStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  /*\n   * Maximum borrow rate that can ever be applied (.0005% / block)\n   */\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  /*\n   * Maximum fraction of interest that can be set aside for reserves + fees\n   */\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  IonicComptroller public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  /*\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n   */\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for admin fees\n   */\n  uint256 public adminFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for Ionic fees\n   */\n  uint256 public ionicFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total amount of admin fees of the underlying held in this market\n   */\n  uint256 public totalAdminFees;\n\n  /**\n   * @notice Total amount of Ionic fees of the underlying held in this market\n   */\n  uint256 public totalIonicFees;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  /*\n   * Official record of token balances for each account\n   */\n  mapping(address => uint256) internal accountTokens;\n\n  /*\n   * Approved token transfer amounts on behalf of others\n   */\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /*\n   * Mapping of account addresses to outstanding borrow balances\n   */\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /*\n   * Share of seized collateral that is added to reserves\n   */\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n  /*\n   * Share of seized collateral taken as fees\n   */\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\n\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n\n  /**\n   * @notice Addresses Provider\n   */\n  AddressesProvider public ap;\n}\n\nabstract contract CTokenBaseEvents {\n  /* ERC20 */\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the admin fee is changed\n   */\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n  /**\n   * @notice Event emitted when the Ionic fee is changed\n   */\n  event NewIonicFee(uint256 oldIonicFeeMantissa, uint256 newIonicFeeMantissa);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n}\n\nabstract contract CTokenFirstExtensionEvents is CTokenBaseEvents {\n  event Flash(address receiver, uint256 amount);\n}\n\nabstract contract CTokenSecondExtensionEvents is CTokenBaseEvents {\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n}\n\ninterface CTokenFirstExtensionInterface {\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\n\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function exchangeRateCurrent() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function totalBorrowsCurrent() external view returns (uint256);\n\n  function borrowBalanceCurrent(address account) external view returns (uint256);\n\n  function getTotalUnderlyingSupplied() external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external view returns (uint256);\n\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n\n  function flash(uint256 amount, bytes calldata data) external;\n\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256);\n\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256);\n\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) external view returns (uint256);\n\n  function registerInSFS() external returns (uint256);\n}\n\ninterface CTokenSecondExtensionInterface {\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _withdrawAdminFees(uint256 withdrawAmount) external returns (uint256);\n\n  function _withdrawIonicFees(uint256 withdrawAmount) external returns (uint256);\n\n  function selfTransferOut(address to, uint256 amount) external;\n\n  function selfTransferIn(address from, uint256 amount) external returns (uint256);\n}\n\ninterface CDelegatorInterface {\n  function implementation() external view returns (address);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external;\n\n  /**\n   * @dev upgrades the implementation if necessary\n   */\n  function _upgrade() external;\n}\n\ninterface CDelegateInterface {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes calldata data) external;\n\n  function delegateType() external pure returns (uint8);\n\n  function contractType() external pure returns (string memory);\n}\n\nabstract contract CErc20AdminBase is CErc20Storage {\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\n    return\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\n      (msg.sender == address(ionicAdmin) && comptrollerStorage.ionicAdminHasRights());\n  }\n}\n\nabstract contract CErc20FirstExtensionBase is\n  CErc20AdminBase,\n  CTokenFirstExtensionEvents,\n  CTokenFirstExtensionInterface\n{}\n\nabstract contract CTokenSecondExtensionBase is\n  CErc20AdminBase,\n  CTokenSecondExtensionEvents,\n  CTokenSecondExtensionInterface,\n  CDelegateInterface\n{}\n\nabstract contract CErc20DelegatorBase is CErc20AdminBase, CTokenSecondExtensionEvents, CDelegatorInterface {}\n\ninterface CErc20StorageInterface {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdmin() external view returns (address);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function comptroller() external view returns (IonicComptroller);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function adminFeeMantissa() external view returns (uint256);\n\n  function ionicFeeMantissa() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function feeSeizeShareMantissa() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalAdminFees() external view returns (uint256);\n\n  function totalIonicFees() external view returns (uint256);\n\n  function totalBorrows() external view returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function borrowIndex() external view returns (uint256);\n\n  function interestRateModel() external view returns (address);\n}\n\ninterface CErc20PluginStorageInterface is CErc20StorageInterface {\n  function plugin() external view returns (address);\n}\n\ninterface CErc20PluginRewardsInterface is CErc20PluginStorageInterface {\n  function approve(address, address) external;\n}\n\ninterface ICErc20 is\n  CErc20StorageInterface,\n  CTokenSecondExtensionInterface,\n  CTokenFirstExtensionInterface,\n  CDelegatorInterface,\n  CDelegateInterface\n{}\n\ninterface ICErc20Plugin is CErc20PluginStorageInterface, ICErc20 {\n  function _updatePlugin(address _plugin) external;\n}\n\ninterface ICErc20PluginRewards is CErc20PluginRewardsInterface, ICErc20 {}\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return uint256 The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool success);\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transfer(address dst, uint256 amount) external;\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY,\n    SUPPLIER_NOT_WHITELISTED,\n    BORROW_BELOW_MIN,\n    SUPPLY_ABOVE_MAX,\n    NONZERO_TOTAL_SUPPLY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n    SET_WHITELIST_STATUS_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\n    UNSUPPORT_MARKET_OWNER_CHECK,\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\n    UNSUPPORT_MARKET_IN_USE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return uint256(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    BAD_INPUT,\n    COMPTROLLER_REJECTION,\n    COMPTROLLER_CALCULATION_ERROR,\n    INTEREST_RATE_MODEL_ERROR,\n    INVALID_ACCOUNT_PAIR,\n    INVALID_CLOSE_AMOUNT_REQUESTED,\n    INVALID_COLLATERAL_FACTOR,\n    MATH_ERROR,\n    MARKET_NOT_FRESH,\n    MARKET_NOT_LISTED,\n    TOKEN_INSUFFICIENT_ALLOWANCE,\n    TOKEN_INSUFFICIENT_BALANCE,\n    TOKEN_INSUFFICIENT_CASH,\n    TOKEN_TRANSFER_IN_FAILED,\n    TOKEN_TRANSFER_OUT_FAILED,\n    UTILIZATION_ABOVE_MAX\n  }\n\n  /*\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\n   *       This is because FailureInfo grows significantly faster, and\n   *       the order of Error has some meaning, while the order of FailureInfo\n   *       is entirely arbitrary.\n   */\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_IONIC_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    BORROW_ACCRUE_INTEREST_FAILED,\n    BORROW_CASH_NOT_AVAILABLE,\n    BORROW_FRESHNESS_CHECK,\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    BORROW_MARKET_NOT_LISTED,\n    BORROW_COMPTROLLER_REJECTION,\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n    LIQUIDATE_COMPTROLLER_REJECTION,\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n    LIQUIDATE_FRESHNESS_CHECK,\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_SEIZE_TOO_MUCH,\n    MINT_ACCRUE_INTEREST_FAILED,\n    MINT_COMPTROLLER_REJECTION,\n    MINT_EXCHANGE_CALCULATION_FAILED,\n    MINT_EXCHANGE_RATE_READ_FAILED,\n    MINT_FRESHNESS_CHECK,\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    MINT_TRANSFER_IN_FAILED,\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\n    REDEEM_ACCRUE_INTEREST_FAILED,\n    REDEEM_COMPTROLLER_REJECTION,\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\n    REDEEM_FRESHNESS_CHECK,\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n    WITHDRAW_IONIC_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_IONIC_FEES_FRESH_CHECK,\n    WITHDRAW_IONIC_FEES_VALIDATION,\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n    WITHDRAW_ADMIN_FEES_VALIDATION,\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n    REDUCE_RESERVES_ADMIN_CHECK,\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n    REDUCE_RESERVES_FRESH_CHECK,\n    REDUCE_RESERVES_VALIDATION,\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_COMPTROLLER_REJECTION,\n    REPAY_BORROW_FRESHNESS_CHECK,\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COMPTROLLER_OWNER_CHECK,\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n    SET_ADMIN_FEE_ADMIN_CHECK,\n    SET_ADMIN_FEE_FRESH_CHECK,\n    SET_ADMIN_FEE_BOUNDS_CHECK,\n    SET_IONIC_FEE_ACCRUE_INTEREST_FAILED,\n    SET_IONIC_FEE_FRESH_CHECK,\n    SET_IONIC_FEE_BOUNDS_CHECK,\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\n    SET_RESERVE_FACTOR_FRESH_CHECK,\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\n    TRANSFER_COMPTROLLER_REJECTION,\n    TRANSFER_NOT_ALLOWED,\n    TRANSFER_NOT_ENOUGH,\n    TRANSFER_TOO_MUCH,\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n    ADD_RESERVES_FRESH_CHECK,\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\n  }\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  struct Exp {\n    uint256 mantissa;\n  }\n\n  struct Double {\n    uint256 mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n  }\n}\n"
    },
    "contracts/compound/IERC4626.sol": {
      "content": "pragma solidity >=0.8.0;\npragma experimental ABIEncoderV2;\n\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\n\ninterface IERC4626 is EIP20Interface {\n  /*----------------------------------------------------------------\n                                Events\n    ----------------------------------------------------------------*/\n\n  event Deposit(address indexed from, address indexed to, uint256 value);\n\n  event Withdraw(address indexed from, address indexed to, uint256 value);\n\n  /*----------------------------------------------------------------\n                            Mutable Functions\n    ----------------------------------------------------------------*/\n\n  /**\n      @notice Deposit a specific amount of underlying tokens.\n      @param underlyingAmount The amount of the underlying token to deposit.\n      @param to The address to receive shares corresponding to the deposit\n      @return shares The shares in the vault credited to `to`\n    */\n  function deposit(uint256 underlyingAmount, address to) external returns (uint256 shares);\n\n  /**\n      @notice Mint an exact amount of shares for a variable amount of underlying tokens.\n      @param shareAmount The amount of vault shares to mint.\n      @param to The address to receive shares corresponding to the mint.\n      @return underlyingAmount The amount of the underlying tokens deposited from the mint call.\n    */\n  function mint(uint256 shareAmount, address to) external returns (uint256 underlyingAmount);\n\n  /**\n      @notice Withdraw a specific amount of underlying tokens.\n      @param underlyingAmount The amount of the underlying token to withdraw.\n      @param to The address to receive underlying corresponding to the withdrawal.\n      @param from The address to burn shares from corresponding to the withdrawal.\n      @return shares The shares in the vault burned from sender\n    */\n  function withdraw(\n    uint256 underlyingAmount,\n    address to,\n    address from\n  ) external returns (uint256 shares);\n\n  /**\n      @notice Redeem a specific amount of shares for underlying tokens.\n      @param shareAmount The amount of shares to redeem.\n      @param to The address to receive underlying corresponding to the redemption.\n      @param from The address to burn shares from corresponding to the redemption.\n      @return value The underlying amount transferred to `to`.\n    */\n  function redeem(\n    uint256 shareAmount,\n    address to,\n    address from\n  ) external returns (uint256 value);\n\n  /*----------------------------------------------------------------\n                            View Functions\n    ----------------------------------------------------------------*/\n  /** \n      @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n      @return the address of the asset\n    */\n  function asset() external view returns (address);\n\n  /** \n      @notice Returns a user's Vault balance in underlying tokens.\n      @param user The user to get the underlying balance of.\n      @return balance The user's Vault balance in underlying tokens.\n    */\n  function balanceOfUnderlying(address user) external view returns (uint256 balance);\n\n  /** \n      @notice Calculates the total amount of underlying tokens the Vault manages.\n      @return The total amount of underlying tokens the Vault manages.\n    */\n  function totalAssets() external view returns (uint256);\n\n  /** \n      @notice Returns the value in underlying terms of one vault token. \n     */\n  function exchangeRate() external view returns (uint256);\n\n  /**\n      @notice Returns the amount of vault tokens that would be obtained if depositing a given amount of underlying tokens in a `deposit` call.\n      @param underlyingAmount the input amount of underlying tokens\n      @return shareAmount the corresponding amount of shares out from a deposit call with `underlyingAmount` in\n     */\n  function previewDeposit(uint256 underlyingAmount) external view returns (uint256 shareAmount);\n\n  /**\n      @notice Returns the amount of underlying tokens that would be deposited if minting a given amount of shares in a `mint` call.\n      @param shareAmount the amount of shares from a mint call.\n      @return underlyingAmount the amount of underlying tokens corresponding to the mint call\n     */\n  function previewMint(uint256 shareAmount) external view returns (uint256 underlyingAmount);\n\n  /**\n      @notice Returns the amount of vault tokens that would be burned if withdrawing a given amount of underlying tokens in a `withdraw` call.\n      @param underlyingAmount the input amount of underlying tokens\n      @return shareAmount the corresponding amount of shares out from a withdraw call with `underlyingAmount` in\n     */\n  function previewWithdraw(uint256 underlyingAmount) external view returns (uint256 shareAmount);\n\n  /**\n      @notice Returns the amount of underlying tokens that would be obtained if redeeming a given amount of shares in a `redeem` call.\n      @param shareAmount the amount of shares from a redeem call.\n      @return underlyingAmount the amount of underlying tokens corresponding to the redeem call\n     */\n  function previewRedeem(uint256 shareAmount) external view returns (uint256 underlyingAmount);\n}\n"
    },
    "contracts/compound/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../ionic/AuthoritiesRegistry.sol\";\n\ninterface IFeeDistributor {\n  function minBorrowEth() external view returns (uint256);\n\n  function maxUtilizationRate() external view returns (uint256);\n\n  function interestFeeRate() external view returns (uint256);\n\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n\n  function latestCErc20Delegate(uint8 delegateType)\n    external\n    view\n    returns (address cErc20Delegate, bytes memory becomeImplementationData);\n\n  function latestPluginImplementation(address oldImplementation) external view returns (address);\n\n  function getComptrollerExtensions(address comptroller) external view returns (address[] memory);\n\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (address[] memory);\n\n  function deployCErc20(\n    uint8 delegateType,\n    bytes calldata constructorData,\n    bytes calldata becomeImplData\n  ) external returns (address);\n\n  function canCall(\n    address pool,\n    address user,\n    address target,\n    bytes4 functionSig\n  ) external view returns (bool);\n\n  function authoritiesRegistry() external view returns (AuthoritiesRegistry);\n\n  fallback() external payable;\n\n  receive() external payable;\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view virtual returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/compound/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract\n * @author Compound\n */\ncontract JumpRateModel is InterestRateModel {\n  event NewInterestParams(\n    uint256 baseRatePerBlock,\n    uint256 multiplierPerBlock,\n    uint256 jumpMultiplierPerBlock,\n    uint256 kink\n  );\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public blocksPerYear;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint256 public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint256 public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param _blocksPerYear The approximate number of blocks per year\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  constructor(\n    uint256 _blocksPerYear,\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) {\n    blocksPerYear = _blocksPerYear;\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = multiplierPerYear / blocksPerYear;\n    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return (borrows * 1e18) / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return ((util * multiplierPerBlock) / 1e18) + baseRatePerBlock;\n    } else {\n      uint256 normalRate = ((kink * multiplierPerBlock) / 1e18) + baseRatePerBlock;\n      uint256 excessUtil = util - kink;\n      return ((excessUtil * jumpMultiplierPerBlock) / 1e18) + normalRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual override returns (uint256) {\n    uint256 oneMinusReserveFactor = 1e18 - reserveFactorMantissa;\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / 1e18;\n    return (utilizationRate(cash, borrows, reserves) * rateToPool) / 1e18;\n  }\n}\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view virtual returns (uint256);\n}\n"
    },
    "contracts/compound/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot underflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction underflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot underflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n   * Reverts on division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n   * Reverts with custom message on division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "contracts/compound/Timelock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant GRACE_PERIOD = 14 days;\n  uint256 public constant MINIMUM_DELAY = 2 days;\n  uint256 public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint256 public delay;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) {\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  receive() external payable {}\n\n  function setDelay(uint256 delay_) public {\n    require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Comptroller.sol\";\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated via the Diamond Extensions\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is ComptrollerV3Storage, ComptrollerErrorReporter, DiamondBase {\n  /**\n   * @notice Event emitted when the admin rights are changed\n   */\n  event AdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  constructor(address payable _ionicAdmin) {\n    admin = msg.sender;\n    ionicAdmin = _ionicAdmin;\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Toggles admin rights.\n   * @param hasRights Boolean indicating if the admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    adminHasRights = hasRights;\n    emit AdminRightsToggled(hasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    address oldPendingAdmin = pendingAdmin;\n    pendingAdmin = newPendingAdmin;\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin  address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    admin = pendingAdmin;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function comptrollerImplementation() public view returns (address) {\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\"_deployMarket(uint8,bytes,bytes,uint256)\"))));\n  }\n\n  /**\n   * @dev upgrades the implementation if necessary\n   */\n  function _upgrade() external {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self || !admin\");\n\n    address currentImplementation = comptrollerImplementation();\n    address latestComptrollerImplementation = IFeeDistributor(ionicAdmin).latestComptrollerImplementation(\n      currentImplementation\n    );\n\n    _updateExtensions(latestComptrollerImplementation);\n\n    if (currentImplementation != latestComptrollerImplementation) {\n      // reinitialize\n      _functionCall(address(this), abi.encodeWithSignature(\"_becomeImplementation()\"), \"!become impl\");\n    }\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function _updateExtensions(address currentComptroller) internal {\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getComptrollerExtensions(currentComptroller);\n    address[] memory currentExtensions = LibDiamond.listExtensions();\n\n    // removed the current (old) extensions\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\n    }\n    // add the new extensions\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\n    }\n  }\n\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\n    require(hasAdminRights(), \"!unauthorized\");\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\n  }\n}\n"
    },
    "contracts/external/aave/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\nimport \"./ILendingPool.sol\";\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken {\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  function getPreviousIndex(address user) external view returns (uint256);\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  function POOL() external view returns (ILendingPool);\n}\n"
    },
    "contracts/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n}\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/external/algebra/IAlgebraFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/**\n * @title The interface for the Algebra Factory\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\n */\ninterface IAlgebraFactory {\n  /**\n   *  @notice Emitted when the owner of the factory is changed\n   *  @param newOwner The owner after the owner was changed\n   */\n  event Owner(address indexed newOwner);\n\n  /**\n   *  @notice Emitted when the vault address is changed\n   *  @param newVaultAddress The vault address after the address was changed\n   */\n  event VaultAddress(address indexed newVaultAddress);\n\n  /**\n   *  @notice Emitted when a pool is created\n   *  @param token0 The first token of the pool by address sort order\n   *  @param token1 The second token of the pool by address sort order\n   *  @param pool The address of the created pool\n   */\n  event Pool(address indexed token0, address indexed token1, address pool);\n\n  /**\n   *  @notice Emitted when the farming address is changed\n   *  @param newFarmingAddress The farming address after the address was changed\n   */\n  event FarmingAddress(address indexed newFarmingAddress);\n\n  event FeeConfiguration(\n    uint16 alpha1,\n    uint16 alpha2,\n    uint32 beta1,\n    uint32 beta2,\n    uint16 gamma1,\n    uint16 gamma2,\n    uint32 volumeBeta,\n    uint16 volumeGamma,\n    uint16 baseFee\n  );\n\n  /**\n   *  @notice Returns the current owner of the factory\n   *  @dev Can be changed by the current owner via setOwner\n   *  @return The address of the factory owner\n   */\n  function owner() external view returns (address);\n\n  /**\n   *  @notice Returns the current poolDeployerAddress\n   *  @return The address of the poolDeployer\n   */\n  function poolDeployer() external view returns (address);\n\n  /**\n   * @dev Is retrieved from the pools to restrict calling\n   * certain functions not by a tokenomics contract\n   * @return The tokenomics contract address\n   */\n  function farmingAddress() external view returns (address);\n\n  function vaultAddress() external view returns (address);\n\n  /**\n   *  @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n   *  @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n   *  @param tokenA The contract address of either token0 or token1\n   *  @param tokenB The contract address of the other token\n   *  @return pool The pool address\n   */\n  function poolByPair(address tokenA, address tokenB) external view returns (address pool);\n\n  /**\n   *  @notice Creates a pool for the given two tokens and fee\n   *  @param tokenA One of the two tokens in the desired pool\n   *  @param tokenB The other of the two tokens in the desired pool\n   *  @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n   *  from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n   *  are invalid.\n   *  @return pool The address of the newly created pool\n   */\n  function createPool(address tokenA, address tokenB) external returns (address pool);\n\n  /**\n   *  @notice Updates the owner of the factory\n   *  @dev Must be called by the current owner\n   *  @param _owner The new owner of the factory\n   */\n  function setOwner(address _owner) external;\n\n  /**\n   * @dev updates tokenomics address on the factory\n   * @param _farmingAddress The new tokenomics contract address\n   */\n  function setFarmingAddress(address _farmingAddress) external;\n\n  /**\n   * @dev updates vault address on the factory\n   * @param _vaultAddress The new vault contract address\n   */\n  function setVaultAddress(address _vaultAddress) external;\n\n  /**\n   * @notice Changes initial fee configuration for new pools\n   * @dev changes coefficients for sigmoids:  / (1 + e^( (-x) / ))\n   * alpha1 + alpha2 + baseFee (max possible fee) must be <= type(uint16).max\n   * gammas must be > 0\n   * @param alpha1 max value of the first sigmoid\n   * @param alpha2 max value of the second sigmoid\n   * @param beta1 shift along the x-axis for the first sigmoid\n   * @param beta2 shift along the x-axis for the second sigmoid\n   * @param gamma1 horizontal stretch factor for the first sigmoid\n   * @param gamma2 horizontal stretch factor for the second sigmoid\n   * @param volumeBeta shift along the x-axis for the outer volume-sigmoid\n   * @param volumeGamma horizontal stretch factor the outer volume-sigmoid\n   * @param baseFee minimum possible fee\n   */\n  function setBaseFeeConfiguration(\n    uint16 alpha1,\n    uint16 alpha2,\n    uint32 beta1,\n    uint32 beta2,\n    uint16 gamma1,\n    uint16 gamma2,\n    uint32 volumeBeta,\n    uint16 volumeGamma,\n    uint16 baseFee\n  ) external;\n}\n"
    },
    "contracts/external/algebra/IAlgebraPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./IAlgebraPoolState.sol\";\nimport \"./IAlgebraPoolActions.sol\";\n\n/// @title Pool state that can change\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPool is IAlgebraPoolState, IAlgebraPoolActions {\n  /**\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n   * you must call it with secondsAgos = [3600, 0].\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\n   * from the current block timestamp\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\n   */\n  function getTimepoints(uint32[] calldata secondsAgos)\n    external\n    view\n    returns (\n      int56[] memory tickCumulatives,\n      uint160[] memory secondsPerLiquidityCumulatives,\n      uint112[] memory volatilityCumulatives,\n      uint256[] memory volumePerAvgLiquiditys\n    );\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function tickSpacing() external view returns (int24);\n}\n"
    },
    "contracts/external/algebra/IAlgebraPoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolActions {\n  /**\n   * @notice Sets the initial price for the pool\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n   * @param price the initial sqrt price of the pool as a Q64.96\n   */\n  function initialize(uint160 price) external;\n\n  /**\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\n   * @param sender The address which will receive potential surplus of paid tokens\n   * @param recipient The address for which the liquidity will be created\n   * @param bottomTick The lower tick of the position in which to add liquidity\n   * @param topTick The upper tick of the position in which to add liquidity\n   * @param amount The desired amount of liquidity to mint\n   * @param data Any data that should be passed through to the callback\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n   * @return liquidityActual The actual minted amount of liquidity\n   */\n  function mint(\n    address sender,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount,\n    bytes calldata data\n  )\n    external\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint128 liquidityActual\n    );\n\n  /**\n   * @notice Collects tokens owed to a position\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n   * @param recipient The address which should receive the fees collected\n   * @param bottomTick The lower tick of the position for which to collect fees\n   * @param topTick The upper tick of the position for which to collect fees\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\n   * @return amount0 The amount of fees collected in token0\n   * @return amount1 The amount of fees collected in token1\n   */\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /**\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n   * @dev Fees must be collected separately via a call to #collect\n   * @param bottomTick The lower tick of the position for which to burn liquidity\n   * @param topTick The upper tick of the position for which to burn liquidity\n   * @param amount How much liquidity to burn\n   * @return amount0 The amount of token0 sent to the recipient\n   * @return amount1 The amount of token1 sent to the recipient\n   */\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /**\n   * @notice Swap token0 for token1, or token1 for token0\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\n   * @param recipient The address to receive the output of the swap\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\n   * SwapRouter#SwapCallbackData\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n   */\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountSpecified,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /**\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\n   * @param sender The address called this function (Comes from the Router)\n   * @param recipient The address to receive the output of the swap\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\n   * SwapRouter#SwapCallbackData\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n   */\n  function swapSupportingFeeOnInputTokens(\n    address sender,\n    address recipient,\n    bool zeroToOne,\n    int256 amountSpecified,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /**\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\n   * the donation amount(s) from the callback\n   * @param recipient The address which will receive the token0 and token1 amounts\n   * @param amount0 The amount of token0 to send\n   * @param amount1 The amount of token1 to send\n   * @param data Any data to be passed through to the callback\n   */\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/algebra/IAlgebraPoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolState {\n  /**\n   * @notice The globalState structure in the pool stores many values but requires only one slot\n   * and is exposed as a single method to save gas when accessed externally.\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\n   * boundary;\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\n   * Returns timepointIndex The index of the last written timepoint;\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\n   */\n  function globalState()\n    external\n    view\n    returns (\n      uint160 price,\n      int24 tick,\n      uint16 fee,\n      uint16 timepointIndex,\n      uint8 communityFeeToken0,\n      uint8 communityFeeToken1,\n      bool unlocked\n    );\n\n  /**\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n   * @dev This value can overflow the uint256\n   */\n  function totalFeeGrowth0Token() external view returns (uint256);\n\n  /**\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n   * @dev This value can overflow the uint256\n   */\n  function totalFeeGrowth1Token() external view returns (uint256);\n\n  /**\n   * @notice The currently in range liquidity available to the pool\n   * @dev This value has no relationship to the total liquidity across all ticks.\n   * Returned value cannot exceed type(uint128).max\n   */\n  function liquidity() external view returns (uint128);\n\n  /**\n   * @notice Look up information about a specific tick in the pool\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\n   * @param tick The tick to look up\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\n   * tick upper;\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\n   * a specific position.\n   */\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityTotal,\n      int128 liquidityDelta,\n      uint256 outerFeeGrowth0Token,\n      uint256 outerFeeGrowth1Token,\n      int56 outerTickCumulative,\n      uint160 outerSecondsPerLiquidity,\n      uint32 outerSecondsSpent,\n      bool initialized\n    );\n\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\n  function tickTable(int16 wordPosition) external view returns (uint256);\n\n  /**\n   * @notice Returns the information about a position by the position's key\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\n   * @return liquidityAmount The amount of liquidity in the position;\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\n   */\n  function positions(bytes32 key)\n    external\n    view\n    returns (\n      uint128 liquidityAmount,\n      uint32 lastLiquidityAddTimestamp,\n      uint256 innerFeeGrowth0Token,\n      uint256 innerFeeGrowth1Token,\n      uint128 fees0,\n      uint128 fees1\n    );\n\n  /**\n   * @notice Returns data about a specific timepoint index\n   * @param index The element of the timepoints array to fetch\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\n   * ago, rather than at a specific index in the array.\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\n   * Returns blockTimestamp The timestamp of the timepoint;\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\n   * Returns averageTick Time-weighted average tick;\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\n   */\n  function timepoints(uint256 index)\n    external\n    view\n    returns (\n      bool initialized,\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulative,\n      uint88 volatilityCumulative,\n      int24 averageTick,\n      uint144 volumePerLiquidityCumulative\n    );\n\n  /**\n   * @notice Returns the information about active incentive\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\n   */\n  function activeIncentive() external view returns (address virtualPool);\n\n  /**\n   * @notice Returns the lock time for added liquidity\n   */\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\n}\n"
    },
    "contracts/external/algebra/IAlgebraSwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IAlgebraPoolActions#swap\n/// @notice Any contract that calls IAlgebraPoolActions#swap must implement this interface\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraSwapCallback {\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\n  function algebraSwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/algebra/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IAlgebraSwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Algebra\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-periphery\ninterface IAlgebraSwapRouter is IAlgebraSwapCallback {\n  struct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 limitSqrtPrice;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n  struct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n  struct ExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n    uint160 limitSqrtPrice;\n  }\n\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n  /// @return amountIn The amount of the input token\n  function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n  struct ExactOutputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n  }\n\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n  /// @return amountIn The amount of the input token\n  function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n  /// @dev Unlike standard swaps, handles transferring from user before the actual swap.\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInputSingleSupportingFeeOnTransferTokens(ExactInputSingleParams calldata params)\n    external\n    returns (uint256 amountOut);\n}\n"
    },
    "contracts/external/alpha/Bank.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface Bank is IERC20Upgradeable {\n  /// @dev Return the total ETH entitled to the token holders. Be careful of unaccrued interests.\n  function totalETH() external view returns (uint256);\n\n  /// @dev Add more ETH to the bank. Hope to get some good returns.\n  function deposit() external payable;\n\n  /// @dev Withdraw ETH from the bank by burning the share tokens.\n  function withdraw(uint256 share) external;\n}\n"
    },
    "contracts/external/alpha/ISafeBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBox is IERC20Upgradeable {\n  function cToken() external view returns (address);\n\n  function uToken() external view returns (address);\n\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/external/alpha/ISafeBoxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBoxETH is IERC20Upgradeable {\n  function cToken() external view returns (address);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/external/angle/IGenericLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\n/// @title IGenericLender\n/// @author Yearn with slight modifications from Angle Core Team\n/// @dev Interface for the `GenericLender` contract, the base interface for contracts interacting\n/// with lending and yield farming platforms\ninterface IGenericLender {\n  /// @notice Name of the lender on which funds are invested\n  function lenderName() external view returns (string memory);\n\n  /// @notice Returns an estimation of the current Annual Percentage Rate on the lender\n  function apr() external view returns (uint256);\n\n  /// @notice Returns an estimation of the current Annual Percentage Rate weighted by the assets under\n  /// management of the lender\n  function weightedApr() external view returns (uint256);\n\n  /// @notice Withdraws a given amount from lender\n  /// @param amount The amount the caller wants to withdraw\n  /// @return Amount actually withdrawn\n  function withdraw(uint256 amount) external returns (uint256);\n\n  /// @notice Withdraws as much as possible from the lending platform\n  /// @return Whether everything was withdrawn or not\n  function withdrawAll() external returns (bool);\n\n  /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n  /// of `amount`\n  /// @param amount Amount to add to the lending platform, and that we want to take into account\n  /// in the apr computation\n  function aprAfterDeposit(uint256 amount) external view returns (uint256);\n\n  function aprAfterWithdraw(uint256 amount) external view returns (uint256);\n\n  /// @notice Removes tokens from this Strategy that are not the type of tokens\n  /// managed by this Strategy. This may be used in case of accidentally\n  /// sending the wrong kind of token to this Strategy.\n  ///\n  /// @param _token The token to transfer out of this poolManager.\n  /// @param to Address to send the tokens to.\n  function sweep(address _token, address to) external;\n}\n"
    },
    "contracts/external/api3/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IProxy {\n  function read() external view returns (int224 value, uint32 timestamp);\n\n  function api3ServerV1() external view returns (address);\n}\n"
    },
    "contracts/external/balancer/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n  if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(\n  bool condition,\n  uint256 errorCode,\n  bytes3 prefix\n) pure {\n  if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n  _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n  uint256 prefixUint = uint256(uint24(prefix));\n  // We're going to dynamically create a revert string based on the error code, with the following format:\n  // 'BAL#{errorCode}'\n  // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n  //\n  // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n  // number (8 to 16 bits) than the individual string characters.\n  //\n  // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n  // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n  // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n  assembly {\n    // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n    // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n    // the '0' character.\n\n    let units := add(mod(errorCode, 10), 0x30)\n\n    errorCode := div(errorCode, 10)\n    let tenths := add(mod(errorCode, 10), 0x30)\n\n    errorCode := div(errorCode, 10)\n    let hundreds := add(mod(errorCode, 10), 0x30)\n\n    // With the individual characters, we can now construct the full string.\n    // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n    // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n    // characters to it, each shifted by a multiple of 8.\n    // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n    // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n    // array).\n    let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n    let revertReason := shl(200, add(formattedPrefix, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n    // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n    // message will have the following layout:\n    // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n    // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n    // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n    mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n    // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n    // The string length is fixed: 7 characters.\n    mstore(0x24, 7)\n    // Finally, the string itself is stored.\n    mstore(0x44, revertReason)\n\n    // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n    // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n    revert(0, 100)\n  }\n}\n\nlibrary Errors {\n  // Math\n  uint256 internal constant ADD_OVERFLOW = 0;\n  uint256 internal constant SUB_OVERFLOW = 1;\n  uint256 internal constant SUB_UNDERFLOW = 2;\n  uint256 internal constant MUL_OVERFLOW = 3;\n  uint256 internal constant ZERO_DIVISION = 4;\n  uint256 internal constant DIV_INTERNAL = 5;\n  uint256 internal constant X_OUT_OF_BOUNDS = 6;\n  uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n  uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n  uint256 internal constant INVALID_EXPONENT = 9;\n\n  // Input\n  uint256 internal constant OUT_OF_BOUNDS = 100;\n  uint256 internal constant UNSORTED_ARRAY = 101;\n  uint256 internal constant UNSORTED_TOKENS = 102;\n  uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n  uint256 internal constant ZERO_TOKEN = 104;\n\n  // Shared pools\n  uint256 internal constant MIN_TOKENS = 200;\n  uint256 internal constant MAX_TOKENS = 201;\n  uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n  uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n  uint256 internal constant MINIMUM_BPT = 204;\n  uint256 internal constant CALLER_NOT_VAULT = 205;\n  uint256 internal constant UNINITIALIZED = 206;\n  uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n  uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n  uint256 internal constant EXPIRED_PERMIT = 209;\n  uint256 internal constant NOT_TWO_TOKENS = 210;\n  uint256 internal constant DISABLED = 211;\n\n  // Pools\n  uint256 internal constant MIN_AMP = 300;\n  uint256 internal constant MAX_AMP = 301;\n  uint256 internal constant MIN_WEIGHT = 302;\n  uint256 internal constant MAX_STABLE_TOKENS = 303;\n  uint256 internal constant MAX_IN_RATIO = 304;\n  uint256 internal constant MAX_OUT_RATIO = 305;\n  uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n  uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n  uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n  uint256 internal constant INVALID_TOKEN = 309;\n  uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n  uint256 internal constant ZERO_INVARIANT = 311;\n  uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n  uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n  uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n  uint256 internal constant ORACLE_INVALID_INDEX = 315;\n  uint256 internal constant ORACLE_BAD_SECS = 316;\n  uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n  uint256 internal constant AMP_ONGOING_UPDATE = 318;\n  uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n  uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n  uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n  uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n  uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n  uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n  uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n  uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n  uint256 internal constant SWAPS_DISABLED = 327;\n  uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n  uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n  uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n  uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n  uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n  uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n  uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n  uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n  uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n  uint256 internal constant UNAUTHORIZED_EXIT = 337;\n  uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n  uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n  uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n  uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n  uint256 internal constant INVALID_INITIALIZATION = 342;\n  uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n  uint256 internal constant FEATURE_DISABLED = 344;\n  uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n  uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n  uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n  uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n  uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n  uint256 internal constant MAX_WEIGHT = 350;\n  uint256 internal constant UNAUTHORIZED_JOIN = 351;\n  uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n  uint256 internal constant FRACTIONAL_TARGET = 353;\n\n  // Lib\n  uint256 internal constant REENTRANCY = 400;\n  uint256 internal constant SENDER_NOT_ALLOWED = 401;\n  uint256 internal constant PAUSED = 402;\n  uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n  uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n  uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n  uint256 internal constant INSUFFICIENT_BALANCE = 406;\n  uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n  uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n  uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n  uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n  uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n  uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n  uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n  uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n  uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n  uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n  uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n  uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n  uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n  uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n  uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n  uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n  uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n  uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n  uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n  uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n  uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n  uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n  uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n  uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n  uint256 internal constant NOT_PAUSED = 431;\n  uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n  uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n  uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n  uint256 internal constant INVALID_OPERATION = 435;\n  uint256 internal constant CODEC_OVERFLOW = 436;\n  uint256 internal constant IN_RECOVERY_MODE = 437;\n  uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n  uint256 internal constant INDUCED_FAILURE = 439;\n  uint256 internal constant EXPIRED_SIGNATURE = 440;\n  uint256 internal constant MALFORMED_SIGNATURE = 441;\n  uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n  uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n\n  // Vault\n  uint256 internal constant INVALID_POOL_ID = 500;\n  uint256 internal constant CALLER_NOT_POOL = 501;\n  uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n  uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n  uint256 internal constant INVALID_SIGNATURE = 504;\n  uint256 internal constant EXIT_BELOW_MIN = 505;\n  uint256 internal constant JOIN_ABOVE_MAX = 506;\n  uint256 internal constant SWAP_LIMIT = 507;\n  uint256 internal constant SWAP_DEADLINE = 508;\n  uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n  uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n  uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n  uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n  uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n  uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n  uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n  uint256 internal constant INSUFFICIENT_ETH = 516;\n  uint256 internal constant UNALLOCATED_ETH = 517;\n  uint256 internal constant ETH_TRANSFER = 518;\n  uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n  uint256 internal constant TOKENS_MISMATCH = 520;\n  uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n  uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n  uint256 internal constant TOKENS_ALREADY_SET = 523;\n  uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n  uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n  uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n  uint256 internal constant POOL_NO_TOKENS = 527;\n  uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n  // Fees\n  uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n  uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n  uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n  uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n  // Misc\n  uint256 internal constant UNIMPLEMENTED = 998;\n  uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}\n"
    },
    "contracts/external/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\ncontract BConst {\n  uint256 public constant BONE = 10**18;\n\n  uint256 public constant MIN_BOUND_TOKENS = 2;\n  uint256 public constant MAX_BOUND_TOKENS = 8;\n\n  uint256 public constant MIN_FEE = BONE / 10**6;\n  uint256 public constant MAX_FEE = BONE / 10;\n  uint256 public constant EXIT_FEE = 0;\n\n  uint256 public constant MIN_WEIGHT = BONE;\n  uint256 public constant MAX_WEIGHT = BONE * 50;\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n  uint256 public constant MAX_IN_RATIO = BONE / 2;\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/external/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n"
    },
    "contracts/external/balancer/IBalancerLinearPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IBalancerVault } from \"./IBalancerVault.sol\";\n\ninterface IBalancerLinearPool {\n  function getActualSupply() external view returns (uint256);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getPoolId() external view returns (bytes32);\n\n  function getVault() external view returns (IBalancerVault);\n\n  function getRate() external view returns (uint256);\n\n  function getScalingFactros() external view returns (uint256[] memory);\n\n  function getTokenRate(address token) external view returns (uint256);\n\n  function getMainToken() external view returns (address);\n}\n"
    },
    "contracts/external/balancer/IBalancerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IBalancerVault } from \"./IBalancerVault.sol\";\n\ninterface IBalancerPool {\n  function getFinalTokens() external view returns (address[] memory);\n\n  function getNormalizedWeight(address token) external view returns (uint256);\n\n  function getNormalizedWeights() external view returns (uint256[] memory);\n\n  function getSwapFee() external view returns (uint256);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function getPoolId() external view returns (bytes32);\n\n  function getVault() external view returns (IBalancerVault);\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256 poolAmountOut);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/external/balancer/IBalancerStablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IBalancerVault } from \"./IBalancerVault.sol\";\nimport { IRateProvider } from \"./IRateProvider.sol\";\n\ninterface IBalancerStablePool {\n  function getActualSupply() external view returns (uint256);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getPoolId() external view returns (bytes32);\n\n  function getVault() external view returns (IBalancerVault);\n\n  function getRate() external view returns (uint256);\n\n  function getRateProviders() external view returns (IRateProvider[] memory);\n\n  function getScalingFactros() external view returns (uint256[] memory);\n\n  function getTokenRate(address token) external view returns (uint256);\n\n  function updateTokenRateCache(address token) external;\n}\n"
    },
    "contracts/external/balancer/IBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IAsset {}\n\nenum UserBalanceOpKind {\n  DEPOSIT_INTERNAL,\n  WITHDRAW_INTERNAL,\n  TRANSFER_INTERNAL,\n  TRANSFER_EXTERNAL\n}\n\nenum SwapKind {\n  GIVEN_IN,\n  GIVEN_OUT\n}\n\nenum ExitKind {\n  EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n  EXACT_BPT_IN_FOR_TOKENS_OUT,\n  BPT_IN_FOR_EXACT_TOKENS_OUT,\n  MANAGEMENT_FEE_TOKENS_OUT\n}\n\nstruct UserBalanceOp {\n  UserBalanceOpKind kind;\n  IAsset asset;\n  uint256 amount;\n  address sender;\n  address payable recipient;\n}\nstruct FundManagement {\n  address sender;\n  bool fromInternalBalance;\n  address payable recipient;\n  bool toInternalBalance;\n}\n\nstruct SingleSwap {\n  bytes32 poolId;\n  SwapKind kind;\n  IAsset assetIn;\n  IAsset assetOut;\n  uint256 amount;\n  bytes userData;\n}\n\nstruct ExitPoolRequest {\n  IERC20Upgradeable[] assets;\n  uint256[] minAmountsOut;\n  bytes userData;\n  bool toInternalBalance;\n}\n\ninterface IBalancerVault {\n  function swap(\n    SingleSwap memory singleSwap,\n    FundManagement memory funds,\n    uint256 limit,\n    uint256 deadline\n  ) external returns (uint256 amountCalculated);\n\n  function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n  function getPoolTokens(bytes32 poolId)\n    external\n    view\n    returns (\n      IERC20Upgradeable[] memory tokens,\n      uint256[] memory balances,\n      uint256 lastChangeBlock\n    );\n\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest memory request\n  ) external;\n}\n"
    },
    "contracts/external/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\ninterface IRateProvider {\n  /**\n   * @dev Returns an 18 decimal fixed point number that is the exchange rate of the token to some other underlying\n   * token. The meaning of this rate depends on the context.\n   */\n  function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/external/bomb/IXBomb.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IXBomb is IERC20Upgradeable {\n  function reward() external view returns (IERC20Upgradeable);\n\n  function leave(uint256 _share) external;\n\n  function enter(uint256 _amount) external;\n\n  function getExchangeRate() external view returns (uint256);\n\n  function toREWARD(uint256 stakedAmount) external view returns (uint256 rewardAmount);\n\n  function toSTAKED(uint256 rewardAmount) external view returns (uint256 stakedAmount);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/external/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/external/chainlink/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/external/chainlink/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "contracts/external/chainlink/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "contracts/external/compound/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface ICErc20Compound is ICToken {\n  function underlying() external view returns (address);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    ICToken cTokenCollateral\n  ) external returns (uint256);\n\n  function getTotalUnderlyingSupplied() external view returns (uint256);\n}\n"
    },
    "contracts/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./IPriceOracle.sol\";\nimport \"./ICToken.sol\";\nimport \"./IUnitroller.sol\";\nimport \"./IRewardsDistributor.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ninterface IComptroller {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function oracle() external view returns (IPriceOracle);\n\n  function pauseGuardian() external view returns (address);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function markets(address cToken) external view returns (bool, uint256);\n\n  function getAssetsIn(address account) external view returns (ICToken[] memory);\n\n  function checkMembership(address account, ICToken cToken) external view returns (bool);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  )\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getAccountLiquidity(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function _setPriceOracle(IPriceOracle newOracle) external returns (uint256);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n  function _setCollateralFactor(ICToken market, uint256 newCollateralFactorMantissa) external returns (uint256);\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n  function _become(IUnitroller unitroller) external;\n\n  function borrowGuardianPaused(address cToken) external view returns (bool);\n\n  function mintGuardianPaused(address cToken) external view returns (bool);\n\n  function getRewardsDistributors() external view returns (address[] memory);\n\n  function getAllMarkets() external view returns (ICToken[] memory);\n\n  function getAllBorrowers() external view returns (address[] memory);\n\n  function suppliers(address account) external view returns (bool);\n\n  function supplyCaps(address cToken) external view returns (uint256);\n\n  function borrowCaps(address cToken) external view returns (uint256);\n\n  function enforceWhitelist() external view returns (bool);\n\n  function enterMarkets(address[] memory cTokens) external returns (uint256[] memory);\n\n  function exitMarket(address cTokenAddress) external returns (uint256);\n\n  function autoImplementation() external view returns (bool);\n\n  function isUserOfPool(address user) external view returns (bool);\n\n  function whitelist(address account) external view returns (bool);\n\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\n\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\n\n  function _toggleAutoImplementations(bool enabled) external returns (uint256);\n\n  function _deployMarket(\n    bool isCEther,\n    bytes memory constructorData,\n    bytes calldata becomeImplData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256);\n\n  function getMaxRedeemOrBorrow(\n    address account,\n    ICToken cTokenModify,\n    bool isBorrow\n  ) external view returns (uint256);\n\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\n\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\n\n  function isDeprecated(ICToken cToken) external view returns (bool);\n\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\n\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\n}\n"
    },
    "contracts/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface ICToken {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function ionicAdminHasRights() external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function comptroller() external view returns (address);\n\n  function adminFeeMantissa() external view returns (uint256);\n\n  function ionicFeeMantissa() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalAdminFees() external view returns (uint256);\n\n  function totalIonicFees() external view returns (uint256);\n\n  function isCToken() external view returns (bool);\n\n  function isCEther() external view returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function feeSeizeShareMantissa() external view returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\n\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\n}\n"
    },
    "contracts/external/compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\n\ninterface IPriceOracle {\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\n}\n"
    },
    "contracts/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title RewardsDistributor\n * @author Compound\n */\ninterface IRewardsDistributor {\n  /// @dev The token to reward (i.e., COMP)\n  function rewardToken() external view returns (address);\n\n  /// @notice The portion of compRate that each market currently receives\n  function compSupplySpeeds(address) external view returns (uint256);\n\n  /// @notice The portion of compRate that each market currently receives\n  function compBorrowSpeeds(address) external view returns (uint256);\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  function compAccrued(address) external view returns (uint256);\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) external;\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) external;\n\n  /**\n   * @notice Returns an array of all markets.\n   */\n  function getAllMarkets() external view returns (ICToken[] memory);\n}\n"
    },
    "contracts/external/compound/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ninterface IUnitroller {\n  function _setPendingImplementation(address newPendingImplementation) external returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n}\n"
    },
    "contracts/external/curve/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface ICurveLiquidityGaugeV2 {\n  function lp_token() external view returns (address);\n\n  function deposit(uint256 _value) external;\n\n  function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ICurvePool is IERC20Upgradeable {\n  function get_virtual_price() external view returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n\n  function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n\n  function add_liquidity(uint256[2] calldata _amounts, uint256 _min_mint_amount) external returns (uint256);\n\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external returns (uint256);\n\n  function get_dy(\n    int128 i,\n    int128 j,\n    uint256 _dx\n  ) external view returns (uint256);\n\n  function coins(uint256 index) external view returns (address);\n\n  function lp_token() external view returns (address);\n}\n"
    },
    "contracts/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface ICurveRegistry {\n  function get_n_coins(address lp) external view returns (uint256);\n\n  function get_coins(address pool) external view returns (address[8] memory);\n\n  function get_pool_from_lp_token(address lp) external view returns (address);\n}\n"
    },
    "contracts/external/curve/ICurveStableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ICurveStableSwap is IERC20Upgradeable {\n  function get_balances() external view returns (uint256[2] memory);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n"
    },
    "contracts/external/curve/ICurveV2Pool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\n\ninterface ICurveV2Pool is ICurvePool {\n  function price_oracle() external view returns (uint256);\n\n  function lp_price() external view returns (uint256);\n\n  function coins(uint256 arg0) external view returns (address);\n}\n"
    },
    "contracts/external/gamma/IHypervisor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IHypervisor is IERC20Upgradeable {\n  function baseLower() external view returns (int24);\n\n  function baseUpper() external view returns (int24);\n\n  function limitLower() external view returns (int24);\n\n  function limitUpper() external view returns (int24);\n\n  function pool() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function directDeposit() external view returns (bool);\n\n  function getBasePosition()\n    external\n    view\n    returns (\n      uint256 liquidity,\n      uint256 total0,\n      uint256 total1\n    );\n\n  function getTotalAmounts() external view returns (uint256 total0, uint256 total1);\n\n  function setWhitelist(address _address) external;\n\n  function setFee(uint8 newFee) external;\n\n  function removeWhitelisted() external;\n\n  function transferOwnership(address newOwner) external;\n\n  function withdraw(\n    uint256 shares,\n    address to,\n    address from,\n    uint256[4] memory minAmounts\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  function deposit(\n    uint256 deposit0,\n    uint256 deposit1,\n    address to,\n    address from,\n    uint256[4] memory inMin\n  ) external returns (uint256 shares);\n}\n"
    },
    "contracts/external/gamma/IUniProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\ninterface IUniProxy {\n  /// @notice Deposit into the given position\n  /// @param deposit0 Amount of token0 to deposit\n  /// @param deposit1 Amount of token1 to deposit\n  /// @param to Address to receive liquidity tokens\n  /// @param pos Hypervisor Address\n  /// @return shares Amount of liquidity tokens received\n  function deposit(\n    uint256 deposit0,\n    uint256 deposit1,\n    address to,\n    address pos, // IHypervisor\n    uint256[4] memory minIn\n  ) external returns (uint256 shares);\n\n  /// @notice Get the amount of token to deposit for the given amount of pair token\n  /// @param pos Hypervisor Address\n  /// @param token Address of token to deposit\n  /// @param _deposit Amount of token to deposit\n  /// @return amountStart Minimum amounts of the pair token to deposit\n  /// @return amountEnd Maximum amounts of the pair token to deposit\n  function getDepositAmount(\n    address pos,\n    address token,\n    uint256 _deposit\n  ) external view returns (uint256 amountStart, uint256 amountEnd);\n}\n"
    },
    "contracts/external/gelato/GUniPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ninterface GUniPool {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  /// @notice compute total underlying holdings of the G-UNI token supply\n  /// includes current liquidity invested in uniswap position, current fees earned\n  /// and any uninvested leftover (but does not include manager or gelato fees accrued)\n  /// @return amount0Current current total underlying balance of token0\n  /// @return amount1Current current total underlying balance of token1\n  function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96)\n    external\n    view\n    returns (uint256 amount0Current, uint256 amount1Current);\n\n  /// @notice burn G-UNI tokens (fractional shares of a Uniswap V3 position) and receive tokens\n  /// @param burnAmount The number of G-UNI tokens to burn\n  /// @param receiver The account to receive the underlying amounts of token0 and token1\n  /// @return amount0 amount of token0 transferred to receiver for burning `burnAmount`\n  /// @return amount1 amount of token1 transferred to receiver for burning `burnAmount`\n  /// @return liquidityBurned amount of liquidity removed from the underlying Uniswap V3 position\n  // solhint-disable-next-line function-max-lines\n  function burn(uint256 burnAmount, address receiver)\n    external\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint128 liquidityBurned\n    );\n}\n"
    },
    "contracts/external/harvest/IFarmVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IFarmVault {\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  // function store() external view returns (address);\n  function governance() external view returns (address);\n\n  function controller() external view returns (address);\n\n  function underlying() external view returns (address);\n\n  function strategy() external view returns (address);\n\n  function setStrategy(address _strategy) external;\n\n  function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n  function deposit(uint256 amountWei) external;\n\n  function depositFor(uint256 amountWei, address holder) external;\n\n  function withdrawAll() external;\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n  // hard work should be callable only by the controller (by the hard worker) or by governance\n  function doHardWork() external;\n}\n"
    },
    "contracts/external/inverse/Stabilizer.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\ninterface Stabilizer {\n  function buyFee() external view returns (uint256);\n\n  function synth() external view returns (address);\n\n  function reserve() external view returns (address);\n\n  function buy(uint256 amount) external;\n\n  function sell(uint256 amount) external;\n}\n"
    },
    "contracts/external/jarvis/ISynthereumDeployment.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./ISynthereumFinder.sol\";\n\n/**\n * @title Interface that a pool MUST have in order to be included in the deployer\n */\ninterface ISynthereumDeployment {\n  /**\n   * @notice Get Synthereum finder of the pool/self-minting derivative\n   * @return finder Returns finder contract\n   */\n  function synthereumFinder() external view returns (ISynthereumFinder finder);\n\n  /**\n   * @notice Get Synthereum version\n   * @return poolVersion Returns the version of this pool/self-minting derivative\n   */\n  function version() external view returns (uint8 poolVersion);\n\n  /**\n   * @notice Get the collateral token of this pool/self-minting derivative\n   * @return collateralCurrency The ERC20 collateral token\n   */\n  function collateralToken() external view returns (IERC20Upgradeable collateralCurrency);\n\n  /**\n   * @notice Get the synthetic token associated to this pool/self-minting derivative\n   * @return syntheticCurrency The ERC20 synthetic token\n   */\n  function syntheticToken() external view returns (IERC20Upgradeable syntheticCurrency);\n\n  /**\n   * @notice Get the synthetic token symbol associated to this pool/self-minting derivative\n   * @return symbol The ERC20 synthetic token symbol\n   */\n  function syntheticTokenSymbol() external view returns (string memory symbol);\n}\n"
    },
    "contracts/external/jarvis/ISynthereumFinder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\n/**\n * @title Provides addresses of the contracts implementing certain interfaces.\n */\ninterface ISynthereumFinder {\n  /**\n   * @notice Updates the address of the contract that implements `interfaceName`.\n   * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n   * @param implementationAddress address of the deployed contract that implements the interface.\n   */\n  function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n  /**\n   * @notice Gets the address of the contract that implements the given `interfaceName`.\n   * @param interfaceName queried interface.\n   * @return implementationAddress Address of the deployed contract that implements the interface.\n   */\n  function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "contracts/external/jarvis/ISynthereumLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\nimport \"./ISynthereumLiquidityPoolGeneral.sol\";\n\n//import {\n//IEmergencyShutdown\n//} from '../../../common/interfaces/IEmergencyShutdown.sol';\n//import {ISynthereumLiquidityPoolGeneral} from './ILiquidityPoolGeneral.sol';\n//import {ISynthereumLiquidityPoolStorage} from './ILiquidityPoolStorage.sol';\n//import {ITypology} from '../../../common/interfaces/ITypology.sol';\n\n/**\n * @title Token Issuer Contract Interface\n */\n//ITypology,\n//IEmergencyShutdown,\ninterface ISynthereumLiquidityPool is ISynthereumLiquidityPoolGeneral {\n  struct MintParams {\n    // Minimum amount of synthetic tokens that a user wants to mint using collateral (anti-slippage)\n    uint256 minNumTokens;\n    // Amount of collateral that a user wants to spend for minting\n    uint256 collateralAmount;\n    // Expiration time of the transaction\n    uint256 expiration;\n    // Address to which send synthetic tokens minted\n    address recipient;\n  }\n\n  struct RedeemParams {\n    // Amount of synthetic tokens that user wants to use for redeeming\n    uint256 numTokens;\n    // Minimium amount of collateral that user wants to redeem (anti-slippage)\n    uint256 minCollateral;\n    // Expiration time of the transaction\n    uint256 expiration;\n    // Address to which send collateral tokens redeemed\n    address recipient;\n  }\n\n  //  struct ExchangeParams {\n  //    // Destination pool\n  //    ISynthereumLiquidityPoolGeneral destPool;\n  //    // Amount of source synthetic tokens that user wants to use for exchanging\n  //    uint256 numTokens;\n  //    // Minimum Amount of destination synthetic tokens that user wants to receive (anti-slippage)\n  //    uint256 minDestNumTokens;\n  //    // Expiration time of the transaction\n  //    uint256 expiration;\n  //    // Address to which send synthetic tokens exchanged\n  //    address recipient;\n  //  }\n\n  /**\n   * @notice Mint synthetic tokens using fixed amount of collateral\n   * @notice This calculate the price using on chain price feed\n   * @notice User must approve collateral transfer for the mint request to succeed\n   * @param mintParams Input parameters for minting (see MintParams struct)\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\n   * @return feePaid Amount of collateral paid by the user as fee\n   */\n  function mint(MintParams calldata mintParams) external returns (uint256 syntheticTokensMinted, uint256 feePaid);\n\n  /**\n   * @notice Redeem amount of collateral using fixed number of synthetic token\n   * @notice This calculate the price using on chain price feed\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\n   * @return collateralRedeemed Amount of collateral redeem by user\n   * @return feePaid Amount of collateral paid by user as fee\n   */\n  function redeem(RedeemParams calldata redeemParams) external returns (uint256 collateralRedeemed, uint256 feePaid);\n\n  //  /**\n  //   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\n  //   * @notice This calculate the price using on chain price feed\n  //   * @notice User must approve synthetic token transfer for the redeem request to succeed\n  //   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\n  //   * @return destNumTokensMinted Amount of collateral redeem by user\n  //   * @return feePaid Amount of collateral paid by user as fee\n  //   */\n  //  function exchange(ExchangeParams calldata exchangeParams)\n  //  external\n  //  returns (uint256 destNumTokensMinted, uint256 feePaid);\n\n  /**\n   * @notice Withdraw unused deposited collateral by the LP\n   * @notice Only a sender with LP role can call this function\n   * @param collateralAmount Collateral to be withdrawn\n   * @return remainingLiquidity Remaining unused collateral in the pool\n   */\n  function withdrawLiquidity(uint256 collateralAmount) external returns (uint256 remainingLiquidity);\n\n  /**\n   * @notice Increase collaterallization of Lp position\n   * @notice Only a sender with LP role can call this function\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\n   * @param collateralToIncrease Collateral to be added to the position\n   * @return newTotalCollateral New total collateral amount\n   */\n  function increaseCollateral(uint256 collateralToTransfer, uint256 collateralToIncrease)\n    external\n    returns (uint256 newTotalCollateral);\n\n  /**\n   * @notice Decrease collaterallization of Lp position\n   * @notice Check that final poosition is not undercollateralized\n   * @notice Only a sender with LP role can call this function\n   * @param collateralToDecrease Collateral to decreased from the position\n   * @param collateralToWithdraw Collateral to be transferred to the LP\n   * @return newTotalCollateral New total collateral amount\n   */\n  function decreaseCollateral(uint256 collateralToDecrease, uint256 collateralToWithdraw)\n    external\n    returns (uint256 newTotalCollateral);\n\n  /**\n   * @notice Withdraw fees gained by the sender\n   * @return feeClaimed Amount of fee claimed\n   */\n  function claimFee() external returns (uint256 feeClaimed);\n\n  /**\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\n   * @notice Revert if position is not undercollateralized\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\n   */\n  function liquidate(uint256 numSynthTokens)\n    external\n    returns (\n      uint256 synthTokensLiquidated,\n      uint256 collateralReceived,\n      uint256 rewardAmount\n    );\n\n  /**\n   * @notice Redeem tokens after emergency shutdown\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\n   */\n  function settleEmergencyShutdown() external returns (uint256 synthTokensSettled, uint256 collateralSettled);\n\n  //  /**\n  //   * @notice Update the fee percentage, recipients and recipient proportions\n  //   * @notice Only the maintainer can call this function\n  //   * @param _feeData Fee info (percentage + recipients + weigths)\n  //   */\n  //  function setFee(ISynthereumLiquidityPoolStorage.FeeData calldata _feeData)\n  //  external;\n\n  /**\n   * @notice Update the fee percentage\n   * @notice Only the maintainer can call this function\n   * @param _feePercentage The new fee percentage\n   */\n  function setFeePercentage(uint256 _feePercentage) external;\n\n  /**\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\n   * @notice Only the maintainer can call this function\n   * @param feeRecipients An array of the addresses of recipients that will receive generated fees\n   * @param feeProportions An array of the proportions of fees generated each recipient will receive\n   */\n  function setFeeRecipients(address[] calldata feeRecipients, uint32[] calldata feeProportions) external;\n\n  /**\n   * @notice Update the overcollateralization percentage\n   * @notice Only the maintainer can call this function\n   * @param _overCollateralization Overcollateralization percentage\n   */\n  function setOverCollateralization(uint256 _overCollateralization) external;\n\n  /**\n   * @notice Update the liquidation reward percentage\n   * @notice Only the maintainer can call this function\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\n   */\n  function setLiquidationReward(uint256 _liquidationReward) external;\n\n  /**\n   * @notice Returns fee percentage set by the maintainer\n   * @return Fee percentage\n   */\n  function feePercentage() external view returns (uint256);\n\n  /**\n   * @notice Returns fee recipients info\n   * @return Addresses, weigths and total of weigths\n   */\n  function feeRecipientsInfo()\n    external\n    view\n    returns (\n      address[] memory,\n      uint32[] memory,\n      uint256\n    );\n\n  /**\n   * @notice Returns total number of synthetic tokens generated by this pool\n   * @return Number of synthetic tokens\n   */\n  function totalSyntheticTokens() external view returns (uint256);\n\n  /**\n   * @notice Returns the total amount of collateral used for collateralizing tokens (users + LP)\n   * @return Total collateral amount\n   */\n  function totalCollateralAmount() external view returns (uint256);\n\n  /**\n   * @notice Returns the total amount of fees to be withdrawn\n   * @return Total fee amount\n   */\n  function totalFeeAmount() external view returns (uint256);\n\n  /**\n   * @notice Returns the user's fee to be withdrawn\n   * @param user User's address\n   * @return User's fee\n   */\n  function userFee(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\n   * @return Percentage of overcollateralization\n   */\n  function collateralRequirement() external view returns (uint256);\n\n  /**\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\n   * @return Percentage of reward\n   */\n  function liquidationReward() external view returns (uint256);\n\n  /**\n   * @notice Returns the price of the pair at the moment of the shutdown\n   * @return Price of the pair\n   */\n  function emergencyShutdownPrice() external view returns (uint256);\n\n  /**\n   * @notice Returns the timestamp (unix time) at the moment of the shutdown\n   * @return Timestamp\n   */\n  function emergencyShutdownTimestamp() external view returns (uint256);\n\n  /**\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\n   */\n  function collateralCoverage() external returns (bool, uint256);\n\n  /**\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\n   * @param inputCollateral Input collateral amount to be exchanged\n   * @return synthTokensReceived Synthetic tokens will be minted\n   * @return feePaid Collateral fee will be paid\n   */\n  function getMintTradeInfo(uint256 inputCollateral)\n    external\n    view\n    returns (uint256 synthTokensReceived, uint256 feePaid);\n\n  /**\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\n   * @return collateralAmountReceived Collateral amount will be received by the user\n   * @return feePaid Collateral fee will be paid\n   */\n  function getRedeemTradeInfo(uint256 syntheticTokens)\n    external\n    view\n    returns (uint256 collateralAmountReceived, uint256 feePaid);\n\n  //  /**\n  //   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\n  //   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\n  //   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\n  //   * @param  destinationPool Pool in which mint the destination synthetic token\n  //   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\n  //   * @return feePaid Collateral fee will be paid\n  //   */\n  //  function getExchangeTradeInfo(\n  //    uint256 syntheticTokens,\n  //    ISynthereumLiquidityPoolGeneral destinationPool\n  //  )\n  //  external\n  //  view\n  //  returns (uint256 destSyntheticTokensReceived, uint256 feePaid);\n  /**\n   * @notice Shutdown the pool or self-minting-derivative in case of emergency\n   * @notice Only Synthereum manager contract can call this function\n   * @return timestamp Timestamp of emergency shutdown transaction\n   * @return price Price of the pair at the moment of shutdown execution\n   */\n  function emergencyShutdown() external returns (uint256 timestamp, uint256 price);\n}\n"
    },
    "contracts/external/jarvis/ISynthereumLiquidityPoolGeneral.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\nimport \"./ISynthereumDeployment.sol\";\n\ninterface ISynthereumLiquidityPoolGeneral is\n  ISynthereumDeployment\n  //,\n  //ISynthereumLiquidityPoolInteraction\n{}\n"
    },
    "contracts/external/kyber/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport { IPoolOracle } from \"./IPoolOracle.sol\";\n\ninterface IPool {\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The oracle contract that stores necessary data for price oracle\n  /// @return The contract address\n  function poolOracle() external view returns (IPoolOracle);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The fee to be charged for a swap in basis points\n  /// @return The swap fee in basis points\n  function swapFeeUnits() external view returns (uint24);\n\n  /// @notice The pool tick distance\n  /// @dev Ticks can only be initialized and used at multiples of this value\n  /// It remains an int24 to avoid casting even though it is >= 1.\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\n  /// @return The tick distance\n  function tickDistance() external view returns (int24);\n\n  /// @notice Maximum gross liquidity that an initialized tick can have\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxTickLiquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside,\n      uint128 secondsPerLiquidityOutside\n    );\n\n  /// @notice Returns the previous and next initialized ticks of a specific tick\n  /// @dev If specified tick is uninitialized, the returned values are zero.\n  /// @param tick The tick to look up\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @return liquidity the liquidity quantity of the position\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\n  function getPositions(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\n\n  /// @notice Fetches the pool's prices, ticks and lock status\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\n  /// @return currentTick pool's current tick\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\n  /// @return locked true if pool is locked, false otherwise\n  function getPoolState()\n    external\n    view\n    returns (\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nearestCurrentTick,\n      bool locked\n    );\n\n  /// @notice Fetches the pool's liquidity values\n  /// @return baseL pool's base liquidity without reinvest liqudity\n  /// @return reinvestL the liquidity is reinvested into the pool\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\n  function getLiquidityState()\n    external\n    view\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint128 reinvestLLast\n    );\n\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\n  function getFeeGrowthGlobal() external view returns (uint256);\n\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\n  function getSecondsPerLiquidityData()\n    external\n    view\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\n\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\n  /// @param tickLower The lower tick (of a position)\n  /// @param tickUpper The upper tick (of a position)\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\n  /// between the 2 ticks, per unit of liquidity.\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\n    external\n    view\n    returns (uint128 secondsPerLiquidityInside);\n}\n"
    },
    "contracts/external/kyber/IPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolOracle {\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\n  event OwnerWithdrew(address indexed owner, address indexed token, uint256 indexed amount);\n\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param pool The pool address to update\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Initalize observation data for the caller.\n  function initializeOracle(uint32 time) external returns (uint16 cardinality, uint16 cardinalityNext);\n\n  /// @notice Write a new oracle entry into the array\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function writeNewEntry(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint16 cardinality,\n    uint16 cardinalityNext\n  ) external returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function write(\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity\n  ) external returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Increase the maximum number of price observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param pool The pool address to be updated\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(address pool, uint16 observationCardinalityNext) external;\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observe function for more details\n  function observeFromPool(address pool, uint32[] memory secondsAgos)\n    external\n    view\n    returns (int56[] memory tickCumulatives);\n\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\n  /// @dev Reverts if `secondsAgo` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observeSingle function for more details\n  function observeSingleFromPool(address pool, uint32 secondsAgo) external view returns (int56 tickCumulative);\n\n  /// @notice Return the latest pool observation data given the pool address\n  function getPoolObservation(address pool)\n    external\n    view\n    returns (\n      bool initialized,\n      uint16 index,\n      uint16 cardinality,\n      uint16 cardinalityNext\n    );\n\n  /// @notice Returns data about a specific observation index\n  /// @param pool The pool address of the observations array to fetch\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function getObservationAt(address pool, uint256 index)\n    external\n    view\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      bool initialized\n    );\n}\n"
    },
    "contracts/external/lido/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH {\n  function stETH() external view returns (address);\n\n  /**\n   * @notice Get amount of stETH for a one wstETH\n   * @return Amount of stETH for 1 wstETH\n   */\n  function stEthPerToken() external view returns (uint256);\n\n  /**\n   * @notice Get amount of wstETH for a one stETH\n   * @return Amount of wstETH for a 1 stETH\n   */\n  function tokensPerStEth() external view returns (uint256);\n\n  /**\n   * @notice Exchanges wstETH to stETH\n   * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n   * @dev Requirements:\n   *  - `_wstETHAmount` must be non-zero\n   *  - msg.sender must have at least `_wstETHAmount` wstETH.\n   * @return Amount of stETH user receives after unwrap\n   */\n  function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./MassetStructs.sol\";\n\n/**\n * @title IMasset\n * @dev   (Internal) Interface for interacting with Masset\n *        VERSION: 1.0\n *        DATE:    2020-05-05\n */\ninterface IMasset is MassetStructs {\n  // Mint\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 mintOutput);\n\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 mintOutput);\n\n  function getMintOutput(address _input, uint256 _inputQuantity) external view returns (uint256 mintOutput);\n\n  function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\n    external\n    view\n    returns (uint256 mintOutput);\n\n  // Swaps\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 swapOutput);\n\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view returns (uint256 swapOutput);\n\n  // Redemption\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 outputQuantity);\n\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  ) external returns (uint256[] memory outputQuantities);\n\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  ) external returns (uint256 mAssetRedeemed);\n\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity) external view returns (uint256 bAssetOutput);\n\n  function getRedeemExactBassetsOutput(address[] calldata _outputs, uint256[] calldata _outputQuantities)\n    external\n    view\n    returns (uint256 mAssetAmount);\n\n  // Views\n  function getBasket() external view returns (bool, bool);\n\n  function getBasset(address _token) external view returns (BassetPersonal memory personal, BassetData memory data);\n\n  function getBassets() external view returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n  function bAssetIndexes(address) external view returns (uint8);\n\n  // SavingsManager\n  function collectInterest() external returns (uint256 swapFeesGained, uint256 newSupply);\n\n  function collectPlatformInterest() external returns (uint256 mintAmount, uint256 newSupply);\n\n  // Admin\n  function setCacheSize(uint256 _cacheSize) external;\n\n  function upgradeForgeValidator(address _newForgeValidator) external;\n\n  function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n  function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration) external;\n}\n"
    },
    "contracts/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\n/**\n * @title ISavingsContractV2\n */\ninterface ISavingsContractV2 {\n  function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\n\n  function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\ninterface MassetStructs {\n  struct BassetPersonal {\n    // Address of the bAsset\n    address addr;\n    // Address of the bAsset\n    address integrator;\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n    bool hasTxFee; // takes a byte in storage\n    // Status of the bAsset\n    BassetStatus status;\n  }\n\n  struct BassetData {\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n    uint128 ratio;\n    // Amount of the Basset that is held in Collateral\n    uint128 vaultBalance;\n  }\n\n  // Status of the Basset - has it broken its peg?\n  enum BassetStatus {\n    Default,\n    Normal,\n    BrokenBelowPeg,\n    BrokenAbovePeg,\n    Blacklisted,\n    Liquidating,\n    Liquidated,\n    Failed\n  }\n\n  struct BasketState {\n    bool undergoingRecol;\n    bool failed;\n  }\n\n  struct InvariantConfig {\n    uint256 a;\n    WeightLimits limits;\n  }\n\n  struct WeightLimits {\n    uint128 min;\n    uint128 max;\n  }\n\n  struct AmpData {\n    uint64 initialA;\n    uint64 targetA;\n    uint64 rampStartTime;\n    uint64 rampEndTime;\n  }\n}\n"
    },
    "contracts/external/olympus/OlympusStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nabstract contract OlympusStaking {\n  address public OHM;\n\n  function unstake(uint256 _amount, bool _trigger) external virtual;\n}\n"
    },
    "contracts/external/olympus/sOlympus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nabstract contract sOlympus {\n  address public stakingContract;\n}\n"
    },
    "contracts/external/pcs/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/external/pstake/IStakePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n// 1 stkBNB = (totalWei / poolTokenSupply) BNB\n// 1 BNB = (poolTokenSupply / totalWei) stkBNB\n// Over time, stkBNB appreciates in value as compared to BNB.\nstruct ExchangeRateData {\n  uint256 totalWei; // total amount of BNB managed by the pool\n  uint256 poolTokenSupply; // total amount of stkBNB managed by the pool\n}\n\n// External protocols (eg: Wombat Exchange) that integrate with us, rely on this interface.\n// We must always ensure that StakePool conforms to this interface.\ninterface IStakePool {\n  function exchangeRate() external view returns (ExchangeRateData memory);\n}\n"
    },
    "contracts/external/pyth/IExpressRelay.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\ninterface IExpressRelay {\n    // Check if the combination of protocol and permissionKey is allowed within this transaction.\n    // This will return true if and only if it's being called while executing the auction winner(s) call.\n    // @param protocolFeeReceiver The address of the protocol that is gating an action behind this permission\n    // @param permissionId The id that represents the action being gated\n    // @return permissioned True if the permission is allowed, false otherwise\n    function isPermissioned(\n        address protocolFeeReceiver,\n        bytes calldata permissionId\n    ) external view returns (bool permissioned);\n}\n"
    },
    "contracts/external/pyth/IExpressRelayFeeReceiver.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\ninterface IExpressRelayFeeReceiver {\n    // Receive the proceeds of an auction.\n    // @param permissionKey The permission key where the auction was conducted on.\n    function receiveAuctionProceedings(\n        bytes calldata permissionKey\n    ) external payable;\n}\n"
    },
    "contracts/external/redstone/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IRedstoneOracle {\n  function priceOf(address asset) external view returns (uint256);\n\n  function priceOfETH() external view returns (uint256);\n\n  function getDataFeedIdForAsset(address asset) external view returns (bytes32);\n\n  function getDataFeedIds() external view returns (bytes32[] memory dataFeedIds);\n}\n"
    },
    "contracts/external/saddle/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface ISwap {\n  // pool data view functions\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getToken(uint8 index) external view returns (address);\n\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n  function getTokenBalance(uint8 index) external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function owner() external view returns (address);\n\n  function isGuarded() external view returns (bool);\n\n  function paused() external view returns (bool);\n\n  // min return calculation functions\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\n\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n  function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n}\n"
    },
    "contracts/external/solidly/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nstruct Observation {\n  uint256 timestamp;\n  uint256 reserve0Cumulative;\n  uint256 reserve1Cumulative;\n}\n\ninterface IPair {\n  function observations(uint256 index) external pure returns (Observation memory);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function metadata()\n    external\n    view\n    returns (\n      uint256 dec0,\n      uint256 dec1,\n      uint256 r0,\n      uint256 r1,\n      bool st,\n      address t0,\n      address t1\n    );\n\n  function claimFees() external returns (uint256, uint256);\n\n  function tokens() external returns (address, address);\n\n  function stable() external view returns (bool);\n\n  function observationLength() external view returns (uint256);\n\n  function lastObservation() external view returns (Observation memory);\n\n  function current(address tokenIn, uint256 amountIn) external view returns (uint256 amountOut);\n\n  function currentCumulativePrices()\n    external\n    view\n    returns (\n      uint256 reserve0Cumulative,\n      uint256 reserve1Cumulative,\n      uint256 blockTimestamp\n    );\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function sync() external;\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint256 _reserve0,\n      uint256 _reserve1,\n      uint256 _blockTimestampLast\n    );\n\n  function getAmountOut(uint256, address) external view returns (uint256);\n}\n"
    },
    "contracts/external/solidly/IRouter.sol": {
      "content": "pragma solidity >=0.8.0;\n\ninterface IRouter {\n  struct Route {\n    address from;\n    address to;\n    bool stable;\n  }\n\n  function isPair(address pair) external view returns (bool);\n\n  function getReserves(\n    address tokenA,\n    address tokenB,\n    bool stable\n  ) external view returns (uint256 reserveA, uint256 reserveB);\n\n  function pairFor(\n    address tokenA,\n    address tokenB,\n    bool stable\n  ) external view returns (address pair);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function swapExactTokensForTokensSimple(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address tokenFrom,\n    address tokenTo,\n    bool stable,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    Route[] calldata routes,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);\n\n  function quoteAddLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint256 amountADesired,\n    uint256 amountBDesired\n  )\n    external\n    view\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n}\n"
    },
    "contracts/external/stader/IStakeManager.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ninterface IStakeManager {\n  function deposit() external payable;\n\n  function getTotalPooledBnb() external view returns (uint256);\n\n  function getContracts()\n    external\n    view\n    returns (\n      address _manager,\n      address _bnbX,\n      address _tokenHub,\n      address _bcDepositWallet\n    );\n\n  function getExtraBnbInContract() external view returns (uint256 _extraBnb);\n\n  function convertBnbToBnbX(uint256 _amount) external view returns (uint256);\n\n  function convertBnbXToBnb(uint256 _amountInBnbX) external view returns (uint256);\n}\n"
    },
    "contracts/external/sushi/SushiBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract SushiBar is IERC20Upgradeable {\n  IERC20Upgradeable public sushi;\n\n  // Enter the bar. Pay some SUSHIs. Earn some shares.\n  function enter(uint256 _amount) public virtual;\n\n  // Leave the bar. Claim back your SUSHIs.\n  function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/external/umbrella/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRegistry {\n  event LogRegistered(address indexed destination, bytes32 name);\n\n  /// @dev imports new contract addresses and override old addresses, if they exist under provided name\n  /// This method can be used for contracts that for some reason do not have `getName` method\n  /// @param  _names array of contract names that we want to register\n  /// @param  _destinations array of contract addresses\n  function importAddresses(bytes32[] calldata _names, address[] calldata _destinations) external;\n\n  /// @dev imports new contracts and override old addresses, if they exist.\n  /// Names of contracts are fetched directly from each contract by calling `getName`\n  /// @param  _destinations array of contract addresses\n  function importContracts(address[] calldata _destinations) external;\n\n  /// @dev this method ensure, that old and new contract is aware of it state in registry\n  /// Note: BSC registry does not have this method. This method was introduced in later stage.\n  /// @param _newContract address of contract that will replace old one\n  function atomicUpdate(address _newContract) external;\n\n  /// @dev similar to `getAddress` but throws when contract name not exists\n  /// @param name contract name\n  /// @return contract address registered under provided name or throws, if does not exists\n  function requireAndGetAddress(bytes32 name) external view returns (address);\n\n  /// @param name contract name in a form of bytes32\n  /// @return contract address registered under provided name\n  function getAddress(bytes32 name) external view returns (address);\n\n  /// @param _name contract name\n  /// @return contract address assigned to the name or address(0) if not exists\n  function getAddressByString(string memory _name) external view returns (address);\n\n  /// @dev helper method that converts string to bytes32,\n  /// you can use to to generate contract name\n  function stringToBytes32(string memory _string) external pure returns (bytes32 result);\n}\n"
    },
    "contracts/external/umbrella/IUmbrellaFeeds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUmbrellaFeeds {\n  struct PriceData {\n    /// @dev this is placeholder, that can be used for some additional data\n    /// atm of creating this smart contract, it is only used as marker for removed data (when == type(uint8).max)\n    uint8 data;\n    /// @dev heartbeat: how often price data will be refreshed in case price stay flat\n    uint24 heartbeat;\n    /// @dev timestamp: price time, at this time validators run consensus\n    uint32 timestamp;\n    /// @dev price\n    uint128 price;\n  }\n\n  /// @dev this is main endpoint for reading feeds.\n  /// In case timestamp is empty (that means there is no data), contract will execute fallback call.\n  /// Check main contract description for fallback details.\n  /// If you do not need whole data from `PriceData` struct, you can save some gas by using other view methods that\n  /// returns just what you need.\n  /// @notice method will revert if data for `_key` not exists.\n  /// @param _key hash of feed name\n  /// @return data full PriceData struct\n  function getPriceData(bytes32 _key) external view returns (PriceData memory data);\n\n  /// @dev this is only for dev debug,\n  /// please use `getPriceData` directly for lower has cost and fallback functionality\n  function priceData(string memory _key) external view returns (PriceData memory);\n\n  /// @notice same as `getPriceData` but does not revert when no data\n  /// @param _key hash of feed name\n  /// @return data full PriceData struct\n  function getPriceDataRaw(bytes32 _key) external view returns (PriceData memory data);\n\n  /// @notice reader for mapping\n  /// @param _key hash of feed name\n  /// @return data full PriceData struct\n  function prices(bytes32 _key) external view returns (PriceData memory data);\n\n  /// @notice method will revert if data for `_key` not exists.\n  /// @param _key hash of feed name\n  /// @return price\n  function getPrice(bytes32 _key) external view returns (uint128 price);\n\n  /// @notice method will revert if data for `_key` not exists.\n  /// @param _key hash of feed name\n  /// @return price\n  /// @return timestamp\n  function getPriceTimestamp(bytes32 _key) external view returns (uint128 price, uint32 timestamp);\n\n  /// @notice method will revert if data for `_key` not exists.\n  /// @param _key hash of feed name\n  /// @return price\n  /// @return timestamp\n  /// @return heartbeat\n  function getPriceTimestampHeartbeat(bytes32 _key)\n    external\n    view\n    returns (\n      uint128 price,\n      uint32 timestamp,\n      uint24 heartbeat\n    );\n\n  /// @dev This method should be used only for Layer2 as it is more gas consuming than others views.\n  /// @notice It does not revert on empty data.\n  /// @param _name string feed name\n  /// @return data PriceData\n  function getPriceDataByName(string calldata _name) external view returns (PriceData memory data);\n\n  /// @dev decimals for prices stored in this contract\n  function DECIMALS() external view returns (uint8); // solhint-disable-line func-name-mixedcase\n}\n"
    },
    "contracts/external/uniswap/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// From Uniswap3 Core\n\n// Updated to Solidity 0.8 by Midas Capital:\n//   * Rewrite unary negation of denominator, which is a uint\n//   * Wrapped function bodies with \"unchecked {}\" so as to not add any extra gas costs\n\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n  /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = a * b\n      // Compute the product mod 2**256 and mod 2**256 - 1\n      // then use the Chinese Remainder Theorem to reconstruct\n      // the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2**256 + prod0\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(a, b, not(0))\n        prod0 := mul(a, b)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division\n      if (prod1 == 0) {\n        require(denominator > 0);\n        assembly {\n          result := div(prod0, denominator)\n        }\n        return result;\n      }\n\n      // Make sure the result is less than 2**256.\n      // Also prevents denominator == 0\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0]\n      // Compute remainder using mulmod\n      uint256 remainder;\n      assembly {\n        remainder := mulmod(a, b, denominator)\n      }\n      // Subtract 256 bit number from 512 bit number\n      assembly {\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator\n      // Compute largest power of two divisor of denominator.\n      // Always >= 1.\n      uint256 twos = denominator & (~denominator + 1);\n\n      // Divide denominator by power of two\n      assembly {\n        denominator := div(denominator, twos)\n      }\n\n      // Divide [prod1 prod0] by the factors of two\n      assembly {\n        prod0 := div(prod0, twos)\n      }\n      // Shift in bits from prod1 into prod0. For this we need\n      // to flip `twos` such that it is 2**256 / twos.\n      // If twos is zero, then it becomes one\n      assembly {\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n      return result;\n    }\n  }\n\n  /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    unchecked {\n      result = mulDiv(a, b, denominator);\n      if (mulmod(a, b, denominator) > 0) {\n        require(result < type(uint256).max);\n        result++;\n      }\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n  struct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  struct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n  }\n\n  struct ExactOutputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  struct ExactOutputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountOut;\n    uint256 amountInMaximum;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n  function exactInput(ExactInputParams calldata params) external returns (uint256 amountOut);\n\n  function exactOutputSingle(ExactOutputSingleParams calldata params) external returns (uint256 amountIn);\n\n  function exactOutput(ExactOutputParams calldata params) external returns (uint256 amountIn);\n\n  function factory() external returns (address);\n\n  function multicall(uint256 deadline, bytes[] calldata data) external payable returns (bytes[] memory);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV1Exchange {\n  function tokenToEthSwapInput(\n    uint256 tokens_sold,\n    uint256 min_eth,\n    uint256 deadline\n  ) external returns (uint256);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV1Factory {\n  function getExchange(address token) external view returns (address);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Callee {\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    address referrer,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n  /// @notice Emitted when the owner of the factory is changed\n  /// @param oldOwner The owner before the owner was changed\n  /// @param newOwner The owner after the owner was changed\n  event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n  /// @notice Emitted when a pool is created\n  /// @param token0 The first token of the pool by address sort order\n  /// @param token1 The second token of the pool by address sort order\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// @param tickSpacing The minimum number of ticks between initialized ticks\n  /// @param pool The address of the created pool\n  event PoolCreated(\n    address indexed token0,\n    address indexed token1,\n    uint24 indexed fee,\n    int24 tickSpacing,\n    address pool\n  );\n\n  /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n  /// @param fee The enabled fee, denominated in hundredths of a bip\n  /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n  event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n  /// @notice Returns the current owner of the factory\n  /// @dev Can be changed by the current owner via setOwner\n  /// @return The address of the factory owner\n  function owner() external view returns (address);\n\n  /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n  /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n  /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n  /// @return The tick spacing\n  function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n  /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n  /// @param tokenA The contract address of either token0 or token1\n  /// @param tokenB The contract address of the other token\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// @return pool The pool address\n  function getPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) external view returns (address pool);\n\n  /// @notice Creates a pool for the given two tokens and fee\n  /// @param tokenA One of the two tokens in the desired pool\n  /// @param tokenB The other of the two tokens in the desired pool\n  /// @param fee The desired fee for the pool\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n  /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n  /// are invalid.\n  /// @return pool The address of the newly created pool\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) external returns (address pool);\n\n  /// @notice Updates the owner of the factory\n  /// @dev Must be called by the current owner\n  /// @param _owner The new owner of the factory\n  function setOwner(address _owner) external;\n\n  /// @notice Enables a fee amount with the given tickSpacing\n  /// @dev Fee amounts may never be removed once enabled\n  /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n  /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n  /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n  /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n  /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n  function uniswapV3FlashCallback(\n    uint256 fee0,\n    uint256 fee1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IUniswapV3PoolActions.sol\";\n\ninterface IUniswapV3Pool is IUniswapV3PoolActions {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function fee() external view returns (uint24);\n\n  function slot0()\n    external\n    view\n    returns (\n      uint160 sqrtPriceX96,\n      int24 tick,\n      uint16 observationIndex,\n      uint16 observationCardinality,\n      uint16 observationCardinalityNext,\n      uint8 feeProtocol,\n      bool unlocked\n    );\n\n  function liquidity() external view returns (uint128);\n\n  function observe(uint32[] calldata secondsAgos)\n    external\n    view\n    returns (int56[] memory tickCumulatives, uint160[] memory liquidityCumulatives);\n\n  function observations(uint256 index)\n    external\n    view\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint160 liquidityCumulative,\n      bool initialized\n    );\n\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside0X128,\n      uint256 feeGrowthOutside1X128,\n      int56 tickCumulativeOutside,\n      uint160 secondsPerLiquidityOutsideX128,\n      uint32 secondsOutside,\n      bool initialized\n    );\n\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n\n  function positions(bytes32 key)\n    external\n    view\n    returns (\n      uint128 _liquidity,\n      uint256 feeGrowthInside0LastX128,\n      uint256 feeGrowthInside1LastX128,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n}\n"
    },
    "contracts/external/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/external/uniswap/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\nimport { FullMath } from \"./FullMath.sol\";\n\nlibrary FixedPoint96 {\n  uint8 internal constant RESOLUTION = 96;\n  uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n  function toUint128(uint256 x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function getLiquidityForAmount0(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount0\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n    return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function getLiquidityForAmount1(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount1\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount0,\n    uint256 amount1\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function getAmount0ForLiquidity(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return\n      FullMath.mulDiv(uint256(liquidity) << FixedPoint96.RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96) /\n      sqrtRatioAX96;\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function getAmount1ForLiquidity(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount0, uint256 amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IQuoter {\n  function estimateMaxSwapUniswapV3(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    uint24 _poolFee\n  ) external view returns (uint256);\n\n  function estimateMinSwapUniswapV3(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    uint24 _poolFee\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IUniswapV3Quoter {\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\n  /// @param amountIn The amount of the first token to swap\n  /// @return amountOut The amount of the last token that would be received\n  function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n  /// @param tokenIn The token being swapped in\n  /// @param tokenOut The token being swapped out\n  /// @param fee The fee of the token pool to consider for the pair\n  /// @param amountIn The desired input amount\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountOut The amount of `tokenOut` that would be received\n  function quoteExactInputSingle(\n    address tokenIn,\n    address tokenOut,\n    uint24 fee,\n    uint256 amountIn,\n    uint160 sqrtPriceLimitX96\n  ) external returns (uint256 amountOut);\n\n  /// @notice Returns the amount in required for a given exact output swap without executing the swap\n  /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n  /// @param amountOut The amount of the last token to receive\n  /// @return amountIn The amount of first token required to be paid\n  function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n  /// @param tokenIn The token being swapped in\n  /// @param tokenOut The token being swapped out\n  /// @param fee The fee of the token pool to consider for the pair\n  /// @param amountOut The desired output amount\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n  function quoteExactOutputSingle(\n    address tokenIn,\n    address tokenOut,\n    uint24 fee,\n    uint256 amountOut,\n    uint160 sqrtPriceLimitX96\n  ) external returns (uint256 amountIn);\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n  /// @notice Returns the index of the most significant bit of the number,\n  ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n  /// @dev The function satisfies the property:\n  ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n  /// @param x the value for which to compute the most significant bit, must be greater than 0\n  /// @return r the index of the most significant bit\n  function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n    require(x > 0);\n\n    if (x >= 0x100000000000000000000000000000000) {\n      x >>= 128;\n      r += 128;\n    }\n    if (x >= 0x10000000000000000) {\n      x >>= 64;\n      r += 64;\n    }\n    if (x >= 0x100000000) {\n      x >>= 32;\n      r += 32;\n    }\n    if (x >= 0x10000) {\n      x >>= 16;\n      r += 16;\n    }\n    if (x >= 0x100) {\n      x >>= 8;\n      r += 8;\n    }\n    if (x >= 0x10) {\n      x >>= 4;\n      r += 4;\n    }\n    if (x >= 0x4) {\n      x >>= 2;\n      r += 2;\n    }\n    if (x >= 0x2) r += 1;\n  }\n\n  /// @notice Returns the index of the least significant bit of the number,\n  ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n  /// @dev The function satisfies the property:\n  ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n  /// @param x the value for which to compute the least significant bit, must be greater than 0\n  /// @return r the index of the least significant bit\n  function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n    require(x > 0);\n\n    r = 255;\n    if (x & type(uint128).max > 0) {\n      r -= 128;\n    } else {\n      x >>= 128;\n    }\n    if (x & type(uint64).max > 0) {\n      r -= 64;\n    } else {\n      x >>= 64;\n    }\n    if (x & type(uint32).max > 0) {\n      r -= 32;\n    } else {\n      x >>= 32;\n    }\n    if (x & type(uint16).max > 0) {\n      r -= 16;\n    } else {\n      x >>= 16;\n    }\n    if (x & type(uint8).max > 0) {\n      r -= 8;\n    } else {\n      x >>= 8;\n    }\n    if (x & 0xf > 0) {\n      r -= 4;\n    } else {\n      x >>= 4;\n    }\n    if (x & 0x3 > 0) {\n      r -= 2;\n    } else {\n      x >>= 2;\n    }\n    if (x & 0x1 > 0) r -= 1;\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n  uint8 internal constant RESOLUTION = 96;\n  uint256 internal constant Q96 = 0x1000000000000000000000000; // 2^96\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n  /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n  /// @param x The liquidity before change\n  /// @param y The delta by which liquidity should be changed\n  /// @return z The liquidity delta\n  function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n    if (y < 0) {\n      require((z = x - uint128(-y)) < x, \"LS\");\n    } else {\n      require((z = x + uint128(y)) >= x, \"LA\");\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x + y) >= x);\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x - y) <= x);\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(x == 0 || (z = x * y) / x == y);\n  }\n\n  /// @notice Returns x + y, reverts if overflows or underflows\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(int256 x, int256 y) internal pure returns (int256 z) {\n    require((z = x + y) >= x == (y >= 0));\n  }\n\n  /// @notice Returns x - y, reverts if overflows or underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(int256 x, int256 y) internal pure returns (int256 z) {\n    require((z = x - y) <= x == (y >= 0));\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n  /// @notice Cast a uint256 to a uint160, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\n    require((z = uint160(y)) == y);\n  }\n\n  /// @notice Cast a int256 to a int128, revert on overflow or underflow\n  /// @param y The int256 to be downcasted\n  /// @return z The downcasted integer, now type int128\n  function toInt128(int256 y) internal pure returns (int128 z) {\n    require((z = int128(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a int256, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2**255);\n    z = int256(y);\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./LowGasSafeMath.sol\";\nimport \"./SafeCast.sol\";\n\nimport \"../../FullMath.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"./FixedPoint96.sol\";\nimport \"./BitMath.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n  using LowGasSafeMath for uint256;\n  using SafeCast for uint256;\n\n  /// @notice Gets the next sqrt price given a delta of token0\n  /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n  /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n  /// price less in order to not send too much output.\n  /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n  /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n  /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n  /// @param liquidity The amount of usable liquidity\n  /// @param amount How much of token0 to add or remove from virtual reserves\n  /// @param add Whether to add or remove the amount of token0\n  /// @return The price after adding or removing amount, depending on add\n  function getNextSqrtPriceFromAmount0RoundingUp(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amount,\n    bool add\n  ) internal pure returns (uint160) {\n    // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n    if (amount == 0) return sqrtPX96;\n    uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n    bool overflow = false;\n    if (numerator1 != 0 && sqrtPX96 != 0)\n      overflow = uint256(BitMath.mostSignificantBit(numerator1)) + uint256(BitMath.mostSignificantBit(sqrtPX96)) >= 254;\n\n    if (add) {\n      uint256 product;\n      if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n        product = overflow ? FullMath.mulDivRoundingUp(amount, sqrtPX96, uint256(liquidity)) : product;\n        numerator1 = overflow ? FixedPoint96.Q96 : numerator1;\n        uint256 denominator = numerator1 + product;\n        if (denominator >= numerator1) {\n          // always fits in 160 bits\n          return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n        }\n      }\n\n      return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n    } else {\n      uint256 product;\n      // if the product overflows, we know the denominator underflows\n      // in addition, we must check that the denominator does not underflow\n      require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n      product = overflow ? FullMath.mulDivRoundingUp(amount, sqrtPX96, uint256(liquidity)) : product;\n      numerator1 = overflow ? FixedPoint96.Q96 : numerator1;\n      uint256 denominator = numerator1 - product;\n      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n    }\n  }\n\n  /// @notice Gets the next sqrt price given a delta of token1\n  /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n  /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n  /// price less in order to not send too much output.\n  /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n  /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n  /// @param liquidity The amount of usable liquidity\n  /// @param amount How much of token1 to add, or remove, from virtual reserves\n  /// @param add Whether to add, or remove, the amount of token1\n  /// @return The price after adding or removing `amount`\n  function getNextSqrtPriceFromAmount1RoundingDown(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amount,\n    bool add\n  ) internal pure returns (uint160) {\n    // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n    // in both cases, avoid a mulDiv for most inputs\n    if (add) {\n      uint256 quotient = (\n        amount <= type(uint160).max\n          ? (amount << FixedPoint96.RESOLUTION) / liquidity\n          : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n      );\n\n      return uint256(sqrtPX96).add(quotient).toUint160();\n    } else {\n      uint256 quotient = (\n        amount <= type(uint160).max\n          ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n          : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n      );\n\n      require(sqrtPX96 > quotient);\n      // always fits 160 bits\n      return uint160(sqrtPX96 - quotient);\n    }\n  }\n\n  /// @notice Gets the next sqrt price given an input amount of token0 or token1\n  /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n  /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n  /// @param liquidity The amount of usable liquidity\n  /// @param amountIn How much of token0, or token1, is being swapped in\n  /// @param zeroForOne Whether the amount in is token0 or token1\n  /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n  function getNextSqrtPriceFromInput(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amountIn,\n    bool zeroForOne\n  ) internal pure returns (uint160 sqrtQX96) {\n    require(sqrtPX96 > 0);\n    require(liquidity > 0);\n\n    // round to make sure that we don't pass the target price\n    return\n      zeroForOne\n        ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n        : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n  }\n\n  /// @notice Gets the next sqrt price given an output amount of token0 or token1\n  /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n  /// @param sqrtPX96 The starting price before accounting for the output amount\n  /// @param liquidity The amount of usable liquidity\n  /// @param amountOut How much of token0, or token1, is being swapped out\n  /// @param zeroForOne Whether the amount out is token0 or token1\n  /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n  function getNextSqrtPriceFromOutput(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amountOut,\n    bool zeroForOne\n  ) internal pure returns (uint160 sqrtQX96) {\n    require(sqrtPX96 > 0);\n    require(liquidity > 0);\n\n    // round to make sure that we pass the target price\n    return\n      zeroForOne\n        ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n        : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n  }\n\n  /// @notice Gets the amount0 delta between two prices\n  /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n  /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The amount of usable liquidity\n  /// @param roundUp Whether to round the amount up or down\n  /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n  function getAmount0Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity,\n    bool roundUp\n  ) internal pure returns (uint256 amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n    uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n    require(sqrtRatioAX96 > 0);\n\n    bool overflow = false;\n    if (numerator1 != 0 && numerator2 != 0)\n      overflow =\n        uint256(BitMath.mostSignificantBit(numerator1)) + uint256(BitMath.mostSignificantBit(numerator2)) >= 254;\n\n    if (overflow) {\n      return\n        roundUp\n          ? FullMath.mulDivRoundingUp(\n            FullMath.mulDivRoundingUp(uint256(liquidity), numerator2, sqrtRatioBX96),\n            FixedPoint96.Q96,\n            sqrtRatioAX96\n          )\n          : FullMath.mulDiv(\n            FullMath.mulDiv(uint256(liquidity), numerator2, sqrtRatioBX96),\n            FixedPoint96.Q96,\n            sqrtRatioAX96\n          );\n    } else {\n      return\n        roundUp\n          ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\n          : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n    }\n  }\n\n  /// @notice Gets the amount1 delta between two prices\n  /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The amount of usable liquidity\n  /// @param roundUp Whether to round the amount up, or down\n  /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n  function getAmount1Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity,\n    bool roundUp\n  ) internal pure returns (uint256 amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return\n      roundUp\n        ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n        : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n  }\n\n  /// @notice Helper that gets signed token0 delta\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The change in liquidity for which to compute the amount0 delta\n  /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n  function getAmount0Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    int128 liquidity\n  ) internal pure returns (int256 amount0) {\n    return\n      liquidity < 0\n        ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n        : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n  }\n\n  /// @notice Helper that gets signed token1 delta\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The change in liquidity for which to compute the amount1 delta\n  /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n  function getAmount1Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    int128 liquidity\n  ) internal pure returns (int256 amount1) {\n    return\n      liquidity < 0\n        ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n        : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"../../FullMath.sol\";\nimport \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n  /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n  /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n  /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n  /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n  /// @param liquidity The usable liquidity\n  /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n  /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n  /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n  /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n  /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n  /// @return feeAmount The amount of input that will be taken as a fee\n  function computeSwapStep(\n    uint160 sqrtRatioCurrentX96,\n    uint160 sqrtRatioTargetX96,\n    uint128 liquidity,\n    int256 amountRemaining,\n    uint24 feePips,\n    bool zeroForOne\n  )\n    internal\n    pure\n    returns (\n      uint160 sqrtRatioNextX96,\n      uint256 amountIn,\n      uint256 amountOut,\n      uint256 feeAmount\n    )\n  {\n    require(zeroForOne == sqrtRatioCurrentX96 >= sqrtRatioTargetX96, \"SPD\");\n    bool exactIn = amountRemaining >= 0;\n\n    if (exactIn) {\n      uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n      amountIn = zeroForOne\n        ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n      if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n      else\n        sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          amountRemainingLessFee,\n          zeroForOne\n        );\n    } else {\n      amountOut = zeroForOne\n        ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n        : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n\n      if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n      else\n        sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          uint256(-amountRemaining),\n          zeroForOne\n        );\n    }\n\n    bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n    // get the input/output amounts\n    if (zeroForOne) {\n      amountIn = max && exactIn\n        ? amountIn\n        : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n      amountOut = max && !exactIn\n        ? amountOut\n        : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n    } else {\n      amountIn = max && exactIn\n        ? amountIn\n        : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n      amountOut = max && !exactIn\n        ? amountOut\n        : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n    }\n\n    // cap the output amount to not exceed the remaining output amount\n    if (!exactIn && amountOut > uint256(-amountRemaining)) {\n      amountOut = uint256(-amountRemaining);\n    }\n\n    if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n      // we didn't reach the target, so take the remainder of the maximum input as fee\n      feeAmount = uint256(amountRemaining) - amountIn;\n    } else {\n      feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/Tick.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./LowGasSafeMath.sol\";\nimport \"./SafeCast.sol\";\n\nimport \"../../TickMath.sol\";\nimport \"./LiquidityMath.sol\";\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\n\n/// Ithil to modify it, since it does not have access to storage arrays\nlibrary Tick {\n  using LowGasSafeMath for int256;\n  using SafeCast for int256;\n\n  // info stored for each initialized individual tick\n  struct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute  the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n  }\n\n  /// @notice Derives max liquidity per tick from given tick spacing\n  /// @dev Executed within the pool constructor\n  /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n  ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n  /// @return The max liquidity per tick\n  function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n    int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\n    int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\n    uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;\n    return type(uint128).max / numTicks;\n  }\n\n  /// @notice Retrieves fee growth data\n  /// Ithil: only use it with lower = self[tickLower] and upper = self[tickUpper]\n  /// @param lower The info of the lower tick boundary of the position\n  /// @param upper The info of the upper tick boundary of the position\n  /// @param tickLower The lower tick boundary of the position\n  /// @param tickUpper The upper tick boundary of the position\n  /// @param tickCurrent The current tick\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n  /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n  function getFeeGrowthInside(\n    Tick.Info memory lower,\n    Tick.Info memory upper,\n    int24 tickLower,\n    int24 tickUpper,\n    int24 tickCurrent,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128\n  ) internal pure returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n    // calculate fee growth below\n    uint256 feeGrowthBelow0X128;\n    uint256 feeGrowthBelow1X128;\n    if (tickCurrent >= tickLower) {\n      feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;\n      feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;\n    } else {\n      feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;\n      feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;\n    }\n\n    // calculate fee growth above\n    uint256 feeGrowthAbove0X128;\n    uint256 feeGrowthAbove1X128;\n    if (tickCurrent < tickUpper) {\n      feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;\n      feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;\n    } else {\n      feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;\n      feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;\n    }\n\n    feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;\n    feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;\n  }\n\n  /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n  /// Ithil: always use with info = self[tick]\n  /// @param info The info tick that will be updated\n  /// @param tick The tick that will be updated\n  /// @param tickCurrent The current tick\n  /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool\n  /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n  /// @param time The current block timestamp cast to a uint32\n  /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n  /// @param maxLiquidity The maximum liquidity allocation for a single tick\n  /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n  function update(\n    Tick.Info memory info,\n    int24 tick,\n    int24 tickCurrent,\n    int128 liquidityDelta,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128,\n    uint160 secondsPerLiquidityCumulativeX128,\n    int56 tickCumulative,\n    uint32 time,\n    bool upper,\n    uint128 maxLiquidity\n  ) internal pure returns (bool flipped) {\n    uint128 liquidityGrossBefore = info.liquidityGross;\n    uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);\n\n    require(liquidityGrossAfter <= maxLiquidity, \"LO\");\n\n    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n    if (liquidityGrossBefore == 0) {\n      // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n      if (tick <= tickCurrent) {\n        info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n        info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n        info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n        info.tickCumulativeOutside = tickCumulative;\n        info.secondsOutside = time;\n      }\n      info.initialized = true;\n    }\n\n    info.liquidityGross = liquidityGrossAfter;\n\n    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n    info.liquidityNet = upper\n      ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()\n      : int256(info.liquidityNet).add(liquidityDelta).toInt128();\n  }\n\n  /// @notice Transitions to next tick as needed by price movement\n  /// @param info The result of the mapping containing all tick information for initialized ticks\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity\n  /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n  /// @param time The current block.timestamp\n  /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n  function cross(\n    Tick.Info memory info,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128,\n    uint160 secondsPerLiquidityCumulativeX128,\n    int56 tickCumulative,\n    uint32 time\n  ) internal pure returns (int128 liquidityNet) {\n    info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n    info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n    info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;\n    info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;\n    info.secondsOutside = time - info.secondsOutside;\n    liquidityNet = info.liquidityNet;\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\nimport \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n  /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n  /// @param tick The tick for which to compute the position\n  /// @return wordPos The key in the mapping containing the word in which the bit is stored\n  /// @return bitPos The bit position in the word where the flag is stored\n  /// @dev simply divides @param tick by 256 with remainder: tick = wordPos * 256 + bitPos\n  function position(int24 tick) internal pure returns (int16 wordPos, uint8 bitPos) {\n    wordPos = int16(tick >> 8);\n    bitPos = uint8(int8(tick % 256));\n  }\n\n  /// Written by Ithil\n  function computeWordPos(\n    int24 tick,\n    int24 tickSpacing,\n    bool lte\n  ) internal pure returns (int16 wordPos) {\n    int24 compressed = tick / tickSpacing;\n    if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n    (wordPos, ) = lte ? position(compressed) : position(compressed + 1);\n  }\n\n  /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n  /// @param selfResult The result of the mapping in which to flip the tick (Ithil modified)\n  /// @param tick The tick to flip\n  /// @param tickSpacing The spacing between usable ticks\n  function flipTick(\n    uint256 selfResult,\n    int24 tick,\n    int24 tickSpacing\n  ) internal pure {\n    require(tick % tickSpacing == 0); // ensure that the tick is spaced\n    (, uint8 bitPos) = position(tick / tickSpacing);\n    uint256 mask = 1 << bitPos;\n    selfResult ^= mask;\n  }\n\n  /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n  /// to the left (less than or equal to) or right (greater than) of the given tick\n  /// @param selfResult The result of the mapping in which to compute the next initialized tick (Ithil modified)\n  /// @param tick The starting tick\n  /// @param tickSpacing The spacing between usable ticks\n  /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n  /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n  /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n  function nextInitializedTickWithinOneWord(\n    uint256 selfResult,\n    int24 tick,\n    int24 tickSpacing,\n    bool lte\n  ) internal pure returns (int24 next, bool initialized) {\n    int24 compressed = tick / tickSpacing;\n    if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n    if (lte) {\n      (, uint8 bitPos) = position(compressed);\n      // all the 1s at or to the right of the current bitPos\n      uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n      uint256 masked = selfResult & mask;\n\n      // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n      initialized = masked != 0;\n      // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n      next = initialized\n        ? (compressed - int24(uint24(bitPos) - uint24(BitMath.mostSignificantBit(masked)))) * tickSpacing\n        : (compressed - int24(uint24(bitPos))) * tickSpacing;\n    } else {\n      // start from the word of the next tick, since the current tick state doesn't matter\n      (, uint8 bitPos) = position(compressed + 1);\n      // all the 1s at or to the left of the bitPos\n      uint256 mask = ~((1 << bitPos) - 1);\n      uint256 masked = selfResult & mask;\n\n      // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n      initialized = masked != 0;\n      // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n      next = initialized\n        ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n        : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n  /// @notice Returns ceil(x / y)\n  /// @dev division by 0 has unspecified behavior, and must be checked externally\n  /// @param x The dividend\n  /// @param y The divisor\n  /// @return z The quotient, ceil(x / y)\n  function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    assembly {\n      z := add(div(x, y), gt(mod(x, y), 0))\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/Quoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../IUniswapV3Factory.sol\";\nimport \"./interfaces/IQuoter.sol\";\nimport \"./UniswapV3Quoter.sol\";\n\ncontract Quoter is IQuoter, UniswapV3Quoter {\n  IUniswapV3Factory internal uniV3Factory; // TODO should it be immutable?\n\n  constructor(address _uniV3Factory) {\n    uniV3Factory = IUniswapV3Factory(_uniV3Factory);\n  }\n\n  // This should be equal to quoteExactInputSingle(_fromToken, _toToken, _poolFee, _amount, 0)\n  // todo: add price limit\n  function estimateMaxSwapUniswapV3(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    uint24 _poolFee\n  ) public view override returns (uint256) {\n    address pool = uniV3Factory.getPool(_fromToken, _toToken, _poolFee);\n\n    return _estimateOutputSingle(_toToken, _fromToken, _amount, pool);\n  }\n\n  // This should be equal to quoteExactOutputSingle(_fromToken, _toToken, _poolFee, _amount, 0)\n  // todo: add price limit\n  function estimateMinSwapUniswapV3(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    uint24 _poolFee\n  ) public view override returns (uint256) {\n    address pool = uniV3Factory.getPool(_fromToken, _toToken, _poolFee);\n\n    return _estimateInputSingle(_fromToken, _toToken, _amount, pool);\n  }\n\n  // todo: add price limit\n  function _estimateOutputSingle(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    address _pool\n  ) internal view returns (uint256 amountOut) {\n    bool zeroForOne = _fromToken > _toToken;\n    // todo: price limit?\n    (int256 amount0, int256 amount1) = quoteSwap(\n      _pool,\n      int256(_amount),\n      zeroForOne ? (TickMath.MIN_SQRT_RATIO + 1) : (TickMath.MAX_SQRT_RATIO - 1),\n      zeroForOne\n    );\n    if (zeroForOne) amountOut = amount1 > 0 ? uint256(amount1) : uint256(-amount1);\n    else amountOut = amount0 > 0 ? uint256(amount0) : uint256(-amount0);\n  }\n\n  // todo: add price limit\n  function _estimateInputSingle(\n    address _fromToken,\n    address _toToken,\n    uint256 _amount,\n    address _pool\n  ) internal view returns (uint256 amountOut) {\n    bool zeroForOne = _fromToken < _toToken;\n    // todo: price limit?\n    (int256 amount0, int256 amount1) = quoteSwap(\n      _pool,\n      -int256(_amount),\n      zeroForOne ? (TickMath.MIN_SQRT_RATIO + 1) : (TickMath.MAX_SQRT_RATIO - 1),\n      zeroForOne\n    );\n    if (zeroForOne) amountOut = amount0 > 0 ? uint256(amount0) : uint256(-amount0);\n    else amountOut = amount1 > 0 ? uint256(amount1) : uint256(-amount1);\n  }\n\n  function doesPoolExist(address _token0, address _token1) external view returns (bool) {\n    // try 0.05%\n    address pool = uniV3Factory.getPool(_token0, _token1, 500);\n    if (pool != address(0)) return true;\n\n    // try 0.3%\n    pool = uniV3Factory.getPool(_token0, _token1, 3000);\n    if (pool != address(0)) return true;\n\n    // try 1%\n    pool = uniV3Factory.getPool(_token0, _token1, 10000);\n    if (pool != address(0)) return true;\n    else return false;\n  }\n}\n"
    },
    "contracts/external/uniswap/quoter/UniswapV3Quoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6;\n\nimport \"./libraries/LowGasSafeMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Tick.sol\";\nimport \"./libraries/TickBitmap.sol\";\n\nimport \"../FullMath.sol\";\nimport \"../TickMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./libraries/SwapMath.sol\";\n\nimport \"./interfaces/IUniswapV3Quoter.sol\";\nimport \"../IUniswapV3Pool.sol\";\nimport \"../IUniswapV3PoolImmutables.sol\";\n\ncontract UniswapV3Quoter {\n  using LowGasSafeMath for int256;\n  using SafeCast for uint256;\n  using Tick for mapping(int24 => Tick.Info);\n\n  struct PoolState {\n    // the current price\n    uint160 sqrtPriceX96;\n    // the current tick\n    int24 tick;\n    // the tick spacing\n    int24 tickSpacing;\n    // the pool's fee\n    uint24 fee;\n    // the pool's liquidity\n    uint128 liquidity;\n    // whether the pool is locked\n    bool unlocked;\n  }\n\n  // accumulated protocol fees in token0/token1 units\n  struct ProtocolFees {\n    uint128 token0;\n    uint128 token1;\n  }\n\n  // the top level state of the swap, the results of which are recorded in storage at the end\n  struct SwapState {\n    // the amount remaining to be swapped in/out of the input/output asset\n    int256 amountSpecifiedRemaining;\n    // the amount already swapped out/in of the output/input asset\n    int256 amountCalculated;\n    // current sqrt(price)\n    uint160 sqrtPriceX96;\n    // the tick associated with the current price\n    int24 tick;\n    // the current liquidity in range\n    uint128 liquidity;\n  }\n\n  struct StepComputations {\n    // the price at the beginning of the step\n    uint160 sqrtPriceStartX96;\n    // the next tick to swap to from the current tick in the swap direction\n    int24 tickNext;\n    // whether tickNext is initialized or not\n    bool initialized;\n    // sqrt(price) for the next tick (1/0)\n    uint160 sqrtPriceNextX96;\n    // how much is being swapped in in this step\n    uint256 amountIn;\n    // how much is being swapped out\n    uint256 amountOut;\n    // how much fee is being paid in\n    uint256 feeAmount;\n  }\n\n  struct InitialState {\n    address poolAddress;\n    PoolState poolState;\n    uint256 feeGrowthGlobal0X128;\n    uint256 feeGrowthGlobal1X128;\n  }\n\n  struct NextTickPassage {\n    int24 tick;\n    int24 tickSpacing;\n  }\n\n  function fetchState(address _pool) internal view returns (PoolState memory poolState) {\n    IUniswapV3Pool pool = IUniswapV3Pool(_pool);\n    (uint160 sqrtPriceX96, int24 tick, , , , , bool unlocked) = pool.slot0(); // external call\n    uint128 liquidity = pool.liquidity(); // external call\n    int24 tickSpacing = IUniswapV3PoolImmutables(_pool).tickSpacing(); // external call\n    uint24 fee = IUniswapV3PoolImmutables(_pool).fee(); // external call\n    poolState = PoolState(sqrtPriceX96, tick, tickSpacing, fee, liquidity, unlocked);\n  }\n\n  function setInitialState(\n    PoolState memory initialPoolState,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool zeroForOne\n  )\n    internal\n    pure\n    returns (\n      SwapState memory state,\n      uint128 liquidity,\n      uint160 sqrtPriceX96\n    )\n  {\n    liquidity = initialPoolState.liquidity;\n\n    sqrtPriceX96 = initialPoolState.sqrtPriceX96;\n\n    require(\n      zeroForOne\n        ? sqrtPriceLimitX96 < initialPoolState.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n        : sqrtPriceLimitX96 > initialPoolState.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n      \"SPL\"\n    );\n\n    state = SwapState({\n      amountSpecifiedRemaining: amountSpecified,\n      amountCalculated: 0,\n      sqrtPriceX96: initialPoolState.sqrtPriceX96,\n      tick: initialPoolState.tick,\n      liquidity: 0 // to be modified after initialization\n    });\n  }\n\n  function getNextTickAndPrice(\n    int24 tickSpacing,\n    int24 currentTick,\n    IUniswapV3Pool pool,\n    bool zeroForOne\n  )\n    internal\n    view\n    returns (\n      int24 tickNext,\n      bool initialized,\n      uint160 sqrtPriceNextX96\n    )\n  {\n    int24 compressed = currentTick / tickSpacing;\n    if (!zeroForOne) compressed++;\n    if (currentTick < 0 && currentTick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n    uint256 selfResult = pool.tickBitmap(int16(compressed >> 8)); // external call\n\n    (tickNext, initialized) = TickBitmap.nextInitializedTickWithinOneWord(\n      selfResult,\n      currentTick,\n      tickSpacing,\n      zeroForOne\n    );\n\n    if (tickNext < TickMath.MIN_TICK) {\n      tickNext = TickMath.MIN_TICK;\n    } else if (tickNext > TickMath.MAX_TICK) {\n      tickNext = TickMath.MAX_TICK;\n    }\n    sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(tickNext);\n  }\n\n  function processSwapWithinTick(\n    IUniswapV3Pool pool,\n    PoolState memory initialPoolState,\n    SwapState memory state,\n    uint160 firstSqrtPriceX96,\n    uint128 firstLiquidity,\n    uint160 sqrtPriceLimitX96,\n    bool zeroForOne,\n    bool exactAmount\n  )\n    internal\n    view\n    returns (\n      uint160 sqrtPriceNextX96,\n      uint160 finalSqrtPriceX96,\n      uint128 finalLiquidity\n    )\n  {\n    StepComputations memory step;\n\n    step.sqrtPriceStartX96 = firstSqrtPriceX96;\n\n    (step.tickNext, step.initialized, sqrtPriceNextX96) = getNextTickAndPrice(\n      initialPoolState.tickSpacing,\n      state.tick,\n      pool,\n      zeroForOne\n    );\n\n    (finalSqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n      firstSqrtPriceX96,\n      (zeroForOne ? sqrtPriceNextX96 < sqrtPriceLimitX96 : sqrtPriceNextX96 > sqrtPriceLimitX96)\n        ? sqrtPriceLimitX96\n        : sqrtPriceNextX96,\n      firstLiquidity,\n      state.amountSpecifiedRemaining,\n      initialPoolState.fee,\n      zeroForOne\n    );\n\n    if (exactAmount) {\n      state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n      state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());\n    } else {\n      state.amountSpecifiedRemaining += step.amountOut.toInt256();\n      state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());\n    }\n\n    if (finalSqrtPriceX96 == sqrtPriceNextX96) {\n      if (step.initialized) {\n        (, int128 liquidityNet, , , , , , ) = pool.ticks(step.tickNext);\n        if (zeroForOne) liquidityNet = -liquidityNet;\n        finalLiquidity = LiquidityMath.addDelta(firstLiquidity, liquidityNet);\n      }\n      state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n    } else if (finalSqrtPriceX96 != step.sqrtPriceStartX96) {\n      // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n      state.tick = TickMath.getTickAtSqrtRatio(finalSqrtPriceX96);\n    }\n  }\n\n  function returnedAmount(\n    SwapState memory state,\n    int256 amountSpecified,\n    bool zeroForOne\n  ) internal pure returns (int256 amount0, int256 amount1) {\n    if (amountSpecified > 0) {\n      (amount0, amount1) = zeroForOne\n        ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)\n        : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);\n    } else {\n      (amount0, amount1) = zeroForOne\n        ? (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining)\n        : (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated);\n    }\n  }\n\n  function quoteSwap(\n    address poolAddress,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bool zeroForOne\n  ) internal view returns (int256 amount0, int256 amount1) {\n    bool exactAmount = amountSpecified > 0;\n\n    PoolState memory initialPoolState = fetchState(poolAddress);\n    uint160 sqrtPriceNextX96;\n\n    (SwapState memory state, uint128 liquidity, uint160 sqrtPriceX96) = setInitialState(\n      initialPoolState,\n      amountSpecified,\n      sqrtPriceLimitX96,\n      zeroForOne\n    );\n\n    while (state.amountSpecifiedRemaining != 0 && sqrtPriceX96 != sqrtPriceLimitX96)\n      (sqrtPriceNextX96, sqrtPriceX96, liquidity) = processSwapWithinTick(\n        IUniswapV3Pool(poolAddress),\n        initialPoolState,\n        state,\n        sqrtPriceX96,\n        liquidity,\n        sqrtPriceLimitX96,\n        zeroForOne,\n        exactAmount\n      );\n\n    (amount0, amount1) = returnedAmount(state, amountSpecified, zeroForOne);\n  }\n}\n"
    },
    "contracts/external/uniswap/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\n// From Uniswap3 Core\n\n// Updated to Solidity 0.8 by Midas Capital:\n//   * Cast MAX_TICK to int256 before casting to uint\n//   * Wrapped function bodies with \"unchecked {}\" so as to not add any extra gas costs\n\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = -887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = -MIN_TICK;\n\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n    unchecked {\n      uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n      require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n      uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n      if (tick > 0) ratio = type(uint256).max / ratio;\n\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n      sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    unchecked {\n      // second inequality must be < because the price can never reach the price at the max tick\n      require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\n      uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n      uint256 r = ratio;\n      uint256 msb = 0;\n\n      assembly {\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(5, gt(r, 0xFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(4, gt(r, 0xFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(3, gt(r, 0xFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(2, gt(r, 0xF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(1, gt(r, 0x3))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := gt(r, 0x1)\n        msb := or(msb, f)\n      }\n\n      if (msb >= 128) r = ratio >> (msb - 127);\n      else r = ratio << (127 - msb);\n\n      int256 log_2 = (int256(msb) - 128) << 64;\n\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(63, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(62, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(61, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(60, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(59, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(58, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(57, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(56, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(55, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(54, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(53, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(52, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(51, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(50, f))\n      }\n\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n  }\n}\n"
    },
    "contracts/external/uniswap/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IUniswapV2Pair.sol\";\nimport \"./IUniswapV2Factory.sol\";\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (address pair) {\n    return IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint8 flashSwapFee\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 amountInWithFee = amountIn * (10000 - flashSwapFee);\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 10000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut,\n    uint8 flashSwapFee\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 numerator = reserveIn * amountOut * 10000;\n    uint256 denominator = (reserveOut - amountOut) * (10000 - flashSwapFee);\n    amountIn = numerator / denominator + 1;\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path,\n    uint8 flashSwapFee\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, flashSwapFee);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path,\n    uint8 flashSwapFee\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, flashSwapFee);\n    }\n  }\n}\n"
    },
    "contracts/external/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVault {\n  function getPricePerFullShare() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function deposit(uint256 _amount) external;\n\n  function withdraw(uint256 _shares) external;\n}\n"
    },
    "contracts/external/yearn/IVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVaultV2 {\n  function pricePerShare() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function deposit(uint256 _amount) external returns (uint256);\n\n  function withdraw(uint256 maxShares) external returns (uint256);\n}\n"
    },
    "contracts/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\nimport { CErc20Delegator } from \"./compound/CErc20Delegator.sol\";\nimport { CErc20PluginDelegate } from \"./compound/CErc20PluginDelegate.sol\";\nimport { SafeOwnableUpgradeable } from \"./ionic/SafeOwnableUpgradeable.sol\";\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\nimport { DiamondExtension, DiamondBase } from \"./ionic/DiamondExtension.sol\";\nimport { AuthoritiesRegistry } from \"./ionic/AuthoritiesRegistry.sol\";\n\ncontract FeeDistributorStorage {\n  struct CDelegateUpgradeData {\n    address implementation;\n    bytes becomeImplementationData;\n  }\n\n  /**\n   * @notice Maps Unitroller (Comptroller proxy) addresses to the proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   * @dev A value of 0 means unset whereas a negative value means 0.\n   */\n  mapping(address => int256) public customInterestFeeRates;\n\n  /**\n   * @dev Latest Comptroller implementation for each existing implementation.\n   */\n  mapping(address => address) internal _latestComptrollerImplementation;\n\n  /**\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\n   */\n  mapping(uint8 => CDelegateUpgradeData) internal _latestCErc20Delegate;\n\n  /**\n   * @dev Latest Plugin implementation for each existing implementation.\n   */\n  mapping(address => address) internal _latestPluginImplementation;\n\n  mapping(address => DiamondExtension[]) public comptrollerExtensions;\n\n  mapping(address => DiamondExtension[]) public cErc20DelegateExtensions;\n\n  AuthoritiesRegistry public authoritiesRegistry;\n\n  /**\n   * @dev used as salt for the creation of new markets\n   */\n  uint256 public marketsCounter;\n\n  /**\n   * @dev Minimum borrow balance (in ETH) per user per Ionic pool asset (only checked on new borrows, not redemptions).\n   */\n  uint256 public minBorrowEth;\n\n  /**\n   * @dev Maximum utilization rate (scaled by 1e18) for Ionic pool assets (only checked on new borrows, not redemptions).\n   * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n   */\n  uint256 public maxUtilizationRate;\n\n  /**\n   * @notice The proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  uint256 public defaultInterestFeeRate;\n}\n\n/**\n * @title FeeDistributor\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FeeDistributor controls and receives protocol fees from Ionic pools and relays admin actions to Ionic pools.\n */\ncontract FeeDistributor is SafeOwnableUpgradeable, FeeDistributorStorage {\n  using AddressUpgradeable for address;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Initializer that sets initial values of state variables.\n   * @param _defaultInterestFeeRate The default proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function initialize(uint256 _defaultInterestFeeRate) public initializer {\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    __SafeOwnable_init(msg.sender);\n    defaultInterestFeeRate = _defaultInterestFeeRate;\n    maxUtilizationRate = type(uint256).max;\n  }\n\n  function reinitialize(AuthoritiesRegistry _ar) public onlyOwnerOrAdmin {\n    authoritiesRegistry = _ar;\n  }\n\n  /**\n   * @dev Sets the default proportion of Ionic pool interest taken as a protocol fee.\n   * @param _defaultInterestFeeRate The default proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function _setDefaultInterestFeeRate(uint256 _defaultInterestFeeRate) external onlyOwner {\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    defaultInterestFeeRate = _defaultInterestFeeRate;\n  }\n\n  /**\n   * @dev Withdraws accrued fees on interest.\n   * @param erc20Contract The ERC20 token address to withdraw. Set to the zero address to withdraw ETH.\n   */\n  function _withdrawAssets(address erc20Contract) external {\n    if (erc20Contract == address(0)) {\n      uint256 balance = address(this).balance;\n      require(balance > 0, \"No balance available to withdraw.\");\n      (bool success, ) = owner().call{ value: balance }(\"\");\n      require(success, \"Failed to transfer ETH balance to msg.sender.\");\n    } else {\n      IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n      uint256 balance = token.balanceOf(address(this));\n      require(balance > 0, \"No token balance available to withdraw.\");\n      token.safeTransfer(owner(), balance);\n    }\n  }\n\n  /**\n   * @dev Sets the proportion of Ionic pool interest taken as a protocol fee.\n   * @param _minBorrowEth Minimum borrow balance (in ETH) per user per Ionic pool asset (only checked on new borrows, not redemptions).\n   * @param _maxUtilizationRate Maximum utilization rate (scaled by 1e18) for Ionic pool assets (only checked on new borrows, not redemptions).\n   */\n  function _setPoolLimits(uint256 _minBorrowEth, uint256 _maxUtilizationRate) external onlyOwner {\n    minBorrowEth = _minBorrowEth;\n    maxUtilizationRate = _maxUtilizationRate;\n  }\n\n  function getMinBorrowEth(ICErc20 _ctoken) public view returns (uint256) {\n    (, , uint256 borrowBalance, ) = _ctoken.getAccountSnapshot(_msgSender());\n    if (borrowBalance == 0) return minBorrowEth;\n    IonicComptroller comptroller = IonicComptroller(address(_ctoken.comptroller()));\n    BasePriceOracle oracle = comptroller.oracle();\n    uint256 underlyingPriceEth = oracle.price(ICErc20(address(_ctoken)).underlying());\n    uint256 underlyingDecimals = _ctoken.decimals();\n    uint256 borrowBalanceEth = (underlyingPriceEth * borrowBalance) / 10**underlyingDecimals;\n    if (borrowBalanceEth > minBorrowEth) {\n      return 0;\n    }\n    return minBorrowEth - borrowBalanceEth;\n  }\n\n  /**\n   * @dev Receives native fees.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Sends data to a contract.\n   * @param targets The contracts to which `data` will be sent.\n   * @param data The data to be sent to each of `targets`.\n   */\n  function _callPool(address[] calldata targets, bytes[] calldata data) external onlyOwner {\n    require(targets.length > 0 && targets.length == data.length, \"Array lengths must be equal and greater than 0.\");\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data[i]);\n  }\n\n  /**\n   * @dev Sends data to a contract.\n   * @param targets The contracts to which `data` will be sent.\n   * @param data The data to be sent to each of `targets`.\n   */\n  function _callPool(address[] calldata targets, bytes calldata data) external onlyOwner {\n    require(targets.length > 0, \"No target addresses specified.\");\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data);\n  }\n\n  /**\n   * @dev Deploys a CToken for an underlying ERC20\n   * @param constructorData Encoded construction data for `CToken initialize()`\n   */\n  function deployCErc20(\n    uint8 delegateType,\n    bytes calldata constructorData,\n    bytes calldata becomeImplData\n  ) external returns (address) {\n    // Make sure comptroller == msg.sender\n    (address underlying, address comptroller) = abi.decode(constructorData[0:64], (address, address));\n    require(comptroller == msg.sender, \"Comptroller is not sender.\");\n\n    // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\n    bytes32 salt = keccak256(abi.encodePacked(msg.sender, underlying, ++marketsCounter));\n\n    bytes memory cErc20DelegatorCreationCode = abi.encodePacked(type(CErc20Delegator).creationCode, constructorData);\n    address proxy = Create2Upgradeable.deploy(0, salt, cErc20DelegatorCreationCode);\n\n    CDelegateUpgradeData memory data = _latestCErc20Delegate[delegateType];\n    DiamondExtension delegateAsExtension = DiamondExtension(data.implementation);\n    // register the first extension\n    DiamondBase(proxy)._registerExtension(delegateAsExtension, DiamondExtension(address(0)));\n    // derive and configure the other extensions\n    DiamondExtension[] memory ctokenExts = cErc20DelegateExtensions[address(delegateAsExtension)];\n    for (uint256 i = 0; i < ctokenExts.length; i++) {\n      if (ctokenExts[i] == delegateAsExtension) continue;\n      DiamondBase(proxy)._registerExtension(ctokenExts[i], DiamondExtension(address(0)));\n    }\n    CErc20PluginDelegate(address(proxy))._becomeImplementation(becomeImplData);\n\n    return proxy;\n  }\n\n  /**\n   * @dev Latest Comptroller implementation for each existing implementation.\n   */\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address) {\n    return\n      _latestComptrollerImplementation[oldImplementation] != address(0)\n        ? _latestComptrollerImplementation[oldImplementation]\n        : oldImplementation;\n  }\n\n  /**\n   * @dev Sets the latest `Comptroller` upgrade implementation address.\n   * @param oldImplementation The old `Comptroller` implementation address to upgrade from.\n   * @param newImplementation Latest `Comptroller` implementation address.\n   */\n  function _setLatestComptrollerImplementation(address oldImplementation, address newImplementation)\n    external\n    onlyOwner\n  {\n    _latestComptrollerImplementation[oldImplementation] = newImplementation;\n  }\n\n  /**\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\n   */\n  function latestCErc20Delegate(uint8 delegateType) external view returns (address, bytes memory) {\n    CDelegateUpgradeData memory data = _latestCErc20Delegate[delegateType];\n    bytes memory emptyBytes;\n    return\n      data.implementation != address(0)\n        ? (data.implementation, data.becomeImplementationData)\n        : (address(0), emptyBytes);\n  }\n\n  /**\n   * @dev Sets the latest `CErc20Delegate` upgrade implementation address and data.\n   * @param delegateType The old `CErc20Delegate` implementation address to upgrade from.\n   * @param newImplementation Latest `CErc20Delegate` implementation address.\n   * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n   */\n  function _setLatestCErc20Delegate(\n    uint8 delegateType,\n    address newImplementation,\n    bytes calldata becomeImplementationData\n  ) external onlyOwner {\n    _latestCErc20Delegate[delegateType] = CDelegateUpgradeData(newImplementation, becomeImplementationData);\n  }\n\n  /**\n   * @dev Latest Plugin implementation for each existing implementation.\n   */\n  function latestPluginImplementation(address oldImplementation) external view returns (address) {\n    return\n      _latestPluginImplementation[oldImplementation] != address(0)\n        ? _latestPluginImplementation[oldImplementation]\n        : oldImplementation;\n  }\n\n  /**\n   * @dev Sets the latest plugin upgrade implementation address.\n   * @param oldImplementation The old plugin implementation address to upgrade from.\n   * @param newImplementation Latest plugin implementation address.\n   */\n  function _setLatestPluginImplementation(address oldImplementation, address newImplementation) external onlyOwner {\n    _latestPluginImplementation[oldImplementation] = newImplementation;\n  }\n\n  /**\n   * @dev Upgrades a plugin of a CErc20PluginDelegate market to the latest implementation\n   * @param cDelegator the proxy address\n   * @return if the plugin was upgraded or not\n   */\n  function _upgradePluginToLatestImplementation(address cDelegator) external onlyOwner returns (bool) {\n    CErc20PluginDelegate market = CErc20PluginDelegate(cDelegator);\n\n    address oldPluginAddress = address(market.plugin());\n    market._updatePlugin(_latestPluginImplementation[oldPluginAddress]);\n    address newPluginAddress = address(market.plugin());\n\n    return newPluginAddress != oldPluginAddress;\n  }\n\n  /**\n   * @notice Returns the proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function interestFeeRate() external view returns (uint256) {\n    (bool success, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(\"comptroller()\"));\n\n    if (success && data.length == 32) {\n      address comptroller = abi.decode(data, (address));\n      int256 customRate = customInterestFeeRates[comptroller];\n      if (customRate > 0) return uint256(customRate);\n      if (customRate < 0) return 0;\n    }\n\n    return defaultInterestFeeRate;\n  }\n\n  /**\n   * @dev Sets the proportion of Ionic pool interest taken as a protocol fee.\n   * @param comptroller The Unitroller (Comptroller proxy) address.\n   * @param rate The proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function _setCustomInterestFeeRate(address comptroller, int256 rate) external onlyOwner {\n    require(rate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    customInterestFeeRates[comptroller] = rate;\n  }\n\n  function getComptrollerExtensions(address comptroller) external view returns (DiamondExtension[] memory) {\n    return comptrollerExtensions[comptroller];\n  }\n\n  function _setComptrollerExtensions(address comptroller, DiamondExtension[] calldata extensions) external onlyOwner {\n    comptrollerExtensions[comptroller] = extensions;\n  }\n\n  function _registerComptrollerExtension(\n    address payable pool,\n    DiamondExtension extensionToAdd,\n    DiamondExtension extensionToReplace\n  ) external onlyOwner {\n    DiamondBase(pool)._registerExtension(extensionToAdd, extensionToReplace);\n  }\n\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (DiamondExtension[] memory) {\n    return cErc20DelegateExtensions[cErc20Delegate];\n  }\n\n  function _setCErc20DelegateExtensions(address cErc20Delegate, DiamondExtension[] calldata extensions)\n    external\n    onlyOwner\n  {\n    cErc20DelegateExtensions[cErc20Delegate] = extensions;\n  }\n\n  function autoUpgradePool(IonicComptroller pool) external onlyOwner {\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    // auto upgrade the pool\n    pool._upgrade();\n\n    for (uint8 i = 0; i < markets.length; i++) {\n      // upgrade the market\n      markets[i]._upgrade();\n    }\n  }\n\n  function canCall(\n    address pool,\n    address user,\n    address target,\n    bytes4 functionSig\n  ) external view returns (bool) {\n    return authoritiesRegistry.canCall(pool, user, target, functionSig);\n  }\n}\n"
    },
    "contracts/GlobalPauser.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\ninterface IPoolDirectory {\n  struct Pool {\n    string name;\n    address creator;\n    address comptroller;\n    uint256 blockPosted;\n    uint256 timestampPosted;\n  }\n\n  function getActivePools() external view returns (uint256, Pool[] memory);\n}\n\ncontract GlobalPauser is Ownable2Step {\n  IPoolDirectory public poolDirectory;\n  mapping(address => bool) public pauseGuardian;\n\n  modifier onlyPauseGuardian() {\n    require(pauseGuardian[msg.sender], \"!guardian\");\n    _;\n  }\n\n  constructor(address _poolDirectory) Ownable2Step() {\n    poolDirectory = IPoolDirectory(_poolDirectory);\n  }\n\n  function setPauseGuardian(address _pauseGuardian, bool _isPauseGuardian) external onlyOwner {\n    pauseGuardian[_pauseGuardian] = _isPauseGuardian;\n  }\n\n  function pauseAll() external onlyPauseGuardian {\n    (, IPoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      ICErc20[] memory markets = IonicComptroller(pools[i].comptroller).getAllMarkets();\n      for (uint256 j = 0; j < markets.length; j++) {\n        bool isPaused = IonicComptroller(pools[i].comptroller).borrowGuardianPaused(address(markets[j]));\n        if (!isPaused) {\n          IonicComptroller(pools[i].comptroller)._setBorrowPaused(markets[j], true);\n        }\n\n        isPaused = IonicComptroller(pools[i].comptroller).mintGuardianPaused(address(markets[j]));\n        if (!isPaused) {\n          IonicComptroller(pools[i].comptroller)._setMintPaused(markets[j], true);\n        }\n      }\n    }\n  }\n}\n"
    },
    "contracts/ILiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\nimport \"./liquidators/IRedemptionStrategy.sol\";\nimport \"./liquidators/IFundsConversionStrategy.sol\";\n\ninterface ILiquidator {\n  /**\n   * borrower The borrower's Ethereum address.\n   * repayAmount The amount to repay to liquidate the unhealthy loan.\n   * cErc20 The borrowed CErc20 contract to repay.\n   * cTokenCollateral The cToken collateral contract to be liquidated.\n   * minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n   * redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n   */\n  struct LiquidateToTokensWithFlashSwapVars {\n    address borrower;\n    uint256 repayAmount;\n    ICErc20 cErc20;\n    ICErc20 cTokenCollateral;\n    address flashSwapContract;\n    uint256 minProfitAmount;\n    IRedemptionStrategy[] redemptionStrategies;\n    bytes[] strategyData;\n    IFundsConversionStrategy[] debtFundingStrategies;\n    bytes[] debtFundingStrategiesData;\n  }\n\n  function redemptionStrategiesWhitelist(address strategy) external view returns (bool);\n\n  function safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) external returns (uint256);\n\n  function safeLiquidateToTokensWithFlashLoan(LiquidateToTokensWithFlashSwapVars calldata vars)\n    external\n    returns (uint256);\n\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external;\n\n  function _whitelistRedemptionStrategies(IRedemptionStrategy[] calldata strategies, bool[] calldata whitelisted)\n    external;\n\n  function setExpressRelay(address _expressRelay) external;\n\n  function setPoolLens(address _poolLens) external;\n\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external;\n}\n"
    },
    "contracts/ionic/AddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title AddressesProvider\n * @notice The Addresses Provider serves as a central storage of system internal and external\n *         contract addresses that change between deploys and across chains\n * @author Veliko Minkov <veliko@midascapital.xyz>\n */\ncontract AddressesProvider is SafeOwnableUpgradeable {\n  mapping(string => address) private _addresses;\n  mapping(address => Contract) public plugins;\n  mapping(address => Contract) public flywheelRewards;\n  mapping(address => RedemptionStrategy) public redemptionStrategiesConfig;\n  mapping(address => FundingStrategy) public fundingStrategiesConfig;\n  JarvisPool[] public jarvisPoolsConfig;\n  CurveSwapPool[] public curveSwapPoolsConfig;\n  mapping(address => mapping(address => address)) public balancerPoolForTokens;\n\n  /// @dev Initializer to set the admin that can set and change contracts addresses\n  function initialize(address owner) public initializer {\n    __SafeOwnable_init(owner);\n  }\n\n  /**\n   * @dev The contract address and a string that uniquely identifies the contract's interface\n   */\n  struct Contract {\n    address addr;\n    string contractInterface;\n  }\n\n  struct RedemptionStrategy {\n    address addr;\n    string contractInterface;\n    address outputToken;\n  }\n\n  struct FundingStrategy {\n    address addr;\n    string contractInterface;\n    address inputToken;\n  }\n\n  struct JarvisPool {\n    address syntheticToken;\n    address collateralToken;\n    address liquidityPool;\n    uint256 expirationTime;\n  }\n\n  struct CurveSwapPool {\n    address poolAddress;\n    address[] coins;\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the flywheel for the reward token\n   * @param rewardToken the reward token address\n   * @param flywheelRewardsModule the flywheel rewards module address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setFlywheelRewards(\n    address rewardToken,\n    address flywheelRewardsModule,\n    string calldata contractInterface\n  ) public onlyOwner {\n    flywheelRewards[rewardToken] = Contract(flywheelRewardsModule, contractInterface);\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the ERC4626 plugin for the asset\n   * @param asset the asset address\n   * @param plugin the ERC4626 plugin address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setPlugin(\n    address asset,\n    address plugin,\n    string calldata contractInterface\n  ) public onlyOwner {\n    plugins[asset] = Contract(plugin, contractInterface);\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the redemption strategy for the asset\n   * @param asset the asset address\n   * @param strategy redemption strategy address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setRedemptionStrategy(\n    address asset,\n    address strategy,\n    string calldata contractInterface,\n    address outputToken\n  ) public onlyOwner {\n    redemptionStrategiesConfig[asset] = RedemptionStrategy(strategy, contractInterface, outputToken);\n  }\n\n  function getRedemptionStrategy(address asset) public view returns (RedemptionStrategy memory) {\n    return redemptionStrategiesConfig[asset];\n  }\n\n  /**\n   * @dev sets the address and contract interface ID of the funding strategy for the asset\n   * @param asset the asset address\n   * @param strategy funding strategy address\n   * @param contractInterface a string that uniquely identifies the contract's interface\n   */\n  function setFundingStrategy(\n    address asset,\n    address strategy,\n    string calldata contractInterface,\n    address inputToken\n  ) public onlyOwner {\n    fundingStrategiesConfig[asset] = FundingStrategy(strategy, contractInterface, inputToken);\n  }\n\n  function getFundingStrategy(address asset) public view returns (FundingStrategy memory) {\n    return fundingStrategiesConfig[asset];\n  }\n\n  /**\n   * @dev configures the Jarvis pool of a Jarvis synthetic token\n   * @param syntheticToken the synthetic token address\n   * @param collateralToken the collateral token address\n   * @param liquidityPool the liquidity pool address\n   * @param expirationTime the operation expiration time\n   */\n  function setJarvisPool(\n    address syntheticToken,\n    address collateralToken,\n    address liquidityPool,\n    uint256 expirationTime\n  ) public onlyOwner {\n    jarvisPoolsConfig.push(JarvisPool(syntheticToken, collateralToken, liquidityPool, expirationTime));\n  }\n\n  function setCurveSwapPool(address poolAddress, address[] calldata coins) public onlyOwner {\n    curveSwapPoolsConfig.push(CurveSwapPool(poolAddress, coins));\n  }\n\n  /**\n   * @dev Sets an address for an id replacing the address saved in the addresses map\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(string calldata id, address newAddress) external onlyOwner {\n    _addresses[id] = newAddress;\n  }\n\n  /**\n   * @dev Returns an address by id\n   * @return The address\n   */\n  function getAddress(string calldata id) public view returns (address) {\n    return _addresses[id];\n  }\n\n  function getCurveSwapPools() public view returns (CurveSwapPool[] memory) {\n    return curveSwapPoolsConfig;\n  }\n\n  function getJarvisPools() public view returns (JarvisPool[] memory) {\n    return jarvisPoolsConfig;\n  }\n\n  function setBalancerPoolForTokens(\n    address inputToken,\n    address outputToken,\n    address pool\n  ) external onlyOwner {\n    balancerPoolForTokens[inputToken][outputToken] = pool;\n  }\n\n  function getBalancerPoolForTokens(address inputToken, address outputToken) external view returns (address) {\n    return balancerPoolForTokens[inputToken][outputToken];\n  }\n}\n"
    },
    "contracts/ionic/AuthoritiesRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AuthoritiesRegistry is SafeOwnableUpgradeable {\n  mapping(address => PoolRolesAuthority) public poolsAuthorities;\n  PoolRolesAuthority public poolAuthLogic;\n  address public leveredPositionsFactory;\n  bool public noAuthRequired;\n\n  function initialize(address _leveredPositionsFactory) public initializer {\n    __SafeOwnable_init(msg.sender);\n    leveredPositionsFactory = _leveredPositionsFactory;\n    poolAuthLogic = new PoolRolesAuthority();\n  }\n\n  function reinitialize(address _leveredPositionsFactory) public onlyOwnerOrAdmin {\n    leveredPositionsFactory = _leveredPositionsFactory;\n    poolAuthLogic = new PoolRolesAuthority();\n    // for Neon the auth is not required\n    noAuthRequired = block.chainid == 245022934;\n  }\n\n  function createPoolAuthority(address pool) public onlyOwner returns (PoolRolesAuthority auth) {\n    require(address(poolsAuthorities[pool]) == address(0), \"already created\");\n\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(poolAuthLogic), _getProxyAdmin(), \"\");\n    auth = PoolRolesAuthority(address(proxy));\n    auth.initialize(address(this));\n    poolsAuthorities[pool] = auth;\n\n    auth.openPoolSupplierCapabilities(IonicComptroller(pool));\n    auth.setUserRole(address(this), auth.REGISTRY_ROLE(), true);\n    // sets the registry owner as the auth owner\n    reconfigureAuthority(pool);\n  }\n\n  function reconfigureAuthority(address poolAddress) public {\n    IonicComptroller pool = IonicComptroller(poolAddress);\n    PoolRolesAuthority auth = poolsAuthorities[address(pool)];\n\n    if (msg.sender != poolAddress || address(auth) != address(0)) {\n      require(address(auth) != address(0), \"no such authority\");\n      require(msg.sender == owner() || msg.sender == poolAddress, \"not owner or pool\");\n\n      auth.configureRegistryCapabilities();\n      auth.configurePoolSupplierCapabilities(pool);\n      auth.configurePoolBorrowerCapabilities(pool);\n      // everyone can be a liquidator\n      auth.configureOpenPoolLiquidatorCapabilities(pool);\n      auth.configureLeveredPositionCapabilities(pool);\n\n      if (auth.owner() != owner()) {\n        auth.setOwner(owner());\n      }\n    }\n  }\n\n  function canCall(\n    address pool,\n    address user,\n    address target,\n    bytes4 functionSig\n  ) external view returns (bool) {\n    PoolRolesAuthority authorityForPool = poolsAuthorities[pool];\n    if (address(authorityForPool) == address(0)) {\n      return noAuthRequired;\n    } else {\n      // allow only if an auth exists and it allows the action\n      return authorityForPool.canCall(user, target, functionSig);\n    }\n  }\n\n  function setUserRole(\n    address pool,\n    address user,\n    uint8 role,\n    bool enabled\n  ) external {\n    PoolRolesAuthority poolAuth = poolsAuthorities[pool];\n\n    require(address(poolAuth) != address(0), \"auth does not exist\");\n    require(msg.sender == owner() || msg.sender == leveredPositionsFactory, \"not owner or factory\");\n    require(msg.sender != leveredPositionsFactory || role == poolAuth.LEVERED_POSITION_ROLE(), \"only lev pos role\");\n\n    poolAuth.setUserRole(user, role, enabled);\n  }\n}\n"
    },
    "contracts/ionic/DiamondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @notice a base contract for logic extensions that use the diamond pattern storage\n * to map the functions when looking up the extension contract to delegate to.\n */\nabstract contract DiamondExtension {\n  /**\n   * @return a list of all the function selectors that this logic extension exposes\n   */\n  function _getExtensionFunctions() external pure virtual returns (bytes4[] memory);\n}\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\n// When no extension exists for function called\nerror ExtensionNotFound(bytes4 _functionSelector);\n\n// When the function is already added\nerror FunctionAlreadyAdded(bytes4 _functionSelector, address _currentImpl);\n\nabstract contract DiamondBase {\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external virtual;\n\n  function _listExtensions() public view returns (address[] memory) {\n    return LibDiamond.listExtensions();\n  }\n\n  fallback() external {\n    address extension = LibDiamond.getExtensionForFunction(msg.sig);\n    if (extension == address(0)) revert FunctionNotFound(msg.sig);\n    // Execute external function from extension using delegatecall and return any value.\n    assembly {\n      // copy function selector and any arguments\n      calldatacopy(0, 0, calldatasize())\n      // execute function call using the extension\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\n      // get any return value\n      returndatacopy(0, 0, returndatasize())\n      // return any return value or error back to the caller\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n\n/**\n * @notice a library to use in a contract, whose logic is extended with diamond extension\n */\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.extensions.diamond.storage\");\n\n  struct Function {\n    address extension;\n    bytes4 selector;\n  }\n\n  struct LogicStorage {\n    Function[] functions;\n    address[] extensions;\n  }\n\n  function getExtensionForFunction(bytes4 msgSig) internal view returns (address) {\n    return getExtensionForSelector(msgSig, diamondStorage());\n  }\n\n  function diamondStorage() internal pure returns (LogicStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  function listExtensions() internal view returns (address[] memory) {\n    return diamondStorage().extensions;\n  }\n\n  function registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) internal {\n    if (address(extensionToReplace) != address(0)) {\n      removeExtension(extensionToReplace);\n    }\n    addExtension(extensionToAdd);\n  }\n\n  function removeExtension(DiamondExtension extension) internal {\n    LogicStorage storage ds = diamondStorage();\n    // remove all functions of the extension to replace\n    removeExtensionFunctions(extension);\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\n      if (ds.extensions[i] == address(extension)) {\n        ds.extensions[i] = ds.extensions[ds.extensions.length - 1];\n        ds.extensions.pop();\n      }\n    }\n  }\n\n  function addExtension(DiamondExtension extension) internal {\n    LogicStorage storage ds = diamondStorage();\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\n      require(ds.extensions[i] != address(extension), \"extension already added\");\n    }\n    addExtensionFunctions(extension);\n    ds.extensions.push(address(extension));\n  }\n\n  function removeExtensionFunctions(DiamondExtension extension) internal {\n    bytes4[] memory fnsToRemove = extension._getExtensionFunctions();\n    LogicStorage storage ds = diamondStorage();\n    for (uint16 i = 0; i < fnsToRemove.length; i++) {\n      bytes4 selectorToRemove = fnsToRemove[i];\n      // must never fail\n      assert(address(extension) == getExtensionForSelector(selectorToRemove, ds));\n      // swap with the last element in the selectorAtIndex array and remove the last element\n      uint16 indexToKeep = getIndexForSelector(selectorToRemove, ds);\n      ds.functions[indexToKeep] = ds.functions[ds.functions.length - 1];\n      ds.functions.pop();\n    }\n  }\n\n  function addExtensionFunctions(DiamondExtension extension) internal {\n    bytes4[] memory fnsToAdd = extension._getExtensionFunctions();\n    LogicStorage storage ds = diamondStorage();\n    uint16 functionsCount = uint16(ds.functions.length);\n    for (uint256 functionsIndex = 0; functionsIndex < fnsToAdd.length; functionsIndex++) {\n      bytes4 selector = fnsToAdd[functionsIndex];\n      address oldImplementation = getExtensionForSelector(selector, ds);\n      if (oldImplementation != address(0)) revert FunctionAlreadyAdded(selector, oldImplementation);\n      ds.functions.push(Function(address(extension), selector));\n      functionsCount++;\n    }\n  }\n\n  function getExtensionForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (address) {\n    uint256 fnsLen = ds.functions.length;\n    for (uint256 i = 0; i < fnsLen; i++) {\n      if (ds.functions[i].selector == selector) return ds.functions[i].extension;\n    }\n\n    return address(0);\n  }\n\n  function getIndexForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (uint16) {\n    uint16 fnsLen = uint16(ds.functions.length);\n    for (uint16 i = 0; i < fnsLen; i++) {\n      if (ds.functions[i].selector == selector) return i;\n    }\n\n    return type(uint16).max;\n  }\n}\n"
    },
    "contracts/ionic/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IFlashLoanReceiver {\n  function receiveFlashLoan(\n    address borrowedAsset,\n    uint256 borrowedAmount,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/ionic/irms/AdjustableJumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../compound/InterestRateModel.sol\";\nimport \"../../compound/SafeMath.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract\n * @author Compound\n */\n\nstruct InterestRateModelParams {\n  uint256 blocksPerYear; // The approximate number of blocks per year\n  uint256 baseRatePerYear; // The approximate target base APR, as a mantissa (scaled by 1e18)\n  uint256 multiplierPerYear; // The rate of increase in interest rate wrt utilization (scaled by 1e18)\n  uint256 jumpMultiplierPerYear; // The multiplierPerBlock after hitting a specified utilization point\n  uint256 kink; // The utilization point at which the jump multiplier is applied\n}\n\ncontract AdjustableJumpRateModel is Ownable, InterestRateModel {\n  using SafeMath for uint256;\n\n  event NewInterestParams(\n    uint256 baseRatePerBlock,\n    uint256 multiplierPerBlock,\n    uint256 jumpMultiplierPerBlock,\n    uint256 kink\n  );\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public blocksPerYear;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint256 public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint256 public kink;\n\n  /**\n   * @notice Initialise an interest rate model\n   */\n\n  constructor(InterestRateModelParams memory params) {\n    blocksPerYear = params.blocksPerYear;\n    baseRatePerBlock = params.baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = params.multiplierPerYear.div(blocksPerYear);\n    jumpMultiplierPerBlock = params.jumpMultiplierPerYear.div(blocksPerYear);\n    kink = params.kink;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n  }\n\n  function _setIrmParameters(InterestRateModelParams memory params) public onlyOwner {\n    blocksPerYear = params.blocksPerYear;\n    baseRatePerBlock = params.baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = params.multiplierPerYear.div(blocksPerYear);\n    jumpMultiplierPerBlock = params.jumpMultiplierPerYear.div(blocksPerYear);\n    kink = params.kink;\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    } else {\n      uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n      uint256 excessUtil = util.sub(kink);\n      return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual override returns (uint256) {\n    uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n  }\n}\n"
    },
    "contracts/ionic/irms/PrudentiaInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { InterestRateModel } from \"../../compound/InterestRateModel.sol\";\n\nimport { IRateComputer } from \"adrastia-periphery/rates/IRateComputer.sol\";\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title Adrastia Prudentia Interest Rate Model\n * @author TRILEZ SOFTWARE INC.\n */\ncontract PrudentiaInterestRateModel is InterestRateModel {\n  using Math for uint256;\n\n  /**\n   * @notice The address of the underlying token for which the interest rate model calculates rates.\n   */\n  address public immutable underlyingToken;\n\n  /**\n   * @notice The address of the Adrastia Prudentia interest rate controller.\n   */\n  IRateComputer public immutable rateController;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model.\n   */\n  uint256 public immutable blocksPerYear;\n\n  /**\n   * @notice Construct a new interest rate model that reads from an Adrastia Prudentia interest rate controller.\n   *\n   * @param blocksPerYear_ The approximate number of blocks per year that is assumed by the interest rate model.\n   * @param underlyingToken_ The address of the underlying token for which the interest rate model calculates rates.\n   * @param rateController_ The address of the Adrastia Prudentia interest rate controller.\n   */\n  constructor(\n    uint256 blocksPerYear_,\n    address underlyingToken_,\n    IRateComputer rateController_\n  ) {\n    if (underlyingToken_ == address(0)) {\n      revert(\"PrudentiaInterestRateModel: underlyingToken is the zero address\");\n    }\n    if (address(rateController_) == address(0)) {\n      revert(\"PrudentiaInterestRateModel: rateController is the zero address\");\n    }\n\n    blocksPerYear = blocksPerYear_;\n    underlyingToken = underlyingToken_;\n    rateController = rateController_;\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`.\n   *\n   * @param cash The amount of cash in the market.\n   * @param borrows The amount of borrows in the market.\n   * @param reserves The amount of reserves in the market.\n   *\n   * @return The utilization rate as a mantissa between [0, 1e18].\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    uint256 total = cash + borrows - reserves;\n    if (total == 0) {\n      // Utilization rate is zero when nothing is available (prevents division by zero)\n      return 0;\n    }\n\n    return (borrows * 1e18) / total;\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block by reading the current rate from the Adrastia Prudentia\n   * interest rate controller.\n   *\n   * @param cash Not used.\n   * @param borrows Not used.\n   * @param reserves Not used.\n   *\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18).\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    // Silence unused variable warnings\n    cash;\n    borrows;\n    reserves;\n\n    uint256 annualRate = rateController.computeRate(underlyingToken);\n\n    return annualRate.ceilDiv(blocksPerYear); // Convert the annual rate to a per-block rate, rounding up\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block.\n   *\n   * @param cash The amount of cash in the market.\n   * @param borrows The amount of borrows in the market.\n   * @param reserves The amount of reserves in the market.\n   * @param reserveFactorMantissa The current reserve factor for the market.\n   *\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18).\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual override returns (uint256) {\n    uint256 oneMinusReserveFactor = 1e18 - reserveFactorMantissa;\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / 1e18;\n\n    return (utilizationRate(cash, borrows, reserves) * rateToPool) / 1e18;\n  }\n}\n"
    },
    "contracts/ionic/levered/ILeveredPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ILeveredPositionFactoryStorage {\n  function feeDistributor() external view returns (IFeeDistributor);\n\n  function liquidatorsRegistry() external view returns (ILiquidatorsRegistry);\n\n  function blocksPerYear() external view returns (uint256);\n\n  function owner() external view returns (address);\n}\n\ninterface ILeveredPositionFactoryBase {\n  function _setLiquidatorsRegistry(ILiquidatorsRegistry _liquidatorsRegistry) external;\n\n  function _setPairWhitelisted(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    bool _whitelisted\n  ) external;\n}\n\ninterface ILeveredPositionFactoryFirstExtension {\n  function getRedemptionStrategies(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData);\n\n  function getMinBorrowNative() external view returns (uint256);\n\n  function removeClosedPosition(address closedPosition) external returns (bool removed);\n\n  function closeAndRemoveUserPosition(LeveredPosition position) external returns (bool);\n\n  function getPositionsByAccount(address account) external view returns (address[] memory, bool[] memory);\n\n  function getAccountsWithOpenPositions() external view returns (address[] memory);\n\n  function getWhitelistedCollateralMarkets() external view returns (address[] memory);\n\n  function getBorrowableMarketsByCollateral(ICErc20 _collateralMarket) external view returns (address[] memory);\n\n  function getPositionsExtension(bytes4 msgSig) external view returns (address);\n}\n\ninterface ILeveredPositionFactorySecondExtension {\n  function createPosition(ICErc20 _collateralMarket, ICErc20 _stableMarket) external returns (LeveredPosition);\n\n  function createAndFundPosition(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    IERC20Upgradeable _fundingAsset,\n    uint256 _fundingAmount\n  ) external returns (LeveredPosition);\n\n  function createAndFundPositionAtRatio(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    IERC20Upgradeable _fundingAsset,\n    uint256 _fundingAmount,\n    uint256 _leverageRatio\n  ) external returns (LeveredPosition);\n}\n\ninterface ILeveredPositionFactoryExtension is\n  ILeveredPositionFactoryFirstExtension,\n  ILeveredPositionFactorySecondExtension\n{}\n\ninterface ILeveredPositionFactory is\n  ILeveredPositionFactoryStorage,\n  ILeveredPositionFactoryBase,\n  ILeveredPositionFactoryExtension\n{}\n"
    },
    "contracts/ionic/levered/LeveredPosition.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\nimport { IFlashLoanReceiver } from \"../IFlashLoanReceiver.sol\";\nimport { IonicFlywheel } from \"../../ionic/strategies/flywheel/IonicFlywheel.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { LeveredPositionStorage } from \"./LeveredPositionStorage.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract LeveredPosition is LeveredPositionStorage, IFlashLoanReceiver {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  error OnlyWhenClosed();\n  error NotPositionOwner();\n  error RepayFlashLoanFailed(address asset, uint256 currentBalance, uint256 repayAmount);\n\n  error ConvertFundsFailed();\n  error ExitFailed(uint256 errorCode);\n  error RedeemFailed(uint256 errorCode);\n  error SupplyCollateralFailed(uint256 errorCode);\n  error BorrowStableFailed(uint256 errorCode);\n  error RepayBorrowFailed(uint256 errorCode);\n  error RedeemCollateralFailed(uint256 errorCode);\n  error ExtNotFound(bytes4 _functionSelector);\n\n  constructor(\n    address _positionOwner,\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket\n  ) LeveredPositionStorage(_positionOwner) {\n    IonicComptroller collateralPool = _collateralMarket.comptroller();\n    IonicComptroller stablePool = _stableMarket.comptroller();\n    require(collateralPool == stablePool, \"markets pools differ\");\n    pool = collateralPool;\n\n    collateralMarket = _collateralMarket;\n    collateralAsset = IERC20Upgradeable(_collateralMarket.underlying());\n    stableMarket = _stableMarket;\n    stableAsset = IERC20Upgradeable(_stableMarket.underlying());\n\n    factory = ILeveredPositionFactory(msg.sender);\n  }\n\n  /*----------------------------------------------------------------\n                          Mutable Functions\n  ----------------------------------------------------------------*/\n\n  function fundPosition(IERC20Upgradeable fundingAsset, uint256 amount) public {\n    fundingAsset.safeTransferFrom(msg.sender, address(this), amount);\n    _supplyCollateral(fundingAsset);\n\n    if (!pool.checkMembership(address(this), collateralMarket)) {\n      address[] memory cTokens = new address[](1);\n      cTokens[0] = address(collateralMarket);\n      pool.enterMarkets(cTokens);\n    }\n  }\n\n  function closePosition() public returns (uint256) {\n    return closePosition(msg.sender);\n  }\n\n  function closePosition(address withdrawTo) public returns (uint256 withdrawAmount) {\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\n\n    _leverDown(1e18);\n\n    // calling accrue and exit allows to redeem the full underlying balance\n    collateralMarket.accrueInterest();\n    uint256 errorCode = pool.exitMarket(address(collateralMarket));\n    if (errorCode != 0) revert ExitFailed(errorCode);\n\n    // redeem all cTokens should leave no dust\n    errorCode = collateralMarket.redeem(collateralMarket.balanceOf(address(this)));\n    if (errorCode != 0) revert RedeemFailed(errorCode);\n\n    if (stableAsset.balanceOf(address(this)) > 0) {\n      // convert all overborrowed leftovers/profits to the collateral asset\n      convertAllTo(stableAsset, collateralAsset);\n    }\n\n    // withdraw the redeemed collateral\n    withdrawAmount = collateralAsset.balanceOf(address(this));\n    collateralAsset.safeTransfer(withdrawTo, withdrawAmount);\n  }\n\n  function adjustLeverageRatio(uint256 targetRatioMantissa) public returns (uint256) {\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\n\n    // anything under 1x means removing the leverage\n    if (targetRatioMantissa <= 1e18) _leverDown(1e18);\n\n    if (getCurrentLeverageRatio() < targetRatioMantissa) _leverUp(targetRatioMantissa);\n    else _leverDown(targetRatioMantissa);\n\n    // return the de facto achieved ratio\n    return getCurrentLeverageRatio();\n  }\n\n  function receiveFlashLoan(\n    address assetAddress,\n    uint256 borrowedAmount,\n    bytes calldata data\n  ) external override {\n    if (msg.sender == address(collateralMarket)) {\n      // increasing the leverage ratio\n      uint256 stableBorrowAmount = abi.decode(data, (uint256));\n      _leverUpPostFL(stableBorrowAmount);\n      uint256 positionCollateralBalance = collateralAsset.balanceOf(address(this));\n      if (positionCollateralBalance < borrowedAmount)\n        revert RepayFlashLoanFailed(address(collateralAsset), positionCollateralBalance, borrowedAmount);\n    } else if (msg.sender == address(stableMarket)) {\n      // decreasing the leverage ratio\n      uint256 amountToRedeem = abi.decode(data, (uint256));\n      _leverDownPostFL(borrowedAmount, amountToRedeem);\n      uint256 positionStableBalance = stableAsset.balanceOf(address(this));\n      if (positionStableBalance < borrowedAmount)\n        revert RepayFlashLoanFailed(address(stableAsset), positionStableBalance, borrowedAmount);\n    } else {\n      revert(\"!fl not from either markets\");\n    }\n\n    // repay FL\n    IERC20Upgradeable(assetAddress).approve(msg.sender, borrowedAmount);\n  }\n\n  function withdrawStableLeftovers(address withdrawTo) public returns (uint256) {\n    if (msg.sender != positionOwner) revert NotPositionOwner();\n    if (!isPositionClosed()) revert OnlyWhenClosed();\n\n    uint256 stableLeftovers = stableAsset.balanceOf(address(this));\n    stableAsset.safeTransfer(withdrawTo, stableLeftovers);\n    return stableLeftovers;\n  }\n\n  function claimRewards() public {\n    claimRewards(msg.sender);\n  }\n\n  function claimRewards(address withdrawTo) public {\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\n\n    address[] memory flywheels = pool.getRewardsDistributors();\n\n    for (uint256 i = 0; i < flywheels.length; i++) {\n      IonicFlywheel fw = IonicFlywheel(flywheels[i]);\n      fw.accrue(ERC20(address(collateralMarket)), address(this));\n      fw.accrue(ERC20(address(stableMarket)), address(this));\n      fw.claimRewards(address(this));\n      ERC20 rewardToken = fw.rewardToken();\n      uint256 rewardsAccrued = rewardToken.balanceOf(address(this));\n      if (rewardsAccrued > 0) {\n        rewardToken.transfer(withdrawTo, rewardsAccrued);\n      }\n    }\n  }\n\n  fallback() external {\n    address extension = factory.getPositionsExtension(msg.sig);\n    if (extension == address(0)) revert ExtNotFound(msg.sig);\n    // Execute external function from extension using delegatecall and return any value.\n    assembly {\n      // copy function selector and any arguments\n      calldatacopy(0, 0, calldatasize())\n      // execute function call using the extension\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\n      // get any return value\n      returndatacopy(0, 0, returndatasize())\n      // return any return value or error back to the caller\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /*----------------------------------------------------------------\n                          View Functions\n  ----------------------------------------------------------------*/\n\n  /// @notice this is a lens fn, it is not intended to be used on-chain\n  function getAccruedRewards()\n    external\n    returns (\n      /*view*/\n      ERC20[] memory rewardTokens,\n      uint256[] memory amounts\n    )\n  {\n    address[] memory flywheels = pool.getRewardsDistributors();\n\n    rewardTokens = new ERC20[](flywheels.length);\n    amounts = new uint256[](flywheels.length);\n\n    for (uint256 i = 0; i < flywheels.length; i++) {\n      IonicFlywheel fw = IonicFlywheel(flywheels[i]);\n      fw.accrue(ERC20(address(collateralMarket)), address(this));\n      fw.accrue(ERC20(address(stableMarket)), address(this));\n      rewardTokens[i] = fw.rewardToken();\n      amounts[i] = fw.rewardsAccrued(address(this));\n    }\n  }\n\n  function getCurrentLeverageRatio() public view returns (uint256) {\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\n    if (positionSupplyAmount == 0) return 0;\n\n    BasePriceOracle oracle = pool.oracle();\n\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n    uint256 positionValue = (collateralAssetPrice * positionSupplyAmount) / 1e18;\n\n    uint256 debtValue = 0;\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\n    if (debtAmount > 0) {\n      uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n      debtValue = (borrowedAssetPrice * debtAmount) / 1e18;\n    }\n\n    // TODO check if positionValue > debtValue\n    // s / ( s - b )\n    return (positionValue * 1e18) / (positionValue - debtValue);\n  }\n\n  function getMinLeverageRatio() public view returns (uint256) {\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\n    if (positionSupplyAmount == 0) return 0;\n\n    BasePriceOracle oracle = pool.oracle();\n    uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 minStableBorrowAmount = (factory.getMinBorrowNative() * 1e18) / borrowedAssetPrice;\n    return _getLeverageRatioAfterBorrow(minStableBorrowAmount, positionSupplyAmount, 0);\n  }\n\n  function getMaxLeverageRatio() public view returns (uint256) {\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\n    if (positionSupplyAmount == 0) return 0;\n\n    uint256 maxBorrow = pool.getMaxRedeemOrBorrow(address(this), stableMarket, true);\n    uint256 positionBorrowAmount = stableMarket.borrowBalanceCurrent(address(this));\n    return _getLeverageRatioAfterBorrow(maxBorrow, positionSupplyAmount, positionBorrowAmount);\n  }\n\n  function _getLeverageRatioAfterBorrow(\n    uint256 newBorrowsAmount,\n    uint256 positionSupplyAmount,\n    uint256 positionBorrowAmount\n  ) internal view returns (uint256 r) {\n    BasePriceOracle oracle = pool.oracle();\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n\n    uint256 currentBorrowsValue = (positionBorrowAmount * stableAssetPrice) / 1e18;\n    uint256 newBorrowsValue = (newBorrowsAmount * stableAssetPrice) / 1e18;\n    uint256 positionValue = (positionSupplyAmount * collateralAssetPrice) / 1e18;\n\n    // accounting for swaps slippage\n    uint256 assumedSlippage = factory.liquidatorsRegistry().getSlippage(stableAsset, collateralAsset);\n    {\n      // add 10 bps just to not go under the min borrow value\n      assumedSlippage += 10;\n    }\n    uint256 topUpCollateralValue = (newBorrowsValue * 10000) / (10000 + assumedSlippage);\n\n    int256 s = int256(positionValue);\n    int256 b = int256(currentBorrowsValue);\n    int256 x = int256(topUpCollateralValue);\n\n    r = uint256(((s + x) * 1e18) / (s + x - b - int256(newBorrowsValue)));\n  }\n\n  function isPositionClosed() public view returns (bool) {\n    return collateralMarket.balanceOfUnderlying(address(this)) == 0;\n  }\n\n  function getEquityAmount() external view returns (uint256 equityAmount) {\n    BasePriceOracle oracle = pool.oracle();\n    uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\n    uint256 positionValue = (collateralAssetPrice * positionSupplyAmount) / 1e18;\n\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\n    uint256 debtValue = (borrowedAssetPrice * debtAmount) / 1e18;\n\n    uint256 equityValue = positionValue - debtValue;\n    equityAmount = (equityValue * 1e18) / collateralAssetPrice;\n  }\n\n  function getSupplyAmountDelta(uint256 targetRatio) public view returns (uint256, uint256) {\n    BasePriceOracle oracle = pool.oracle();\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n\n    uint256 currentRatio = getCurrentLeverageRatio();\n    bool up = targetRatio > currentRatio;\n    return _getSupplyAmountDelta(up, targetRatio, collateralAssetPrice, stableAssetPrice);\n  }\n\n  function _getSupplyAmountDelta(\n    bool up,\n    uint256 targetRatio,\n    uint256 collateralAssetPrice,\n    uint256 borrowedAssetPrice\n  ) internal view returns (uint256 supplyDelta, uint256 borrowsDelta) {\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\n    uint256 assumedSlippage;\n    if (up) assumedSlippage = factory.liquidatorsRegistry().getSlippage(stableAsset, collateralAsset);\n    else assumedSlippage = factory.liquidatorsRegistry().getSlippage(collateralAsset, stableAsset);\n    uint256 slippageFactor = (1e18 * (10000 + assumedSlippage)) / 10000;\n\n    uint256 supplyValueDeltaAbs;\n    {\n      // s = supply value before\n      // b = borrow value before\n      // r = target ratio after\n      // c = borrow value coefficient to account for the slippage\n      int256 s = int256((collateralAssetPrice * positionSupplyAmount) / 1e18);\n      int256 b = int256((borrowedAssetPrice * debtAmount) / 1e18);\n      int256 r = int256(targetRatio);\n      int256 r1 = r - 1e18;\n      int256 c = int256(slippageFactor);\n\n      // some math magic here\n      // https://www.wolframalpha.com/input?i2d=true&i=r%3D%5C%2840%29Divide%5B%5C%2840%29s%2Bx%5C%2841%29%2C%5C%2840%29s%2Bx-b-c*x%5C%2841%29%5D+%5C%2841%29+solve+for+x\n\n      // x = supplyValueDelta\n      int256 supplyValueDelta = (((r1 * s) - (b * r)) * 1e18) / ((c * r) - (1e18 * r1));\n      supplyValueDeltaAbs = uint256((supplyValueDelta < 0) ? -supplyValueDelta : supplyValueDelta);\n    }\n\n    supplyDelta = (supplyValueDeltaAbs * 1e18) / collateralAssetPrice;\n    borrowsDelta = (supplyValueDeltaAbs * 1e18) / borrowedAssetPrice;\n\n    if (up) {\n      // stables to borrow = c * x\n      borrowsDelta = (borrowsDelta * slippageFactor) / 1e18;\n    } else {\n      // amount to redeem = c * x\n      supplyDelta = (supplyDelta * slippageFactor) / 1e18;\n    }\n  }\n\n  /*----------------------------------------------------------------\n                            Internal Functions\n  ----------------------------------------------------------------*/\n\n  function _supplyCollateral(IERC20Upgradeable fundingAsset) internal returns (uint256 amountToSupply) {\n    // in case the funding is with a different asset\n    if (address(collateralAsset) != address(fundingAsset)) {\n      // swap for collateral asset\n      convertAllTo(fundingAsset, collateralAsset);\n    }\n\n    // supply the collateral\n    amountToSupply = collateralAsset.balanceOf(address(this));\n    collateralAsset.approve(address(collateralMarket), amountToSupply);\n    uint256 errorCode = collateralMarket.mint(amountToSupply);\n    if (errorCode != 0) revert SupplyCollateralFailed(errorCode);\n  }\n\n  // @dev flash loan the needed amount, then borrow stables and swap them for the amount needed to repay the FL\n  function _leverUp(uint256 targetRatio) internal {\n    BasePriceOracle oracle = pool.oracle();\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n\n    (uint256 flashLoanCollateralAmount, uint256 stableToBorrow) = _getSupplyAmountDelta(\n      true,\n      targetRatio,\n      collateralAssetPrice,\n      stableAssetPrice\n    );\n\n    collateralMarket.flash(flashLoanCollateralAmount, abi.encode(stableToBorrow));\n    // the execution will first receive a callback to receiveFlashLoan()\n    // then it continues from here\n\n    // all stables are swapped for collateral to repay the FL\n    uint256 collateralLeftovers = collateralAsset.balanceOf(address(this));\n    if (collateralLeftovers > 0) {\n      collateralAsset.approve(address(collateralMarket), collateralLeftovers);\n      collateralMarket.mint(collateralLeftovers);\n    }\n  }\n\n  // @dev supply the flash loaned collateral and then borrow stables with it\n  function _leverUpPostFL(uint256 stableToBorrow) internal {\n    // supply the flash loaned collateral\n    _supplyCollateral(collateralAsset);\n\n    // borrow stables that will be swapped to repay the FL\n    uint256 errorCode = stableMarket.borrow(stableToBorrow);\n    if (errorCode != 0) revert BorrowStableFailed(errorCode);\n\n    // swap for the FL asset\n    convertAllTo(stableAsset, collateralAsset);\n  }\n\n  // @dev redeems the supplied collateral by first repaying the debt with which it was levered\n  function _leverDown(uint256 targetRatio) internal {\n    uint256 amountToRedeem;\n    uint256 borrowsToRepay;\n\n    BasePriceOracle oracle = pool.oracle();\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\n\n    if (targetRatio <= 1e18) {\n      // if max levering down, then derive the amount to redeem from the debt to be repaid\n      borrowsToRepay = stableMarket.borrowBalanceCurrent(address(this));\n      uint256 borrowsToRepayValueScaled = borrowsToRepay * stableAssetPrice;\n      // accounting for swaps slippage\n      uint256 assumedSlippage = factory.liquidatorsRegistry().getSlippage(collateralAsset, stableAsset);\n      uint256 amountToRedeemValueScaled = (borrowsToRepayValueScaled * (10000 + assumedSlippage)) / 10000;\n      amountToRedeem = amountToRedeemValueScaled / collateralAssetPrice;\n    } else {\n      // else derive the debt to be repaid from the amount to redeem\n      (amountToRedeem, borrowsToRepay) = _getSupplyAmountDelta(\n        false,\n        targetRatio,\n        collateralAssetPrice,\n        stableAssetPrice\n      );\n      // the slippage is already accounted for in _getSupplyAmountDelta\n    }\n\n    if (borrowsToRepay > 0) {\n      ICErc20(address(stableMarket)).flash(borrowsToRepay, abi.encode(amountToRedeem));\n      // the execution will first receive a callback to receiveFlashLoan()\n      // then it continues from here\n    }\n\n    // all the redeemed collateral is swapped for stables to repay the FL\n    uint256 stableLeftovers = stableAsset.balanceOf(address(this));\n    if (stableLeftovers > 0) {\n      uint256 borrowBalance = stableMarket.borrowBalanceCurrent(address(this));\n      if (borrowBalance > 0) {\n        // whatever is smaller\n        uint256 amountToRepay = borrowBalance > stableLeftovers ? stableLeftovers : borrowBalance;\n        stableAsset.approve(address(stableMarket), amountToRepay);\n        stableMarket.repayBorrow(amountToRepay);\n      }\n    }\n  }\n\n  function _leverDownPostFL(uint256 _flashLoanedCollateral, uint256 _amountToRedeem) internal {\n    // repay the borrows\n    uint256 borrowBalance = stableMarket.borrowBalanceCurrent(address(this));\n    uint256 repayAmount = _flashLoanedCollateral < borrowBalance ? _flashLoanedCollateral : borrowBalance;\n    stableAsset.approve(address(stableMarket), repayAmount);\n    uint256 errorCode = stableMarket.repayBorrow(repayAmount);\n    if (errorCode != 0) revert RepayBorrowFailed(errorCode);\n\n    // redeem the corresponding amount needed to repay the FL\n    errorCode = collateralMarket.redeemUnderlying(_amountToRedeem);\n    if (errorCode != 0) revert RedeemCollateralFailed(errorCode);\n\n    // swap for the FL asset\n    convertAllTo(collateralAsset, stableAsset);\n  }\n\n  function convertAllTo(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    private\n    returns (uint256 outputAmount)\n  {\n    uint256 inputAmount = inputToken.balanceOf(address(this));\n    (IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategiesData) = factory\n      .getRedemptionStrategies(inputToken, outputToken);\n\n    if (redemptionStrategies.length == 0) revert ConvertFundsFailed();\n\n    for (uint256 i = 0; i < redemptionStrategies.length; i++) {\n      IRedemptionStrategy redemptionStrategy = redemptionStrategies[i];\n      bytes memory strategyData = strategiesData[i];\n      (outputToken, outputAmount) = convertCustomFunds(inputToken, inputAmount, redemptionStrategy, strategyData);\n      inputAmount = outputAmount;\n      inputToken = outputToken;\n    }\n  }\n\n  function convertCustomFunds(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IRedemptionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.redeem.selector, inputToken, inputAmount, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\nimport { DiamondBase, DiamondExtension, LibDiamond } from \"../../ionic/DiamondExtension.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract LeveredPositionFactory is LeveredPositionFactoryStorage, DiamondBase {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /*----------------------------------------------------------------\n                            Constructor\n  ----------------------------------------------------------------*/\n\n  constructor(\n    IFeeDistributor _feeDistributor,\n    ILiquidatorsRegistry _registry,\n    uint256 _blocksPerYear\n  ) {\n    feeDistributor = _feeDistributor;\n    liquidatorsRegistry = _registry;\n    blocksPerYear = _blocksPerYear;\n  }\n\n  /*----------------------------------------------------------------\n                            Admin Functions\n  ----------------------------------------------------------------*/\n\n  function _setPairWhitelisted(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    bool _whitelisted\n  ) external onlyOwner {\n    require(_collateralMarket.comptroller() == _stableMarket.comptroller(), \"markets not of the same pool\");\n\n    if (_whitelisted) {\n      collateralMarkets.add(address(_collateralMarket));\n      borrowableMarketsByCollateral[_collateralMarket].add(address(_stableMarket));\n    } else {\n      borrowableMarketsByCollateral[_collateralMarket].remove(address(_stableMarket));\n      if (borrowableMarketsByCollateral[_collateralMarket].length() == 0)\n        collateralMarkets.remove(address(_collateralMarket));\n    }\n  }\n\n  function _setLiquidatorsRegistry(ILiquidatorsRegistry _liquidatorsRegistry) external onlyOwner {\n    liquidatorsRegistry = _liquidatorsRegistry;\n  }\n\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace)\n    public\n    override\n    onlyOwner\n  {\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\n  }\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionFactoryFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../../ionic/DiamondExtension.sol\";\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\nimport { ILeveredPositionFactoryFirstExtension } from \"./ILeveredPositionFactory.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\nimport { IComptroller, IPriceOracle } from \"../../external/compound/IComptroller.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { AuthoritiesRegistry } from \"../AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../PoolRolesAuthority.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract LeveredPositionFactoryFirstExtension is\n  LeveredPositionFactoryStorage,\n  DiamondExtension,\n  ILeveredPositionFactoryFirstExtension\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error PairNotWhitelisted();\n  error NoSuchPosition();\n  error PositionNotClosed();\n\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\n    uint8 fnsCount = 9;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.removeClosedPosition.selector;\n    functionSelectors[--fnsCount] = this.closeAndRemoveUserPosition.selector;\n    functionSelectors[--fnsCount] = this.getMinBorrowNative.selector;\n    functionSelectors[--fnsCount] = this.getRedemptionStrategies.selector;\n    functionSelectors[--fnsCount] = this.getBorrowableMarketsByCollateral.selector;\n    functionSelectors[--fnsCount] = this.getWhitelistedCollateralMarkets.selector;\n    functionSelectors[--fnsCount] = this.getAccountsWithOpenPositions.selector;\n    functionSelectors[--fnsCount] = this.getPositionsByAccount.selector;\n    functionSelectors[--fnsCount] = this.getPositionsExtension.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  /*----------------------------------------------------------------\n                          Mutable Functions\n  ----------------------------------------------------------------*/\n\n  // @return true if removed, otherwise false\n  function removeClosedPosition(address closedPosition) external returns (bool) {\n    return _removeClosedPosition(closedPosition, msg.sender);\n  }\n\n  function closeAndRemoveUserPosition(LeveredPosition position) external onlyOwner returns (bool) {\n    address positionOwner = position.positionOwner();\n    position.closePosition(positionOwner);\n    return _removeClosedPosition(address(position), positionOwner);\n  }\n\n  function _removeClosedPosition(address closedPosition, address positionOwner) internal returns (bool removed) {\n    EnumerableSet.AddressSet storage userPositions = positionsByAccount[positionOwner];\n    if (!userPositions.contains(closedPosition)) revert NoSuchPosition();\n    if (!LeveredPosition(closedPosition).isPositionClosed()) revert PositionNotClosed();\n\n    removed = userPositions.remove(closedPosition);\n    if (userPositions.length() == 0) accountsWithOpenPositions.remove(positionOwner);\n  }\n\n  /*----------------------------------------------------------------\n                            View Functions\n  ----------------------------------------------------------------*/\n\n  function getMinBorrowNative() external view returns (uint256) {\n    return feeDistributor.minBorrowEth();\n  }\n\n  function getRedemptionStrategies(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData)\n  {\n    return liquidatorsRegistry.getRedemptionStrategies(inputToken, outputToken);\n  }\n\n  function getPositionsByAccount(address account)\n    external\n    view\n    returns (address[] memory positions, bool[] memory closed)\n  {\n    positions = positionsByAccount[account].values();\n    closed = new bool[](positions.length);\n    for (uint256 i = 0; i < positions.length; i++) {\n      closed[i] = LeveredPosition(positions[i]).isPositionClosed();\n    }\n  }\n\n  function getAccountsWithOpenPositions() external view returns (address[] memory) {\n    return accountsWithOpenPositions.values();\n  }\n\n  function getWhitelistedCollateralMarkets() external view returns (address[] memory) {\n    return collateralMarkets.values();\n  }\n\n  function getBorrowableMarketsByCollateral(ICErc20 _collateralMarket) external view returns (address[] memory) {\n    return borrowableMarketsByCollateral[_collateralMarket].values();\n  }\n\n  function getPositionsExtension(bytes4 msgSig) external view returns (address) {\n    // TODO\n    return address(0);\n  }\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionFactorySecondExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../../ionic/DiamondExtension.sol\";\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\nimport { ILeveredPositionFactorySecondExtension } from \"./ILeveredPositionFactory.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\nimport { IComptroller, IPriceOracle } from \"../../external/compound/IComptroller.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { AuthoritiesRegistry } from \"../AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../PoolRolesAuthority.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract LeveredPositionFactorySecondExtension is\n  LeveredPositionFactoryStorage,\n  DiamondExtension,\n  ILeveredPositionFactorySecondExtension\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error PairNotWhitelisted();\n\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\n    uint8 fnsCount = 3;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.createPosition.selector;\n    functionSelectors[--fnsCount] = this.createAndFundPosition.selector;\n    functionSelectors[--fnsCount] = this.createAndFundPositionAtRatio.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  /*----------------------------------------------------------------\n                          Mutable Functions\n  ----------------------------------------------------------------*/\n\n  function createPosition(ICErc20 _collateralMarket, ICErc20 _stableMarket) public returns (LeveredPosition) {\n    if (!borrowableMarketsByCollateral[_collateralMarket].contains(address(_stableMarket))) revert PairNotWhitelisted();\n\n    LeveredPosition position = new LeveredPosition(msg.sender, _collateralMarket, _stableMarket);\n\n    accountsWithOpenPositions.add(msg.sender);\n    positionsByAccount[msg.sender].add(address(position));\n\n    AuthoritiesRegistry authoritiesRegistry = feeDistributor.authoritiesRegistry();\n    address poolAddress = address(_collateralMarket.comptroller());\n    PoolRolesAuthority poolAuth = authoritiesRegistry.poolsAuthorities(poolAddress);\n    if (address(poolAuth) != address(0)) {\n      authoritiesRegistry.setUserRole(poolAddress, address(position), poolAuth.LEVERED_POSITION_ROLE(), true);\n    }\n\n    return position;\n  }\n\n  function createAndFundPosition(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    IERC20Upgradeable _fundingAsset,\n    uint256 _fundingAmount\n  ) public returns (LeveredPosition) {\n    LeveredPosition position = createPosition(_collateralMarket, _stableMarket);\n    _fundingAsset.safeTransferFrom(msg.sender, address(this), _fundingAmount);\n    _fundingAsset.approve(address(position), _fundingAmount);\n    position.fundPosition(_fundingAsset, _fundingAmount);\n    return position;\n  }\n\n  function createAndFundPositionAtRatio(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    IERC20Upgradeable _fundingAsset,\n    uint256 _fundingAmount,\n    uint256 _leverageRatio\n  ) external returns (LeveredPosition) {\n    LeveredPosition position = createAndFundPosition(_collateralMarket, _stableMarket, _fundingAsset, _fundingAmount);\n    if (_leverageRatio > 1e18) {\n      position.adjustLeverageRatio(_leverageRatio);\n    }\n    return position;\n  }\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { SafeOwnable } from \"../../ionic/SafeOwnable.sol\";\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nabstract contract LeveredPositionFactoryStorage is SafeOwnable {\n  EnumerableSet.AddressSet internal accountsWithOpenPositions;\n  mapping(address => EnumerableSet.AddressSet) internal positionsByAccount;\n  EnumerableSet.AddressSet internal collateralMarkets;\n  mapping(ICErc20 => EnumerableSet.AddressSet) internal borrowableMarketsByCollateral;\n\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) private __unused;\n\n  IFeeDistributor public feeDistributor;\n  ILiquidatorsRegistry public liquidatorsRegistry;\n  uint256 public blocksPerYear;\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionsLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract LeveredPositionsLens is Initializable {\n  ILeveredPositionFactory public factory;\n\n  function initialize(ILeveredPositionFactory _factory) external initializer {\n    factory = _factory;\n  }\n\n  function reinitialize(ILeveredPositionFactory _factory) external reinitializer(2) {\n    factory = _factory;\n  }\n\n  /// @notice this is a lens fn, it is not intended to be used on-chain\n  /// @dev returns lists of the market addresses, names and symbols of the underlying assets of those collateral markets that are whitelisted\n  function getCollateralMarkets()\n    external\n    view\n    returns (\n      address[] memory markets,\n      IonicComptroller[] memory poolOfMarket,\n      address[] memory underlyings,\n      uint256[] memory underlyingPrices,\n      string[] memory names,\n      string[] memory symbols,\n      uint8[] memory decimals,\n      uint256[] memory totalUnderlyingSupplied,\n      uint256[] memory ratesPerBlock\n    )\n  {\n    markets = factory.getWhitelistedCollateralMarkets();\n    poolOfMarket = new IonicComptroller[](markets.length);\n    underlyings = new address[](markets.length);\n    underlyingPrices = new uint256[](markets.length);\n    names = new string[](markets.length);\n    symbols = new string[](markets.length);\n    totalUnderlyingSupplied = new uint256[](markets.length);\n    decimals = new uint8[](markets.length);\n    ratesPerBlock = new uint256[](markets.length);\n    for (uint256 i = 0; i < markets.length; i++) {\n      ICErc20 market = ICErc20(markets[i]);\n      poolOfMarket[i] = market.comptroller();\n      underlyingPrices[i] = BasePriceOracle(poolOfMarket[i].oracle()).getUnderlyingPrice(market);\n      underlyings[i] = market.underlying();\n      ERC20Upgradeable underlying = ERC20Upgradeable(underlyings[i]);\n      names[i] = underlying.name();\n      symbols[i] = underlying.symbol();\n      decimals[i] = underlying.decimals();\n      totalUnderlyingSupplied[i] = market.getTotalUnderlyingSupplied();\n      ratesPerBlock[i] = market.supplyRatePerBlock();\n    }\n  }\n\n  /// @notice this is a lens fn, it is not intended to be used on-chain\n  /// @dev returns the Rate for the chosen borrowable at the specified leverage ratio and supply amount\n  function getBorrowRateAtRatio(\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    uint256 _equityAmount,\n    uint256 _targetLeverageRatio\n  ) external view returns (uint256) {\n    IonicComptroller pool = IonicComptroller(_stableMarket.comptroller());\n    BasePriceOracle oracle = pool.oracle();\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(_stableMarket);\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(_collateralMarket);\n\n    uint256 borrowAmount = ((_targetLeverageRatio - 1e18) * _equityAmount * collateralAssetPrice) /\n      (stableAssetPrice * 1e18);\n    return _stableMarket.borrowRatePerBlockAfterBorrow(borrowAmount) * factory.blocksPerYear();\n  }\n\n  /// @notice this is a lens fn, it is not intended to be used on-chain\n  /// @dev returns lists of the market addresses, names, symbols and the current Rate for each Borrowable asset\n  function getBorrowableMarketsAndRates(ICErc20 _collateralMarket)\n    external\n    view\n    returns (\n      address[] memory markets,\n      address[] memory underlyings,\n      uint256[] memory underlyingsPrices,\n      string[] memory names,\n      string[] memory symbols,\n      uint256[] memory rates,\n      uint8[] memory decimals\n    )\n  {\n    markets = factory.getBorrowableMarketsByCollateral(_collateralMarket);\n    underlyings = new address[](markets.length);\n    names = new string[](markets.length);\n    symbols = new string[](markets.length);\n    rates = new uint256[](markets.length);\n    decimals = new uint8[](markets.length);\n    underlyingsPrices = new uint256[](markets.length);\n    for (uint256 i = 0; i < markets.length; i++) {\n      ICErc20 market = ICErc20(markets[i]);\n      address underlyingAddress = market.underlying();\n      underlyings[i] = underlyingAddress;\n      ERC20Upgradeable underlying = ERC20Upgradeable(underlyingAddress);\n      names[i] = underlying.name();\n      symbols[i] = underlying.symbol();\n      rates[i] = market.borrowRatePerBlock();\n      decimals[i] = underlying.decimals();\n      underlyingsPrices[i] = market.comptroller().oracle().getUnderlyingPrice(market);\n    }\n  }\n\n  /// @notice this is a lens fn, it is not intended to be used on-chain\n  function getNetAPY(\n    uint256 _supplyAPY,\n    uint256 _supplyAmount,\n    ICErc20 _collateralMarket,\n    ICErc20 _stableMarket,\n    uint256 _targetLeverageRatio\n  ) public view returns (int256 netAPY) {\n    if (_supplyAmount == 0 || _targetLeverageRatio <= 1e18) return 0;\n\n    IonicComptroller pool = IonicComptroller(_collateralMarket.comptroller());\n    BasePriceOracle oracle = pool.oracle();\n    // TODO the calcs can be implemented without using collateralAssetPrice\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(_collateralMarket);\n\n    // total collateral = base collateral + levered collateral\n    uint256 totalCollateral = (_supplyAmount * _targetLeverageRatio) / 1e18;\n    uint256 yieldFromTotalSupplyScaled = _supplyAPY * totalCollateral;\n    int256 yieldValueScaled = int256((yieldFromTotalSupplyScaled * collateralAssetPrice) / 1e18);\n\n    uint256 borrowedValueScaled = (totalCollateral - _supplyAmount) * collateralAssetPrice;\n    uint256 _borrowRate = _stableMarket.borrowRatePerBlock() * factory.blocksPerYear();\n    int256 borrowInterestValueScaled = int256((_borrowRate * borrowedValueScaled) / 1e18);\n\n    int256 netValueDiffScaled = yieldValueScaled - borrowInterestValueScaled;\n\n    netAPY = ((netValueDiffScaled / int256(collateralAssetPrice)) * 1e18) / int256(_supplyAmount);\n  }\n\n  function getPositionsInfo(LeveredPosition[] calldata positions, uint256[] calldata supplyApys)\n    external\n    view\n    returns (PositionInfo[] memory infos)\n  {\n    infos = new PositionInfo[](positions.length);\n    for (uint256 i = 0; i < positions.length; i++) {\n      infos[i] = getPositionInfo(positions[i], supplyApys[i]);\n    }\n  }\n\n  function getLeverageRatioAfterFunding(LeveredPosition pos, uint256 newFunding) public view returns (uint256) {\n    uint256 equityAmount = pos.getEquityAmount();\n    if (equityAmount == 0 && newFunding == 0) return 0;\n\n    uint256 suppliedCollateralCurrent = pos.collateralMarket().balanceOfUnderlying(address(pos));\n    return ((suppliedCollateralCurrent + newFunding) * 1e18) / (equityAmount + newFunding);\n  }\n\n  function getNetApyForPositionAfterFunding(\n    LeveredPosition pos,\n    uint256 supplyAPY,\n    uint256 newFunding\n  ) public view returns (int256) {\n    return\n      getNetAPY(\n        supplyAPY,\n        pos.getEquityAmount() + newFunding,\n        pos.collateralMarket(),\n        pos.stableMarket(),\n        getLeverageRatioAfterFunding(pos, newFunding)\n      );\n  }\n\n  function getNetApyForPosition(LeveredPosition pos, uint256 supplyAPY) public view returns (int256) {\n    return getNetApyForPositionAfterFunding(pos, supplyAPY, 0);\n  }\n\n  struct PositionInfo {\n    uint256 collateralAssetPrice;\n    uint256 borrowedAssetPrice;\n    uint256 positionSupplyAmount;\n    uint256 positionValue;\n    uint256 debtAmount;\n    uint256 debtValue;\n    uint256 equityAmount;\n    uint256 equityValue;\n    int256 currentApy;\n    uint256 debtRatio;\n    uint256 liquidationThreshold;\n    uint256 safetyBuffer;\n  }\n\n  function getPositionInfo(LeveredPosition pos, uint256 supplyApy) public view returns (PositionInfo memory info) {\n    ICErc20 collateralMarket = pos.collateralMarket();\n    IonicComptroller pool = pos.pool();\n    info.collateralAssetPrice = pool.oracle().getUnderlyingPrice(collateralMarket);\n    {\n      info.positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(pos));\n      info.positionValue = (info.collateralAssetPrice * info.positionSupplyAmount) / 1e18;\n      info.currentApy = getNetApyForPosition(pos, supplyApy);\n    }\n\n    {\n      ICErc20 stableMarket = pos.stableMarket();\n      info.borrowedAssetPrice = pool.oracle().getUnderlyingPrice(stableMarket);\n      info.debtAmount = stableMarket.borrowBalanceCurrent(address(pos));\n      info.debtValue = (info.borrowedAssetPrice * info.debtAmount) / 1e18;\n      info.equityValue = info.positionValue - info.debtValue;\n      info.debtRatio = info.positionValue == 0 ? 0 : (info.debtValue * 1e18) / info.positionValue;\n      info.equityAmount = (info.equityValue * 1e18) / info.collateralAssetPrice;\n    }\n\n    {\n      (, uint256 collateralFactor) = pool.markets(address(collateralMarket));\n      info.liquidationThreshold = collateralFactor;\n      info.safetyBuffer = collateralFactor - info.debtRatio;\n    }\n  }\n}\n"
    },
    "contracts/ionic/levered/LeveredPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract LeveredPositionStorage {\n  address public immutable positionOwner;\n  ILeveredPositionFactory public factory;\n\n  ICErc20 public collateralMarket;\n  ICErc20 public stableMarket;\n  IonicComptroller public pool;\n\n  IERC20Upgradeable public collateralAsset;\n  IERC20Upgradeable public stableAsset;\n\n  constructor(address _positionOwner) {\n    positionOwner = _positionOwner;\n  }\n}\n"
    },
    "contracts/ionic/PoolRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IonicComptroller, ComptrollerInterface } from \"../compound/ComptrollerInterface.sol\";\nimport { ICErc20, CTokenSecondExtensionInterface, CTokenFirstExtensionInterface } from \"../compound/CTokenInterfaces.sol\";\n\nimport { RolesAuthority, Authority } from \"solmate/auth/authorities/RolesAuthority.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\ncontract PoolRolesAuthority is RolesAuthority, Initializable {\n  constructor() RolesAuthority(address(0), Authority(address(0))) {\n    _disableInitializers();\n  }\n\n  function initialize(address _owner) public initializer {\n    owner = _owner;\n    authority = this;\n  }\n\n  // up to 256 roles\n  uint8 public constant REGISTRY_ROLE = 0;\n  uint8 public constant SUPPLIER_ROLE = 1;\n  uint8 public constant BORROWER_ROLE = 2;\n  uint8 public constant LIQUIDATOR_ROLE = 3;\n  uint8 public constant LEVERED_POSITION_ROLE = 4;\n\n  function configureRegistryCapabilities() external requiresAuth {\n    setRoleCapability(REGISTRY_ROLE, address(this), PoolRolesAuthority.configureRegistryCapabilities.selector, true);\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configurePoolSupplierCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configurePoolBorrowerCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureClosedPoolLiquidatorCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureOpenPoolLiquidatorCapabilities.selector,\n      true\n    );\n    setRoleCapability(\n      REGISTRY_ROLE,\n      address(this),\n      PoolRolesAuthority.configureLeveredPositionCapabilities.selector,\n      true\n    );\n    setRoleCapability(REGISTRY_ROLE, address(this), RolesAuthority.setUserRole.selector, true);\n  }\n\n  function openPoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolSupplierCapabilities(pool, true);\n  }\n\n  function closePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolSupplierCapabilities(pool, false);\n  }\n\n  function _setPublicPoolSupplierCapabilities(IonicComptroller pool, bool setPublic) internal {\n    setPublicCapability(address(pool), pool.enterMarkets.selector, setPublic);\n    setPublicCapability(address(pool), pool.exitMarket.selector, setPublic);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      bytes4[] memory selectors = getSupplierMarketSelectors();\n      for (uint256 j = 0; j < selectors.length; j++) {\n        setPublicCapability(address(allMarkets[i]), selectors[j], setPublic);\n      }\n    }\n  }\n\n  function configurePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\n    _configurePoolSupplierCapabilities(pool, SUPPLIER_ROLE);\n  }\n\n  function getSupplierMarketSelectors() internal pure returns (bytes4[] memory selectors) {\n    uint8 fnsCount = 6;\n    selectors = new bytes4[](fnsCount);\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.mint.selector;\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeem.selector;\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeemUnderlying.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transfer.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transferFrom.selector;\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.approve.selector;\n\n    require(fnsCount == 0, \"use the correct array length\");\n    return selectors;\n  }\n\n  function _configurePoolSupplierCapabilities(IonicComptroller pool, uint8 role) internal {\n    setRoleCapability(role, address(pool), pool.enterMarkets.selector, true);\n    setRoleCapability(role, address(pool), pool.exitMarket.selector, true);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      bytes4[] memory selectors = getSupplierMarketSelectors();\n      for (uint256 j = 0; j < selectors.length; j++) {\n        setRoleCapability(role, address(allMarkets[i]), selectors[j], true);\n      }\n    }\n  }\n\n  function openPoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolBorrowerCapabilities(pool, true);\n  }\n\n  function closePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    _setPublicPoolBorrowerCapabilities(pool, false);\n  }\n\n  function _setPublicPoolBorrowerCapabilities(IonicComptroller pool, bool setPublic) internal {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].borrow.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrow.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, setPublic);\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].flash.selector, setPublic);\n    }\n  }\n\n  function configurePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\n    // borrowers have the SUPPLIER_ROLE capabilities by default\n    _configurePoolSupplierCapabilities(pool, BORROWER_ROLE);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, true);\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\n    }\n  }\n\n  function configureClosedPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, false);\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n    }\n  }\n\n  function configureOpenPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\n      // TODO this leaves redeeming open for everyone\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n    }\n  }\n\n  function configureLeveredPositionCapabilities(IonicComptroller pool) external requiresAuth {\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.enterMarkets.selector, true);\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.exitMarket.selector, true);\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].mint.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeemUnderlying.selector, true);\n\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\n    }\n  }\n}\n"
    },
    "contracts/ionic/RewardsClaimer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.10;\n\nimport { Initializable } from \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport { SafeERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract RewardsClaimer is Initializable {\n  using SafeERC20Upgradeable for ERC20Upgradeable;\n\n  event RewardDestinationUpdate(address indexed newDestination);\n\n  event ClaimRewards(address indexed rewardToken, uint256 amount);\n\n  /// @notice the address to send rewards\n  address public rewardDestination;\n\n  /// @notice the array of reward tokens to send to\n  ERC20Upgradeable[] public rewardTokens;\n\n  function __RewardsClaimer_init(address _rewardDestination, ERC20Upgradeable[] memory _rewardTokens)\n    internal\n    onlyInitializing\n  {\n    rewardDestination = _rewardDestination;\n    rewardTokens = _rewardTokens;\n  }\n\n  /// @notice claim all token rewards\n  function claimRewards() public {\n    beforeClaim(); // hook to accrue/pull in rewards, if needed\n\n    uint256 len = rewardTokens.length;\n    // send all tokens to destination\n    for (uint256 i = 0; i < len; i++) {\n      ERC20Upgradeable token = rewardTokens[i];\n      uint256 amount = token.balanceOf(address(this));\n\n      token.safeTransfer(rewardDestination, amount);\n\n      emit ClaimRewards(address(token), amount);\n    }\n  }\n\n  /// @notice set the address of the new reward destination\n  /// @param newDestination the new reward destination\n  function setRewardDestination(address newDestination) external {\n    require(msg.sender == rewardDestination, \"UNAUTHORIZED\");\n    rewardDestination = newDestination;\n    emit RewardDestinationUpdate(newDestination);\n  }\n\n  /// @notice hook to accrue/pull in rewards, if needed\n  function beforeClaim() internal virtual {}\n}\n"
    },
    "contracts/ionic/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nabstract contract SafeOwnable is Ownable2Step {\n  function renounceOwnership() public override onlyOwner {\n    revert(\"renounce ownership not allowed\");\n  }\n}\n"
    },
    "contracts/ionic/SafeOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\n\n/**\n * @dev Ownable extension that requires a two-step process of setting the pending owner and the owner accepting it.\n * @notice Existing OwnableUpgradeable contracts cannot be upgraded due to the extra storage variable\n * that will shift the other.\n */\nabstract contract SafeOwnableUpgradeable is OwnableUpgradeable {\n  /**\n   * @notice Pending owner of this contract\n   */\n  address public pendingOwner;\n\n  function __SafeOwnable_init(address owner_) internal onlyInitializing {\n    __Ownable_init();\n    _transferOwnership(owner_);\n  }\n\n  struct AddressSlot {\n    address value;\n  }\n\n  modifier onlyOwnerOrAdmin() {\n    bool isOwner = owner() == _msgSender();\n    if (!isOwner) {\n      address admin = _getProxyAdmin();\n      bool isAdmin = admin == _msgSender();\n      require(isAdmin, \"Ownable: caller is neither the owner nor the admin\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Emitted when pendingOwner is changed\n   */\n  event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\n\n  /**\n   * @notice Emitted when pendingOwner is accepted, which means owner is updated\n   */\n  event NewOwner(address oldOwner, address newOwner);\n\n  /**\n   * @notice Begins transfer of owner rights. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\n   * @dev Owner function to begin change of owner. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\n   * @param newPendingOwner New pending owner.\n   */\n  function _setPendingOwner(address newPendingOwner) public onlyOwner {\n    // Save current value, if any, for inclusion in log\n    address oldPendingOwner = pendingOwner;\n\n    // Store pendingOwner with value newPendingOwner\n    pendingOwner = newPendingOwner;\n\n    // Emit NewPendingOwner(oldPendingOwner, newPendingOwner)\n    emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n  }\n\n  /**\n   * @notice Accepts transfer of owner rights. msg.sender must be pendingOwner\n   * @dev Owner function for pending owner to accept role and update owner\n   */\n  function _acceptOwner() public {\n    // Check caller is pendingOwner and pendingOwner  address(0)\n    require(msg.sender == pendingOwner, \"not the pending owner\");\n\n    // Save current values for inclusion in log\n    address oldOwner = owner();\n    address oldPendingOwner = pendingOwner;\n\n    // Store owner with value pendingOwner\n    _transferOwnership(pendingOwner);\n\n    // Clear the pending value\n    pendingOwner = address(0);\n\n    emit NewOwner(oldOwner, pendingOwner);\n    emit NewPendingOwner(oldPendingOwner, pendingOwner);\n  }\n\n  function renounceOwnership() public override onlyOwner {\n    // do not remove this overriding fn\n    revert(\"not used anymore\");\n  }\n\n  function transferOwnership(address newOwner) public override onlyOwner {\n    emit NewPendingOwner(pendingOwner, newOwner);\n    pendingOwner = newOwner;\n  }\n\n  function _getProxyAdmin() internal view returns (address admin) {\n    bytes32 _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    AddressSlot storage adminSlot;\n    assembly {\n      adminSlot.slot := _ADMIN_SLOT\n    }\n    admin = adminSlot.value;\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/FlywheelCore.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\nimport {IFlywheelRewards} from \"./rewards/IFlywheelRewards.sol\";\nimport {IFlywheelBooster} from \"./IFlywheelBooster.sol\";\n\n/**\n @title Flywheel Core Incentives Manager\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Core contract maintaings three important pieces of state:\n         * the rewards index which determines how many rewards are owed per token per strategy. User indexes track how far behind the strategy they are to lazily calculate all catch-up rewards.\n         * the accrued (unclaimed) rewards per user.\n         * references to the booster and rewards module described below.\n\n         Core does not manage any tokens directly. The rewards module maintains token balances, and approves core to pull transfer them to users when they claim.\n\n         SECURITY NOTE: For maximum accuracy and to avoid exploits, rewards accrual should be notified atomically through the accrue hook. \n         Accrue should be called any time tokens are transferred, minted, or burned.\n */\ncontract FlywheelCore is Auth {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    /// @notice The token to reward\n    ERC20 public immutable rewardToken;\n\n    /// @notice append-only list of strategies added\n    ERC20[] public allStrategies;\n\n    /// @notice the rewards contract for managing streams\n    IFlywheelRewards public flywheelRewards;\n\n    /// @notice optional booster module for calculating virtual balances on strategies\n    IFlywheelBooster public flywheelBooster;\n\n    constructor(\n        ERC20 _rewardToken,\n        IFlywheelRewards _flywheelRewards,\n        IFlywheelBooster _flywheelBooster,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) {\n        rewardToken = _rewardToken;\n        flywheelRewards = _flywheelRewards;\n        flywheelBooster = _flywheelBooster;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ACCRUE/CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a user's rewards accrue to a given strategy.\n      @param strategy the updated rewards strategy\n      @param user the user of the rewards\n      @param rewardsDelta how many new rewards accrued to the user\n      @param rewardsIndex the market index for rewards per token accrued\n    */\n    event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n    /** \n      @notice Emitted when a user claims accrued rewards.\n      @param user the user of the rewards\n      @param amount the amount of rewards claimed\n    */\n    event ClaimRewards(address indexed user, uint256 amount);\n\n    /// @notice The accrued but not yet transferred rewards for each user\n    mapping(address => uint256) public rewardsAccrued;\n\n    /** \n      @notice accrue rewards for a single user on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the user to be accrued\n      @return the cumulative amount of rewards accrued to user (including prior)\n    */\n    function accrue(ERC20 strategy, address user) public returns (uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return 0;\n\n        state = accrueStrategy(strategy, state);\n        return accrueUser(strategy, user, state);\n    }\n\n    /** \n      @notice accrue rewards for a two users on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the first user to be accrued\n      @param user the second user to be accrued\n      @return the cumulative amount of rewards accrued to the first user (including prior)\n      @return the cumulative amount of rewards accrued to the second user (including prior)\n    */\n    function accrue(\n        ERC20 strategy,\n        address user,\n        address secondUser\n    ) public returns (uint256, uint256) {\n        RewardsState memory state = strategyState[strategy];\n\n        if (state.index == 0) return (0, 0);\n\n        state = accrueStrategy(strategy, state);\n        return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\n    }\n\n    /** \n      @notice claim rewards for a given user\n      @param user the user claiming rewards\n      @dev this function is public, and all rewards transfer to the user\n    */\n    function claimRewards(address user) external {\n        uint256 accrued = rewardsAccrued[user];\n\n        if (accrued != 0) {\n            rewardsAccrued[user] = 0;\n\n            rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n            emit ClaimRewards(user, accrued);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /** \n      @notice Emitted when a new strategy is added to flywheel by the admin\n      @param newStrategy the new added strategy\n    */\n    event AddStrategy(address indexed newStrategy);\n\n    /// @notice initialize a new strategy\n    function addStrategyForRewards(ERC20 strategy) external requiresAuth {\n        _addStrategyForRewards(strategy);\n    }\n\n    function _addStrategyForRewards(ERC20 strategy) internal {\n        require(strategyState[strategy].index == 0, \"strategy\");\n        strategyState[strategy] = RewardsState({index: ONE, lastUpdatedTimestamp: block.timestamp.safeCastTo32()});\n\n        allStrategies.push(strategy);\n        emit AddStrategy(address(strategy));\n    }\n\n    function getAllStrategies() external view returns (ERC20[] memory) {\n        return allStrategies;\n    }\n\n    /** \n      @notice Emitted when the rewards module changes\n      @param newFlywheelRewards the new rewards module\n    */\n    event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\n\n    /// @notice swap out the flywheel rewards contract\n    function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {\n        uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n        if (oldRewardBalance > 0) {\n            rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n        }\n\n        flywheelRewards = newFlywheelRewards;\n\n        emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n    }\n\n    /** \n      @notice Emitted when the booster module changes\n      @param newBooster the new booster module\n    */\n    event FlywheelBoosterUpdate(address indexed newBooster);\n\n    /// @notice swap out the flywheel booster contract\n    function setBooster(IFlywheelBooster newBooster) external requiresAuth {\n        flywheelBooster = newBooster;\n\n        emit FlywheelBoosterUpdate(address(newBooster));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    struct RewardsState {\n        /// @notice The strategy's last updated index\n        uint224 index;\n        /// @notice The timestamp the index was last updated at\n        uint32 lastUpdatedTimestamp;\n    }\n\n    /// @notice the fixed point factor of flywheel\n    uint224 public constant ONE = 1e18;\n\n    /// @notice The strategy index and last updated per strategy\n    mapping(ERC20 => RewardsState) public strategyState;\n\n    /// @notice user index per strategy\n    mapping(ERC20 => mapping(address => uint224)) public userIndex;\n\n    /// @notice accumulate global rewards on a strategy\n    function accrueStrategy(ERC20 strategy, RewardsState memory state)\n        private\n        returns (RewardsState memory rewardsState)\n    {\n        // calculate accrued rewards through module\n        uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\n\n        rewardsState = state;\n        if (strategyRewardsAccrued > 0) {\n            // use the booster or token supply to calculate reward index denominator\n            uint256 supplyTokens = address(flywheelBooster) != address(0)\n                ? flywheelBooster.boostedTotalSupply(strategy)\n                : strategy.totalSupply();\n\n            uint224 deltaIndex;\n\n            if (supplyTokens != 0) deltaIndex = ((strategyRewardsAccrued * ONE) / supplyTokens).safeCastTo224();\n\n            // accumulate rewards per token onto the index, multiplied by fixed-point factor\n            rewardsState = RewardsState({\n                index: state.index + deltaIndex,\n                lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n            });\n            strategyState[strategy] = rewardsState;\n        }\n    }\n\n    /// @notice accumulate rewards on a strategy for a specific user\n    function accrueUser(\n        ERC20 strategy,\n        address user,\n        RewardsState memory state\n    ) private returns (uint256) {\n        // load indices\n        uint224 strategyIndex = state.index;\n        uint224 supplierIndex = userIndex[strategy][user];\n\n        // sync user index to global\n        userIndex[strategy][user] = strategyIndex;\n\n        // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n        // zero balances will have no effect other than syncing to global index\n        if (supplierIndex == 0) {\n            supplierIndex = ONE;\n        }\n\n        uint224 deltaIndex = strategyIndex - supplierIndex;\n        // use the booster or token balance to calculate reward balance multiplier\n        uint256 supplierTokens = address(flywheelBooster) != address(0)\n            ? flywheelBooster.boostedBalanceOf(strategy, user)\n            : strategy.balanceOf(user);\n\n        // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n        uint256 supplierDelta = (supplierTokens * deltaIndex) / ONE;\n        uint256 supplierAccrued = rewardsAccrued[user] + supplierDelta;\n\n        rewardsAccrued[user] = supplierAccrued;\n\n        emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\n\n        return supplierAccrued;\n    }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IFlywheelBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/**\n @title Balance Booster Module for Flywheel\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\n        \n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\n\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\n*/\ninterface IFlywheelBooster {\n    /**\n      @notice calculate the boosted supply of a strategy.\n      @param strategy the strategy to calculate boosted supply of\n      @return the boosted supply\n     */\n    function boostedTotalSupply(ERC20 strategy) external view returns (uint256);\n\n    /**\n      @notice calculate the boosted balance of a user in a given strategy.\n      @param strategy the strategy to calculate boosted balance of\n      @param user the user to calculate boosted balance of\n      @return the boosted balance\n     */\n    function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256);\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IIonicFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\ninterface IIonicFlywheel {\n  function isRewardsDistributor() external returns (bool);\n\n  function isFlywheel() external returns (bool);\n\n  function flywheelPreSupplierAction(address market, address supplier) external;\n\n  function flywheelPreBorrowerAction(address market, address borrower) external;\n\n  function flywheelPreTransferAction(address market, address src, address dst) external;\n\n  function compAccrued(address user) external view returns (uint256);\n\n  function addMarketForRewards(ERC20 strategy) external;\n\n  function marketState(ERC20 strategy) external view returns (uint224 index, uint32 lastUpdatedTimestamp);\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IIonicFlywheelBorrowBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\n/**\n @title Balance Booster Module for Flywheel\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\n        \n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\n\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\n*/\ninterface IIonicFlywheelBorrowBooster {\n  /**\n      @notice calculate the boosted supply of a strategy.\n      @param strategy the strategy to calculate boosted supply of\n      @return the boosted supply\n     */\n  function boostedTotalSupply(ICErc20 strategy) external view returns (uint256);\n\n  /**\n      @notice calculate the boosted balance of a user in a given strategy.\n      @param strategy the strategy to calculate boosted balance of\n      @param user the user to calculate boosted balance of\n      @return the boosted balance\n     */\n  function boostedBalanceOf(ICErc20 strategy, address user) external view returns (uint256);\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { IonicFlywheelCore } from \"./IonicFlywheelCore.sol\";\nimport \"./IIonicFlywheel.sol\";\n\ncontract IonicFlywheel is IonicFlywheelCore, IIonicFlywheel {\n  bool public constant isRewardsDistributor = true;\n  bool public constant isFlywheel = true;\n\n  function flywheelPreSupplierAction(address market, address supplier) external {\n    accrue(ERC20(market), supplier);\n  }\n\n  function flywheelPreBorrowerAction(address market, address borrower) external {}\n\n  function flywheelPreTransferAction(address market, address src, address dst) external {\n    accrue(ERC20(market), src, dst);\n  }\n\n  function compAccrued(address user) external view returns (uint256) {\n    return _rewardsAccrued[user];\n  }\n\n  function addMarketForRewards(ERC20 strategy) external onlyOwner {\n    _addStrategyForRewards(strategy);\n  }\n\n  // TODO remove\n  function marketState(ERC20 strategy) external view returns (uint224, uint32) {\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelBorrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { IonicFlywheelCore } from \"./IonicFlywheelCore.sol\";\nimport \"./IIonicFlywheel.sol\";\n\ncontract IonicFlywheelBorrow is IonicFlywheelCore, IIonicFlywheel {\n  bool public constant isRewardsDistributor = true;\n  bool public constant isFlywheel = true;\n\n  function flywheelPreSupplierAction(address market, address supplier) external {}\n\n  function flywheelPreBorrowerAction(address market, address borrower) external {\n    accrue(ERC20(market), borrower);\n  }\n\n  function flywheelPreTransferAction(address market, address src, address dst) external {}\n\n  function compAccrued(address user) external view returns (uint256) {\n    return _rewardsAccrued[user];\n  }\n\n  function addMarketForRewards(ERC20 strategy) external onlyOwner {\n    _addStrategyForRewards(strategy);\n  }\n\n  // TODO remove\n  function marketState(ERC20 strategy) external view returns (uint224, uint32) {\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelBorrowBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\nimport \"./IIonicFlywheelBorrowBooster.sol\";\n\ncontract IonicFlywheelBorrowBooster is IIonicFlywheelBorrowBooster {\n  string public constant BOOSTER_TYPE = \"FlywheelBorrowBooster\";\n\n  /**\n      @notice calculate the boosted supply of a strategy.\n      @param strategy the strategy to calculate boosted supply of\n      @return the boosted supply\n     */\n  function boostedTotalSupply(ICErc20 strategy) external view returns (uint256) {\n    return strategy.totalBorrows();\n  }\n\n  /**\n      @notice calculate the boosted balance of a user in a given strategy.\n      @param strategy the strategy to calculate boosted balance of\n      @param user the user to calculate boosted balance of\n      @return the boosted balance\n     */\n  function boostedBalanceOf(ICErc20 strategy, address user) external view returns (uint256) {\n    return strategy.borrowBalanceCurrent(user);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelCore.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\n\nimport { IFlywheelRewards } from \"./rewards/IFlywheelRewards.sol\";\nimport { IFlywheelBooster } from \"./IFlywheelBooster.sol\";\n\nimport { SafeOwnableUpgradeable } from \"../../../ionic/SafeOwnableUpgradeable.sol\";\n\ncontract IonicFlywheelCore is SafeOwnableUpgradeable {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n\n  /// @notice How much rewardsToken will be send to treasury\n  uint256 public performanceFee;\n\n  /// @notice Address that gets rewardsToken accrued by performanceFee\n  address public feeRecipient;\n\n  /// @notice The token to reward\n  ERC20 public rewardToken;\n\n  /// @notice append-only list of strategies added\n  ERC20[] public allStrategies;\n\n  /// @notice the rewards contract for managing streams\n  IFlywheelRewards public flywheelRewards;\n\n  /// @notice optional booster module for calculating virtual balances on strategies\n  IFlywheelBooster public flywheelBooster;\n\n  /// @notice The accrued but not yet transferred rewards for each user\n  mapping(address => uint256) internal _rewardsAccrued;\n\n  /// @notice The strategy index and last updated per strategy\n  mapping(ERC20 => RewardsState) internal _strategyState;\n\n  /// @notice user index per strategy\n  mapping(ERC20 => mapping(address => uint224)) internal _userIndex;\n\n  constructor() {\n    // prevents the misusage of the implementation contract\n    _disableInitializers();\n  }\n\n  function initialize(\n    ERC20 _rewardToken,\n    IFlywheelRewards _flywheelRewards,\n    IFlywheelBooster _flywheelBooster,\n    address _owner\n  ) public initializer {\n    __SafeOwnable_init(msg.sender);\n\n    rewardToken = _rewardToken;\n    flywheelRewards = _flywheelRewards;\n    flywheelBooster = _flywheelBooster;\n\n    _transferOwnership(_owner);\n\n    performanceFee = 10e16; // 10%\n    feeRecipient = _owner;\n  }\n\n  /*----------------------------------------------------------------\n                        ACCRUE/CLAIM LOGIC\n    ----------------------------------------------------------------*/\n\n  /** \n      @notice Emitted when a user's rewards accrue to a given strategy.\n      @param strategy the updated rewards strategy\n      @param user the user of the rewards\n      @param rewardsDelta how many new rewards accrued to the user\n      @param rewardsIndex the market index for rewards per token accrued\n    */\n  event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\n\n  /** \n      @notice Emitted when a user claims accrued rewards.\n      @param user the user of the rewards\n      @param amount the amount of rewards claimed\n    */\n  event ClaimRewards(address indexed user, uint256 amount);\n\n  /** \n      @notice accrue rewards for a single user on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the user to be accrued\n      @return the cumulative amount of rewards accrued to user (including prior)\n    */\n  function accrue(ERC20 strategy, address user) public returns (uint256) {\n    (uint224 index, uint32 ts) = strategyState(strategy);\n    RewardsState memory state = RewardsState(index, ts);\n\n    if (state.index == 0) return 0;\n\n    state = accrueStrategy(strategy, state);\n    return accrueUser(strategy, user, state);\n  }\n\n  /** \n      @notice accrue rewards for a two users on a strategy\n      @param strategy the strategy to accrue a user's rewards on\n      @param user the first user to be accrued\n      @param user the second user to be accrued\n      @return the cumulative amount of rewards accrued to the first user (including prior)\n      @return the cumulative amount of rewards accrued to the second user (including prior)\n    */\n  function accrue(\n    ERC20 strategy,\n    address user,\n    address secondUser\n  ) public returns (uint256, uint256) {\n    (uint224 index, uint32 ts) = strategyState(strategy);\n    RewardsState memory state = RewardsState(index, ts);\n\n    if (state.index == 0) return (0, 0);\n\n    state = accrueStrategy(strategy, state);\n    return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\n  }\n\n  /** \n      @notice claim rewards for a given user\n      @param user the user claiming rewards\n      @dev this function is public, and all rewards transfer to the user\n    */\n  function claimRewards(address user) external {\n    uint256 accrued = rewardsAccrued(user);\n\n    if (accrued != 0) {\n      _rewardsAccrued[user] = 0;\n\n      rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\n\n      emit ClaimRewards(user, accrued);\n    }\n  }\n\n  /*----------------------------------------------------------------\n                          ADMIN LOGIC\n    ----------------------------------------------------------------*/\n\n  /** \n      @notice Emitted when a new strategy is added to flywheel by the admin\n      @param newStrategy the new added strategy\n    */\n  event AddStrategy(address indexed newStrategy);\n\n  /// @notice initialize a new strategy\n  function addStrategyForRewards(ERC20 strategy) external onlyOwner {\n    _addStrategyForRewards(strategy);\n  }\n\n  function _addStrategyForRewards(ERC20 strategy) internal {\n    (uint224 index, ) = strategyState(strategy);\n    require(index == 0, \"strategy\");\n    _strategyState[strategy] = RewardsState({\n      index: (10**rewardToken.decimals()).safeCastTo224(),\n      lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n    });\n\n    allStrategies.push(strategy);\n    emit AddStrategy(address(strategy));\n  }\n\n  function getAllStrategies() external view returns (ERC20[] memory) {\n    return allStrategies;\n  }\n\n  /** \n      @notice Emitted when the rewards module changes\n      @param newFlywheelRewards the new rewards module\n    */\n  event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\n\n  /// @notice swap out the flywheel rewards contract\n  function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external onlyOwner {\n    if (address(flywheelRewards) != address(0)) {\n      uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\n      if (oldRewardBalance > 0) {\n        rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\n      }\n    }\n\n    flywheelRewards = newFlywheelRewards;\n\n    emit FlywheelRewardsUpdate(address(newFlywheelRewards));\n  }\n\n  /** \n      @notice Emitted when the booster module changes\n      @param newBooster the new booster module\n    */\n  event FlywheelBoosterUpdate(address indexed newBooster);\n\n  /// @notice swap out the flywheel booster contract\n  function setBooster(IFlywheelBooster newBooster) external onlyOwner {\n    flywheelBooster = newBooster;\n\n    emit FlywheelBoosterUpdate(address(newBooster));\n  }\n\n  event UpdatedFeeSettings(\n    uint256 oldPerformanceFee,\n    uint256 newPerformanceFee,\n    address oldFeeRecipient,\n    address newFeeRecipient\n  );\n\n  /**\n   * @notice Update performanceFee and/or feeRecipient\n   * @dev Claim rewards first from the previous feeRecipient before changing it\n   */\n  function updateFeeSettings(uint256 _performanceFee, address _feeRecipient) external onlyOwner {\n    _updateFeeSettings(_performanceFee, _feeRecipient);\n  }\n\n  function _updateFeeSettings(uint256 _performanceFee, address _feeRecipient) internal {\n    emit UpdatedFeeSettings(performanceFee, _performanceFee, feeRecipient, _feeRecipient);\n\n    if (feeRecipient != _feeRecipient) {\n      _rewardsAccrued[_feeRecipient] += rewardsAccrued(feeRecipient);\n      _rewardsAccrued[feeRecipient] = 0;\n    }\n    performanceFee = _performanceFee;\n    feeRecipient = _feeRecipient;\n  }\n\n  /*----------------------------------------------------------------\n                    INTERNAL ACCOUNTING LOGIC\n    ----------------------------------------------------------------*/\n\n  struct RewardsState {\n    /// @notice The strategy's last updated index\n    uint224 index;\n    /// @notice The timestamp the index was last updated at\n    uint32 lastUpdatedTimestamp;\n  }\n\n  /// @notice accumulate global rewards on a strategy\n  function accrueStrategy(ERC20 strategy, RewardsState memory state)\n    private\n    returns (RewardsState memory rewardsState)\n  {\n    // calculate accrued rewards through module\n    uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\n\n    rewardsState = state;\n\n    if (strategyRewardsAccrued > 0) {\n      // use the booster or token supply to calculate reward index denominator\n      uint256 supplyTokens = address(flywheelBooster) != address(0)\n        ? flywheelBooster.boostedTotalSupply(strategy)\n        : strategy.totalSupply();\n\n      // 100% = 100e16\n      uint256 accruedFees = (strategyRewardsAccrued * performanceFee) / uint224(100e16);\n\n      _rewardsAccrued[feeRecipient] += accruedFees;\n      strategyRewardsAccrued -= accruedFees;\n\n      uint224 deltaIndex;\n\n      if (supplyTokens != 0)\n        deltaIndex = ((strategyRewardsAccrued * (10**strategy.decimals())) / supplyTokens).safeCastTo224();\n\n      // accumulate rewards per token onto the index, multiplied by fixed-point factor\n      rewardsState = RewardsState({\n        index: state.index + deltaIndex,\n        lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n      });\n      _strategyState[strategy] = rewardsState;\n    }\n  }\n\n  /// @notice accumulate rewards on a strategy for a specific user\n  function accrueUser(\n    ERC20 strategy,\n    address user,\n    RewardsState memory state\n  ) private returns (uint256) {\n    // load indices\n    uint224 strategyIndex = state.index;\n    uint224 supplierIndex = userIndex(strategy, user);\n\n    // sync user index to global\n    _userIndex[strategy][user] = strategyIndex;\n\n    // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n    // zero balances will have no effect other than syncing to global index\n    if (supplierIndex == 0) {\n      supplierIndex = (10**rewardToken.decimals()).safeCastTo224();\n    }\n\n    uint224 deltaIndex = strategyIndex - supplierIndex;\n    // use the booster or token balance to calculate reward balance multiplier\n    uint256 supplierTokens = address(flywheelBooster) != address(0)\n      ? flywheelBooster.boostedBalanceOf(strategy, user)\n      : strategy.balanceOf(user);\n\n    // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n    uint256 supplierDelta = (deltaIndex * supplierTokens) / (10**strategy.decimals());\n    uint256 supplierAccrued = rewardsAccrued(user) + supplierDelta;\n\n    _rewardsAccrued[user] = supplierAccrued;\n\n    emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\n\n    return supplierAccrued;\n  }\n\n  function rewardsAccrued(address user) public virtual returns (uint256) {\n    return _rewardsAccrued[user];\n  }\n\n  function userIndex(ERC20 strategy, address user) public virtual returns (uint224) {\n    return _userIndex[strategy][user];\n  }\n\n  function strategyState(ERC20 strategy) public virtual returns (uint224 index, uint32 lastUpdatedTimestamp) {\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelLensRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\nimport { IonicFlywheelCore } from \"./IonicFlywheelCore.sol\";\nimport { IonicComptroller } from \"../../../compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { PoolDirectory } from \"../../../PoolDirectory.sol\";\n\ninterface IPriceOracle_IFLR {\n  function getUnderlyingPrice(ERC20 cToken) external view returns (uint256);\n\n  function price(address underlying) external view returns (uint256);\n}\n\ncontract IonicFlywheelLensRouter {\n  PoolDirectory public fpd;\n\n  constructor(PoolDirectory _fpd) {\n    fpd = _fpd;\n  }\n\n  struct MarketRewardsInfo {\n    /// @dev comptroller oracle price of market underlying\n    uint256 underlyingPrice;\n    ICErc20 market;\n    RewardsInfo[] rewardsInfo;\n  }\n\n  struct RewardsInfo {\n    /// @dev rewards in `rewardToken` paid per underlying staked token in `market` per second\n    uint256 rewardSpeedPerSecondPerToken;\n    /// @dev comptroller oracle price of reward token\n    uint256 rewardTokenPrice;\n    /// @dev APR scaled by 1e18. Calculated as rewardSpeedPerSecondPerToken * rewardTokenPrice * 365.25 days / underlyingPrice * 1e18 / market.exchangeRate\n    uint256 formattedAPR;\n    address flywheel;\n    address rewardToken;\n  }\n\n  function getPoolMarketRewardsInfo(IonicComptroller comptroller) external returns (MarketRewardsInfo[] memory) {\n    ICErc20[] memory markets = comptroller.getAllMarkets();\n    return _getMarketRewardsInfo(markets, comptroller);\n  }\n\n  function getMarketRewardsInfo(ICErc20[] memory markets) external returns (MarketRewardsInfo[] memory) {\n    IonicComptroller pool;\n    for (uint256 i = 0; i < markets.length; i++) {\n      ICErc20 asMarket = ICErc20(address(markets[i]));\n      if (address(pool) == address(0)) pool = asMarket.comptroller();\n      else require(asMarket.comptroller() == pool);\n    }\n    return _getMarketRewardsInfo(markets, pool);\n  }\n\n  function _getMarketRewardsInfo(ICErc20[] memory markets, IonicComptroller comptroller)\n    internal\n    returns (MarketRewardsInfo[] memory)\n  {\n    if (address(comptroller) == address(0) || markets.length == 0) return new MarketRewardsInfo[](0);\n\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\n    address[] memory rewardTokens = new address[](flywheels.length);\n    uint256[] memory rewardTokenPrices = new uint256[](flywheels.length);\n    uint256[] memory rewardTokenDecimals = new uint256[](flywheels.length);\n    BasePriceOracle oracle = comptroller.oracle();\n\n    MarketRewardsInfo[] memory infoList = new MarketRewardsInfo[](markets.length);\n    for (uint256 i = 0; i < markets.length; i++) {\n      RewardsInfo[] memory rewardsInfo = new RewardsInfo[](flywheels.length);\n\n      ICErc20 market = ICErc20(address(markets[i]));\n      uint256 price = oracle.price(market.underlying()); // scaled to 1e18\n\n      if (i == 0) {\n        for (uint256 j = 0; j < flywheels.length; j++) {\n          ERC20 rewardToken = IonicFlywheelCore(flywheels[j]).rewardToken();\n          rewardTokens[j] = address(rewardToken);\n          rewardTokenPrices[j] = oracle.price(address(rewardToken)); // scaled to 1e18\n          rewardTokenDecimals[j] = uint256(rewardToken.decimals());\n        }\n      }\n\n      for (uint256 j = 0; j < flywheels.length; j++) {\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\n\n        uint256 rewardSpeedPerSecondPerToken = getRewardSpeedPerSecondPerToken(\n          flywheel,\n          market,\n          rewardTokenDecimals[j]\n        );\n        uint256 apr = getApr(\n          rewardSpeedPerSecondPerToken,\n          rewardTokenPrices[j],\n          price, \n          market.exchangeRateCurrent(),\n          address(flywheel.flywheelBooster()) != address(0)\n        );\n\n        rewardsInfo[j] = RewardsInfo({\n          rewardSpeedPerSecondPerToken: rewardSpeedPerSecondPerToken, // scaled in 1e18\n          rewardTokenPrice: rewardTokenPrices[j],\n          formattedAPR: apr, // scaled in 1e18\n          flywheel: address(flywheel),\n          rewardToken: rewardTokens[j]\n        });\n      }\n\n      infoList[i] = MarketRewardsInfo({ market: market, rewardsInfo: rewardsInfo, underlyingPrice: price });\n    }\n\n    return infoList;\n  }\n\n  function scaleIndexDiff(uint256 indexDiff, uint256 decimals) internal pure returns (uint256) {\n    return decimals <= 18 ? uint256(indexDiff) * (10**(18 - decimals)) : uint256(indexDiff) / (10**(decimals - 18));\n  }\n\n  function getRewardSpeedPerSecondPerToken(\n    IonicFlywheelCore flywheel,\n    ICErc20 market,\n    uint256 decimals\n  ) internal returns (uint256 rewardSpeedPerSecondPerToken) {\n    ERC20 strategy = ERC20(address(market));\n    (uint224 indexBefore, uint32 lastUpdatedTimestampBefore) = flywheel.strategyState(strategy);\n    flywheel.accrue(strategy, address(0));\n    (uint224 indexAfter, uint32 lastUpdatedTimestampAfter) = flywheel.strategyState(strategy);\n    if (lastUpdatedTimestampAfter > lastUpdatedTimestampBefore) {\n      rewardSpeedPerSecondPerToken =\n        scaleIndexDiff((indexAfter - indexBefore), decimals) /\n        (lastUpdatedTimestampAfter - lastUpdatedTimestampBefore);\n    }\n  }\n\n  function getApr(\n    uint256 rewardSpeedPerSecondPerToken,\n    uint256 rewardTokenPrice,\n    uint256 underlyingPrice,\n    uint256 exchangeRate,\n    bool isBorrow\n  ) internal pure returns (uint256) {\n    if (rewardSpeedPerSecondPerToken == 0) return 0;\n    uint256 nativeSpeedPerSecondPerCToken = rewardSpeedPerSecondPerToken * rewardTokenPrice; // scaled to 1e36\n    uint256 nativeSpeedPerYearPerCToken = nativeSpeedPerSecondPerCToken * 365.25 days; // scaled to 1e36\n    uint256 assetSpeedPerYearPerCToken = nativeSpeedPerYearPerCToken / underlyingPrice; // scaled to 1e18\n    uint256 assetSpeedPerYearPerCTokenScaled = assetSpeedPerYearPerCToken * 1e18; // scaled to 1e36\n    uint256 apr = assetSpeedPerYearPerCTokenScaled;\n    if (!isBorrow) {\n      // if not borrowing, use exchange rate to scale\n      apr = assetSpeedPerYearPerCTokenScaled / exchangeRate; // scaled to 1e18\n    } else {\n      apr = assetSpeedPerYearPerCTokenScaled / 1e18; // scaled to 1e18\n    }\n    return apr;\n  }\n\n  function getRewardsAprForMarket(ICErc20 market) internal returns (int256 totalMarketRewardsApr) {\n    IonicComptroller comptroller = market.comptroller();\n    BasePriceOracle oracle = comptroller.oracle();\n    uint256 underlyingPrice = oracle.getUnderlyingPrice(market);\n\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\n    for (uint256 j = 0; j < flywheels.length; j++) {\n      IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\n      ERC20 rewardToken = flywheel.rewardToken();\n\n      uint256 rewardSpeedPerSecondPerToken = getRewardSpeedPerSecondPerToken(\n        flywheel,\n        market,\n        uint256(rewardToken.decimals())\n      );\n\n      uint256 marketApr = getApr(\n        rewardSpeedPerSecondPerToken,\n        oracle.price(address(rewardToken)),\n        underlyingPrice,\n        market.exchangeRateCurrent(),\n        address(flywheel.flywheelBooster()) != address(0)\n      );\n\n      totalMarketRewardsApr += int256(marketApr);\n    }\n  }\n\n  function getUserNetValueDeltaForMarket(\n    address user,\n    ICErc20 market,\n    int256 offchainApr,\n    int256 blocksPerYear\n  ) internal returns (int256) {\n    IonicComptroller comptroller = market.comptroller();\n    BasePriceOracle oracle = comptroller.oracle();\n    int256 netApr = getRewardsAprForMarket(market) +\n      getUserInterestAprForMarket(user, market, blocksPerYear) +\n      offchainApr;\n    return (netApr * int256(market.balanceOfUnderlying(user)) * int256(oracle.getUnderlyingPrice(market))) / 1e36;\n  }\n\n  function getUserInterestAprForMarket(\n    address user,\n    ICErc20 market,\n    int256 blocksPerYear\n  ) internal returns (int256) {\n    uint256 borrows = market.borrowBalanceCurrent(user);\n    uint256 supplied = market.balanceOfUnderlying(user);\n    uint256 supplyRatePerBlock = market.supplyRatePerBlock();\n    uint256 borrowRatePerBlock = market.borrowRatePerBlock();\n\n    IonicComptroller comptroller = market.comptroller();\n    BasePriceOracle oracle = comptroller.oracle();\n    uint256 assetPrice = oracle.getUnderlyingPrice(market);\n    uint256 collateralValue = (supplied * assetPrice) / 1e18;\n    uint256 borrowsValue = (borrows * assetPrice) / 1e18;\n\n    uint256 yieldValuePerBlock = collateralValue * supplyRatePerBlock;\n    uint256 interestOwedValuePerBlock = borrowsValue * borrowRatePerBlock;\n\n    if (collateralValue == 0) return 0;\n    return ((int256(yieldValuePerBlock) - int256(interestOwedValuePerBlock)) * blocksPerYear) / int256(collateralValue);\n  }\n\n  struct AdjustedUserNetAprVars {\n    int256 userNetAssetsValue;\n    int256 userNetValueDelta;\n    BasePriceOracle oracle;\n    ICErc20[] markets;\n    IonicComptroller pool;\n  }\n\n  function getAdjustedUserNetApr(\n    address user,\n    int256 blocksPerYear,\n    address[] memory offchainRewardsAprMarkets,\n    int256[] memory offchainRewardsAprs\n  ) public returns (int256) {\n    AdjustedUserNetAprVars memory vars;\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      vars.oracle = pool.oracle();\n      vars.markets = pool.getAllMarkets();\n      for (uint256 j = 0; j < vars.markets.length; j++) {\n        int256 offchainRewardsApr = 0;\n        for (uint256 k = 0; k < offchainRewardsAprMarkets.length; k++) {\n          if (offchainRewardsAprMarkets[k] == address(vars.markets[j])) offchainRewardsApr = offchainRewardsAprs[k];\n        }\n        vars.userNetAssetsValue +=\n          int256(vars.markets[j].balanceOfUnderlying(user) * vars.oracle.getUnderlyingPrice(vars.markets[j])) /\n          1e18;\n        vars.userNetValueDelta += getUserNetValueDeltaForMarket(\n          user,\n          vars.markets[j],\n          offchainRewardsApr,\n          blocksPerYear\n        );\n      }\n    }\n\n    if (vars.userNetAssetsValue == 0) return 0;\n    else return (vars.userNetValueDelta * 1e18) / vars.userNetAssetsValue;\n  }\n\n  function getUserNetApr(address user, int256 blocksPerYear) external returns (int256) {\n    address[] memory emptyAddrArray = new address[](0);\n    int256[] memory emptyIntArray = new int256[](0);\n    return getAdjustedUserNetApr(user, blocksPerYear, emptyAddrArray, emptyIntArray);\n  }\n\n  function getAllRewardTokens() public view returns (address[] memory uniqueRewardTokens) {\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    uint256 rewardTokensCounter;\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      address[] memory fws = pool.getRewardsDistributors();\n\n      rewardTokensCounter += fws.length;\n    }\n\n    address[] memory rewardTokens = new address[](rewardTokensCounter);\n\n    uint256 uniqueRewardTokensCounter = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      address[] memory fws = pool.getRewardsDistributors();\n\n      for (uint256 j = 0; j < fws.length; j++) {\n        address rwToken = address(IonicFlywheelCore(fws[j]).rewardToken());\n        if (rwToken == address(0)) break;\n\n        bool added;\n        for (uint256 k = 0; k < rewardTokens.length; k++) {\n          if (rwToken == rewardTokens[k]) {\n            added = true;\n            break;\n          }\n        }\n        if (!added) rewardTokens[uniqueRewardTokensCounter++] = rwToken;\n      }\n    }\n\n    uniqueRewardTokens = new address[](uniqueRewardTokensCounter);\n    for (uint256 i = 0; i < uniqueRewardTokensCounter; i++) {\n      uniqueRewardTokens[i] = rewardTokens[i];\n    }\n  }\n\n  function claimAllRewardTokens(address user) external returns (address[] memory, uint256[] memory) {\n    address[] memory rewardTokens = getAllRewardTokens();\n    uint256[] memory rewardsClaimedForToken = new uint256[](rewardTokens.length);\n\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\n      rewardsClaimedForToken[i] = claimRewardsOfRewardToken(user, rewardTokens[i]);\n    }\n\n    return (rewardTokens, rewardsClaimedForToken);\n  }\n\n  function claimRewardsOfRewardToken(address user, address rewardToken) public returns (uint256 rewardsClaimed) {\n    uint256 balanceBefore = ERC20(rewardToken).balanceOf(user);\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      ERC20[] memory markets;\n      {\n        ICErc20[] memory cerc20s = pool.getAllMarkets();\n        markets = new ERC20[](cerc20s.length);\n        for (uint256 j = 0; j < cerc20s.length; j++) {\n          markets[j] = ERC20(address(cerc20s[j]));\n        }\n      }\n\n      address[] memory flywheelAddresses = pool.getAccruingFlywheels();\n      for (uint256 k = 0; k < flywheelAddresses.length; k++) {\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheelAddresses[k]);\n        if (address(flywheel.rewardToken()) == rewardToken) {\n          for (uint256 m = 0; m < markets.length; m++) {\n            flywheel.accrue(markets[m], user);\n          }\n          flywheel.claimRewards(user);\n        }\n      }\n    }\n\n    uint256 balanceAfter = ERC20(rewardToken).balanceOf(user);\n    return balanceAfter - balanceBefore;\n  }\n\n  function claimRewardsForMarket(\n    address user,\n    ERC20 market,\n    IonicFlywheelCore[] calldata flywheels,\n    bool[] calldata accrue\n  )\n    external\n    returns (\n      IonicFlywheelCore[] memory,\n      address[] memory rewardTokens,\n      uint256[] memory rewards\n    )\n  {\n    uint256 size = flywheels.length;\n    rewards = new uint256[](size);\n    rewardTokens = new address[](size);\n\n    for (uint256 i = 0; i < size; i++) {\n      uint256 newRewards;\n      if (accrue[i]) {\n        newRewards = flywheels[i].accrue(market, user);\n      } else {\n        newRewards = flywheels[i].rewardsAccrued(user);\n      }\n\n      // Take the max, because rewards are cumulative.\n      rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\n\n      flywheels[i].claimRewards(user);\n      rewardTokens[i] = address(flywheels[i].rewardToken());\n    }\n\n    return (flywheels, rewardTokens, rewards);\n  }\n\n  function claimRewardsForPool(address user, IonicComptroller comptroller)\n    public\n    returns (\n      IonicFlywheelCore[] memory,\n      address[] memory,\n      uint256[] memory\n    )\n  {\n    ICErc20[] memory cerc20s = comptroller.getAllMarkets();\n    ERC20[] memory markets = new ERC20[](cerc20s.length);\n    address[] memory flywheelAddresses = comptroller.getAccruingFlywheels();\n    IonicFlywheelCore[] memory flywheels = new IonicFlywheelCore[](flywheelAddresses.length);\n    bool[] memory accrue = new bool[](flywheelAddresses.length);\n\n    for (uint256 j = 0; j < flywheelAddresses.length; j++) {\n      flywheels[j] = IonicFlywheelCore(flywheelAddresses[j]);\n      accrue[j] = true;\n    }\n\n    for (uint256 j = 0; j < cerc20s.length; j++) {\n      markets[j] = ERC20(address(cerc20s[j]));\n    }\n\n    return claimRewardsForMarkets(user, markets, flywheels, accrue);\n  }\n\n  function claimRewardsForMarkets(\n    address user,\n    ERC20[] memory markets,\n    IonicFlywheelCore[] memory flywheels,\n    bool[] memory accrue\n  )\n    public\n    returns (\n      IonicFlywheelCore[] memory,\n      address[] memory rewardTokens,\n      uint256[] memory rewards\n    )\n  {\n    rewards = new uint256[](flywheels.length);\n    rewardTokens = new address[](flywheels.length);\n\n    for (uint256 i = 0; i < flywheels.length; i++) {\n      for (uint256 j = 0; j < markets.length; j++) {\n        ERC20 market = markets[j];\n\n        uint256 newRewards;\n        if (accrue[i]) {\n          newRewards = flywheels[i].accrue(market, user);\n        } else {\n          newRewards = flywheels[i].rewardsAccrued(user);\n        }\n\n        // Take the max, because rewards are cumulative.\n        rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\n      }\n\n      flywheels[i].claimRewards(user);\n      rewardTokens[i] = address(flywheels[i].rewardToken());\n    }\n\n    return (flywheels, rewardTokens, rewards);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/IonicReplacingFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./IonicFlywheel.sol\";\n\nimport { IFlywheelRewards } from \"./rewards/IFlywheelRewards.sol\";\nimport { IFlywheelBooster } from \"./IFlywheelBooster.sol\";\n\ncontract IonicReplacingFlywheel is IonicFlywheel {\n  IonicFlywheelCore public flywheelToReplace;\n  mapping(address => bool) private rewardsTransferred;\n\n  function reinitialize(IonicFlywheelCore _flywheelToReplace) public onlyOwnerOrAdmin {\n    flywheelToReplace = _flywheelToReplace;\n  }\n\n  function rewardsAccrued(address user) public override returns (uint256) {\n    if (address(flywheelToReplace) != address(0)) {\n      if (_rewardsAccrued[user] == 0 && !rewardsTransferred[user]) {\n        uint256 oldStateRewardsAccrued = flywheelToReplace.rewardsAccrued(user);\n        if (oldStateRewardsAccrued != 0) {\n          rewardsTransferred[user] = true;\n          _rewardsAccrued[user] = oldStateRewardsAccrued;\n        }\n      }\n    }\n    return _rewardsAccrued[user];\n  }\n\n  function strategyState(ERC20 strategy) public override returns (uint224, uint32) {\n    if (address(flywheelToReplace) != address(0)) {\n      RewardsState memory newStateStrategyState = _strategyState[strategy];\n      if (newStateStrategyState.index == 0) {\n        (uint224 index, uint32 ts) = flywheelToReplace.strategyState(strategy);\n        if (index != 0) {\n          _strategyState[strategy] = RewardsState(index, ts);\n        }\n      }\n    }\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\n  }\n\n  function userIndex(ERC20 strategy, address user) public override returns (uint224) {\n    if (address(flywheelToReplace) != address(0)) {\n      if (_userIndex[strategy][user] == 0) {\n        uint224 oldStateUserIndex = flywheelToReplace.userIndex(strategy, user);\n        if (oldStateUserIndex != 0) {\n          _userIndex[strategy][user] = oldStateUserIndex;\n        }\n      }\n    }\n    return _userIndex[strategy][user];\n  }\n\n  function addInitializedStrategy(ERC20 strategy) public onlyOwner {\n    (uint224 index, ) = strategyState(strategy);\n    if (index > 0) {\n      ERC20[] memory strategies = this.getAllStrategies();\n      for (uint8 i = 0; i < strategies.length; i++) {\n        require(address(strategy) != address(strategies[i]), \"!added\");\n      }\n\n      allStrategies.push(strategy);\n      emit AddStrategy(address(strategy));\n    }\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/LooplessFlywheelBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./IFlywheelBooster.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\ncontract LooplessFlywheelBooster is IFlywheelBooster {\n  string public constant BOOSTER_TYPE = \"LooplessFlywheelBooster\";\n\n  /**\n      @notice calculate the boosted supply of a strategy.\n      @param strategy the strategy to calculate boosted supply of\n      @return the boosted supply\n     */\n  function boostedTotalSupply(ERC20 strategy) external view returns (uint256) {\n    return strategy.totalSupply();\n  }\n\n  /**\n      @notice calculate the boosted balance of a user in a given strategy.\n      @param strategy the strategy to calculate boosted balance of\n      @param user the user to calculate boosted balance of\n      @return the boosted balance\n     */\n  function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256) {\n    uint256 cTokensBalance = strategy.balanceOf(user);\n    ICErc20 asMarket = ICErc20(address(strategy));\n    uint256 cTokensBorrow = (asMarket.borrowBalanceCurrent(user) * 1e18) / asMarket.exchangeRateCurrent();\n    return (cTokensBalance > cTokensBorrow) ? cTokensBalance - cTokensBorrow : 0;\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/BaseFlywheelRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {SafeTransferLib, ERC20} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IFlywheelRewards} from \"./IFlywheelRewards.sol\";\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\n\n/** \n @title Flywheel Reward Module\n @notice Determines how many rewards accrue to each strategy globally over a given time period.\n @dev approves the flywheel core for the reward token to allow balances to be managed by the module but claimed from core.\n*/\nabstract contract BaseFlywheelRewards is IFlywheelRewards {\n    using SafeTransferLib for ERC20;\n\n    /// @notice thrown when caller is not the flywheel\n    error FlywheelError();\n\n    /// @notice the reward token paid\n    ERC20 public immutable override rewardToken;\n\n    /// @notice the flywheel core contract\n    IonicFlywheelCore public immutable override flywheel;\n\n    constructor(IonicFlywheelCore _flywheel) {\n        flywheel = _flywheel;\n        ERC20 _rewardToken = _flywheel.rewardToken();\n        rewardToken = _rewardToken;\n\n        _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\n    }\n\n    modifier onlyFlywheel() {\n        if (msg.sender != address(flywheel)) revert FlywheelError();\n        _;\n    }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/FlywheelDynamicRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {BaseFlywheelRewards} from \"./BaseFlywheelRewards.sol\";\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\nimport {SafeTransferLib, ERC20} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\n\n/** \n @title Flywheel Dynamic Reward Stream\n @notice Determines rewards based on a dynamic reward stream.\n         Rewards are transferred linearly over a \"rewards cycle\" to prevent gaming the reward distribution. \n         The reward source can be arbitrary logic, but most common is to \"pass through\" rewards from some other source.\n         The getNextCycleRewards() hook should also transfer the next cycle's rewards to this contract to ensure proper accounting.\n*/\nabstract contract FlywheelDynamicRewards is BaseFlywheelRewards {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    event NewRewardsCycle(uint32 indexed start, uint32 indexed end, uint192 reward);\n\n    /// @notice the length of a rewards cycle\n    uint32 public immutable rewardsCycleLength;\n\n    struct RewardsCycle {\n        uint32 start;\n        uint32 end;\n        uint192 reward;\n    }\n\n    mapping(ERC20 => RewardsCycle) public rewardsCycle;\n\n    constructor(IonicFlywheelCore _flywheel, uint32 _rewardsCycleLength) BaseFlywheelRewards(_flywheel) {\n        rewardsCycleLength = _rewardsCycleLength;\n    }\n\n    /**\n     @notice calculate and transfer accrued rewards to flywheel core\n     @param strategy the strategy to accrue rewards for\n     @return amount the amount of tokens accrued and transferred\n     */\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp)\n        external\n        override\n        onlyFlywheel\n        returns (uint256 amount)\n    {\n        RewardsCycle memory cycle = rewardsCycle[strategy];\n\n        uint32 timestamp = block.timestamp.safeCastTo32();\n\n        uint32 latest = timestamp >= cycle.end ? cycle.end : timestamp;\n        uint32 earliest = lastUpdatedTimestamp <= cycle.start ? cycle.start : lastUpdatedTimestamp;\n        if (cycle.end != 0) {\n            amount = (cycle.reward * (latest - earliest)) / (cycle.end - cycle.start);\n            assert(amount <= cycle.reward); // should never happen because latest <= cycle.end and earliest >= cycle.start\n        }\n        // if cycle has ended, reset cycle and transfer all available\n        if (timestamp >= cycle.end) {\n            uint32 end = ((timestamp + rewardsCycleLength) / rewardsCycleLength) * rewardsCycleLength;\n            uint192 rewards = getNextCycleRewards(strategy);\n\n            // reset for next cycle\n            rewardsCycle[strategy] = RewardsCycle({start: timestamp, end: end, reward: rewards});\n\n            emit NewRewardsCycle(timestamp, end, rewards);\n        }\n    }\n\n    function getNextCycleRewards(ERC20 strategy) internal virtual returns (uint192);\n}"
    },
    "contracts/ionic/strategies/flywheel/rewards/FlywheelStaticRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {BaseFlywheelRewards} from \"./BaseFlywheelRewards.sol\";\nimport {ERC20} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\n\n/** \n @title Flywheel Static Reward Stream\n @notice Determines rewards per strategy based on a fixed reward rate per second\n*/\ncontract FlywheelStaticRewards is Auth, BaseFlywheelRewards {\n    event RewardsInfoUpdate(ERC20 indexed strategy, uint224 rewardsPerSecond, uint32 rewardsEndTimestamp);\n\n    struct RewardsInfo {\n        /// @notice Rewards per second\n        uint224 rewardsPerSecond;\n        /// @notice The timestamp the rewards end at\n        /// @dev use 0 to specify no end\n        uint32 rewardsEndTimestamp;\n    }\n\n    /// @notice rewards info per strategy\n    mapping(ERC20 => RewardsInfo) public rewardsInfo;\n\n    constructor(\n        IonicFlywheelCore _flywheel,\n        address _owner,\n        Authority _authority\n    ) Auth(_owner, _authority) BaseFlywheelRewards(_flywheel) {}\n\n    /**\n     @notice set rewards per second and rewards end time for Fei Rewards\n     @param strategy the strategy to accrue rewards for\n     @param rewards the rewards info for the strategy\n     */\n    function setRewardsInfo(ERC20 strategy, RewardsInfo calldata rewards) external requiresAuth {\n        rewardsInfo[strategy] = rewards;\n        emit RewardsInfoUpdate(strategy, rewards.rewardsPerSecond, rewards.rewardsEndTimestamp);\n    }\n\n    /**\n     @notice calculate and transfer accrued rewards to flywheel core\n     @param strategy the strategy to accrue rewards for\n     @param lastUpdatedTimestamp the last updated time for strategy\n     @return amount the amount of tokens accrued and transferred\n     */\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp)\n        external\n        view\n        override\n        onlyFlywheel\n        returns (uint256 amount)\n    {\n        RewardsInfo memory rewards = rewardsInfo[strategy];\n\n        uint256 elapsed;\n        if (rewards.rewardsEndTimestamp == 0 || rewards.rewardsEndTimestamp > block.timestamp) {\n            elapsed = block.timestamp - lastUpdatedTimestamp;\n        } else if (rewards.rewardsEndTimestamp > lastUpdatedTimestamp) {\n            elapsed = rewards.rewardsEndTimestamp - lastUpdatedTimestamp;\n        }\n\n        amount = rewards.rewardsPerSecond * elapsed;\n    }\n}"
    },
    "contracts/ionic/strategies/flywheel/rewards/IFlywheelRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\n\n/**\n @title Rewards Module for Flywheel\n @notice Flywheel is a general framework for managing token incentives.\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\n\n         The Rewards module is responsible for:\n         * determining the ongoing reward amounts to entire strategies (core handles the logic for dividing among users)\n         * actually holding rewards that are yet to be claimed\n\n         The reward stream can follow arbitrary logic as long as the amount of rewards passed to flywheel core has been sent to this contract.\n\n         Different module strategies include:\n         * a static reward rate per second\n         * a decaying reward rate\n         * a dynamic just-in-time reward stream\n         * liquid governance reward delegation (Curve Gauge style)\n\n         SECURITY NOTE: The rewards strategy should be smooth and continuous, to prevent gaming the reward distribution by frontrunning.\n */\ninterface IFlywheelRewards {\n    /**\n     @notice calculate the rewards amount accrued to a strategy since the last update.\n     @param strategy the strategy to accrue rewards for.\n     @param lastUpdatedTimestamp the last time rewards were accrued for the strategy.\n     @return rewards the amount of rewards accrued to the market\n    */\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);\n\n    /// @notice return the flywheel core address\n    function flywheel() external view returns (IonicFlywheelCore);\n\n    /// @notice return the reward token associated with flywheel core.\n    function rewardToken() external view returns (ERC20);\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/IonicFlywheelDynamicRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { FlywheelDynamicRewards } from \"./FlywheelDynamicRewards.sol\";\nimport { IonicFlywheelCore } from \"../IonicFlywheelCore.sol\";\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\n\ncontract IonicFlywheelDynamicRewards is FlywheelDynamicRewards {\n    using SafeTransferLib for ERC20;\n\n    constructor(IonicFlywheelCore _flywheel, uint32 _cycleLength)\n        FlywheelDynamicRewards(_flywheel, _cycleLength)\n    {}\n\n    function getNextCycleRewards(ERC20 strategy)\n        internal\n        override\n        returns (uint192)\n    {\n        uint256 rewardAmount = rewardToken.balanceOf(address(strategy));\n        if (rewardAmount != 0) {\n            rewardToken.safeTransferFrom(\n                address(strategy),\n                address(this),\n                rewardAmount\n            );\n        }\n        return uint192(rewardAmount);\n    }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/IonicFlywheelDynamicRewardsPlugin.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./FlywheelDynamicRewards.sol\";\n\ninterface ICERC20 {\n    function plugin() external returns (address);\n}\n\ninterface IPlugin_FDR {\n    function claimRewards() external;\n}\n\n/** \n @title Ionic Flywheel Dynamic Reward Stream\n @notice Determines rewards based on reward cycle\n Each cycle, claims rewards on the plugin before getting the reward amount\n*/\ncontract IonicFlywheelDynamicRewardsPlugin is FlywheelDynamicRewards {\n    using SafeTransferLib for ERC20;\n\n    constructor(IonicFlywheelCore _flywheel, uint32 _cycleLength)\n        FlywheelDynamicRewards(_flywheel, _cycleLength)\n    {}\n\n    function getNextCycleRewards(ERC20 strategy)\n        internal\n        override\n        returns (uint192)\n    {\n        IPlugin_FDR plugin = IPlugin_FDR(ICERC20(address(strategy)).plugin());\n        try plugin.claimRewards() {} catch {}\n\n        uint256 rewardAmount = rewardToken.balanceOf(address(strategy));\n        if (rewardAmount != 0) {\n            rewardToken.safeTransferFrom(\n                address(strategy),\n                address(this),\n                rewardAmount\n            );\n        }\n        return uint192(rewardAmount);\n    }\n}"
    },
    "contracts/ionic/strategies/flywheel/rewards/ReplacingFlywheelDynamicRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { FlywheelDynamicRewards } from \"./FlywheelDynamicRewards.sol\";\nimport { IonicFlywheelCore } from \"../IonicFlywheelCore.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\n\ninterface ICERC20_RFDR {\n  function plugin() external returns (address);\n}\n\ninterface IPlugin_RFDR {\n  function claimRewards() external;\n}\n\ncontract ReplacingFlywheelDynamicRewards is FlywheelDynamicRewards {\n  using SafeTransferLib for ERC20;\n\n  IonicFlywheelCore public replacedFlywheel;\n\n  constructor(\n    IonicFlywheelCore _replacedFlywheel,\n    IonicFlywheelCore _flywheel,\n    uint32 _cycleLength\n  ) FlywheelDynamicRewards(_flywheel, _cycleLength) {\n    replacedFlywheel = _replacedFlywheel;\n    // rewardToken.safeApprove(address(_replacedFlywheel), type(uint256).max);\n  }\n\n  function getNextCycleRewards(ERC20 strategy) internal override returns (uint192) {\n    if (msg.sender == address(replacedFlywheel)) {\n      return 0;\n    } else {\n      // make it work for both pulled (claimed) and pushed (transferred some other way) rewards\n      try ICERC20_RFDR(address(strategy)).plugin() returns (address plugin) {\n        try IPlugin_RFDR(plugin).claimRewards() {} catch {}\n      } catch {}\n\n      uint256 rewardAmount = rewardToken.balanceOf(address(strategy));\n      if (rewardAmount != 0) {\n        rewardToken.safeTransferFrom(address(strategy), address(this), rewardAmount);\n      }\n      return uint192(rewardAmount);\n    }\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/ReplacingFlywheelStaticRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { FlywheelStaticRewards } from \"./FlywheelStaticRewards.sol\";\nimport { IonicFlywheelCore } from \"../IonicFlywheelCore.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\n\ncontract ReplacingFlywheelStaticRewards is FlywheelStaticRewards {\n  using SafeTransferLib for ERC20;\n\n  IonicFlywheelCore public replacedFlywheel;\n\n  constructor(\n    IonicFlywheelCore _replacedFlywheel,\n    IonicFlywheelCore _flywheel,\n    address _owner,\n    Authority _authority\n  ) FlywheelStaticRewards(_flywheel, _owner, _authority) {\n    ERC20 _rewardToken = _flywheel.rewardToken();\n    _rewardToken.safeApprove(address(_replacedFlywheel), type(uint256).max);\n  }\n}\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/WithdrawableFlywheelStaticRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport { FlywheelStaticRewards } from \"./FlywheelStaticRewards.sol\";\nimport { IonicFlywheelCore } from \"../IonicFlywheelCore.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\n\ncontract WithdrawableFlywheelStaticRewards is FlywheelStaticRewards {\n  using SafeTransferLib for ERC20;\n\n  constructor(\n    IonicFlywheelCore _flywheel,\n    address _owner,\n    Authority _authority\n  ) FlywheelStaticRewards(_flywheel, _owner, _authority) {}\n\n  function withdraw(uint256 amount) external {\n    require(msg.sender == flywheel.owner());\n    rewardToken.safeTransfer(address(flywheel.owner()), amount);\n  }\n}\n"
    },
    "contracts/ionic/strategies/IonicERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport { PausableUpgradeable } from \"openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\";\nimport { ERC4626Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nabstract contract IonicERC4626 is SafeOwnableUpgradeable, PausableUpgradeable, ERC4626Upgradeable {\n  using FixedPointMathLib for uint256;\n  using SafeERC20Upgradeable for ERC20Upgradeable;\n\n  /* ========== STATE VARIABLES ========== */\n\n  uint256 public vaultShareHWM;\n  uint256 public performanceFee;\n  address public feeRecipient;\n\n  /* ========== EVENTS ========== */\n\n  event UpdatedFeeSettings(\n    uint256 oldPerformanceFee,\n    uint256 newPerformanceFee,\n    address oldFeeRecipient,\n    address newFeeRecipient\n  );\n\n  /* ========== INITIALIZER ========== */\n\n  function __IonicER4626_init(ERC20Upgradeable asset_) internal onlyInitializing {\n    __SafeOwnable_init(msg.sender);\n    __Pausable_init();\n    __Context_init();\n    __ERC20_init(\n      string(abi.encodePacked(\"Ionic \", asset_.name(), \" Vault\")),\n      string(abi.encodePacked(\"mv\", asset_.symbol()))\n    );\n    __ERC4626_init(asset_);\n\n    vaultShareHWM = 10**asset_.decimals();\n    feeRecipient = msg.sender;\n  }\n\n  function _asset() internal view returns (ERC20Upgradeable) {\n    return ERC20Upgradeable(super.asset());\n  }\n\n  /* ========== DEPOSIT/WITHDRAW FUNCTIONS ========== */\n\n  function deposit(uint256 assets, address receiver) public override whenNotPaused returns (uint256 shares) {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(uint256 shares, address receiver) public override whenNotPaused returns (uint256 assets) {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public override returns (uint256 shares) {\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\n    }\n\n    if (!paused()) {\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\n\n      beforeWithdraw(assets, shares);\n\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\n    }\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset().safeTransfer(receiver, assets);\n  }\n\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public override returns (uint256 assets) {\n    if (msg.sender != owner) {\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\n\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\n    }\n\n    // Check for rounding error since we round down in previewRedeem.\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n    if (!paused()) {\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\n\n      beforeWithdraw(assets, shares);\n\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\n    }\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset().safeTransfer(receiver, assets);\n  }\n\n  /* ========== FEE FUNCTIONS ========== */\n\n  /**\n   * @notice Take the performance fee that has accrued since last fee harvest.\n   * @dev Performance fee is based on a vault share high water mark value. If vault share value has increased above the\n   *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\n   */\n  function takePerformanceFee() external onlyOwner {\n    require(feeRecipient != address(0), \"fee recipient not initialized\");\n\n    uint256 currentAssets = totalAssets();\n    uint256 shareValue = convertToAssets(10**_asset().decimals());\n\n    require(shareValue > vaultShareHWM, \"shareValue !> vaultShareHWM\");\n    // cache value\n    uint256 supply = totalSupply();\n\n    uint256 accruedPerformanceFee = (performanceFee * (shareValue - vaultShareHWM) * supply) / 1e36;\n    _mint(feeRecipient, accruedPerformanceFee.mulDivDown(supply, (currentAssets - accruedPerformanceFee)));\n\n    vaultShareHWM = convertToAssets(10**_asset().decimals());\n  }\n\n  /**\n   * @notice Transfer accrued fees to rewards manager contract. Caller must be a registered keeper.\n   * @dev We must make sure that feeRecipient is not address(0) before withdrawing fees\n   */\n  function withdrawAccruedFees() external onlyOwner {\n    redeem(balanceOf(feeRecipient), feeRecipient, feeRecipient);\n  }\n\n  /**\n   * @notice Update performanceFee and/or feeRecipient\n   */\n  function updateFeeSettings(uint256 newPerformanceFee, address newFeeRecipient) external onlyOwner {\n    emit UpdatedFeeSettings(performanceFee, newPerformanceFee, feeRecipient, newFeeRecipient);\n\n    performanceFee = newPerformanceFee;\n\n    if (newFeeRecipient != feeRecipient) {\n      if (feeRecipient != address(0)) {\n        uint256 oldFees = balanceOf(feeRecipient);\n\n        _burn(feeRecipient, oldFees);\n        _approve(feeRecipient, owner(), 0);\n        _mint(newFeeRecipient, oldFees);\n      }\n\n      _approve(newFeeRecipient, owner(), type(uint256).max);\n    }\n\n    feeRecipient = newFeeRecipient;\n  }\n\n  /* ========== EMERGENCY FUNCTIONS ========== */\n\n  // Should withdraw all funds from the strategy and pause the contract\n  function emergencyWithdrawAndPause() external virtual;\n\n  function unpause() external virtual;\n\n  function shutdown(address market) external onlyOwner whenPaused returns (uint256) {\n    ERC20Upgradeable theAsset = _asset();\n    uint256 endBalance = theAsset.balanceOf(address(this));\n    theAsset.transfer(market, endBalance);\n    return endBalance;\n  }\n\n  /* ========== INTERNAL HOOKS LOGIC ========== */\n\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual;\n\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual;\n}\n"
    },
    "contracts/ionic/strategies/MockERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\n\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\n/**\n * @title Mock ERC4626 Contract\n * @notice ERC4626 wrapper for Tribe Token\n * @author carlomazzaferro\n *\n */\ncontract MockERC4626 is ERC4626 {\n  using SafeTransferLib for ERC20;\n  using FixedPointMathLib for uint256;\n\n  /**\n    @notice Creates a new Vault that accepts a specific underlying token.\n     @param _asset The ERC20 compliant token the Vault should accept.\n    */\n  constructor(ERC20 _asset)\n    ERC4626(\n      _asset,\n      string(abi.encodePacked(\"Midas \", _asset.name(), \" Vault\")),\n      string(abi.encodePacked(\"mv\", _asset.symbol()))\n    )\n  {}\n\n  /* ========== VIEWS ========== */\n\n  /// @notice Calculates the total amount of underlying tokens the Vault holds.\n  /// @return The total amount of underlying tokens the Vault holds.\n  function totalAssets() public view override returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n\n  /// @notice Calculates the total amount of underlying tokens the user holds.\n  /// @return The total amount of underlying tokens the user holds.\n  function balanceOfUnderlying(address account) public view returns (uint256) {\n    return convertToAssets(balanceOf[account]);\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  function afterDeposit(uint256 amount, uint256) internal override {}\n\n  function beforeWithdraw(uint256, uint256 shares) internal override {}\n}\n"
    },
    "contracts/ionic/strategies/MockERC4626Dynamic.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\nimport { IonicFlywheelCore } from \"./flywheel/IonicFlywheelCore.sol\";\n\n/**\n * @title Mock ERC4626 Contract\n * @notice ERC4626 wrapper for Tribe Token\n * @author carlomazzaferro\n *\n */\ncontract MockERC4626Dynamic is ERC4626 {\n  using FixedPointMathLib for uint256;\n\n  /* ========== STATE VARIABLES ========== */\n  IonicFlywheelCore public immutable flywheel;\n\n  /* ========== INITIALIZER ========== */\n\n  /**\n     @notice Initializes the Vault.\n     @param _asset The ERC20 compliant token the Vault should accept.\n     @param _flywheel Flywheel to pull in rewardsToken\n    */\n  constructor(ERC20 _asset, IonicFlywheelCore _flywheel)\n    ERC4626(\n      _asset,\n      string(abi.encodePacked(\"Midas \", _asset.name(), \" Vault\")),\n      string(abi.encodePacked(\"mv\", _asset.symbol()))\n    )\n  {\n    flywheel = _flywheel;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @notice Calculates the total amount of underlying tokens the Vault holds.\n  /// @return The total amount of underlying tokens the Vault holds.\n  function totalAssets() public view override returns (uint256) {\n    return asset.balanceOf(address(this));\n  }\n\n  /// @notice Calculates the total amount of underlying tokens the user holds.\n  /// @return The total amount of underlying tokens the user holds.\n  function balanceOfUnderlying(address account) public view returns (uint256) {\n    return convertToAssets(balanceOf[account]);\n  }\n\n  /* ========== INTERNAL FUNCTIONS ========== */\n\n  function afterDeposit(uint256 amount, uint256) internal override {}\n\n  function beforeWithdraw(uint256, uint256 shares) internal override {}\n}\n"
    },
    "contracts/IonicLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./liquidators/IRedemptionStrategy.sol\";\nimport \"./liquidators/IFundsConversionStrategy.sol\";\nimport \"./ILiquidator.sol\";\n\nimport \"./utils/IW_NATIVE.sol\";\n\nimport \"./external/uniswap/IUniswapV2Router02.sol\";\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\nimport \"./external/uniswap/IUniswapV2Callee.sol\";\nimport \"./external/uniswap/UniswapV2Library.sol\";\nimport \"./external/pyth/IExpressRelay.sol\";\nimport \"./external/pyth/IExpressRelayFeeReceiver.sol\";\n\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\n\n\nimport \"./PoolLens.sol\";\n\n/**\n * @title IonicLiquidator\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice IonicLiquidator safely liquidates unhealthy borrowers (with flashloan support).\n * @dev Do not transfer NATIVE or tokens directly to this address. Only send NATIVE here when using a method, and only approve tokens for transfer to here when using a method. Direct NATIVE transfers will be rejected and direct token transfers will be lost.\n */\ncontract IonicLiquidator is OwnableUpgradeable, ILiquidator, IUniswapV2Callee, IExpressRelayFeeReceiver {\n  using AddressUpgradeable for address payable;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  event VaultReceivedETH(address sender, uint256 amount, bytes permissionKey);\n\n  /**\n   * @dev W_NATIVE contract address.\n   */\n  address public W_NATIVE_ADDRESS;\n\n  /**\n   * @dev UniswapV2Router02 contract object. (Is interchangable with any UniV2 forks)\n   */\n  IUniswapV2Router02 public UNISWAP_V2_ROUTER_02;\n\n  /**\n   * @dev Cached liquidator profit exchange source.\n   * ERC20 token address or the zero address for NATIVE.\n   * For use in `safeLiquidateToTokensWithFlashLoan` after it is set by `postFlashLoanTokens`.\n   */\n  address private _liquidatorProfitExchangeSource;\n\n  mapping(address => bool) public redemptionStrategiesWhitelist;\n\n  /**\n   * @dev Cached flash swap amount.\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\n   */\n  uint256 private _flashSwapAmount;\n\n  /**\n   * @dev Cached flash swap token.\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\n   */\n  address private _flashSwapToken;\n  /**\n   * @dev Percentage of the flash swap fee, measured in basis points.\n   */\n  uint8 public flashSwapFee;\n\n  /**\n   * @dev Addres of Pyth Express Relay for preventing value leakage in liquidations.\n   */\n  IExpressRelay public expressRelay;\n  /**\n   * @dev Pool Lens.\n   */\n  PoolLens public lens;\n  /**\n   * @dev Health Factor below which PER permissioning is bypassed.\n   */\n  uint256 public healthFactorThreshold;\n\n  modifier onlyLowHF(address borrower, ICErc20 cToken) {\n    uint256 currentHealthFactor = lens.getHealthFactor(borrower, cToken.comptroller());\n    require(currentHealthFactor < healthFactorThreshold, \"HF not low enough, reserving for PYTH\");\n    _;\n  }\n\n  function initialize(\n    address _wtoken,\n    address _uniswapV2router,\n    uint8 _flashSwapFee\n  ) external initializer {\n    __Ownable_init();\n    require(_uniswapV2router != address(0), \"_uniswapV2router not defined.\");\n    W_NATIVE_ADDRESS = _wtoken;\n    UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(_uniswapV2router);\n    flashSwapFee = _flashSwapFee;\n  }\n\n  function _becomeImplementation(bytes calldata data) external {}\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @dev Internal function to approve\n   */\n  function justApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 amount\n  ) private {\n    token.approve(to, amount);\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n   * @param borrower The borrower's Ethereum address.\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n   * @param cErc20 The borrowed cErc20 to repay.\n   * @param cTokenCollateral The cToken collateral to be liquidated.\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n   */\n  function _safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) internal returns (uint256) {\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\n    IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\n    underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n    justApprove(underlying, address(cErc20), repayAmount);\n    require(cErc20.liquidateBorrow(borrower, repayAmount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\n\n    // Redeem seized cTokens for underlying asset\n    uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n    uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n    return transferSeizedFunds(address(cTokenCollateral.underlying()), minOutputAmount);\n  }\n\n  function safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) external onlyLowHF(borrower, cTokenCollateral) returns (uint256) {\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\n  }\n\n  function safeLiquidatePyth(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) external returns (uint256) {\n    require(expressRelay.isPermissioned(address(this), abi.encode(borrower)), \"invalid liquidation\");\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\n  }\n\n  /**\n   * @dev Transfers seized funds to the sender.\n   * @param erc20Contract The address of the token to transfer.\n   * @param minOutputAmount The minimum amount to transfer.\n   */\n  function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\n    IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n    uint256 seizedOutputAmount = token.balanceOf(address(this));\n    require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\n    if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\n\n    return seizedOutputAmount;\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in NATIVE profit is seized.\n   * @param vars @see LiquidateToTokensWithFlashSwapVars.\n   */\n  function safeLiquidateToTokensWithFlashLoan(LiquidateToTokensWithFlashSwapVars calldata vars)\n    external\n    onlyLowHF(vars.borrower, vars.cTokenCollateral)\n    returns (uint256)\n  {\n    // Input validation\n    require(vars.repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n    // we want to calculate the needed flashSwapAmount on-chain to\n    // avoid errors due to changing market conditions\n    // between the time of calculating and including the tx in a block\n    uint256 fundingAmount = vars.repayAmount;\n    IERC20Upgradeable fundingToken;\n    if (vars.debtFundingStrategies.length > 0) {\n      require(\n        vars.debtFundingStrategies.length == vars.debtFundingStrategiesData.length,\n        \"Funding IFundsConversionStrategy contract array and strategy data bytes array must be the same length.\"\n      );\n      // estimate the initial (flash-swapped token) input from the expected output (debt token)\n      for (uint256 i = 0; i < vars.debtFundingStrategies.length; i++) {\n        bytes memory strategyData = vars.debtFundingStrategiesData[i];\n        IFundsConversionStrategy fcs = vars.debtFundingStrategies[i];\n        (fundingToken, fundingAmount) = fcs.estimateInputAmount(fundingAmount, strategyData);\n      }\n    } else {\n      fundingToken = IERC20Upgradeable(ICErc20(address(vars.cErc20)).underlying());\n    }\n\n    // the last outputs from estimateInputAmount are the ones to be flash-swapped\n    _flashSwapAmount = fundingAmount;\n    _flashSwapToken = address(fundingToken);\n\n    IUniswapV2Pair flashSwapPair = IUniswapV2Pair(vars.flashSwapContract);\n    bool token0IsFlashSwapFundingToken = flashSwapPair.token0() == address(fundingToken);\n    flashSwapPair.swap(\n      token0IsFlashSwapFundingToken ? fundingAmount : 0,\n      !token0IsFlashSwapFundingToken ? fundingAmount : 0,\n      address(this),\n      msg.data\n    );\n\n    return transferSeizedFunds(_liquidatorProfitExchangeSource, vars.minProfitAmount);\n  }\n\n  /**\n   * @dev Receives NATIVE from liquidations and flashloans.\n   * Requires that `msg.sender` is W_NATIVE, a CToken, or a Uniswap V2 Router, or another contract.\n   */\n  receive() external payable {\n    require(payable(msg.sender).isContract(), \"Sender is not a contract.\");\n  }\n\n  /**\n   * @notice receiveAuctionProceedings function - receives native token from the express relay\n   * You can use permission key to distribute the received funds to users who got liquidated, LPs, etc...\n   */\n  function receiveAuctionProceedings(bytes calldata permissionKey) external payable {\n    emit VaultReceivedETH(msg.sender, msg.value, permissionKey);\n  }\n\n  function withdrawAll() external onlyOwner {\n    uint256 balance = address(this).balance;\n    require(balance > 0, \"No Ether left to withdraw\");\n\n    // Transfer all Ether to the owner\n    (bool sent, ) = msg.sender.call{ value: balance }(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  /**\n   * @dev Callback function for Uniswap flashloans.\n   */\n  function uniswapV2Call(\n    address,\n    uint256,\n    uint256,\n    bytes calldata data\n  ) public override {\n    // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\n    // Decode params\n    LiquidateToTokensWithFlashSwapVars memory vars = abi.decode(data[4:], (LiquidateToTokensWithFlashSwapVars));\n\n    // Post token flashloan\n    // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\n    _liquidatorProfitExchangeSource = postFlashLoanTokens(vars);\n  }\n\n  /**\n   * @dev Callback function for PCS flashloans.\n   */\n  function pancakeCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    uniswapV2Call(sender, amount0, amount1, data);\n  }\n\n  function moraswapCall(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external {\n    uniswapV2Call(sender, amount0, amount1, data);\n  }\n\n  /**\n   * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n   */\n  function postFlashLoanTokens(LiquidateToTokensWithFlashSwapVars memory vars) private returns (address) {\n    IERC20Upgradeable debtRepaymentToken = IERC20Upgradeable(_flashSwapToken);\n    uint256 debtRepaymentAmount = _flashSwapAmount;\n\n    if (vars.debtFundingStrategies.length > 0) {\n      // loop backwards to convert the initial (flash-swapped token) input to the final expected output (debt token)\n      for (uint256 i = vars.debtFundingStrategies.length; i > 0; i--) {\n        (debtRepaymentToken, debtRepaymentAmount) = convertCustomFunds(\n          debtRepaymentToken,\n          debtRepaymentAmount,\n          vars.debtFundingStrategies[i - 1],\n          vars.debtFundingStrategiesData[i - 1]\n        );\n      }\n    }\n\n    // Approve the debt repayment transfer, liquidate and redeem the seized collateral\n    {\n      address underlyingBorrow = vars.cErc20.underlying();\n      require(\n        address(debtRepaymentToken) == underlyingBorrow,\n        \"the debt repayment funds should be converted to the underlying debt token\"\n      );\n      require(debtRepaymentAmount >= vars.repayAmount, \"debt repayment amount not enough\");\n      // Approve repayAmount to cErc20\n      justApprove(IERC20Upgradeable(underlyingBorrow), address(vars.cErc20), vars.repayAmount);\n\n      // Liquidate borrow\n      require(\n        vars.cErc20.liquidateBorrow(vars.borrower, vars.repayAmount, address(vars.cTokenCollateral)) == 0,\n        \"Liquidation failed.\"\n      );\n\n      // Redeem seized cTokens for underlying asset\n      uint256 seizedCTokenAmount = vars.cTokenCollateral.balanceOf(address(this));\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n      uint256 redeemResult = vars.cTokenCollateral.redeem(seizedCTokenAmount);\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n    }\n\n    // Repay flashloan\n    return repayTokenFlashLoan(vars.cTokenCollateral, vars.redemptionStrategies, vars.strategyData);\n  }\n\n  /**\n   * @dev Repays token flashloans.\n   */\n  function repayTokenFlashLoan(\n    ICErc20 cTokenCollateral,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) private returns (address) {\n    // Calculate flashloan return amount\n    uint256 flashSwapReturnAmount = (_flashSwapAmount * 10000) / (10000 - flashSwapFee);\n    if ((_flashSwapAmount * 10000) % (10000 - flashSwapFee) > 0) flashSwapReturnAmount++; // Round up if division resulted in a remainder\n\n    // Swap cTokenCollateral for cErc20 via Uniswap\n    // Check underlying collateral seized\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n    // Redeem custom collateral if liquidation strategy is set\n    if (redemptionStrategies.length > 0) {\n      require(\n        redemptionStrategies.length == strategyData.length,\n        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n      );\n      for (uint256 i = 0; i < redemptionStrategies.length; i++)\n        (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\n          underlyingCollateral,\n          underlyingCollateralSeized,\n          redemptionStrategies[i],\n          strategyData[i]\n        );\n    }\n\n    IUniswapV2Pair pair = IUniswapV2Pair(msg.sender);\n\n    // Check if we can repay directly one of the sides with collateral\n    if (address(underlyingCollateral) == pair.token0() || address(underlyingCollateral) == pair.token1()) {\n      // Repay flashloan directly with collateral\n      uint256 collateralRequired;\n      if (address(underlyingCollateral) == _flashSwapToken) {\n        // repay amount for the borrow side\n        collateralRequired = flashSwapReturnAmount;\n      } else {\n        // repay amount for the non-borrow side\n        collateralRequired = UniswapV2Library.getAmountsIn(\n          UNISWAP_V2_ROUTER_02.factory(),\n          _flashSwapAmount, //flashSwapReturnAmount,\n          array(address(underlyingCollateral), _flashSwapToken),\n          flashSwapFee\n        )[0];\n      }\n\n      // Repay flashloan\n      require(\n        collateralRequired <= underlyingCollateralSeized,\n        \"Token flashloan return amount greater than seized collateral.\"\n      );\n      require(\n        underlyingCollateral.transfer(msg.sender, collateralRequired),\n        \"Failed to repay token flashloan on borrow side.\"\n      );\n\n      return address(underlyingCollateral);\n    } else {\n      // exchange the collateral to W_NATIVE to repay the borrow side\n      uint256 wethRequired;\n      if (_flashSwapToken == W_NATIVE_ADDRESS) {\n        wethRequired = flashSwapReturnAmount;\n      } else {\n        // Get W_NATIVE required to repay flashloan\n        wethRequired = UniswapV2Library.getAmountsIn(\n          UNISWAP_V2_ROUTER_02.factory(),\n          flashSwapReturnAmount,\n          array(W_NATIVE_ADDRESS, _flashSwapToken),\n          flashSwapFee\n        )[0];\n      }\n\n      if (address(underlyingCollateral) != W_NATIVE_ADDRESS) {\n        // Approve to Uniswap router\n        justApprove(underlyingCollateral, address(UNISWAP_V2_ROUTER_02), underlyingCollateralSeized);\n\n        // Swap collateral tokens for W_NATIVE to be repaid via Uniswap router\n        UNISWAP_V2_ROUTER_02.swapTokensForExactTokens(\n          wethRequired,\n          underlyingCollateralSeized,\n          array(address(underlyingCollateral), W_NATIVE_ADDRESS),\n          address(this),\n          block.timestamp\n        );\n      }\n\n      // Repay flashloan\n      require(\n        wethRequired <= IERC20Upgradeable(W_NATIVE_ADDRESS).balanceOf(address(this)),\n        \"Not enough W_NATIVE exchanged from seized collateral to repay flashloan.\"\n      );\n      require(\n        IW_NATIVE(W_NATIVE_ADDRESS).transfer(msg.sender, wethRequired),\n        \"Failed to repay Uniswap flashloan with W_NATIVE exchanged from seized collateral.\"\n      );\n\n      // Return the profited token (underlying collateral if same as exchangeProfitTo; otherwise, W_NATIVE)\n      return address(underlyingCollateral);\n    }\n  }\n\n  /**\n   * @dev for security reasons only whitelisted redemption strategies may be used.\n   * Each whitelisted redemption strategy has to be checked to not be able to\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\n   */\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external onlyOwner {\n    redemptionStrategiesWhitelist[address(strategy)] = whitelisted;\n  }\n\n  /**\n   * @dev for security reasons only whitelisted redemption strategies may be used.\n   * Each whitelisted redemption strategy has to be checked to not be able to\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\n   */\n  function _whitelistRedemptionStrategies(IRedemptionStrategy[] calldata strategies, bool[] calldata whitelisted)\n    external\n    onlyOwner\n  {\n    require(\n      strategies.length > 0 && strategies.length == whitelisted.length,\n      \"list of strategies empty or whitelist does not match its length\"\n    );\n\n    for (uint256 i = 0; i < strategies.length; i++) {\n      redemptionStrategiesWhitelist[address(strategies[i])] = whitelisted[i];\n    }\n  }\n\n  function setExpressRelay(address _expressRelay) external onlyOwner {\n    expressRelay = IExpressRelay(_expressRelay);\n  }\n\n  function setPoolLens(address _poolLens) external onlyOwner {\n    lens = PoolLens(_poolLens);\n  }\n\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external onlyOwner {\n    require(_healthFactorThreshold <= 1e18, \"Invalid Health Factor Threshold\");\n    healthFactorThreshold = _healthFactorThreshold;\n  }\n\n  /**\n   * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * Public visibility because we have to call this function externally if called from a payable IonicLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\n   */\n  function redeemCustomCollateral(\n    IERC20Upgradeable underlyingCollateral,\n    uint256 underlyingCollateralSeized,\n    IRedemptionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\n\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  function convertCustomFunds(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IFundsConversionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\n\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.convert.selector, inputToken, inputAmount, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\n   */\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\n   */\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  /**\n   * @dev Returns an array containing the parameters supplied.\n   */\n  function array(address a, address b) private pure returns (address[] memory) {\n    address[] memory arr = new address[](2);\n    arr[0] = a;\n    arr[1] = b;\n    return arr;\n  }\n}\n"
    },
    "contracts/IonicUniV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./liquidators/IRedemptionStrategy.sol\";\nimport \"./liquidators/IFundsConversionStrategy.sol\";\nimport \"./ILiquidator.sol\";\n\nimport \"./external/uniswap/IUniswapV3FlashCallback.sol\";\nimport \"./external/uniswap/IUniswapV3Pool.sol\";\nimport \"./external/pyth/IExpressRelay.sol\";\nimport \"./external/pyth/IExpressRelayFeeReceiver.sol\";\nimport { IUniswapV3Quoter } from \"./external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol\";\n\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\n\nimport \"./PoolLens.sol\";\n\n/**\n * @title IonicUniV3Liquidator\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\n * @notice IonicUniV3Liquidator liquidates unhealthy borrowers with flashloan support.\n */\ncontract IonicUniV3Liquidator is OwnableUpgradeable, ILiquidator, IUniswapV3FlashCallback, IExpressRelayFeeReceiver {\n  using AddressUpgradeable for address payable;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  event VaultReceivedETH(address sender, uint256 amount, bytes permissionKey);\n  /**\n   * @dev Cached liquidator profit exchange source.\n   * ERC20 token address or the zero address for NATIVE.\n   * For use in `safeLiquidateToTokensWithFlashLoan` after it is set by `postFlashLoanTokens`.\n   */\n  address private _liquidatorProfitExchangeSource;\n\n  /**\n   * @dev Cached flash swap amount.\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\n   */\n  uint256 private _flashSwapAmount;\n\n  /**\n   * @dev Cached flash swap token.\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\n   */\n  address private _flashSwapToken;\n\n  address public W_NATIVE_ADDRESS;\n  mapping(address => bool) public redemptionStrategiesWhitelist;\n  IUniswapV3Quoter public quoter;\n\n  /**\n   * @dev Addres of Pyth Express Relay for preventing value leakage in liquidations.\n   */\n  IExpressRelay public expressRelay;\n  /**\n   * @dev Pool Lens.\n   */\n  PoolLens public lens;\n  /**\n   * @dev Health Factor below which PER permissioning is bypassed.\n   */\n  uint256 public healthFactorThreshold;\n\n  modifier onlyLowHF(address borrower, ICErc20 cToken) {\n    uint256 currentHealthFactor = lens.getHealthFactor(borrower, cToken.comptroller());\n    require(currentHealthFactor < healthFactorThreshold, \"HF not low enough, reserving for PYTH\");\n    _;\n  }\n\n  function initialize(address _wtoken, address _quoter) external initializer {\n    __Ownable_init();\n    W_NATIVE_ADDRESS = _wtoken;\n    quoter = IUniswapV3Quoter(_quoter);\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n   * @param borrower The borrower's Ethereum address.\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n   * @param cErc20 The borrowed cErc20 to repay.\n   * @param cTokenCollateral The cToken collateral to be liquidated.\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n   */\n  function _safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) internal returns (uint256) {\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\n    IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\n    underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n    underlying.approve(address(cErc20), repayAmount);\n    require(cErc20.liquidateBorrow(borrower, repayAmount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\n\n    // Redeem seized cTokens for underlying asset\n    uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n    uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n    return transferSeizedFunds(address(cTokenCollateral.underlying()), minOutputAmount);\n  }\n\n  function safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) external onlyLowHF(borrower, cTokenCollateral) returns (uint256) {\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\n  }\n\n  function safeLiquidatePyth(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICErc20 cTokenCollateral,\n    uint256 minOutputAmount\n  ) external returns (uint256) {\n    require(expressRelay.isPermissioned(address(this), abi.encode(borrower)), \"invalid liquidation\");\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\n  }\n\n  /**\n   * @dev Transfers seized funds to the sender.\n   * @param erc20Contract The address of the token to transfer.\n   * @param minOutputAmount The minimum amount to transfer.\n   */\n  function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\n    IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n    uint256 seizedOutputAmount = token.balanceOf(address(this));\n    require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\n    if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\n\n    return seizedOutputAmount;\n  }\n\n  function safeLiquidateToTokensWithFlashLoan(LiquidateToTokensWithFlashSwapVars calldata vars)\n    external\n    onlyLowHF(vars.borrower, vars.cTokenCollateral)\n    returns (uint256)\n  {\n    // Input validation\n    require(vars.repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n    // we want to calculate the needed flashSwapAmount on-chain to\n    // avoid errors due to changing market conditions\n    // between the time of calculating and including the tx in a block\n    uint256 fundingAmount = vars.repayAmount;\n    IERC20Upgradeable fundingToken;\n    if (vars.debtFundingStrategies.length > 0) {\n      require(\n        vars.debtFundingStrategies.length == vars.debtFundingStrategiesData.length,\n        \"Funding IFundsConversionStrategy contract array and strategy data bytes array must be the same length.\"\n      );\n      // estimate the initial (flash-swapped token) input from the expected output (debt token)\n      for (uint256 i = 0; i < vars.debtFundingStrategies.length; i++) {\n        bytes memory strategyData = vars.debtFundingStrategiesData[i];\n        IFundsConversionStrategy fcs = vars.debtFundingStrategies[i];\n        (fundingToken, fundingAmount) = fcs.estimateInputAmount(fundingAmount, strategyData);\n      }\n    } else {\n      fundingToken = IERC20Upgradeable(ICErc20(address(vars.cErc20)).underlying());\n    }\n\n    // the last outputs from estimateInputAmount are the ones to be flash-swapped\n    _flashSwapAmount = fundingAmount;\n    _flashSwapToken = address(fundingToken);\n\n    IUniswapV3Pool flashSwapPool = IUniswapV3Pool(vars.flashSwapContract);\n    bool token0IsFlashSwapFundingToken = flashSwapPool.token0() == address(fundingToken);\n    flashSwapPool.flash(\n      address(this),\n      token0IsFlashSwapFundingToken ? fundingAmount : 0,\n      !token0IsFlashSwapFundingToken ? fundingAmount : 0,\n      msg.data\n    );\n\n    return transferSeizedFunds(_liquidatorProfitExchangeSource, vars.minProfitAmount);\n  }\n\n  /**\n   * @dev Receives NATIVE from liquidations and flashloans.\n   * Requires that `msg.sender` is W_NATIVE, a CToken, or a Uniswap V2 Router, or another contract.\n   */\n  receive() external payable {\n    require(payable(msg.sender).isContract(), \"Sender is not a contract.\");\n  }\n\n  /**\n   * @notice receiveAuctionProceedings function - receives native token from the express relay\n   * You can use permission key to distribute the received funds to users who got liquidated, LPs, etc...\n   */\n  function receiveAuctionProceedings(bytes calldata permissionKey) external payable {\n    emit VaultReceivedETH(msg.sender, msg.value, permissionKey);\n  }\n\n  function withdrawAll() external onlyOwner {\n    uint256 balance = address(this).balance;\n    require(balance > 0, \"No Ether left to withdraw\");\n\n    // Transfer all Ether to the owner\n    (bool sent, ) = msg.sender.call{ value: balance }(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  /**\n   * @dev Callback function for Uniswap flashloans.\n   */\n\n  function supV3FlashCallback(\n    uint256 fee0,\n    uint256 fee1,\n    bytes calldata data\n  ) external {\n    uniswapV3FlashCallback(fee0, fee1, data);\n  }\n\n  function algebraFlashCallback(\n    uint256 fee0,\n    uint256 fee1,\n    bytes calldata data\n  ) external {\n    uniswapV3FlashCallback(fee0, fee1, data);\n  }\n\n  function uniswapV3FlashCallback(\n    uint256 fee0,\n    uint256 fee1,\n    bytes calldata data\n  ) public {\n    // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\n    // Decode params\n    LiquidateToTokensWithFlashSwapVars memory vars = abi.decode(data[4:], (LiquidateToTokensWithFlashSwapVars));\n\n    // Post token flashloan\n    // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\n    _liquidatorProfitExchangeSource = postFlashLoanTokens(vars, fee0, fee1);\n  }\n\n  /**\n   * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n   */\n  function postFlashLoanTokens(\n    LiquidateToTokensWithFlashSwapVars memory vars,\n    uint256 fee0,\n    uint256 fee1\n  ) private returns (address) {\n    IERC20Upgradeable debtRepaymentToken = IERC20Upgradeable(_flashSwapToken);\n    uint256 debtRepaymentAmount = _flashSwapAmount;\n\n    if (vars.debtFundingStrategies.length > 0) {\n      // loop backwards to convert the initial (flash-swapped token) input to the final expected output (debt token)\n      for (uint256 i = vars.debtFundingStrategies.length; i > 0; i--) {\n        (debtRepaymentToken, debtRepaymentAmount) = convertCustomFunds(\n          debtRepaymentToken,\n          debtRepaymentAmount,\n          vars.debtFundingStrategies[i - 1],\n          vars.debtFundingStrategiesData[i - 1]\n        );\n      }\n    }\n\n    // Approve the debt repayment transfer, liquidate and redeem the seized collateral\n    {\n      address underlyingBorrow = vars.cErc20.underlying();\n      require(\n        address(debtRepaymentToken) == underlyingBorrow,\n        \"the debt repayment funds should be converted to the underlying debt token\"\n      );\n      require(debtRepaymentAmount >= vars.repayAmount, \"debt repayment amount not enough\");\n      // Approve repayAmount to cErc20\n      IERC20Upgradeable(underlyingBorrow).approve(address(vars.cErc20), vars.repayAmount);\n\n      // Liquidate borrow\n      require(\n        vars.cErc20.liquidateBorrow(vars.borrower, vars.repayAmount, address(vars.cTokenCollateral)) == 0,\n        \"Liquidation failed.\"\n      );\n\n      // Redeem seized cTokens for underlying asset\n      uint256 seizedCTokenAmount = vars.cTokenCollateral.balanceOf(address(this));\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n      uint256 redeemResult = vars.cTokenCollateral.redeem(seizedCTokenAmount);\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n    }\n\n    // Repay flashloan\n    return repayTokenFlashLoan(vars.cTokenCollateral, vars.redemptionStrategies, vars.strategyData, fee0, fee1);\n  }\n\n  /**\n   * @dev Repays token flashloans.\n   */\n  function repayTokenFlashLoan(\n    ICErc20 cTokenCollateral,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    uint256 fee0,\n    uint256 fee1\n  ) private returns (address) {\n    IUniswapV3Pool pool = IUniswapV3Pool(msg.sender);\n    uint256 flashSwapReturnAmount = _flashSwapAmount;\n    if (IUniswapV3Pool(msg.sender).token0() == _flashSwapToken) {\n      flashSwapReturnAmount += fee0;\n    } else if (IUniswapV3Pool(msg.sender).token1() == _flashSwapToken) {\n      flashSwapReturnAmount += fee1;\n    } else {\n      revert(\"wrong pool or _flashSwapToken\");\n    }\n\n    // Swap cTokenCollateral for cErc20 via Uniswap\n    // Check underlying collateral seized\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n    // Redeem custom collateral if liquidation strategy is set\n    if (redemptionStrategies.length > 0) {\n      require(\n        redemptionStrategies.length == strategyData.length,\n        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n      );\n      for (uint256 i = 0; i < redemptionStrategies.length; i++)\n        (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\n          underlyingCollateral,\n          underlyingCollateralSeized,\n          redemptionStrategies[i],\n          strategyData[i]\n        );\n    }\n\n    // Check if we can repay directly one of the sides with collateral\n    if (address(underlyingCollateral) == pool.token0() || address(underlyingCollateral) == pool.token1()) {\n      // Repay flashloan directly with collateral\n      uint256 collateralRequired;\n      if (address(underlyingCollateral) == _flashSwapToken) {\n        // repay the borrowed asset directly\n        collateralRequired = flashSwapReturnAmount;\n\n        // Repay flashloan\n        IERC20Upgradeable(_flashSwapToken).transfer(address(pool), flashSwapReturnAmount);\n      } else {\n        // TODO swap within the same pool and then repay the FL to the pool\n        bool zeroForOne = address(underlyingCollateral) == pool.token0();\n\n        {\n          collateralRequired = quoter.quoteExactOutputSingle(\n            zeroForOne ? pool.token0() : pool.token1(),\n            zeroForOne ? pool.token1() : pool.token0(),\n            pool.fee(),\n            _flashSwapAmount,\n            0 // sqrtPriceLimitX96\n          );\n        }\n        require(\n          collateralRequired <= underlyingCollateralSeized,\n          \"Token flashloan return amount greater than seized collateral.\"\n        );\n\n        // Repay flashloan\n        pool.swap(\n          address(pool),\n          zeroForOne,\n          int256(collateralRequired),\n          0, // sqrtPriceLimitX96\n          \"\"\n        );\n      }\n\n      return address(underlyingCollateral);\n    } else {\n      revert(\"the redemptions strategy did not swap to the flash swapped pool assets\");\n    }\n  }\n\n  /**\n   * @dev for security reasons only whitelisted redemption strategies may be used.\n   * Each whitelisted redemption strategy has to be checked to not be able to\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\n   */\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external onlyOwner {\n    redemptionStrategiesWhitelist[address(strategy)] = whitelisted;\n  }\n\n  /**\n   * @dev for security reasons only whitelisted redemption strategies may be used.\n   * Each whitelisted redemption strategy has to be checked to not be able to\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\n   */\n  function _whitelistRedemptionStrategies(IRedemptionStrategy[] calldata strategies, bool[] calldata whitelisted)\n    external\n    onlyOwner\n  {\n    require(\n      strategies.length > 0 && strategies.length == whitelisted.length,\n      \"list of strategies empty or whitelist does not match its length\"\n    );\n\n    for (uint256 i = 0; i < strategies.length; i++) {\n      redemptionStrategiesWhitelist[address(strategies[i])] = whitelisted[i];\n    }\n  }\n\n  function setExpressRelay(address _expressRelay) external onlyOwner {\n    expressRelay = IExpressRelay(_expressRelay);\n  }\n\n  function setPoolLens(address _poolLens) external onlyOwner {\n    lens = PoolLens(_poolLens);\n  }\n\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external onlyOwner {\n    require(_healthFactorThreshold <= 1e18, \"Invalid Health Factor Threshold\");\n    healthFactorThreshold = _healthFactorThreshold;\n  }\n\n  /**\n   * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * Public visibility because we have to call this function externally if called from a payable IonicLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\n   */\n  function redeemCustomCollateral(\n    IERC20Upgradeable underlyingCollateral,\n    uint256 underlyingCollateralSeized,\n    IRedemptionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\n\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  function convertCustomFunds(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IFundsConversionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\n\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.convert.selector, inputToken, inputAmount, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\n   */\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\n   */\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/liquidators/AaveTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICErc20.sol\";\nimport \"../external/aave/IAToken.sol\";\nimport \"../external/aave/ILendingPool.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AaveTokenLiquidator\n * @notice Redeems seized Aave Market Tokens for underlying tokens for use as a step in a liquidation.\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @author Veliko Minkov <veliko@midascapital.xyz> (https://github.com/vminkov)\n */\ncontract AaveTokenLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    address _outputToken = abi.decode(strategyData, (address));\n\n    IAToken aaveMarket = IAToken(address(inputToken));\n    ILendingPool pool = aaveMarket.POOL();\n\n    pool.withdraw(_outputToken, type(uint256).max, address(this));\n\n    outputToken = IERC20Upgradeable(_outputToken);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"AaveTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/AlgebraSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IRedemptionStrategy.sol\";\nimport \"../external/algebra/ISwapRouter.sol\";\n\n/**\n * @title AlgebraSwapLiquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Algebra router for use as a step in a liquidation.\n * @author Veliko Minkov <veliko@midascapital.xyz> (https://github.com/vminkov)\n */\ncontract AlgebraSwapLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address _outputToken, IAlgebraSwapRouter swapRouter) = abi.decode(strategyData, (address, IAlgebraSwapRouter));\n    outputToken = IERC20Upgradeable(_outputToken);\n\n    inputToken.approve(address(swapRouter), inputAmount);\n\n    IAlgebraSwapRouter.ExactInputSingleParams memory params = IAlgebraSwapRouter.ExactInputSingleParams(\n      address(inputToken),\n      _outputToken,\n      address(this),\n      block.timestamp,\n      inputAmount,\n      0, // amountOutMinimum\n      0 // limitSqrtPrice\n    );\n\n    outputAmount = swapRouter.exactInputSingle(params);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"AlgebraSwapLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV1BankLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/Bank.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV1BankLiquidator\n * @notice Redeems seized Alpha Homora v1 ibETH (Bank) tokens for ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1BankLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ETH token (and store output as new collateral)\n    Bank bank = Bank(address(inputToken));\n    bank.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(address(0));\n    outputAmount = address(this).balance;\n\n    // Convert to W_NATIVE because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"AlphaHomoraV1BankLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxETHLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBoxETH.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxETHLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibETHv2\" (SafeBoxETH) tokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxETHLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ETH (and store output as new collateral)\n    ISafeBoxETH safeBox = ISafeBoxETH(address(inputToken));\n    safeBox.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(address(0));\n    outputAmount = address(this).balance;\n\n    // Convert to W_NATIVE because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"AlphaHomoraV2SafeBoxETHLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBox.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibTokenV2\" or SafeBox tokens (e.g., ibDAIv2) for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ERC20 token (and store output as new collateral)\n    ISafeBox safeBox = ISafeBox(address(inputToken));\n    safeBox.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(safeBox.uToken());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"AlphaHomoraV2SafeBoxLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/BalancerLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IRedemptionStrategy.sol\";\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/balancer/IBalancerVault.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract BalancerLpTokenLiquidator is IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    IBalancerPool pool = IBalancerPool(address(inputToken));\n    IBalancerVault vault = pool.getVault();\n    bytes32 poolId = pool.getPoolId();\n    (IERC20Upgradeable[] memory tokens, , ) = vault.getPoolTokens(poolId);\n\n    uint256 outputTokenIndex = type(uint256).max;\n    address outputTokenAddress = abi.decode(strategyData, (address));\n\n    uint256 offset = 0;\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (address(tokens[i]) == outputTokenAddress) {\n        outputTokenIndex = i;\n        break;\n      } else if (address(tokens[i]) == address(inputToken)) {\n        offset = 1;\n      }\n    }\n\n    uint256[] memory minAmountsOut = new uint256[](tokens.length);\n    minAmountsOut[outputTokenIndex] = 1;\n    outputToken = tokens[outputTokenIndex];\n\n    bytes memory userData = abi.encode(ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, inputAmount, outputTokenIndex - offset);\n\n    ExitPoolRequest memory request = ExitPoolRequest(\n      tokens,\n      minAmountsOut,\n      userData,\n      false //toInternalBalance\n    );\n    vault.exitPool(poolId, address(this), payable(address(this)), request);\n\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"BalancerLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/BalancerPoolTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title BalancerPoolTokenLiquidator\n * @notice Exchanges seized Balancer Pool Token (BPT) collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BalancerPoolTokenLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n  function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n  function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData)\n  external\n  override\n  returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit Balancer pool\n    IBalancerPool balancerPool = IBalancerPool(address(inputToken));\n    address[] memory tokens = balancerPool.getFinalTokens();\n    uint256[] memory minAmountsOut = new uint256[](tokens.length);\n    balancerPool.exitPool(inputAmount, minAmountsOut);\n\n    // Swap underlying tokens\n    (IUniswapV2Router02 uniswapV2Router, address[][] memory swapPaths) = abi.decode(strategyData, (IUniswapV2Router02, address[][]));\n    require(swapPaths.length == tokens.length, \"Swap paths array length must match the number of underlying tokens in the Balancer pool.\");\n    for (uint256 i = 1; i < swapPaths.length; i++)\n      require((swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]) == (swapPaths[i].length > 0 ? swapPaths[i][swapPaths[i].length - 1] : tokens[i]), \"All underlying token swap paths must output the same token.\");\n\n    for (uint256 i = 0; i < swapPaths.length; i++) if (swapPaths[i].length > 0 && swapPaths[i][swapPaths[i].length - 1] != tokens[i]) {\n      uint256 swapAmountIn = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n      safeApprove(IERC20Upgradeable(tokens[i]), address(uniswapV2Router), swapAmountIn);\n      uniswapV2Router.swapExactTokensForTokens(swapAmountIn, 0, swapPaths[i], address(this), block.timestamp);\n    }\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"BalancerPoolTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/BalancerSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IRedemptionStrategy.sol\";\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/balancer/IBalancerVault.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract BalancerSwapLiquidator is IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address outputTokenAddress, IBalancerPool pool) = abi.decode(strategyData, (address, IBalancerPool));\n\n    IBalancerVault vault = pool.getVault();\n    bytes32 poolId = pool.getPoolId();\n\n    SingleSwap memory singleSwap = SingleSwap(\n      poolId,\n      SwapKind.GIVEN_IN,\n      IAsset(address(inputToken)),\n      IAsset(address(outputTokenAddress)),\n      inputAmount,\n      \"\"\n    );\n\n    FundManagement memory funds = FundManagement(\n      address(this),\n      false, // fromInternalBalance\n      payable(address(this)),\n      false // toInternalBalance\n    );\n\n    inputToken.approve(address(vault), inputAmount);\n    vault.swap(singleSwap, funds, 0, block.timestamp + 10);\n    outputAmount = IERC20Upgradeable(outputTokenAddress).balanceOf(address(this));\n    return (IERC20Upgradeable(outputTokenAddress), outputAmount);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"BalancerSwapLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/BaseUniswapV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\nabstract contract BaseUniswapV2Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap router and path\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapPath) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[])\n    );\n    require(swapPath.length >= 2 && swapPath[0] == address(inputToken), \"Invalid UniswapLiquidator swap path.\");\n\n    // Swap underlying tokens\n    inputToken.approve(address(uniswapV2Router), inputAmount);\n\n    // call the relevant fn depending on the uni v2 fork specifics\n    _swap(uniswapV2Router, inputAmount, swapPath);\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapPath[swapPath.length - 1]);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function _swap(\n    IUniswapV2Router02 uniswapV2Router,\n    uint256 inputAmount,\n    address[] memory swapPath\n  ) internal virtual;\n}\n"
    },
    "contracts/liquidators/CErc20Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CErc20Liquidator\n * @notice Redeems seized Compound/Cream/Ionic CErc20 cTokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CErc20Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem cErc20 for underlying ERC20 token (and store output as new collateral)\n    ICErc20Compound cErc20 = ICErc20Compound(address(inputToken));\n    uint256 redeemResult = cErc20.redeem(inputAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cErc20: error code not equal to 0\");\n    outputToken = IERC20Upgradeable(cErc20.underlying());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CErc20Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveLiquidityGaugeV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\nimport \"../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2Liquidator\n * @notice Redeems seized Curve LiquidityGaugeV2 collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLiquidityGaugeV2Liquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem Curve liquidity gauge V2 token for Curve pool LP token (and store output as new collateral)\n    ICurveLiquidityGaugeV2 gauge = ICurveLiquidityGaugeV2(address(inputToken));\n    gauge.withdraw(inputAmount);\n    inputToken = IERC20Upgradeable(gauge.lp_token());\n\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurvePool curvePool = ICurvePool(\n      ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken))\n    );\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CurveLiquidityGaugeV2Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLpTokenLiquidator\n * @notice Redeems seized Curve LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLpTokenLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurvePool curvePool = ICurvePool(\n      ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken))\n    );\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CurveLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveLpTokenLiquidatorNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurvePool.sol\";\nimport \"../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\n\nimport { WETH } from \"solmate/tokens/WETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLpTokenLiquidatorNoRegistry\n * @notice Redeems seized Curve LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLpTokenLiquidatorNoRegistry is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // TODO get the curvePool from the strategyData instead of the _oracle\n    (address outputTokenAddress, address payable wtoken, address _oracle) = abi.decode(\n      strategyData,\n      (address, address, address)\n    );\n    // the oracle contains the pool registry\n    CurveLpTokenPriceOracleNoRegistry oracle = CurveLpTokenPriceOracleNoRegistry(_oracle);\n\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurvePool curvePool = ICurvePool(oracle.poolOf(address(inputToken)));\n\n    uint8 outputIndex = type(uint8).max;\n\n    uint8 j = 0;\n    while (outputIndex == type(uint8).max) {\n      try curvePool.coins(uint256(j)) returns (address coin) {\n        if (coin == outputTokenAddress) outputIndex = j;\n      } catch {\n        break;\n      }\n      j++;\n    }\n\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(outputIndex)), 1);\n\n    // better safe than sorry\n    if (outputTokenAddress == address(0) || outputTokenAddress == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      WETH(wtoken).deposit{ value: address(this).balance }();\n      outputToken = IERC20Upgradeable(wtoken);\n    } else {\n      outputToken = IERC20Upgradeable(outputTokenAddress);\n    }\n    outputAmount = outputToken.balanceOf(address(this));\n\n    return (outputToken, outputAmount);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CurveLpTokenLiquidatorNoRegistry\";\n  }\n}\n\ncontract CurveLpTokenWrapper is IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (ICurvePool curvePool, address _outputTokenAddress) = abi.decode(strategyData, (ICurvePool, address));\n    outputToken = IERC20Upgradeable(_outputTokenAddress);\n\n    uint8 inputIndex = type(uint8).max;\n\n    uint8 j = 0;\n    while (inputIndex == type(uint8).max) {\n      try curvePool.coins(uint256(j)) returns (address coin) {\n        if (coin == address(inputToken)) inputIndex = j;\n      } catch {\n        break;\n      }\n      j++;\n    }\n\n    inputToken.approve(address(curvePool), inputAmount);\n    uint256[2] memory amounts;\n    amounts[inputIndex] = inputAmount;\n    curvePool.add_liquidity(amounts, 1);\n\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CurveLpTokenWrapper\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveMetapoolLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveStableSwap.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveMetaPoolLpTokenLiquidator\n * @notice Redeems seized Curve Metapool LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveMetaPoolLpTokenLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurveStableSwap curvePool = ICurveStableSwap(address(inputToken));\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CurveMetaPoolLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurvePool.sol\";\n\nimport { WETH } from \"solmate/tokens/WETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\nimport \"../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\nimport \"../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\n\n/**\n * @title CurveSwapLiquidator\n * @notice Swaps seized token collateral via Curve as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveSwapLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable, uint256) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (\n      CurveLpTokenPriceOracleNoRegistry curveV1Oracle,\n      CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle,\n      ,\n      address outputTokenAddress,\n      address payable wtoken\n    ) = abi.decode(\n        strategyData,\n        (CurveLpTokenPriceOracleNoRegistry, CurveV2LpTokenPriceOracleNoRegistry, address, address, address)\n      );\n\n    address inputTokenAddress = address(inputToken);\n\n    ICurvePool curvePool;\n    int128 i;\n    int128 j;\n    if (address(curveV2Oracle) != address(0)) {\n      (curvePool, i, j) = curveV2Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\n    }\n    if (address(curvePool) == address(0)) {\n      (curvePool, i, j) = curveV1Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\n    }\n    require(address(curvePool) != address(0), \"!curve pool\");\n\n    inputToken.approve(address(curvePool), inputAmount);\n    curvePool.exchange(i, j, inputAmount, 0);\n\n    // Convert to W_NATIVE if ETH\n    if (outputTokenAddress == address(0) || outputTokenAddress == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      WETH(wtoken).deposit{ value: outputAmount }();\n      outputToken = IERC20Upgradeable(wtoken);\n    } else {\n      outputToken = IERC20Upgradeable(outputTokenAddress);\n    }\n    outputAmount = outputToken.balanceOf(address(this));\n\n    return (outputToken, outputAmount);\n  }\n\n  function name() public pure virtual returns (string memory) {\n    return \"CurveSwapLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/CurveSwapLiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CurveSwapLiquidator.sol\";\nimport \"./IFundsConversionStrategy.sol\";\n\nimport { IERC20MetadataUpgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ncontract CurveSwapLiquidatorFunder is CurveSwapLiquidator, IFundsConversionStrategy {\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable, uint256)\n  {\n    ICurvePool curvePool;\n    int128 i;\n    int128 j;\n    {\n      (\n        CurveLpTokenPriceOracleNoRegistry curveV1Oracle,\n        CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle,\n        address inputTokenAddress,\n        address outputTokenAddress,\n\n      ) = abi.decode(\n          strategyData,\n          (CurveLpTokenPriceOracleNoRegistry, CurveV2LpTokenPriceOracleNoRegistry, address, address, address)\n        );\n\n      if (address(curveV2Oracle) != address(0)) {\n        (curvePool, i, j) = curveV2Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\n      }\n      if (address(curvePool) == address(0)) {\n        (curvePool, i, j) = curveV1Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\n      }\n    }\n    require(address(curvePool) != address(0), \"!curve pool\");\n\n    IERC20MetadataUpgradeable inputMetadataToken = IERC20MetadataUpgradeable(curvePool.coins(uint256(int256(i))));\n    uint256 inputAmountGuesstimate = guesstimateInputAmount(curvePool, i, j, inputMetadataToken, outputAmount);\n    uint256 inputAmount = binSearch(\n      curvePool,\n      i,\n      j,\n      (70 * inputAmountGuesstimate) / 100,\n      (130 * inputAmountGuesstimate) / 100,\n      outputAmount\n    );\n\n    return (inputMetadataToken, inputAmount);\n  }\n\n  function guesstimateInputAmount(\n    ICurvePool curvePool,\n    int128 i,\n    int128 j,\n    IERC20MetadataUpgradeable inputMetadataToken,\n    uint256 outputAmount\n  ) internal view returns (uint256) {\n    uint256 oneInputToken = 10**inputMetadataToken.decimals();\n    uint256 outputTokensForOneInputToken = curvePool.get_dy(i, j, oneInputToken);\n    // inputAmount / outputAmount = oneInputToken / outputTokensForOneInputToken\n    uint256 inputAmount = (outputAmount * oneInputToken) / outputTokensForOneInputToken;\n    return inputAmount;\n  }\n\n  function binSearch(\n    ICurvePool curvePool,\n    int128 i,\n    int128 j,\n    uint256 low,\n    uint256 high,\n    uint256 value\n  ) internal view returns (uint256) {\n    if (low >= high) return low;\n\n    uint256 mid = (low + high) / 2;\n    uint256 outputAmount = curvePool.get_dy(i, j, mid);\n    if (outputAmount == 0) revert(\"output amount 0\");\n    // output can be up to 10% in excess\n    if (outputAmount >= value && outputAmount <= (11 * value) / 10) return mid;\n    else if (outputAmount > value) {\n      return binSearch(curvePool, i, j, low, mid, value);\n    } else {\n      return binSearch(curvePool, i, j, mid, high, value);\n    }\n  }\n\n  function name() public pure override(CurveSwapLiquidator, IRedemptionStrategy) returns (string memory) {\n    return \"CurveSwapLiquidatorFunder\";\n  }\n}\n"
    },
    "contracts/liquidators/CustomLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CustomLiquidator\n * @notice Redeems seized collateral tokens for the specified output token by calling the specified contract for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CustomLiquidator is IRedemptionStrategy {\n  using AddressUpgradeable for address;\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Call arbitrary contract\n    address target;\n    bytes memory data;\n    (target, data, outputToken) = abi.decode(strategyData, (address, bytes, IERC20Upgradeable));\n    target.functionCall(data);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `IonicLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"CustomLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/DolaStabilizerLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/inverse/Stabilizer.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title DolaStabilizerLiquidator\n * @notice Buys DOLA using DAI and sells DOLA for DAI using the Anchor Stabilizer contract as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract DolaStabilizerLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Anchor's Stabilizer contract for DOLA.\n   */\n  Stabilizer public STABILIZER = Stabilizer(0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd);\n\n  /**\n   * @dev Stabilizer's fee denominator.\n   */\n  uint256 public constant FEE_DENOMINATOR = 10000;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Approve input token to Stabilizer\n    safeApprove(inputToken, address(STABILIZER), inputAmount);\n\n    // Buy or sell depending on if input is synth or reserve\n    address synth = STABILIZER.synth();\n    address reserve = STABILIZER.reserve();\n\n    if (address(inputToken) == reserve) {\n      // Buy DOLA with DAI\n      outputAmount = (inputAmount * FEE_DENOMINATOR) / (FEE_DENOMINATOR + STABILIZER.buyFee());\n      STABILIZER.buy(outputAmount);\n      outputToken = IERC20Upgradeable(synth);\n    } else if (address(inputToken) == synth) {\n      // Sell DOLA for DAI\n      STABILIZER.sell(inputAmount);\n      outputToken = IERC20Upgradeable(reserve);\n      outputAmount = outputToken.balanceOf(address(this));\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"DolaStabilizerLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/ERC4626Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { IERC4626 } from \"../compound/IERC4626.sol\";\nimport { IUniswapV2Router02 } from \"../external/uniswap/IUniswapV2Router02.sol\";\nimport { IRedemptionStrategy } from \"./IRedemptionStrategy.sol\";\nimport { ISwapRouter } from \"../external/uniswap/ISwapRouter.sol\";\nimport { Quoter } from \"../external/uniswap/quoter/Quoter.sol\";\n\n/**\n * @title ERC4626Liquidator\n * @notice Redeems ERC4626 assets and optionally swaps them via Uniswap V2 router for use as a step in a liquidation.\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n */\ncontract ERC4626Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap router and path\n    (IERC20Upgradeable _outputToken, uint24 fee, ISwapRouter swapRouter, address[] memory underlyingTokens, ) = abi\n      .decode(strategyData, (IERC20Upgradeable, uint24, ISwapRouter, address[], Quoter));\n\n    if (underlyingTokens.length == 1) {\n      // If there is only one underlying token, we can just redeem it directly\n      require(\n        address(_outputToken) == underlyingTokens[0],\n        \"ERC4626Liquidator: output token does not match underlying token\"\n      );\n\n      IERC4626(address(inputToken)).redeem(inputAmount, address(this), address(this));\n      outputAmount = IERC20Upgradeable(_outputToken).balanceOf(address(this));\n\n      return (_outputToken, outputAmount);\n    } else {\n      // NOTE: for Sommelier, the underlying tokens can be fetched from the Sommelier contract\n      // E.g. https://etherscan.io/address/0x6b7f87279982d919bbf85182ddeab179b366d8f2#readContract#F20\n      IERC4626(address(inputToken)).redeem(inputAmount, address(this), address(this));\n\n      // for each token, we need to swap it for the output token\n      for (uint256 i = 0; i < underlyingTokens.length; i++) {\n        // do nothing if the token is the output token\n        if (underlyingTokens[i] == address(_outputToken)) {\n          continue;\n        }\n        if (IERC20Upgradeable(underlyingTokens[i]).balanceOf(address(this)) == 0) {\n          continue;\n        }\n        _swap(\n          underlyingTokens[i],\n          IERC20Upgradeable(underlyingTokens[i]).balanceOf(address(this)),\n          address(_outputToken),\n          swapRouter,\n          fee\n        );\n      }\n      outputAmount = _outputToken.balanceOf(address(this));\n      return (_outputToken, outputAmount);\n    }\n  }\n\n  function _swap(\n    address inputToken,\n    uint256 inputAmount,\n    address outputToken,\n    ISwapRouter swapRouter,\n    uint24 fee\n  ) internal returns (uint256 outputAmount) {\n    IERC20Upgradeable(inputToken).approve(address(swapRouter), inputAmount);\n\n    ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n      address(inputToken),\n      outputToken,\n      fee,\n      address(this),\n      block.timestamp,\n      inputAmount,\n      0,\n      0\n    );\n    outputAmount = swapRouter.exactInputSingle(params);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"ERC4626Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/gamma/GammaAlgebraLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"../IRedemptionStrategy.sol\";\nimport { GammaLpTokenLiquidatorBase, GammaAlgebraLpTokenLiquidatorBase, GammaLpTokenWrapperBase } from \"./GammaLpTokenLiquidatorBase.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract GammaAlgebraLpTokenLiquidator is\n  GammaLpTokenLiquidatorBase,\n  GammaAlgebraLpTokenLiquidatorBase,\n  IRedemptionStrategy\n{\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _redeem(inputToken, inputAmount, strategyData);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"GammaAlgebraLpTokenLiquidator\";\n  }\n}\n\ncontract GammaAlgebraLpTokenWrapper is GammaLpTokenWrapperBase, GammaAlgebraLpTokenLiquidatorBase, IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _redeem(inputToken, inputAmount, strategyData);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"GammaAlgebraLpTokenWrapper\";\n  }\n}\n"
    },
    "contracts/liquidators/gamma/GammaLpTokenLiquidatorBase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../IRedemptionStrategy.sol\";\nimport { IHypervisor } from \"../../external/gamma/IHypervisor.sol\";\nimport { IUniProxy } from \"../../external/gamma/IUniProxy.sol\";\nimport { IUniswapV3Pool } from \"../../external/uniswap/IUniswapV3Pool.sol\";\nimport { IAlgebraSwapRouter } from \"../../external/algebra/ISwapRouter.sol\";\nimport { ISwapRouter as IUniswapSwapRouter } from \"../../external/uniswap/ISwapRouter.sol\";\nimport { IAlgebraPool } from \"../../external/algebra/IAlgebraPool.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nabstract contract GammaTokenLiquidatorAbstractBase {\n  function getSqrtX96Price(address pool) public view virtual returns (uint160 sqrtPriceX96);\n\n  function exactInputSingle(\n    address swapRouter,\n    address inputToken,\n    address outputToken,\n    IHypervisor vault,\n    uint256 swapAmount\n  ) public payable virtual returns (uint256);\n}\n\ncontract GammaAlgebraLpTokenLiquidatorBase is GammaTokenLiquidatorAbstractBase {\n  function getSqrtX96Price(address pool) public view override returns (uint160 sqrtPriceX96) {\n    (sqrtPriceX96, , , , , , ) = IAlgebraPool(pool).globalState();\n  }\n\n  function exactInputSingle(\n    address swapRouter,\n    address inputToken,\n    address outputToken,\n    IHypervisor vault,\n    uint256 swapAmount\n  ) public payable override returns (uint256) {\n    if (outputToken == address(0)) {\n      outputToken = inputToken == vault.token0() ? vault.token1() : vault.token0();\n    }\n    return\n      IAlgebraSwapRouter(swapRouter).exactInputSingle(\n        IAlgebraSwapRouter.ExactInputSingleParams(\n          inputToken,\n          outputToken,\n          address(this),\n          block.timestamp,\n          swapAmount,\n          0, // amount out min\n          0 // limitSqrtPrice\n        )\n      );\n  }\n}\n\ncontract GammaUniswapV3LpTokenLiquidatorBase is GammaTokenLiquidatorAbstractBase {\n  function getSqrtX96Price(address pool) public view override returns (uint160 sqrtPriceX96) {\n    (sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n  }\n\n  function exactInputSingle(\n    address swapRouter,\n    address inputToken,\n    address outputToken,\n    IHypervisor vault,\n    uint256 swapAmount\n  ) public payable override returns (uint256) {\n    IUniswapV3Pool pool = IUniswapV3Pool(vault.pool());\n    if (outputToken == address(0)) {\n      outputToken = inputToken == vault.token0() ? vault.token1() : vault.token0();\n    }\n    return\n      IUniswapSwapRouter(swapRouter).exactInputSingle(\n        IUniswapSwapRouter.ExactInputSingleParams(\n          inputToken,\n          outputToken,\n          pool.fee(),\n          address(this),\n          block.timestamp,\n          swapAmount,\n          0, // amount out min\n          0 // limitSqrtPrice\n        )\n      );\n  }\n}\n\n/**\n * @title GammaLpTokenLiquidatorBase\n * @notice Exchanges seized Gamma LP token collateral for underlying tokens via an Algebra pool for use as a step in a liquidation.\n * @author Veliko Minkov <veliko@midascapital.xyz> (https://github.com/vminkov)\n */\nabstract contract GammaLpTokenLiquidatorBase is GammaTokenLiquidatorAbstractBase {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n\n  function _redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Gamma pool and underlying tokens\n    IHypervisor vault = IHypervisor(address(inputToken));\n\n    // First withdraw the underlying tokens\n    uint256[4] memory minAmounts;\n    vault.withdraw(inputAmount, address(this), address(this), minAmounts);\n\n    // then swap one of the underlying for the other\n    IERC20Upgradeable token0 = IERC20Upgradeable(vault.token0());\n    IERC20Upgradeable token1 = IERC20Upgradeable(vault.token1());\n\n    (address _outputToken, address swapRouter) = abi.decode(strategyData, (address, address));\n\n    uint256 swapAmount;\n    IERC20Upgradeable tokenToSwap;\n    if (_outputToken == address(token1)) {\n      swapAmount = token0.balanceOf(address(this));\n      tokenToSwap = token0;\n    } else {\n      swapAmount = token1.balanceOf(address(this));\n      tokenToSwap = token1;\n    }\n\n    tokenToSwap.approve(address(swapRouter), swapAmount);\n\n    exactInputSingle(swapRouter, address(tokenToSwap), _outputToken, vault, swapAmount);\n\n    outputToken = IERC20Upgradeable(_outputToken);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n\nabstract contract GammaLpTokenWrapperBase is GammaTokenLiquidatorAbstractBase {\n  function _redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address swapRouter, IUniProxy proxy, IHypervisor vault) = abi.decode(\n      strategyData,\n      (address, IUniProxy, IHypervisor)\n    );\n\n    address token0 = vault.token0();\n    address token1 = vault.token1();\n    {\n      uint256 swapAmount;\n      {\n        uint256 ratio;\n        uint256 price;\n        {\n          uint256 token0Decimals = 10**ERC20Upgradeable(token0).decimals();\n          uint256 token1Decimals = 10**ERC20Upgradeable(token1).decimals();\n          {\n            uint256 decimalsDiff = (1e18 * token0Decimals) / token1Decimals;\n            uint256 decimalsDenominator = decimalsDiff > 1e12 ? 1e6 : 1;\n            uint256 sqrtPriceX96 = getSqrtX96Price(vault.pool());\n            price = ((sqrtPriceX96**2 * (decimalsDiff / decimalsDenominator)) / (2**192)) * decimalsDenominator;\n          }\n          (uint256 amountStart, uint256 amountEnd) = proxy.getDepositAmount(address(vault), token0, token0Decimals);\n          uint256 amount1 = (((amountStart + amountEnd) / 2) * 1e18) / token1Decimals;\n          ratio = (amount1 * 1e18) / price;\n        }\n\n        uint256 swap0 = (inputAmount * 1e18) / (ratio + 1e18);\n        swapAmount = address(inputToken) == token0 ? inputAmount - swap0 : swap0;\n      }\n\n      inputToken.approve(swapRouter, inputAmount);\n      exactInputSingle(swapRouter, address(inputToken), address(0), vault, swapAmount);\n    }\n\n    uint256 deposit0;\n    uint256 deposit1;\n    {\n      deposit0 = IERC20Upgradeable(token0).balanceOf(address(this));\n      deposit1 = IERC20Upgradeable(token1).balanceOf(address(this));\n      IERC20Upgradeable(token0).approve(address(vault), deposit0);\n      IERC20Upgradeable(token1).approve(address(vault), deposit1);\n    }\n\n    uint256[4] memory minIn;\n    outputAmount = proxy.deposit(\n      deposit0,\n      deposit1,\n      address(this), // to\n      address(vault),\n      minIn\n    );\n\n    outputToken = IERC20Upgradeable(address(vault));\n  }\n}\n"
    },
    "contracts/liquidators/gamma/GammaUniswapV3LpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"../IRedemptionStrategy.sol\";\nimport { GammaLpTokenLiquidatorBase, GammaUniswapV3LpTokenLiquidatorBase, GammaLpTokenWrapperBase } from \"./GammaLpTokenLiquidatorBase.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract GammaUniswapV3LpTokenLiquidator is\n  GammaLpTokenLiquidatorBase,\n  GammaUniswapV3LpTokenLiquidatorBase,\n  IRedemptionStrategy\n{\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _redeem(inputToken, inputAmount, strategyData);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"GammaUniswapV3LpTokenLiquidator\";\n  }\n}\n\ncontract GammaUniswapV3LpTokenWrapper is\n  GammaLpTokenWrapperBase,\n  GammaUniswapV3LpTokenLiquidatorBase,\n  IRedemptionStrategy\n{\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _redeem(inputToken, inputAmount, strategyData);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"GammaUniswapV3LpTokenWrapper\";\n  }\n}\n"
    },
    "contracts/liquidators/GelatoGUniLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../external/gelato/GUniPool.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GelatoGUniLiquidator\n * @notice Exchanges seized GelatoGUni token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GelatoGUniLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit GUni pool\n    GUniPool pool = GUniPool(address(inputToken));\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n    (uint256 amount0, uint256 amount1, ) = pool.burn(inputAmount, address(this));\n\n    // Swap underlying tokens\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[], address[])\n    );\n    require(\n      (swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) ==\n        (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1),\n      \"Output of token0 swap path must equal output of token1 swap path.\"\n    );\n\n    if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n      safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n      uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n    }\n\n    if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n      safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n      uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n    }\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"GelatoGUniLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/HarvestLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/harvest/IFarmVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title HarvestLiquidator\n * @notice Exchanges seized iFARM token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestLiquidator is IRedemptionStrategy {\n  /**\n   * @dev FARM ERC20 token contract.\n   */\n  IERC20Upgradeable public constant FARM = IERC20Upgradeable(0xa0246c9032bC3A600820415aE600c6388619A14D);\n\n  /**\n   * @dev iFARM ERC20 token contract.\n   */\n  IFarmVault public constant IFARM = IFarmVault(0x1571eD0bed4D987fe2b498DdBaE7DFA19519F651);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    if (address(inputToken) == address(IFARM)) {\n      IFARM.withdrawAll();\n      outputToken = FARM;\n      outputAmount = outputToken.balanceOf(address(this));\n    } else revert(\"Invalid token address passed to HarvestLiquidator.\");\n  }\n\n  function name() public pure returns (string memory) {\n    return \"HarvestLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/IFundsConversionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IRedemptionStrategy.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IFundsConversionStrategy is IRedemptionStrategy {\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\n\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable inputToken, uint256 inputAmount);\n}\n"
    },
    "contracts/liquidators/IRedemptionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title IRedemptionStrategy\n * @notice Redeems seized wrapped token collateral for an underlying token for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\n\n  function name() external view returns (string memory);\n}\n"
    },
    "contracts/liquidators/JarvisLiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { IERC20MetadataUpgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\nimport { IFundsConversionStrategy } from \"./IFundsConversionStrategy.sol\";\nimport { ISynthereumLiquidityPool } from \"../external/jarvis/ISynthereumLiquidityPool.sol\";\n\ncontract JarvisLiquidatorFunder is IFundsConversionStrategy {\n  using FixedPointMathLib for uint256;\n\n  /**\n   * @dev Redeems `inputToken` for `outputToken` where `inputAmount` < `outputAmount`\n   * @param inputToken Address of the token\n   * @param inputAmount input amount\n   * @param strategyData context specific data like input token, pool address and tx expiratio period\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (, address poolAddress, ) = abi.decode(strategyData, (address, address, uint256));\n    ISynthereumLiquidityPool pool = ISynthereumLiquidityPool(poolAddress);\n\n    // approve so the pool can pull out the input tokens\n    inputToken.approve(address(pool), inputAmount);\n\n    IERC20Upgradeable collateralToken = pool.collateralToken();\n    IERC20Upgradeable syntheticToken = pool.syntheticToken();\n\n    if (inputToken == syntheticToken) {\n      outputToken = collateralToken;\n\n      uint256 shutdownPrice = 0;\n      // TODO figure out why this method was removed and what to use instead\n      try pool.emergencyShutdownPrice() returns (uint256 price) {\n        shutdownPrice = price;\n      } catch {}\n\n      if (shutdownPrice > 0) {\n        // emergency shutdowns cannot be reverted, so this corner case must be covered\n        (, uint256 collateralSettled) = pool.settleEmergencyShutdown();\n        outputAmount = collateralSettled;\n        // outputToken = collateralToken;\n      } else {\n        // redeem the underlying BUSD\n        // fetch the estimated redeemable collateral in BUSD, less the fee paid\n        (uint256 redeemableCollateralAmount, ) = pool.getRedeemTradeInfo(inputAmount);\n\n        (uint256 collateralAmountReceived, ) = pool.redeem(\n          ISynthereumLiquidityPool.RedeemParams(inputAmount, redeemableCollateralAmount, block.timestamp, address(this))\n        );\n\n        outputAmount = collateralAmountReceived;\n      }\n    } else if (inputToken == collateralToken) {\n      outputToken = syntheticToken;\n\n      // mint jBRL from the supplied bUSD\n      (uint256 synthTokensReceived, ) = pool.getMintTradeInfo(inputAmount);\n\n      (uint256 syntheticTokensMinted, ) = pool.mint(\n        ISynthereumLiquidityPool.MintParams(synthTokensReceived, inputAmount, block.timestamp, address(this))\n      );\n\n      outputAmount = syntheticTokensMinted;\n    } else {\n      revert(\"unknown input token\");\n    }\n  }\n\n  /**\n   * @dev Estimates the needed input amount of the input token for the conversion to return the desired output amount.\n   * @param outputAmount the desired output amount\n   * @param strategyData the input token\n   */\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable inputToken, uint256 inputAmount)\n  {\n    (address inputTokenAddress, address poolAddress, ) = abi.decode(strategyData, (address, address, uint256));\n\n    inputToken = IERC20Upgradeable(inputTokenAddress);\n\n    uint8 decimals = 18;\n    try IERC20MetadataUpgradeable(inputTokenAddress).decimals() returns (uint8 dec) {\n      decimals = dec;\n    } catch {}\n    uint256 ONE = 10**decimals;\n\n    ISynthereumLiquidityPool pool = ISynthereumLiquidityPool(poolAddress);\n    if (inputToken == pool.syntheticToken()) {\n      // collateralAmountReceived / ONE = outputAmount / inputAmount\n      // => inputAmount = (ONE * outputAmount) / collateralAmountReceived\n      (uint256 collateralAmountReceived, ) = ISynthereumLiquidityPool(poolAddress).getRedeemTradeInfo(ONE);\n      inputAmount = ONE.mulDivUp(outputAmount, collateralAmountReceived);\n    } else if (inputToken == pool.collateralToken()) {\n      // synthTokensReceived / ONE = outputAmount / inputAmount\n      // => inputAmount = (ONE * outputAmount) / synthTokensReceived\n      (uint256 synthTokensReceived, ) = ISynthereumLiquidityPool(poolAddress).getMintTradeInfo(ONE);\n      inputAmount = ONE.mulDivUp(outputAmount, synthTokensReceived);\n    } else {\n      revert(\"unknown input token\");\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"JarvisLiquidatorFunder\";\n  }\n}\n"
    },
    "contracts/liquidators/KimUniV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./BaseUniswapV2Liquidator.sol\";\n\ncontract KimUniV2Liquidator is BaseUniswapV2Liquidator {\n  function _swap(\n    IUniswapV2Router02 uniswapV2Router,\n    uint256 inputAmount,\n    address[] memory swapPath\n  ) internal override {\n    uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      inputAmount,\n      0,\n      swapPath,\n      address(this),\n      address(0), // referrer\n      block.timestamp\n    );\n  }\n\n  function name() public pure virtual returns (string memory) {\n    return \"KimUniV2Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/MStableLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/mstable/IMasset.sol\";\nimport \"../external/mstable/ISavingsContractV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title MStableLiquidator\n * @notice Redeems mUSD, imUSD, mBTC, and imBTC for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MStableLiquidator is IRedemptionStrategy {\n  /**\n   * @dev mStable imUSD ERC20 token contract object.\n   */\n  IMasset public constant MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n  /**\n   * @dev mStable mUSD ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n  /**\n   * @dev mStable mBTC ERC20 token contract object.\n   */\n  IMasset public constant MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n  /**\n   * @dev mStable imBTC ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get output token\n    if (strategyData.length > 0) (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n\n    // TODO: Choose asset to redeem dynamically\n    if (address(inputToken) == address(MUSD)) {\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n      outputAmount = MUSD.redeem(address(outputToken), inputAmount, 1, address(this));\n    } else if (address(inputToken) == address(IMUSD)) {\n      // Redeem imUSD for mUSD\n      uint256 mAssetReturned = IMUSD.redeemCredits(inputAmount);\n      require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n      outputAmount = MUSD.redeem(address(outputToken), mAssetReturned, 1, address(this));\n    } else if (address(inputToken) == address(MBTC)) {\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n      outputAmount = MBTC.redeem(address(outputToken), inputAmount, 1, address(this));\n    } else if (address(inputToken) == address(IMBTC)) {\n      // Redeem imUSD for mUSD\n      uint256 mAssetReturned = IMBTC.redeemCredits(inputAmount);\n      require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n      outputAmount = MBTC.redeem(address(outputToken), mAssetReturned, 1, address(this));\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"MStableLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/registry/ILiquidatorsRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ILiquidatorsRegistryStorage {\n  function redemptionStrategiesByName(string memory name) external view returns (IRedemptionStrategy);\n\n  function redemptionStrategiesByTokens(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (IRedemptionStrategy);\n\n  function defaultOutputToken(IERC20Upgradeable inputToken) external view returns (IERC20Upgradeable);\n\n  function owner() external view returns (address);\n\n  function uniswapV3Fees(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) external view returns (uint24);\n\n  function customUniV3Router(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (address);\n}\n\ninterface ILiquidatorsRegistryExtension {\n  function getInputTokensByOutputToken(IERC20Upgradeable outputToken) external view returns (address[] memory);\n\n  function getRedemptionStrategies(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData);\n\n  function getRedemptionStrategy(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (IRedemptionStrategy strategy, bytes memory strategyData);\n\n  function getAllRedemptionStrategies() external view returns (address[] memory);\n\n  function getSlippage(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (uint256 slippage);\n\n  function swap(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IERC20Upgradeable outputToken\n  ) external returns (uint256);\n\n  function amountOutAndSlippageOfSwap(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IERC20Upgradeable outputToken\n  ) external returns (uint256 outputAmount, uint256 slippage);\n}\n\ninterface ILiquidatorsRegistrySecondExtension {\n  function getAllPairsStrategies()\n    external\n    view\n    returns (\n      IRedemptionStrategy[] memory strategies,\n      IERC20Upgradeable[] memory inputTokens,\n      IERC20Upgradeable[] memory outputTokens\n    );\n\n  function pairsStrategiesMatch(\n    IRedemptionStrategy[] calldata configStrategies,\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens\n  ) external view returns (bool);\n\n  function uniswapPairsFeesMatch(\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens,\n    uint256[] calldata configFees\n  ) external view returns (bool);\n\n  function uniswapPairsRoutersMatch(\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens,\n    address[] calldata configRouters\n  ) external view returns (bool);\n\n  function _setRedemptionStrategy(\n    IRedemptionStrategy strategy,\n    IERC20Upgradeable inputToken,\n    IERC20Upgradeable outputToken\n  ) external;\n\n  function _setRedemptionStrategies(\n    IRedemptionStrategy[] calldata strategies,\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens\n  ) external;\n\n  function _resetRedemptionStrategies(\n    IRedemptionStrategy[] calldata strategies,\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens\n  ) external;\n\n  function _removeRedemptionStrategy(IRedemptionStrategy strategyToRemove) external;\n\n  function _setDefaultOutputToken(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) external;\n\n  function _setUniswapV3Fees(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    uint24[] calldata fees\n  ) external;\n\n  function _setUniswapV3Routers(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    address[] calldata routers\n  ) external;\n\n  function _setSlippages(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    uint256[] calldata slippages\n  ) external;\n}\n\ninterface ILiquidatorsRegistry is\n  ILiquidatorsRegistryExtension,\n  ILiquidatorsRegistrySecondExtension,\n  ILiquidatorsRegistryStorage\n{}\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../../ionic/DiamondExtension.sol\";\nimport \"./LiquidatorsRegistryStorage.sol\";\nimport \"./LiquidatorsRegistryExtension.sol\";\n\ncontract LiquidatorsRegistry is LiquidatorsRegistryStorage, DiamondBase {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  constructor(AddressesProvider _ap) SafeOwnable() {\n    ap = _ap;\n  }\n\n  /**\n   * @dev register a logic extension\n   * @param extensionToAdd the extension whose functions are to be added\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\n   */\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace)\n    public\n    override\n    onlyOwner\n  {\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\n  }\n\n  function asExtension() public view returns (LiquidatorsRegistryExtension) {\n    return LiquidatorsRegistryExtension(address(this));\n  }\n}\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistryExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"./ILiquidatorsRegistry.sol\";\nimport \"./LiquidatorsRegistryStorage.sol\";\n\nimport \"../IRedemptionStrategy.sol\";\nimport \"../../ionic/DiamondExtension.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\n\nimport { IRouter } from \"../../external/solidly/IRouter.sol\";\nimport { IPair } from \"../../external/solidly/IPair.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport { ICurvePool } from \"../../external/curve/ICurvePool.sol\";\n\nimport { CurveLpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\nimport { CurveV2LpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\nimport { SaddleLpPriceOracle } from \"../../oracles/default/SaddleLpPriceOracle.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { XBombSwap } from \"../XBombLiquidatorFunder.sol\";\n\ncontract LiquidatorsRegistryExtension is LiquidatorsRegistryStorage, DiamondExtension, ILiquidatorsRegistryExtension {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  error NoRedemptionPath();\n  error OutputTokenMismatch();\n\n  event SlippageUpdated(\n    IERC20Upgradeable indexed from,\n    IERC20Upgradeable indexed to,\n    uint256 prevValue,\n    uint256 newValue\n  );\n\n  // @notice maximum slippage in swaps, in bps\n  uint256 public constant MAX_SLIPPAGE = 900; // 9%\n\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\n    uint8 fnsCount = 7;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.getRedemptionStrategies.selector;\n    functionSelectors[--fnsCount] = this.getRedemptionStrategy.selector;\n    functionSelectors[--fnsCount] = this.getInputTokensByOutputToken.selector;\n    functionSelectors[--fnsCount] = this.swap.selector;\n    functionSelectors[--fnsCount] = this.getAllRedemptionStrategies.selector;\n    functionSelectors[--fnsCount] = this.amountOutAndSlippageOfSwap.selector;\n    functionSelectors[--fnsCount] = this.getSlippage.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  function getSlippage(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    external\n    view\n    returns (uint256 slippage)\n  {\n    slippage = conversionSlippage[inputToken][outputToken];\n    // TODO slippage == 0 should be allowed\n    if (slippage == 0) return MAX_SLIPPAGE;\n  }\n\n  function getAllRedemptionStrategies() public view returns (address[] memory) {\n    return redemptionStrategies.values();\n  }\n\n  function amountOutAndSlippageOfSwap(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IERC20Upgradeable outputToken\n  ) external returns (uint256 outputAmount, uint256 slippage) {\n    if (inputAmount == 0) return (0, 0);\n\n    outputAmount = swap(inputToken, inputAmount, outputToken);\n    if (outputAmount == 0) return (0, 0);\n\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    uint256 inputTokenPrice = mpo.price(address(inputToken));\n    uint256 outputTokenPrice = mpo.price(address(outputToken));\n\n    uint256 inputTokensValue = inputAmount * toScaledPrice(inputTokenPrice, inputToken);\n    uint256 outputTokensValue = outputAmount * toScaledPrice(outputTokenPrice, outputToken);\n\n    if (outputTokensValue < inputTokensValue) {\n      slippage = ((inputTokensValue - outputTokensValue) * 10000) / inputTokensValue;\n    }\n    // min slippage should be non-zero\n    // just in case of rounding errors\n    slippage += 1;\n\n    // cache the slippage\n    uint256 prevValue = conversionSlippage[inputToken][outputToken];\n    if (prevValue == 0 || block.timestamp - conversionSlippageUpdated[inputToken][outputToken] > 5000) {\n      emit SlippageUpdated(inputToken, outputToken, prevValue, slippage);\n\n      conversionSlippage[inputToken][outputToken] = slippage;\n      conversionSlippageUpdated[inputToken][outputToken] = block.timestamp;\n    }\n  }\n\n  /// @dev returns price scaled to 1e36 - decimals\n  function toScaledPrice(uint256 unscaledPrice, IERC20Upgradeable token) internal view returns (uint256) {\n    uint256 tokenDecimals = uint256(ERC20Upgradeable(address(token)).decimals());\n    return\n      tokenDecimals <= 18\n        ? uint256(unscaledPrice) * (10**(18 - tokenDecimals))\n        : uint256(unscaledPrice) / (10**(tokenDecimals - 18));\n  }\n\n  function swap(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IERC20Upgradeable outputToken\n  ) public returns (uint256 outputAmount) {\n    inputToken.safeTransferFrom(msg.sender, address(this), inputAmount);\n    outputAmount = convertAllTo(inputToken, outputToken);\n    outputToken.safeTransfer(msg.sender, outputAmount);\n  }\n\n  function convertAllTo(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) private returns (uint256) {\n    uint256 inputAmount = inputToken.balanceOf(address(this));\n    (IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategiesData) = getRedemptionStrategies(\n      inputToken,\n      outputToken\n    );\n\n    if (redemptionStrategies.length == 0) revert NoRedemptionPath();\n\n    IERC20Upgradeable swapInputToken = inputToken;\n    uint256 swapInputAmount = inputAmount;\n    for (uint256 i = 0; i < redemptionStrategies.length; i++) {\n      IRedemptionStrategy redemptionStrategy = redemptionStrategies[i];\n      bytes memory strategyData = strategiesData[i];\n      (IERC20Upgradeable swapOutputToken, uint256 swapOutputAmount) = convertCustomFunds(\n        swapInputToken,\n        swapInputAmount,\n        redemptionStrategy,\n        strategyData\n      );\n      swapInputAmount = swapOutputAmount;\n      swapInputToken = swapOutputToken;\n    }\n\n    if (swapInputToken != outputToken) revert OutputTokenMismatch();\n    return outputToken.balanceOf(address(this));\n  }\n\n  function convertCustomFunds(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IRedemptionStrategy strategy,\n    bytes memory strategyData\n  ) private returns (IERC20Upgradeable, uint256) {\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.redeem.selector, inputToken, inputAmount, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function getInputTokensByOutputToken(IERC20Upgradeable outputToken) external view returns (address[] memory) {\n    return inputTokensByOutputToken[outputToken].values();\n  }\n\n  function getRedemptionStrategies(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    public\n    view\n    returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData)\n  {\n    IERC20Upgradeable tokenToRedeem = inputToken;\n    IERC20Upgradeable targetOutputToken = outputToken;\n    IRedemptionStrategy[] memory strategiesTemp = new IRedemptionStrategy[](10);\n    bytes[] memory strategiesDataTemp = new bytes[](10);\n    IERC20Upgradeable[] memory tokenPath = new IERC20Upgradeable[](10);\n\n    uint256 k = 0;\n    while (tokenToRedeem != targetOutputToken) {\n      IERC20Upgradeable nextRedeemedToken;\n      IRedemptionStrategy directStrategy = redemptionStrategiesByTokens[tokenToRedeem][targetOutputToken];\n      if (address(directStrategy) != address(0)) {\n        nextRedeemedToken = targetOutputToken;\n      } else {\n        // chain the next redeemed token from the default path\n        nextRedeemedToken = defaultOutputToken[tokenToRedeem];\n      }\n\n      // check if going in an endless loop\n      for (uint256 i = 0; i < tokenPath.length; i++) {\n        if (nextRedeemedToken == tokenPath[i]) break;\n      }\n\n      (IRedemptionStrategy strategy, bytes memory strategyData) = getRedemptionStrategy(\n        tokenToRedeem,\n        nextRedeemedToken\n      );\n      if (address(strategy) == address(0)) break;\n\n      strategiesTemp[k] = strategy;\n      strategiesDataTemp[k] = strategyData;\n      tokenPath[k] = nextRedeemedToken;\n      tokenToRedeem = nextRedeemedToken;\n\n      k++;\n      if (k == 10) break;\n    }\n\n    strategies = new IRedemptionStrategy[](k);\n    strategiesData = new bytes[](k);\n\n    for (uint8 i = 0; i < k; i++) {\n      strategies[i] = strategiesTemp[i];\n      strategiesData[i] = strategiesDataTemp[i];\n    }\n  }\n\n  function getRedemptionStrategy(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    public\n    view\n    returns (IRedemptionStrategy strategy, bytes memory strategyData)\n  {\n    strategy = redemptionStrategiesByTokens[inputToken][outputToken];\n\n    if (isStrategy(strategy, \"SolidlySwapLiquidator\")) {\n      strategyData = solidlySwapLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"SolidlyLpTokenLiquidator\")) {\n      strategyData = solidlyLpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"UniswapV2LiquidatorFunder\") || isStrategy(strategy, \"KimUniV2Liquidator\")) {\n      strategyData = uniswapV2LiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"UniswapV3LiquidatorFunder\")) {\n      strategyData = uniswapV3LiquidatorFunderData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"AlgebraSwapLiquidator\")) {\n      address swapRouter;\n      if (block.chainid == 34443) {\n        swapRouter = 0xAc48FcF1049668B285f3dC72483DF5Ae2162f7e8;\n      } else {\n        swapRouter = ap.getAddress(\"ALGEBRA_SWAP_ROUTER\");\n      }\n      strategyData = algebraSwapLiquidatorData(inputToken, outputToken, swapRouter);\n    } else if (isStrategy(strategy, \"GammaAlgebraLpTokenLiquidator\")) {\n      strategyData = gammaAlgebraLpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"GammaUniswapV3LpTokenLiquidator\")) {\n      strategyData = gammaUniswapV3LpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"BalancerSwapLiquidator\")) {\n      strategyData = balancerSwapLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"UniswapLpTokenLiquidator\") || isStrategy(strategy, \"GelatoGUniLiquidator\")) {\n      strategyData = uniswapLpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"SaddleLpTokenLiquidator\")) {\n      strategyData = saddleLpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"CurveLpTokenLiquidatorNoRegistry\")) {\n      strategyData = curveLpTokenLiquidatorNoRegistryData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"CurveSwapLiquidator\")) {\n      strategyData = curveSwapLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"CurveLpTokenWrapper\")) {\n      strategyData = curveLpTokenWrapperData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"JarvisLiquidatorFunder\")) {\n      strategyData = jarvisLiquidatorFunderData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"XBombLiquidatorFunder\")) {\n      strategyData = xBombLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"BalancerLpTokenLiquidator\")) {\n      strategyData = balancerLpTokenLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"AaveTokenLiquidator\")) {\n      strategyData = aaveLiquidatorData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"GammaAlgebraLpTokenWrapper\")) {\n      strategyData = gammaAlgebraLpTokenWrapperData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"GammaUniswapV3LpTokenWrapper\")) {\n      strategyData = gammaUniswapV3LpTokenWrapperData(inputToken, outputToken);\n    } else if (isStrategy(strategy, \"SolidlyLpTokenWrapper\")) {\n      strategyData = solidlyLpTokenWrapperData(inputToken, outputToken);\n      //} else if (isStrategy(strategy, \"ERC4626Liquidator\")) {\n      //   TODO strategyData = erc4626LiquidatorData(inputToken, outputToken);\n    } else {\n      revert(\"no strategy data\");\n    }\n  }\n\n  function isStrategy(IRedemptionStrategy strategy, string memory name) internal view returns (bool) {\n    return address(strategy) != address(0) && address(strategy) == address(redemptionStrategiesByName[name]);\n  }\n\n  function pickPreferredToken(address[] memory tokens, address strategyOutputToken) internal view returns (address) {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == strategyOutputToken) return strategyOutputToken;\n    }\n    address wnative = ap.getAddress(\"wtoken\");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == wnative) return wnative;\n    }\n    address stableToken = ap.getAddress(\"stableToken\");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == stableToken) return stableToken;\n    }\n    address wbtc = ap.getAddress(\"wBTCToken\");\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == wbtc) return wbtc;\n    }\n    return tokens[0];\n  }\n\n  function getUniswapV3Router(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (address)\n  {\n    address customRouter = customUniV3Router[inputToken][outputToken];\n    if (customRouter == address(0)) {\n      customRouter = customUniV3Router[outputToken][inputToken];\n    }\n\n    if (customRouter != address(0)) {\n      return customRouter;\n    } else {\n      // get asset specific router or default\n      return ap.getAddress(\"UNISWAP_V3_ROUTER\");\n    }\n  }\n\n  function getUniswapV2Router(IERC20Upgradeable inputToken) internal view returns (address) {\n    // get asset specific router or default\n    return ap.getAddress(\"IUniswapV2Router02\");\n  }\n\n  function solidlySwapLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    // assuming bsc for the chain\n    IRouter solidlyRouter = IRouter(ap.getAddress(\"SOLIDLY_SWAP_ROUTER\"));\n    address tokenTo = address(outputToken);\n\n    // Check if stable pair exists\n    address volatilePair = solidlyRouter.pairFor(address(inputToken), tokenTo, false);\n    address stablePair = solidlyRouter.pairFor(address(inputToken), tokenTo, true);\n\n    require(\n      solidlyRouter.isPair(stablePair) || solidlyRouter.isPair(volatilePair),\n      \"Invalid SolidlyLiquidator swap path.\"\n    );\n\n    bool stable;\n    if (!solidlyRouter.isPair(stablePair)) {\n      stable = false;\n    } else if (!solidlyRouter.isPair(volatilePair)) {\n      stable = true;\n    } else {\n      (uint256 stableR0, uint256 stableR1) = solidlyRouter.getReserves(address(inputToken), tokenTo, true);\n      (uint256 volatileR0, uint256 volatileR1) = solidlyRouter.getReserves(address(inputToken), tokenTo, false);\n      // Determine which swap has higher liquidity\n      if (stableR0 > volatileR0 && stableR1 > volatileR1) {\n        stable = true;\n      } else {\n        stable = false;\n      }\n    }\n\n    strategyData = abi.encode(solidlyRouter, outputToken, stable);\n  }\n\n  function solidlyLpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    IPair lpToken = IPair(address(inputToken));\n    require(\n      address(outputToken) == lpToken.token0() || address(outputToken) == lpToken.token1(),\n      \"Output token does not match either of the pair tokens!\"\n    );\n\n    strategyData = abi.encode(ap.getAddress(\"SOLIDLY_SWAP_ROUTER\"), outputToken);\n  }\n\n  function aaveLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    pure\n    returns (bytes memory strategyData)\n  {\n    strategyData = abi.encode(outputToken);\n  }\n\n  function gammaAlgebraLpTokenWrapperData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    address swapRouter = ap.getAddress(\"GAMMA_ALGEBRA_SWAP_ROUTER\");\n    address proxy = ap.getAddress(\"GAMMA_ALGEBRA_UNI_PROXY\"); // IUniProxy\n    address vault = address(outputToken); // IHypervisor\n\n    strategyData = abi.encode(swapRouter, proxy, vault);\n  }\n\n  function gammaUniswapV3LpTokenWrapperData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    address swapRouter = ap.getAddress(\"GAMMA_UNISWAP_V3_SWAP_ROUTER\");\n    address proxy = ap.getAddress(\"GAMMA_UNISWAP_V3_UNI_PROXY\"); // IUniProxy\n    address vault = address(outputToken); // IHypervisor\n\n    strategyData = abi.encode(swapRouter, proxy, vault);\n  }\n\n  function balancerLpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    pure\n    returns (bytes memory strategyData)\n  {\n    strategyData = abi.encode(outputToken);\n  }\n\n  function uniswapV3LiquidatorFunderData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    uint24 fee = uniswapV3Fees[inputToken][outputToken];\n    if (fee == 0) fee = uniswapV3Fees[outputToken][inputToken];\n    if (fee == 0) fee = 500;\n\n    address router = getUniswapV3Router(inputToken, outputToken);\n    strategyData = abi.encode(inputToken, outputToken, fee, router, ap.getAddress(\"Quoter\"));\n  }\n\n  function uniswapV2LiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    IERC20Upgradeable[] memory swapPath = new IERC20Upgradeable[](2);\n    swapPath[0] = inputToken;\n    swapPath[1] = outputToken;\n    strategyData = abi.encode(getUniswapV2Router(inputToken), swapPath);\n  }\n\n  function algebraSwapLiquidatorData(\n    IERC20Upgradeable inputToken,\n    IERC20Upgradeable outputToken,\n    address swapRouter\n  ) internal view returns (bytes memory strategyData) {\n    strategyData = abi.encode(outputToken, swapRouter);\n  }\n\n  function gammaAlgebraLpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    strategyData = abi.encode(outputToken, ap.getAddress(\"GAMMA_ALGEBRA_SWAP_ROUTER\"));\n  }\n\n  function gammaUniswapV3LpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    strategyData = abi.encode(outputToken, ap.getAddress(\"GAMMA_UNISWAP_V3_SWAP_ROUTER\"));\n  }\n\n  function uniswapLpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    IUniswapV2Pair lpToken = IUniswapV2Pair(address(inputToken));\n    address token0 = lpToken.token0();\n    address token1 = lpToken.token1();\n    bool token0IsOutputToken = address(outputToken) == token0;\n    bool token1IsOutputToken = address(outputToken) == token1;\n    require(token0IsOutputToken || token1IsOutputToken, \"Output token does not match either of the pair tokens\");\n\n    address[] memory swap0Path;\n    address[] memory swap1Path;\n    {\n      if (token0IsOutputToken) {\n        swap0Path = new address[](0);\n        swap1Path = new address[](2);\n        swap1Path[0] = token1;\n        swap1Path[1] = token0;\n      } else {\n        swap1Path = new address[](0);\n        swap0Path = new address[](2);\n        swap0Path[0] = token0;\n        swap0Path[1] = token1;\n      }\n    }\n\n    strategyData = abi.encode(getUniswapV2Router(inputToken), swap0Path, swap1Path);\n  }\n\n  function saddleLpTokenLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    SaddleLpPriceOracle saddleLpPriceOracle = SaddleLpPriceOracle(ap.getAddress(\"SaddleLpPriceOracle\"));\n    address[] memory tokens = saddleLpPriceOracle.getUnderlyingTokens(address(inputToken));\n\n    address wnative = ap.getAddress(\"wtoken\");\n    address preferredToken = pickPreferredToken(tokens, address(outputToken));\n    address actualOutputToken = preferredToken;\n    if (preferredToken == address(0) || preferredToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      actualOutputToken = wnative;\n    }\n    // TODO outputToken = actualOutputToken\n\n    strategyData = abi.encode(preferredToken, saddleLpPriceOracle, wnative);\n  }\n\n  function curveLpTokenLiquidatorNoRegistryData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    CurveLpTokenPriceOracleNoRegistry curveLpOracle = CurveLpTokenPriceOracleNoRegistry(\n      ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\")\n    );\n    ICurvePool curvePool = ICurvePool(curveLpOracle.poolOf(address(inputToken)));\n    address[] memory tokens = getUnderlyingTokens(curvePool);\n\n    address preferredToken = pickPreferredToken(tokens, address(outputToken));\n    address actualOutputToken = preferredToken;\n    address wnative = ap.getAddress(\"wtoken\");\n    if (preferredToken == address(0) || preferredToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      actualOutputToken = wnative;\n    }\n    // TODO outputToken = actualOutputToken\n\n    strategyData = abi.encode(preferredToken, wnative, curveLpOracle);\n  }\n\n  function getUnderlyingTokens(ICurvePool curvePool) internal view returns (address[] memory tokens) {\n    uint8 j = 0;\n    while (true) {\n      try curvePool.coins(uint256(j)) returns (address coin) {} catch {\n        break;\n      }\n      j++;\n    }\n    tokens = new address[](j);\n    for (uint256 i = 0; i < j; i++) {\n      tokens[i] = curvePool.coins(i);\n    }\n  }\n\n  function curveLpTokenWrapperData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    CurveLpTokenPriceOracleNoRegistry curveLpOracle = CurveLpTokenPriceOracleNoRegistry(\n      ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\")\n    );\n\n    strategyData = abi.encode(curveLpOracle.poolOf(address(outputToken)), outputToken);\n  }\n\n  function curveSwapLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    address curveV1Oracle = ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\");\n    address curveV2Oracle = ap.getAddress(\"CurveV2LpTokenPriceOracleNoRegistry\");\n    address wnative = ap.getAddress(\"wtoken\");\n\n    strategyData = abi.encode(curveV1Oracle, curveV2Oracle, inputToken, outputToken, wnative);\n  }\n\n  function jarvisLiquidatorFunderData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    AddressesProvider.JarvisPool[] memory pools = ap.getJarvisPools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      AddressesProvider.JarvisPool memory pool = pools[i];\n      if (pool.syntheticToken == address(inputToken)) {\n        strategyData = abi.encode(pool.syntheticToken, pool.liquidityPool, pool.expirationTime);\n        //outputToken = pool.collateralToken;\n        break;\n      } else if (pool.collateralToken == address(inputToken)) {\n        strategyData = abi.encode(pool.collateralToken, pool.liquidityPool, pool.expirationTime);\n      }\n    }\n  }\n\n  function balancerSwapLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    address poolAddress = ap.getBalancerPoolForTokens(address(inputToken), address(outputToken));\n    if (poolAddress == address(0)) {\n      // throw an error\n      revert(\"No balancer pool found for the given tokens\");\n    }\n    strategyData = abi.encode(outputToken, poolAddress);\n  }\n\n  function solidlyLpTokenWrapperData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    IRouter solidlyRouter = IRouter(ap.getAddress(\"SOLIDLY_SWAP_ROUTER\"));\n    IPair pair = IPair(address(outputToken));\n\n    IRouter.Route[] memory swapPath0 = new IRouter.Route[](1);\n    IRouter.Route[] memory swapPath1 = new IRouter.Route[](1);\n    {\n      bool isInputToken0 = pair.token0() == address(inputToken);\n      bool isInputToken1 = pair.token1() == address(inputToken);\n      require(isInputToken0 || isInputToken1, \"!input token not underlying\");\n\n      swapPath0[0].stable = pair.stable();\n      swapPath0[0].from = pair.token0();\n      swapPath0[0].to = pair.token1();\n\n      swapPath1[0].stable = pair.stable();\n      swapPath1[0].from = pair.token1();\n      swapPath1[0].to = pair.token0();\n    }\n\n    strategyData = abi.encode(solidlyRouter, pair, swapPath0, swapPath1);\n  }\n\n  // TODO remove after testing\n  function xBombLiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    if (block.chainid == 56) {\n      address xbomb = 0xAf16cB45B8149DA403AF41C63AbFEBFbcd16264b;\n      address bomb = 0x522348779DCb2911539e76A1042aA922F9C47Ee3;\n      strategyData = abi.encode(inputToken, xbomb, bomb);\n    } else {\n      IERC20Upgradeable chapelBomb = IERC20Upgradeable(0xe45589fBad3A1FB90F5b2A8A3E8958a8BAB5f768);\n      IERC20Upgradeable chapelTUsd = IERC20Upgradeable(0x4f1885D25eF219D3D4Fa064809D6D4985FAb9A0b);\n      IERC20Upgradeable chapelTDai = IERC20Upgradeable(0x8870f7102F1DcB1c35b01af10f1baF1B00aD6805);\n      XBombSwap xbombSwapTUsd = XBombSwap(0x3d312B224DeC414FE865e1e9BfC13e2A86947D19);\n      XBombSwap xbombSwapTDai = XBombSwap(0x8146293bf5225b471625372e985FDb7165C35fe2);\n\n      if (inputToken == chapelBomb) {\n        XBombSwap bombSwap;\n        if (outputToken == chapelTUsd) {\n          bombSwap = xbombSwapTUsd;\n        } else if (outputToken == chapelTDai) {\n          bombSwap = xbombSwapTDai;\n        }\n        strategyData = abi.encode(bombSwap, bombSwap, outputToken, outputToken);\n      } else if (inputToken == chapelTUsd) {\n        strategyData = abi.encode(inputToken, xbombSwapTUsd, inputToken, chapelBomb);\n      } else if (inputToken == chapelTDai) {\n        strategyData = abi.encode(inputToken, xbombSwapTDai, inputToken, chapelBomb);\n      }\n    }\n  }\n\n  // @notice addresses hardcoded, use only for ETHEREUM\n  function erc4626LiquidatorData(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken)\n    internal\n    view\n    returns (bytes memory strategyData)\n  {\n    uint256 fee;\n    address[] memory underlyingTokens;\n    address inputTokenAddr = address(inputToken);\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address realYieldUSD = 0x97e6E0a40a3D02F12d1cEC30ebfbAE04e37C119E;\n    address ethBtcTrend = 0x6b7f87279982d919Bbf85182DDeAB179B366D8f2;\n    address ethBtcMomentum = address(255); // TODO\n\n    if (inputTokenAddr == realYieldUSD) {\n      fee = 10;\n      underlyingTokens = new address[](3);\n      underlyingTokens[0] = usdc;\n      underlyingTokens[1] = dai;\n      underlyingTokens[2] = usdt;\n    } else if (inputTokenAddr == ethBtcMomentum || inputTokenAddr == ethBtcTrend) {\n      fee = 500;\n      underlyingTokens = new address[](3);\n      underlyingTokens[0] = usdc;\n      underlyingTokens[1] = weth;\n      underlyingTokens[2] = wbtc;\n    } else {\n      fee = 300;\n      underlyingTokens = new address[](1);\n      underlyingTokens[0] = address(outputToken);\n    }\n\n    strategyData = abi.encode(\n      outputToken,\n      fee,\n      ap.getAddress(\"UNISWAP_V3_ROUTER\"),\n      underlyingTokens,\n      ap.getAddress(\"Quoter\")\n    );\n  }\n}\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistrySecondExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"./ILiquidatorsRegistry.sol\";\nimport \"./LiquidatorsRegistryStorage.sol\";\n\nimport \"../../ionic/DiamondExtension.sol\";\n\ncontract LiquidatorsRegistrySecondExtension is\n  LiquidatorsRegistryStorage,\n  DiamondExtension,\n  ILiquidatorsRegistrySecondExtension\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\n    uint8 fnsCount = 12;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.getAllPairsStrategies.selector;\n    functionSelectors[--fnsCount] = this.pairsStrategiesMatch.selector;\n    functionSelectors[--fnsCount] = this.uniswapPairsFeesMatch.selector;\n    functionSelectors[--fnsCount] = this.uniswapPairsRoutersMatch.selector;\n    functionSelectors[--fnsCount] = this._setSlippages.selector;\n    functionSelectors[--fnsCount] = this._setUniswapV3Fees.selector;\n    functionSelectors[--fnsCount] = this._setUniswapV3Routers.selector;\n    functionSelectors[--fnsCount] = this._setDefaultOutputToken.selector;\n    functionSelectors[--fnsCount] = this._setRedemptionStrategy.selector;\n    functionSelectors[--fnsCount] = this._setRedemptionStrategies.selector;\n    functionSelectors[--fnsCount] = this._removeRedemptionStrategy.selector;\n    functionSelectors[--fnsCount] = this._resetRedemptionStrategies.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n\n  function _setSlippages(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    uint256[] calldata slippages\n  ) external onlyOwner {\n    require(slippages.length == inputTokens.length && inputTokens.length == outputTokens.length, \"!arrays len\");\n\n    for (uint256 i = 0; i < slippages.length; i++) {\n      conversionSlippage[inputTokens[i]][outputTokens[i]] = slippages[i];\n    }\n  }\n\n  function _setUniswapV3Fees(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    uint24[] calldata fees\n  ) external onlyOwner {\n    require(fees.length == inputTokens.length && inputTokens.length == outputTokens.length, \"!arrays len\");\n\n    for (uint256 i = 0; i < fees.length; i++) {\n      uniswapV3Fees[inputTokens[i]][outputTokens[i]] = fees[i];\n    }\n  }\n\n  function _setUniswapV3Routers(\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens,\n    address[] calldata routers\n  ) external onlyOwner {\n    require(routers.length == inputTokens.length && inputTokens.length == outputTokens.length, \"!arrays len\");\n\n    for (uint256 i = 0; i < routers.length; i++) {\n      customUniV3Router[inputTokens[i]][outputTokens[i]] = routers[i];\n    }\n  }\n\n  function _setDefaultOutputToken(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) external onlyOwner {\n    defaultOutputToken[inputToken] = outputToken;\n  }\n\n  function _setRedemptionStrategy(\n    IRedemptionStrategy strategy,\n    IERC20Upgradeable inputToken,\n    IERC20Upgradeable outputToken\n  ) public onlyOwner {\n    string memory name = strategy.name();\n    IRedemptionStrategy oldStrategy = redemptionStrategiesByName[name];\n\n    redemptionStrategiesByTokens[inputToken][outputToken] = strategy;\n    redemptionStrategiesByName[name] = strategy;\n\n    redemptionStrategies.remove(address(oldStrategy));\n    redemptionStrategies.add(address(strategy));\n\n    if (defaultOutputToken[inputToken] == IERC20Upgradeable(address(0))) {\n      defaultOutputToken[inputToken] = outputToken;\n    }\n    inputTokensByOutputToken[outputToken].add(address(inputToken));\n    outputTokensSet.add(address(outputToken));\n  }\n\n  function _setRedemptionStrategies(\n    IRedemptionStrategy[] calldata strategies,\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens\n  ) external onlyOwner {\n    require(strategies.length == inputTokens.length && inputTokens.length == outputTokens.length, \"!arrays len\");\n    for (uint256 i = 0; i < strategies.length; i++) {\n      _setRedemptionStrategy(strategies[i], inputTokens[i], outputTokens[i]);\n    }\n  }\n\n  function _resetRedemptionStrategies(\n    IRedemptionStrategy[] calldata strategies,\n    IERC20Upgradeable[] calldata inputTokens,\n    IERC20Upgradeable[] calldata outputTokens\n  ) external onlyOwner {\n    require(strategies.length == inputTokens.length && inputTokens.length == outputTokens.length, \"!arrays len\");\n\n    // empty the input/output token mappings/sets\n    address[] memory _outputTokens = outputTokensSet.values();\n    for (uint256 i = 0; i < _outputTokens.length; i++) {\n      IERC20Upgradeable _outputToken = IERC20Upgradeable(_outputTokens[i]);\n      address[] memory _inputTokens = inputTokensByOutputToken[_outputToken].values();\n      for (uint256 j = 0; j < _inputTokens.length; j++) {\n        IERC20Upgradeable _inputToken = IERC20Upgradeable(_inputTokens[j]);\n        redemptionStrategiesByTokens[_inputToken][_outputToken] = IRedemptionStrategy(address(0));\n        inputTokensByOutputToken[_outputToken].remove(_inputTokens[j]);\n        defaultOutputToken[_inputToken] = IERC20Upgradeable(address(0));\n      }\n      outputTokensSet.remove(_outputTokens[i]);\n    }\n\n    // empty the strategies mappings/sets\n    address[] memory _currentStrategies = redemptionStrategies.values();\n    for (uint256 i = 0; i < _currentStrategies.length; i++) {\n      IRedemptionStrategy _currentStrategy = IRedemptionStrategy(_currentStrategies[i]);\n      string memory _name = _currentStrategy.name();\n      redemptionStrategiesByName[_name] = IRedemptionStrategy(address(0));\n      redemptionStrategies.remove(_currentStrategies[i]);\n    }\n\n    // write the new strategies and their tokens configs\n    for (uint256 i = 0; i < strategies.length; i++) {\n      _setRedemptionStrategy(strategies[i], inputTokens[i], outputTokens[i]);\n    }\n  }\n\n  function _removeRedemptionStrategy(IRedemptionStrategy strategyToRemove) external onlyOwner {\n    // check all the input/output tokens if they match the strategy to remove\n    address[] memory _outputTokens = outputTokensSet.values();\n    for (uint256 i = 0; i < _outputTokens.length; i++) {\n      IERC20Upgradeable _outputToken = IERC20Upgradeable(_outputTokens[i]);\n      address[] memory _inputTokens = inputTokensByOutputToken[_outputToken].values();\n      for (uint256 j = 0; j < _inputTokens.length; j++) {\n        IERC20Upgradeable _inputToken = IERC20Upgradeable(_inputTokens[j]);\n        IRedemptionStrategy _currentStrategy = redemptionStrategiesByTokens[_inputToken][_outputToken];\n\n        // only nullify the input/output tokens config if the strategy matches\n        if (_currentStrategy == strategyToRemove) {\n          redemptionStrategiesByTokens[_inputToken][_outputToken] = IRedemptionStrategy(address(0));\n          inputTokensByOutputToken[_outputToken].remove(_inputTokens[j]);\n          if (defaultOutputToken[_inputToken] == _outputToken) {\n            defaultOutputToken[_inputToken] = IERC20Upgradeable(address(0));\n          }\n        }\n      }\n      if (inputTokensByOutputToken[_outputToken].length() == 0) {\n        outputTokensSet.remove(address(_outputToken));\n      }\n    }\n\n    redemptionStrategiesByName[strategyToRemove.name()] = IRedemptionStrategy(address(0));\n    redemptionStrategies.remove(address(strategyToRemove));\n  }\n\n  function uniswapPairsFeesMatch(\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens,\n    uint256[] calldata configFees\n  ) external view returns (bool) {\n    // find a match for each config fee\n    for (uint256 i = 0; i < configFees.length; i++) {\n      if (uniswapV3Fees[configInputTokens[i]][configOutputTokens[i]] != configFees[i]) return false;\n    }\n\n    return true;\n  }\n\n  function uniswapPairsRoutersMatch(\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens,\n    address[] calldata configRouters\n  ) external view returns (bool) {\n    // find a match for each config router\n    for (uint256 i = 0; i < configRouters.length; i++) {\n      if (customUniV3Router[configInputTokens[i]][configOutputTokens[i]] != configRouters[i]) return false;\n    }\n\n    return true;\n  }\n\n  function pairsStrategiesMatch(\n    IRedemptionStrategy[] calldata configStrategies,\n    IERC20Upgradeable[] calldata configInputTokens,\n    IERC20Upgradeable[] calldata configOutputTokens\n  ) external view returns (bool) {\n    (\n      IRedemptionStrategy[] memory onChainStrategies,\n      IERC20Upgradeable[] memory onChainInputTokens,\n      IERC20Upgradeable[] memory onChainOutputTokens\n    ) = getAllPairsStrategies();\n    // find a match for each config strategy\n    for (uint256 i = 0; i < configStrategies.length; i++) {\n      bool foundMatch = false;\n      for (uint256 j = 0; j < onChainStrategies.length; j++) {\n        if (\n          onChainStrategies[j] == configStrategies[i] &&\n          onChainInputTokens[j] == configInputTokens[i] &&\n          onChainOutputTokens[j] == configOutputTokens[i]\n        ) {\n          foundMatch = true;\n          break;\n        }\n      }\n      if (!foundMatch) return false;\n    }\n\n    // find a match for each on-chain strategy\n    for (uint256 i = 0; i < onChainStrategies.length; i++) {\n      bool foundMatch = false;\n      for (uint256 j = 0; j < configStrategies.length; j++) {\n        if (\n          onChainStrategies[i] == configStrategies[j] &&\n          onChainInputTokens[i] == configInputTokens[j] &&\n          onChainOutputTokens[i] == configOutputTokens[j]\n        ) {\n          foundMatch = true;\n          break;\n        }\n      }\n      if (!foundMatch) return false;\n    }\n\n    return true;\n  }\n\n  function getAllPairsStrategies()\n    public\n    view\n    returns (\n      IRedemptionStrategy[] memory strategies,\n      IERC20Upgradeable[] memory inputTokens,\n      IERC20Upgradeable[] memory outputTokens\n    )\n  {\n    address[] memory _outputTokens = outputTokensSet.values();\n    uint256 pairsCounter = 0;\n\n    {\n      for (uint256 i = 0; i < _outputTokens.length; i++) {\n        IERC20Upgradeable _outputToken = IERC20Upgradeable(_outputTokens[i]);\n        address[] memory _inputTokens = inputTokensByOutputToken[_outputToken].values();\n        pairsCounter += _inputTokens.length;\n      }\n\n      strategies = new IRedemptionStrategy[](pairsCounter);\n      inputTokens = new IERC20Upgradeable[](pairsCounter);\n      outputTokens = new IERC20Upgradeable[](pairsCounter);\n    }\n\n    pairsCounter = 0;\n    for (uint256 i = 0; i < _outputTokens.length; i++) {\n      IERC20Upgradeable _outputToken = IERC20Upgradeable(_outputTokens[i]);\n      address[] memory _inputTokens = inputTokensByOutputToken[_outputToken].values();\n      for (uint256 j = 0; j < _inputTokens.length; j++) {\n        IERC20Upgradeable _inputToken = IERC20Upgradeable(_inputTokens[j]);\n        strategies[pairsCounter] = redemptionStrategiesByTokens[_inputToken][_outputToken];\n        inputTokens[pairsCounter] = _inputToken;\n        outputTokens[pairsCounter] = _outputToken;\n        pairsCounter++;\n      }\n    }\n  }\n}\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport \"../IRedemptionStrategy.sol\";\nimport { SafeOwnable } from \"../../ionic/SafeOwnable.sol\";\nimport { AddressesProvider } from \"../../ionic/AddressesProvider.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nabstract contract LiquidatorsRegistryStorage is SafeOwnable {\n  AddressesProvider public ap;\n\n  EnumerableSet.AddressSet internal redemptionStrategies;\n  mapping(string => IRedemptionStrategy) public redemptionStrategiesByName;\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => IRedemptionStrategy)) public redemptionStrategiesByTokens;\n  mapping(IERC20Upgradeable => IERC20Upgradeable) public defaultOutputToken;\n  mapping(IERC20Upgradeable => EnumerableSet.AddressSet) internal inputTokensByOutputToken;\n  EnumerableSet.AddressSet internal outputTokensSet;\n\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) internal conversionSlippage;\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) internal conversionSlippageUpdated;\n\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint24)) public uniswapV3Fees;\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => address)) public customUniV3Router;\n}\n"
    },
    "contracts/liquidators/SaddleLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IRedemptionStrategy.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../external/saddle/ISwap.sol\";\nimport { SaddleLpPriceOracle } from \"../oracles/default/SaddleLpPriceOracle.sol\";\nimport { WETH } from \"solmate/tokens/WETH.sol\";\n\ncontract SaddleLpTokenLiquidator is IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address outputTokenAddress, SaddleLpPriceOracle oracle, address payable wtoken) = abi.decode(\n      strategyData,\n      (address, SaddleLpPriceOracle, address)\n    );\n\n    ISwap pool = ISwap(oracle.poolOf(address(inputToken)));\n    uint8 index = pool.getTokenIndex(outputTokenAddress);\n\n    outputAmount = pool.removeLiquidityOneToken(inputAmount, index, 1, block.timestamp);\n\n    // Convert to W_NATIVE if ETH\n    if (outputTokenAddress == address(0) || outputTokenAddress == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      WETH(wtoken).deposit{ value: outputAmount }();\n      outputToken = IERC20Upgradeable(wtoken);\n    } else {\n      outputToken = IERC20Upgradeable(outputTokenAddress);\n    }\n\n    outputToken = IERC20Upgradeable(outputTokenAddress);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SaddleLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/SOhmLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/olympus/sOlympus.sol\";\nimport \"../external/olympus/OlympusStaking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SOhmLiquidator\n * @notice Redeems sOHM for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SOhmLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unstake sOHM (and store output OHM as new collateral)\n    sOlympus token = sOlympus(address(inputToken));\n    OlympusStaking staking = OlympusStaking(token.stakingContract());\n    safeApprove(inputToken, address(staking), inputAmount);\n    staking.unstake(inputAmount, false);\n    outputToken = IERC20Upgradeable(staking.OHM());\n    outputAmount = inputAmount;\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SOhmLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/SolidlyLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/solidly/IRouter.sol\";\nimport \"../external/solidly/IPair.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SolidlyLpTokenLiquidator\n * @notice Exchanges seized Solidly LP token collateral for underlying tokens for use as a step in a liquidation.\n */\ncontract SolidlyLpTokenLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) internal {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit Uniswap pool\n    IPair pair = IPair(address(inputToken));\n    bool stable = pair.stable();\n\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n    pair.transfer(address(pair), inputAmount);\n    (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n    // Swap underlying tokens\n    (IRouter solidlyRouter, address tokenTo) = abi.decode(strategyData, (IRouter, address));\n\n    if (tokenTo != token0) {\n      safeApprove(IERC20Upgradeable(token0), address(solidlyRouter), amount0);\n      solidlyRouter.swapExactTokensForTokensSimple(amount0, 0, token0, tokenTo, stable, address(this), block.timestamp);\n    } else {\n      safeApprove(IERC20Upgradeable(token1), address(solidlyRouter), amount1);\n      solidlyRouter.swapExactTokensForTokensSimple(amount1, 0, token1, tokenTo, stable, address(this), block.timestamp);\n    }\n    // Get new collateral\n    outputToken = IERC20Upgradeable(tokenTo);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SolidlyLpTokenLiquidator\";\n  }\n}\n\ncontract SolidlyLpTokenWrapper is IRedemptionStrategy {\n  struct WrapSolidlyLpTokenVars {\n    uint256 amountToSwapOfToken0ForToken1;\n    uint256 amountToSwapOfToken1ForToken0;\n    IRouter solidlyRouter;\n    IERC20Upgradeable token0;\n    IERC20Upgradeable token1;\n    bool stable;\n    IPair pair;\n    IRouter.Route[] swapPath0;\n    IRouter.Route[] swapPath1;\n    uint256 ratio;\n  }\n\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    WrapSolidlyLpTokenVars memory vars;\n    (vars.solidlyRouter, vars.pair, vars.swapPath0, vars.swapPath1) = abi.decode(\n      strategyData,\n      (IRouter, IPair, IRouter.Route[], IRouter.Route[])\n    );\n    vars.token0 = IERC20Upgradeable(vars.pair.token0());\n    vars.token1 = IERC20Upgradeable(vars.pair.token1());\n    vars.stable = vars.pair.stable();\n\n    // calculate the amount for token0 or token1 that needs to be swapped for the other\n    {\n      vars.amountToSwapOfToken1ForToken0 = inputAmount / 2;\n      vars.amountToSwapOfToken0ForToken1 = inputAmount - vars.amountToSwapOfToken1ForToken0;\n      if (vars.token0 == inputToken) {\n        uint256 out1 = vars.solidlyRouter.getAmountsOut(vars.amountToSwapOfToken0ForToken1, vars.swapPath0)[\n          vars.swapPath0.length\n        ];\n        // price1For0 is scaled to 18 + token1.decimals - token0.decimals\n        uint256 price1For0 = (out1 * 1e18) / vars.amountToSwapOfToken0ForToken1;\n        // use the quoted input amounts to check what is the actual required ratio of inputs\n        (uint256 amount0, uint256 amount1, ) = vars.solidlyRouter.quoteAddLiquidity(\n          address(vars.token0),\n          address(vars.token1),\n          vars.stable,\n          vars.amountToSwapOfToken1ForToken0,\n          out1\n        );\n\n        vars.ratio = (amount1 * 1e36) / (amount0 * price1For0);\n      }\n\n      if (vars.token1 == inputToken) {\n        uint256 out0 = vars.solidlyRouter.getAmountsOut(vars.amountToSwapOfToken1ForToken0, vars.swapPath1)[\n          vars.swapPath1.length\n        ];\n        // price0For1 is scaled to 18 + token0.decimals - token1.decimals\n        uint256 price0For1 = (out0 * 1e18) / vars.amountToSwapOfToken1ForToken0;\n        // use the quoted input amounts to check what is the actual required ratio of inputs\n        (uint256 amount0, uint256 amount1, ) = vars.solidlyRouter.quoteAddLiquidity(\n          address(vars.token0),\n          address(vars.token1),\n          vars.stable,\n          out0,\n          vars.amountToSwapOfToken0ForToken1\n        );\n\n        vars.ratio = (amount1 * price0For1) / amount0;\n      }\n\n      // recalculate the amounts to swap based on the ratio of the value of the required input amounts\n      vars.amountToSwapOfToken1ForToken0 = (inputAmount * 1e18) / (vars.ratio + 1e18);\n      vars.amountToSwapOfToken0ForToken1 = inputAmount - vars.amountToSwapOfToken1ForToken0;\n    }\n\n    // swap a part of the input token amount for the other token\n    if (vars.token0 == inputToken) {\n      inputToken.approve(address(vars.solidlyRouter), vars.amountToSwapOfToken0ForToken1);\n      vars.solidlyRouter.swapExactTokensForTokens(\n        vars.amountToSwapOfToken0ForToken1,\n        0,\n        vars.swapPath0,\n        address(this),\n        block.timestamp\n      );\n    }\n    if (vars.token1 == inputToken) {\n      inputToken.approve(address(vars.solidlyRouter), vars.amountToSwapOfToken1ForToken0);\n      vars.solidlyRouter.swapExactTokensForTokens(\n        vars.amountToSwapOfToken1ForToken0,\n        0,\n        vars.swapPath1,\n        address(this),\n        block.timestamp\n      );\n    }\n\n    // provide the liquidity\n    uint256 token0Balance = vars.token0.balanceOf(address(this));\n    uint256 token1Balance = vars.token1.balanceOf(address(this));\n\n    vars.token0.approve(address(vars.solidlyRouter), token0Balance);\n    vars.token1.approve(address(vars.solidlyRouter), token1Balance);\n    vars.solidlyRouter.addLiquidity(\n      address(vars.token0),\n      address(vars.token1),\n      vars.stable,\n      token0Balance,\n      token1Balance,\n      1,\n      1,\n      address(this),\n      block.timestamp\n    );\n\n    outputToken = IERC20Upgradeable(address(vars.pair));\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SolidlyLpTokenWrapper\";\n  }\n}\n"
    },
    "contracts/liquidators/SolidlySwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { IRouter } from \"../external/solidly/IRouter.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SolidlySwapLiquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Solidly router for use as a step in a liquidation.\n */\ncontract SolidlySwapLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Solidly router and path\n    (IRouter solidlyRouter, address tokenTo, bool stable) = abi.decode(strategyData, (IRouter, address, bool));\n\n    // Swap underlying tokens\n    inputToken.approve(address(solidlyRouter), inputAmount);\n    solidlyRouter.swapExactTokensForTokensSimple(\n      inputAmount,\n      0,\n      address(inputToken),\n      tokenTo,\n      stable,\n      address(this),\n      block.timestamp\n    );\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(tokenTo);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SolidlySwapLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/SushiBarLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/sushi/SushiBar.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SushiBarLiquidator\n * @notice Redeems SushiBar (xSUSHI) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unstake sOHM (and store output OHM as new collateral)\n    SushiBar sushiBar = SushiBar(address(inputToken));\n    sushiBar.leave(inputAmount);\n    outputToken = IERC20Upgradeable(sushiBar.sushi());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"SushiBarLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapLpTokenLiquidator\n * @notice Exchanges seized Uniswap V2 LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapLpTokenLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) internal {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit Uniswap pool\n    IUniswapV2Pair pair = IUniswapV2Pair(address(inputToken));\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n    pair.transfer(address(pair), inputAmount);\n    (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n    // Swap underlying tokens\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[], address[])\n    );\n    require(\n      (swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) ==\n        (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1),\n      \"Output of token0 swap path must equal output of token1 swap path.\"\n    );\n\n    if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n      safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n      uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n    }\n\n    if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n      safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n      uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n    }\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"UniswapLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV1Exchange.sol\";\nimport \"../external/uniswap/IUniswapV1Factory.sol\";\n\nimport \"../utils/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV1Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V1 pool for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV1Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev The V1 Uniswap factory contract.\n   */\n  IUniswapV1Factory private constant UNISWAP_V1_FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap exchange\n    IUniswapV1Exchange uniswapV1Exchange = IUniswapV1Exchange(UNISWAP_V1_FACTORY.getExchange(address(inputToken)));\n\n    // Swap underlying tokens\n    safeApprove(inputToken, address(uniswapV1Exchange), inputAmount);\n    uniswapV1Exchange.tokenToEthSwapInput(inputAmount, 1, block.timestamp);\n\n    // Get new collateral\n    outputAmount = address(this).balance;\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"UniswapV1Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./BaseUniswapV2Liquidator.sol\";\n\n/**\n * @title UniswapV2Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V2 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV2Liquidator is BaseUniswapV2Liquidator {\n  function _swap(\n    IUniswapV2Router02 uniswapV2Router,\n    uint256 inputAmount,\n    address[] memory swapPath\n  ) internal override {\n    uniswapV2Router.swapExactTokensForTokens(inputAmount, 0, swapPath, address(this), block.timestamp);\n  }\n\n  function name() public pure virtual returns (string memory) {\n    return \"UniswapV2Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV2LiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { UniswapV2Liquidator } from \"./UniswapV2Liquidator.sol\";\nimport \"./IFundsConversionStrategy.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\ncontract UniswapV2LiquidatorFunder is UniswapV2Liquidator, IFundsConversionStrategy {\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable inputToken, uint256 inputAmount)\n  {\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapPath) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[])\n    );\n    require(swapPath.length >= 2, \"Invalid UniswapLiquidator swap path.\");\n\n    uint256[] memory amounts = uniswapV2Router.getAmountsIn(outputAmount, swapPath);\n\n    inputAmount = amounts[0];\n    inputToken = IERC20Upgradeable(swapPath[0]);\n  }\n\n  function name() public pure override(UniswapV2Liquidator, IRedemptionStrategy) returns (string memory) {\n    return \"UniswapV2LiquidatorFunder\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"./IRedemptionStrategy.sol\";\nimport { ISwapRouter } from \"../external/uniswap/ISwapRouter.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract UniswapV3Liquidator is IRedemptionStrategy {\n  /**\n   * @dev Redeems `inputToken` for `outputToken` where `inputAmount` < `outputAmount`\n   * @param inputToken Address of the token\n   * @param inputAmount input amount\n   * @param strategyData context specific data like input token, pool address and tx expiratio period\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (, address _outputToken, uint24 fee, ISwapRouter swapRouter, ) = abi.decode(\n      strategyData,\n      (address, address, uint24, ISwapRouter, address)\n    );\n    outputToken = IERC20Upgradeable(_outputToken);\n\n    inputToken.approve(address(swapRouter), inputAmount);\n\n    outputAmount = swapRouter.exactInputSingle(\n      ISwapRouter.ExactInputSingleParams(\n        address(inputToken),\n        _outputToken,\n        fee,\n        address(this),\n        block.timestamp,\n        inputAmount,\n        0,\n        0\n      )\n    );\n  }\n\n  function name() public pure virtual override returns (string memory) {\n    return \"UniswapV3Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV3LiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\nimport { IFundsConversionStrategy } from \"./IFundsConversionStrategy.sol\";\nimport { IRedemptionStrategy } from \"./IRedemptionStrategy.sol\";\nimport \"./UniswapV3Liquidator.sol\";\n\nimport { Quoter } from \"../external/uniswap/quoter/Quoter.sol\";\n\ncontract UniswapV3LiquidatorFunder is UniswapV3Liquidator, IFundsConversionStrategy {\n  using FixedPointMathLib for uint256;\n\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  /**\n   * @dev Estimates the needed input amount of the input token for the conversion to return the desired output amount.\n   * @param outputAmount the desired output amount\n   * @param strategyData the input token\n   */\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable inputToken, uint256 inputAmount)\n  {\n    (address _inputToken, address _outputToken, uint24 fee, , Quoter quoter) = abi.decode(\n      strategyData,\n      (address, address, uint24, ISwapRouter, Quoter)\n    );\n\n    inputAmount = quoter.estimateMinSwapUniswapV3(_inputToken, _outputToken, outputAmount, fee);\n    inputToken = IERC20Upgradeable(_inputToken);\n  }\n\n  function name() public pure override(UniswapV3Liquidator, IRedemptionStrategy) returns (string memory) {\n    return \"UniswapV3LiquidatorFunder\";\n  }\n}\n"
    },
    "contracts/liquidators/WombatLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\ninterface IWombatPool {\n  function withdraw(\n    address token,\n    uint256 liquidity,\n    uint256 minimumAmount,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amount);\n}\n\ncontract WombatLpTokenLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address poolAddress, address _outputToken) = abi.decode(strategyData, (address, address));\n\n    safeApprove(inputToken, poolAddress, inputAmount);\n\n    outputAmount = IWombatPool(poolAddress).withdraw(_outputToken, inputAmount, 0, address(this), block.timestamp);\n    outputToken = IERC20Upgradeable(_outputToken);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"WombatLpTokenLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/WSTEthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/lido/IWstETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title WSTEthLiquidator\n * @notice Redeems wstETH for underlying stETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unwrap wstETH (and store output stETH as new collateral)\n    IWstETH token = IWstETH(address(inputToken));\n    token.unwrap(inputAmount);\n    outputToken = IERC20Upgradeable(token.stETH());\n    outputAmount = inputAmount;\n  }\n\n  function name() public pure returns (string memory) {\n    return \"WSTEthLiquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/XBombLiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../external/bomb/IXBomb.sol\";\nimport \"./IRedemptionStrategy.sol\";\nimport \"./IFundsConversionStrategy.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\n\n/**\n * @title XBombLiquidatorFunder\n * @notice Exchanges seized xBOMB collateral for underlying BOMB tokens for use as a step in a liquidation.\n * @author Veliko Minkov <veliko@midascapital.xyz>\n */\ncontract XBombLiquidatorFunder is IFundsConversionStrategy {\n  /**\n   * @notice Redeems xBOMB for the underlying BOMB reward tokens.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    return _convert(inputToken, inputAmount, strategyData);\n  }\n\n  function _convert(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    (address inputTokenAddress, address xbomb, IERC20Upgradeable bomb, IERC20Upgradeable _outputToken) = abi.decode(\n      strategyData,\n      (address, address, IERC20Upgradeable, IERC20Upgradeable)\n    );\n    if (inputTokenAddress == xbomb) {\n      // burns the xBOMB and returns the underlying BOMB to the liquidator\n      inputToken.approve(address(xbomb), inputAmount);\n      IXBomb(xbomb).leave(inputAmount);\n\n      outputToken = _outputToken;\n      outputAmount = outputToken.balanceOf(address(this));\n    } else if (inputTokenAddress == address(bomb)) {\n      // mints xBOMB\n      inputToken.approve(address(xbomb), inputAmount);\n      IXBomb(xbomb).enter(inputAmount);\n\n      outputToken = _outputToken;\n      outputAmount = outputToken.balanceOf(address(this));\n    } else {\n      revert(\"unknown input token\");\n    }\n  }\n\n  /**\n   * @dev Estimates the needed input amount of the input token for the conversion to return the desired output amount.\n   * @param outputAmount the desired output amount\n   * @param strategyData the input token\n   */\n  function estimateInputAmount(uint256 outputAmount, bytes memory strategyData)\n    external\n    view\n    returns (IERC20Upgradeable, uint256)\n  {\n    (address inputTokenAddress, address xbomb, IERC20Upgradeable bomb, ) = abi.decode(\n      strategyData,\n      (address, address, IERC20Upgradeable, IERC20Upgradeable)\n    );\n    if (inputTokenAddress == xbomb) {\n      // what amount of staked/xbomb equals the desired output amount of bomb?\n      return (IERC20Upgradeable(inputTokenAddress), IXBomb(xbomb).toSTAKED(outputAmount));\n    } else if (inputTokenAddress == address(bomb)) {\n      // what amount of reward/bomb equals the desired output amount of xbomb?\n      return (IERC20Upgradeable(inputTokenAddress), IXBomb(xbomb).toREWARD(outputAmount));\n    } else {\n      revert(\"unknown input token\");\n    }\n  }\n\n  function name() public pure returns (string memory) {\n    return \"XBombLiquidatorFunder\";\n  }\n}\n\ncontract XBombSwap {\n  IERC20Upgradeable public testingBomb;\n  IERC20Upgradeable public testingStable;\n  MasterPriceOracle public oracle;\n\n  constructor(\n    IERC20Upgradeable _testingBomb,\n    IERC20Upgradeable _testingStable,\n    MasterPriceOracle _oracle\n  ) {\n    testingBomb = _testingBomb;\n    testingStable = _testingStable;\n    oracle = _oracle;\n  }\n\n  function leave(uint256 _share) external {\n    testingBomb.transferFrom(msg.sender, address(this), _share);\n    testingStable.transfer(msg.sender, toREWARD(_share));\n  }\n\n  function enter(uint256 _amount) external {\n    testingStable.transferFrom(msg.sender, address(this), _amount);\n    testingBomb.transfer(msg.sender, toSTAKED(_amount));\n  }\n\n  function getExchangeRate() external view returns (uint256) {\n    return 1e18;\n  }\n\n  function toREWARD(uint256 stakedAmount) public view returns (uint256) {\n    uint256 bombPrice = oracle.price(address(testingBomb));\n    uint256 stablePrice = oracle.price(address(testingStable));\n    return (stakedAmount * bombPrice) / stablePrice;\n  }\n\n  function toSTAKED(uint256 rewardAmount) public view returns (uint256) {\n    uint256 bombPrice = oracle.price(address(testingBomb));\n    uint256 stablePrice = oracle.price(address(testingStable));\n    return (rewardAmount * stablePrice) / bombPrice;\n  }\n}\n"
    },
    "contracts/liquidators/YearnYVaultV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV1Liquidator\n * @notice Exchanges seized Yearn yVault V1 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV1Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem yVault token for underlying token (and store output as new collateral)\n    IVault yVault = IVault(address(inputToken));\n    yVault.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(yVault.token());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n\n  function name() public pure returns (string memory) {\n    return \"YearnYVaultV1Liquidator\";\n  }\n}\n"
    },
    "contracts/liquidators/YearnYVaultV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVaultV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV2Liquidator\n * @notice Exchanges seized Yearn yVault V2 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV2Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem yVault token for underlying token (and store output as new collateral)\n    IVaultV2 yVault = IVaultV2(address(inputToken));\n    outputAmount = yVault.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(yVault.token());\n  }\n\n  function name() public pure returns (string memory) {\n    return \"YearnYVaultV2Liquidator\";\n  }\n}\n"
    },
    "contracts/oracles/1337/MockPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MockPriceOracle\n * @notice Returns mocked prices from a Chainlink-like oracle. Used for local dev only\n * @dev Implements `PriceOracle`.\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\n */\ncontract MockPriceOracle is BasePriceOracle {\n  /**\n   * @notice The maximum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n   */\n  uint256 public maxSecondsBeforePriceIsStale;\n\n  /**\n   * @dev Constructor to set `maxSecondsBeforePriceIsStale` as well as all Chainlink price feeds.\n   */\n  constructor(uint256 _maxSecondsBeforePriceIsStale) {\n    // Set maxSecondsBeforePriceIsStale\n    maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n  }\n\n  /**\n   * @dev Returns a boolean indicating if a price feed exists for the underlying asset.\n   */\n\n  function hasPriceFeed(address underlying) external pure returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n\n  function random() private view returns (uint256) {\n    uint256 r = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 99;\n    r = r + 1;\n    return r;\n  }\n\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n    int256 tokenEthPrice = 1;\n    uint256 r = random();\n\n    return ((uint256(tokenEthPrice) * 1e18) / r) / 1e18;\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    return 1e18;\n  }\n}\n"
    },
    "contracts/oracles/1337/MockRevertPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MockRevertPriceOracle\n * @notice Mocks a failing price oracle. Used for testing purposes only\n * @author Jourdan Dunkley <dunkley.jourdan@gmail.com> (https://github.com/jourdanDunkley)\n */\ncontract MockRevertPriceOracle is BasePriceOracle {\n  constructor() {}\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    revert(\"MockPriceOracle: price function is failing.\");\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    revert(\"MockPriceOracle: getUnderlyingPrice function is failing.\");\n  }\n}\n"
    },
    "contracts/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../compound/CTokenInterfaces.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle {\n  /**\n   * @notice Get the price of an underlying asset.\n   * @param underlying The underlying asset to get the price of.\n   * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n   * Zero means the price is unavailable.\n   */\n  function price(address underlying) external view returns (uint256);\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view returns (uint256);\n}\n"
    },
    "contracts/oracles/default/AerodromePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../BasePriceOracle.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface BasePrices {\n  function getManyRatesWithConnectors(\n    uint8 src_len,\n    address[] memory connectors\n  ) external view returns (uint256[] memory rates);\n}\n\ncontract AerodromePriceOracle is BasePriceOracle {\n  BasePrices immutable prices;\n  address constant WETH = 0x4200000000000000000000000000000000000006;\n\n  constructor(address _prices) {\n    prices = BasePrices(_prices);\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    address[] memory connectors = new address[](2);\n    connectors[0] = token;\n    connectors[1] = WETH;\n    return prices.getManyRatesWithConnectors(1, connectors)[0];\n  }\n}\n"
    },
    "contracts/oracles/default/AlgebraPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"./ConcentratedLiquidityBasePriceOracle.sol\";\nimport { IAlgebraPool } from \"../../external/algebra/IAlgebraPool.sol\";\n\nimport \"../../external/uniswap/TickMath.sol\";\nimport \"../../external/uniswap/FullMath.sol\";\n\n/**\n * @title UniswapV3PriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice AlgebraPriceOracle is a price oracle for Algebra pairs.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract AlgebraPriceOracle is ConcentratedLiquidityBasePriceOracle {\n  /**\n   * @dev Fetches the price for a token from Algebra pools\n   */\n  function _price(address token) internal view override returns (uint256) {\n    uint32[] memory secondsAgos = new uint32[](2);\n    uint256 twapWindow = poolFeeds[token].twapWindow;\n    address baseToken = poolFeeds[token].baseToken;\n\n    secondsAgos[0] = uint32(twapWindow);\n    secondsAgos[1] = 0;\n\n    IAlgebraPool pool = IAlgebraPool(poolFeeds[token].poolAddress);\n    (int56[] memory tickCumulatives, , , ) = pool.getTimepoints(secondsAgos);\n\n    int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(int256(twapWindow)));\n    uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n\n    uint256 tokenPrice = getPriceX96FromSqrtPriceX96(pool.token0(), token, sqrtPriceX96);\n    return scalePrices(baseToken, token, tokenPrice);\n  }\n}\n"
    },
    "contracts/oracles/default/AnkrCertificateTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { IStakeManager } from \"../../external/stader/IStakeManager.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title AnkrCertificateTokenPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice AnkrCertificateTokenPriceOracle is a price oracle for Ankr Certificate liquid staked tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\n\ninterface IAnkrCertificate {\n  function ratio() external view returns (uint256);\n}\n\ncontract AnkrCertificateTokenPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  IAnkrCertificate public aTokenCertificate;\n\n  function initialize(address ankrCertificateToken) public initializer {\n    __SafeOwnable_init(msg.sender);\n    aTokenCertificate = IAnkrCertificate(ankrCertificateToken);\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n    require(underlying == address(aTokenCertificate), \"Invalid underlying\");\n\n    // no need to scale as Ankr Ceritificate Token has 18 decimals\n    return _price();\n  }\n\n  function price(address underlying) external view override returns (uint256) {\n    require(underlying == address(aTokenCertificate), \"Invalid underlying\");\n    return _price();\n  }\n\n  function _price() internal view returns (uint256) {\n    uint256 ONE = 1e18;\n\n    // Returns the aXXXb / aXXXc ratio\n    // Ankr Ceritificate Token Rebasing token is pegged to 1 BNB\n    uint256 exchangeRate = aTokenCertificate.ratio();\n    return (ONE * ONE) / exchangeRate;\n  }\n}\n"
    },
    "contracts/oracles/default/API3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IProxy } from \"../../external/api3/IProxy.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title API3PriceOracle\n * @notice Returns prices from Api3.\n * @dev Implements `PriceOracle`.\n * @author Carlo Mazzaferro <carlo@ionic.money> (https://github.com/carlomazzaferro)\n */\ncontract API3PriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n   */\n  mapping(address => IProxy) public proxies;\n\n  /**\n   * @notice Chainlink NATIVE/USD price feed contracts.\n   */\n  address public NATIVE_TOKEN_USD_PRICE_FEED;\n\n  /**\n   * @notice The USD Token of the chain\n   */\n  address public USD_TOKEN;\n\n  /**\n   * @dev Constructor to set wtoken address and native token USD price feed address\n   * @param _usdToken The Wrapped native asset address\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\n   */\n  function initialize(address _usdToken, address nativeTokenUsd) public initializer {\n    __SafeOwnable_init(msg.sender);\n    USD_TOKEN = _usdToken;\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\n  }\n\n  /**\n   * @dev Constructor to set wtoken address and native token USD price feed address\n   * @param _usdToken The Wrapped native asset address\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\n   */\n  function reinitialize(address _usdToken, address nativeTokenUsd) public onlyOwnerOrAdmin {\n    USD_TOKEN = _usdToken;\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\n   */\n  function setPriceFeeds(address[] memory underlyings, address[] memory feeds) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feeds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set feed and base currency\n      proxies[underlying] = IProxy(feeds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function returning the price in of `underlying`.\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    IProxy proxy = proxies[underlying];\n    require(address(proxy) != address(0), \"No API3 price feed found for this underlying ERC20 token.\");\n\n    uint256 nativeTokenUsdPrice;\n\n    if (NATIVE_TOKEN_USD_PRICE_FEED == address(0)) {\n      // get the USDX/USD price from the MPO\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\n      nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals\n    } else {\n      (int224 nativeTokenUsdPrice224, ) = IProxy(NATIVE_TOKEN_USD_PRICE_FEED).read();\n      if (nativeTokenUsdPrice224 <= 0) {\n        revert(\"API3PriceOracle: native token price <= 0\");\n      }\n      nativeTokenUsdPrice = uint256(uint224(nativeTokenUsdPrice224));\n    }\n    (int224 tokenUsdPrice, ) = proxy.read();\n\n    if (tokenUsdPrice <= 0) {\n      revert(\"API3PriceOracle: token price <= 0\");\n    }\n\n    return (uint256(uint224(tokenUsdPrice)) * 1e18) / nativeTokenUsdPrice;\n  }\n\n  /**\n   * @notice Returns the price in of `underlying` either in USD or the native token (implements `BasePriceOracle`).\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    uint256 oraclePrice = _price(underlying);\n\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerLpLinearPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IBalancerLinearPool } from \"../../external/balancer/IBalancerLinearPool.sol\";\nimport { IBalancerVault } from \"../../external/balancer/IBalancerVault.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\n/**\n * @title BalancerLpLinearPoolPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BalancerLpLinearPoolPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\n\ncontract BalancerLpLinearPoolPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  address[] public underlyings;\n  bytes32 internal constant REENTRANCY_ERROR_HASH = keccak256(abi.encodeWithSignature(\"Error(string)\", \"BAL#400\"));\n\n  function initialize(address[] memory _underlyings) public initializer {\n    __SafeOwnable_init(msg.sender);\n    underlyings = _underlyings;\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IBalancerLinearPool pool = IBalancerLinearPool(underlying);\n    IBalancerVault vault = pool.getVault();\n    address mainToken = pool.getMainToken();\n\n    // read-only re-entracy protection - this call is always unsuccessful\n    (, bytes memory revertData) = address(vault).staticcall{ gas: 5000 }(\n      abi.encodeWithSelector(vault.manageUserBalance.selector, new address[](0))\n    );\n    require(keccak256(revertData) != REENTRANCY_ERROR_HASH, \"Balancer vault view reentrancy\");\n\n    // Returns the BLP Token / Main Token rate (1e18)\n    uint256 rate = pool.getRate();\n\n    // get main token's price (1e18)\n    uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(mainToken);\n    return (rate * baseTokenPrice) / 1e18;\n  }\n\n  /**\n   * @dev Register the an underlying.\n   * @param _underlying Underlying token for which to add an oracle.\n   */\n  function registerToken(address _underlying) external onlyOwner {\n    bool skip = false;\n    for (uint256 j = 0; j < underlyings.length; j++) {\n      if (underlyings[j] == _underlying) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) {\n      underlyings.push(_underlying);\n    }\n  }\n\n  function getAllUnderlyings() external view returns (address[] memory) {\n    return underlyings;\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerLpStablePoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IBalancerStablePool } from \"../../external/balancer/IBalancerStablePool.sol\";\nimport { IBalancerVault } from \"../../external/balancer/IBalancerVault.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\n/**\n * @title BalancerLpStablePoolPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BalancerLpStablePoolPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\n\ncontract BalancerLpStablePoolPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  bytes32 internal constant REENTRANCY_ERROR_HASH = keccak256(abi.encodeWithSignature(\"Error(string)\", \"BAL#400\"));\n\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IBalancerStablePool pool = IBalancerStablePool(underlying);\n    IBalancerVault vault = pool.getVault();\n\n    // read-only re-entrancy protection - this call is always unsuccessful but we need to make sure\n    // it didn't fail due to a re-entrancy attack\n    (, bytes memory revertData) = address(vault).staticcall{ gas: 50000 }(\n      abi.encodeWithSelector(vault.manageUserBalance.selector, new address[](0))\n    );\n    require(keccak256(revertData) != REENTRANCY_ERROR_HASH, \"Balancer vault view reentrancy\");\n\n    bytes32 poolId = pool.getPoolId();\n    (IERC20Upgradeable[] memory tokens, , ) = vault.getPoolTokens(poolId);\n    uint256 bptIndex = pool.getBptIndex();\n\n    uint256 minPrice = type(uint256).max;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (i == bptIndex) {\n        continue;\n      }\n      // Get the price of each of the base tokens in ETH\n      // This also includes the price of the nested LP tokens, if they are e.g. LinearPools\n      // The only requirement is that the nested LP tokens have a price oracle registered\n      // See BalancerLpLinearPoolPriceOracle.sol for an example, as well as the relevant tests\n      uint256 marketTokenPrice = BasePriceOracle(msg.sender).price(address(tokens[i]));\n      uint256 depositTokenPrice = pool.getTokenRate(address(tokens[i]));\n      uint256 finalPrice = (marketTokenPrice * 1e18) / depositTokenPrice;\n      if (finalPrice < minPrice) {\n        minPrice = finalPrice;\n      }\n    }\n    // Multiply the value of each of the base tokens' share in ETH by the rate of the pool\n    // pool.getRate() is the rate of the pool, scaled by 1e18\n    return (minPrice * pool.getRate()) / 1e18;\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/balancer/IBalancerPool.sol\";\nimport \"../../external/balancer/IBalancerVault.sol\";\nimport \"../../external/balancer/BNum.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\n/**\n * @title BalancerLpTokenPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BalancerLpTokenPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\ncontract BalancerLpTokenPriceOracle is SafeOwnableUpgradeable, BasePriceOracle, BNum {\n  /**\n   * @notice MasterPriceOracle for backup for USD price.\n   */\n  MasterPriceOracle public masterPriceOracle;\n\n  function initialize(MasterPriceOracle _masterPriceOracle) public initializer {\n    __SafeOwnable_init(msg.sender);\n    masterPriceOracle = _masterPriceOracle;\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IBalancerPool pool = IBalancerPool(underlying);\n    bytes32 poolId = pool.getPoolId();\n    IBalancerVault vault = pool.getVault();\n    (IERC20Upgradeable[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(poolId);\n\n    require(tokens.length == 2, \"Oracle suitable only for Balancer Pools of 2 tokens\");\n\n    address tokenA = address(tokens[0]);\n    address tokenB = address(tokens[1]);\n\n    uint256[] memory weights = pool.getNormalizedWeights();\n\n    uint256 pxA = masterPriceOracle.price(tokenA);\n    uint256 pxB = masterPriceOracle.price(tokenB);\n\n    uint8 decimalsA = ERC20Upgradeable(tokenA).decimals();\n    uint8 decimalsB = ERC20Upgradeable(tokenB).decimals();\n\n    if (decimalsA < 18) pxA = pxA * (10**(18 - uint256(decimalsA)));\n    if (decimalsA > 18) pxA = pxA / (10**(uint256(decimalsA) - 18));\n    if (decimalsB < 18) pxB = pxB * (10**(18 - uint256(decimalsB)));\n    if (decimalsB > 18) pxB = pxB / (10**(uint256(decimalsB) - 18));\n    (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n      balances[0],\n      balances[1],\n      weights[0],\n      weights[1],\n      pxA,\n      pxB\n    );\n    // use fairReserveA and fairReserveB to compute LP token price\n    // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n    return ((fairResA * pxA) + (fairResB * pxB)) / pool.totalSupply();\n  }\n\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n  /// @param resA Reserve of the first asset\n  /// @param resB Reserve of the second asset\n  /// @param wA Weight of the first asset\n  /// @param wB Weight of the second asset\n  /// @param pxA Fair price of the first asset\n  /// @param pxB Fair price of the second asset\n  function computeFairReserves(\n    uint256 resA,\n    uint256 resB,\n    uint256 wA,\n    uint256 wB,\n    uint256 pxA,\n    uint256 pxB\n  ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    // NOTE: wA + wB = 1 (normalize weights)\n    // constant product = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * fairResB^wB = constant product\n    // - fairResA * pxA / wA = fairResB * pxB / wB\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n    // --> fairResA / r1^wB = constant product\n    // --> fairResA = resA^wA * resB^wB * r1^wB\n    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n    uint256 r0 = bdiv(resA, resB);\n    uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n    // fairResA = resA * (r1 / r0) ^ wB\n    // fairResB = resB * (r0 / r1) ^ wA\n    if (r0 > r1) {\n      uint256 ratio = bdiv(r1, r0);\n      fairResA = bmul(resA, bpow(ratio, wB));\n      fairResB = bdiv(resB, bpow(ratio, wA));\n    } else {\n      uint256 ratio = bdiv(r0, r1);\n      fairResA = bdiv(resA, bpow(ratio, wB));\n      fairResB = bmul(resB, bpow(ratio, wA));\n    }\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerLpTokenPriceOracleNTokens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../../external/balancer/IBalancerPool.sol\";\nimport \"../../external/balancer/IBalancerVault.sol\";\nimport \"../../external/balancer/BNum.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\n/**\n * @title BalancerLpTokenPriceOracleNTokens\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BalancerLpTokenPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n        This implementation generalises the BalancerLpTokenPriceOracle to allow for >= 2 tokens.\n */\ncontract BalancerLpTokenPriceOracleNTokens is SafeOwnableUpgradeable, BasePriceOracle, BNum {\n  /**\n   * @notice MasterPriceOracle for backup for USD price.\n   */\n  MasterPriceOracle public masterPriceOracle;\n\n  function initialize(MasterPriceOracle _masterPriceOracle) public initializer {\n    __SafeOwnable_init(msg.sender);\n    masterPriceOracle = _masterPriceOracle;\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IBalancerPool pool = IBalancerPool(underlying);\n    bytes32 poolId = pool.getPoolId();\n    IBalancerVault vault = IBalancerVault(address(pool.getVault()));\n    (IERC20Upgradeable[] memory tokens, uint256[] memory reserves, ) = vault.getPoolTokens(poolId);\n\n    uint256 nTokens = tokens.length;\n    uint256[] memory weights = pool.getNormalizedWeights();\n\n    require(nTokens == weights.length, \"nTokens != nWeights\");\n\n    uint256[] memory prices = new uint256[](nTokens);\n\n    for (uint256 i = 0; i < nTokens; i++) {\n      uint256 tokenPrice = masterPriceOracle.price(address(tokens[i]));\n      uint256 decimals = ERC20Upgradeable(address(tokens[i])).decimals();\n      if (decimals < 18) {\n        reserves[i] = reserves[i] * (10**(18 - decimals));\n      } else if (decimals > 18) {\n        reserves[i] = reserves[i] / (10**(decimals - 18));\n      } else {\n        reserves[i] = reserves[i];\n      }\n      prices[i] = tokenPrice;\n    }\n\n    uint256[] memory fairRes = computeFairReserves(reserves, weights, prices);\n    // use fairReserveA and fairReserveB to compute LP token price\n    // LP price = (fairRes[i] * px[i] + ... +  fairRes[n] * px[n]) / totalLPSupply\n    uint256 fairResSum = 0;\n    for (uint256 i = 0; i < fairRes.length; i++) {\n      fairResSum = fairResSum + (fairRes[i] * prices[i]);\n    }\n\n    return fairResSum / pool.totalSupply();\n  }\n\n  /// @dev Return fair reserve amounts given spot reserves, weights, and fair prices.\n  /// @param reserves Reserves of the assets\n  /// @param weights Weights of the assets\n  /// @param prices Fair prices of the assets\n  function computeFairReserves(\n    uint256[] memory reserves,\n    uint256[] memory weights,\n    uint256[] memory prices\n  ) internal pure returns (uint256[] memory fairReserves) {\n    // NOTE: wA + ... + wN = 1 (normalize weights)\n    // K = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * .. * fairResN^wN = K\n    // - fairResA * pxA / wA = ... =  fairResN * pxN / wN\n    // define:\n    // - r0_AB = resA / resB ... r0_AN = resA / resN\n    // - r1_AB = (Wa / Pa) * (Pb / Wb) ... r1_AN = (Wa / Pa) * (Pn / Wn)\n\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB * ... * (fairResA * (pxA * wN) / (wA * pxN))^wN = K\n    // --> fairResA^(wA + ... + wN) * (r1_AB)^-wB * ... * (r1_AN)^-wN = K\n    // --> fairResA = resA^wA * ... * resN^wN * (r1_AB)^wB * ... * (r1_AN)^wN\n    // --> fairResA = resA * ((resB * r1_AB ) / resA)^wB * ... * ((resN * r1_AN ) / resA)^wN\n    // --> fairResA = resA * (r1_AB / r0_AB)^wB * ... * (r1_AN / r1_AN)^wN\n\n    // Generalising:\n    // --> fairResB = (r1_BA / r0_BA)^wA * resB * ... * (r1_BN / r1_BN)^wN\n    // ...\n    // --> fairResN = (r1_NA / r0_NA)^wA * ... * (r1_N(N-1) / r1_N(N-1))^w(N-1) * resN\n\n    uint256[] memory fairReservesArray = new uint256[](reserves.length);\n\n    for (uint256 i = 0; i < reserves.length; i++) {\n      uint256[] memory r0array = new uint256[](reserves.length);\n      uint256[] memory r1array = new uint256[](reserves.length);\n      for (uint256 j = 0; j < reserves.length; j++) {\n        if (i == j) {\n          r0array[j] = 1;\n          r1array[j] = 1;\n        } else {\n          r0array[j] = bdiv(reserves[i], reserves[j]);\n          r1array[j] = bdiv(bmul(weights[i], prices[j]), bmul(weights[j], prices[i]));\n        }\n      }\n      uint256 init = reserves[i];\n      for (uint256 k = 0; k < r0array.length; k++) {\n        uint256 r0 = r0array[k];\n        uint256 r1 = r1array[k];\n\n        if (r0 > r1) {\n          uint256 ratio = bdiv(r1, r0);\n          init = bmul(init, bpow(ratio, weights[k]));\n        } else {\n          uint256 ratio = bdiv(r0, r1);\n          init = bmul(init, bpow(ratio, weights[k]));\n        }\n      }\n      fairReservesArray[i] = init;\n    }\n    return fairReservesArray;\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerRateProviderOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { IRateProvider } from \"../../external/balancer/IRateProvider.sol\";\n\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\n\n/**\n * @title BalancerRateProviderOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BalancerRateProviderOracle is a price oracle for tokens that have a Balancer rate provider.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\n\ncontract BalancerRateProviderOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @dev Maps underlying token addresses to rate providers.\n   */\n  mapping(address => IRateProvider) public rateProviders;\n\n  /**\n   * @dev Maps underlying token addresses to base token.\n   */\n  mapping(address => address) public baseTokens;\n\n  address[] public underlyings;\n\n  function initialize(\n    address[] memory _rateProviders,\n    address[] memory _baseTokens,\n    address[] memory _underlyings\n  ) public initializer {\n    __SafeOwnable_init(msg.sender);\n    require(\n      _rateProviders.length == _baseTokens.length && _baseTokens.length == _underlyings.length,\n      \"Array lengths not equal.\"\n    );\n    underlyings = _underlyings;\n    // set the other variables\n    for (uint256 i = 0; i < _rateProviders.length; i++) {\n      rateProviders[_underlyings[i]] = IRateProvider(_rateProviders[i]);\n      baseTokens[_underlyings[i]] = _baseTokens[i];\n    }\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n    // check if the underlying is supported\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  function _price(address underlying) internal view returns (uint256) {\n    // throw if not supported\n    require(baseTokens[underlying] != address(0), \"Unsupported underlying\");\n\n    // Rate is always 1e18 based\n    // ER = TOKEN/BASE\n    uint256 exchangeRate = rateProviders[underlying].getRate();\n\n    // get the base token price, denomimated in NATIVE (1e18)\n    // BP = BASE/NATIVE\n    uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseTokens[underlying]);\n\n    // ER * BP = TOKEN/NATIVE\n    return (exchangeRate * baseTokenPrice) / 1e18;\n  }\n\n  function getAllUnderlyings() public view returns (address[] memory) {\n    return underlyings;\n  }\n\n  /**\n   * @dev Register the pool given underlying, base token and rate provider addresses.\n   * @param _rateProvider Rate provider address for the underlying token.\n   * @param _baseToken Base token for the underlying token.\n   * @param _underlying Underlying token for which to add an oracle.\n   */\n  function registerToken(\n    address _rateProvider,\n    address _baseToken,\n    address _underlying\n  ) external onlyOwner {\n    bool skip = false;\n    for (uint256 j = 0; j < underlyings.length; j++) {\n      if (underlyings[j] == _underlying) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) {\n      underlyings.push(_underlying);\n    }\n    baseTokens[_underlying] = _baseToken;\n    rateProviders[_underlying] = IRateProvider(_rateProvider);\n  }\n}\n"
    },
    "contracts/oracles/default/BNBxPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { IStakeManager } from \"../../external/stader/IStakeManager.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title BNBxPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice BNBxPriceOracle is a price oracle for BNBx liquid staked tokens.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\n\ncontract BNBxPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  IStakeManager public stakeManager;\n  address public BNBx;\n\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n    stakeManager = IStakeManager(0x7276241a669489E4BBB76f63d2A43Bfe63080F2F);\n    (, address _bnbX, , ) = stakeManager.getContracts();\n    BNBx = _bnbX;\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n    require(underlying == BNBx, \"Invalid underlying\");\n    // no need to scale as BNBx has 18 decimals\n    return _price();\n  }\n\n  function price(address underlying) external view override returns (uint256) {\n    require(underlying == BNBx, \"Invalid underlying\");\n    return _price();\n  }\n\n  function _price() internal view returns (uint256) {\n    uint256 oneBNB = 1e18;\n    uint256 exchangeRate = stakeManager.convertBnbXToBnb(oneBNB);\n    return exchangeRate;\n  }\n}\n"
    },
    "contracts/oracles/default/ChainlinkPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title ChainlinkPriceOracleV2\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV2 is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n   */\n  mapping(address => AggregatorV3Interface) public priceFeeds;\n\n  /**\n   * @notice Maps ERC20 token addresses to enums indicating the base currency of the feed.\n   */\n  mapping(address => FeedBaseCurrency) public feedBaseCurrencies;\n\n  /**\n   * @notice Enum indicating the base currency of a Chainlink price feed.\n   * @dev ETH is interchangeable with the nativeToken of the current chain.\n   */\n  enum FeedBaseCurrency {\n    ETH,\n    USD\n  }\n\n  /**\n   * @notice Chainlink NATIVE/USD price feed contracts.\n   */\n  address public NATIVE_TOKEN_USD_PRICE_FEED;\n\n  /**\n   * @notice The USD Token of the chain\n   */\n  address public USD_TOKEN;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   * @param _usdToken The Wrapped native asset address\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\n   */\n  function initialize(address _usdToken, address nativeTokenUsd) public initializer {\n    __SafeOwnable_init(msg.sender);\n    USD_TOKEN = _usdToken;\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\n   * @param baseCurrency The currency in which `feeds` are based.\n   */\n  function setPriceFeeds(\n    address[] memory underlyings,\n    address[] memory feeds,\n    FeedBaseCurrency baseCurrency\n  ) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feeds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set feed and base currency\n      priceFeeds[underlying] = AggregatorV3Interface(feeds[i]);\n      feedBaseCurrencies[underlying] = baseCurrency;\n    }\n  }\n\n  /**\n   * @notice Internal function returning the price in of `underlying`.\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Get token/ETH price from Chainlink\n    AggregatorV3Interface feed = priceFeeds[underlying];\n    require(address(feed) != address(0), \"No Chainlink price feed found for this underlying ERC20 token.\");\n    FeedBaseCurrency baseCurrency = feedBaseCurrencies[underlying];\n\n    if (baseCurrency == FeedBaseCurrency.ETH) {\n      (, int256 tokenEthPrice, , , ) = feed.latestRoundData();\n      return tokenEthPrice >= 0 ? (uint256(tokenEthPrice) * 1e18) / (10**uint256(feed.decimals())) : 0;\n    } else if (baseCurrency == FeedBaseCurrency.USD) {\n      int256 nativeTokenUsdPrice;\n      uint8 usdPriceDecimals;\n\n      if (NATIVE_TOKEN_USD_PRICE_FEED == address(0)) {\n        uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\n        nativeTokenUsdPrice = int256(1e36 / usdNativeTokenPrice); // 18 decimals\n        usdPriceDecimals = 18;\n      } else {\n        (, nativeTokenUsdPrice, , , ) = AggregatorV3Interface(NATIVE_TOKEN_USD_PRICE_FEED).latestRoundData();\n        if (nativeTokenUsdPrice <= 0) return 0;\n        usdPriceDecimals = AggregatorV3Interface(NATIVE_TOKEN_USD_PRICE_FEED).decimals();\n      }\n      (, int256 tokenUsdPrice, , , ) = feed.latestRoundData();\n\n      return\n        tokenUsdPrice >= 0\n          ? ((uint256(tokenUsdPrice) * 1e18 * (10**uint256(usdPriceDecimals))) / (10**uint256(feed.decimals()))) /\n            uint256(nativeTokenUsdPrice)\n          : 0;\n    } else {\n      revert(\"unknown base currency\");\n    }\n  }\n\n  /**\n   * @notice Returns the price in of `underlying` either in USD or the native token (implements `BasePriceOracle`).\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    uint256 oraclePrice = _price(underlying);\n\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/ConcentratedLiquidityBasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\n\nimport \"../../external/uniswap/FullMath.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title ConcentratedLiquidityBasePriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice ConcentratedLiquidityBasePriceOracle is an abstract price oracle for concentrated liquidty (UniV3-like) pairs.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\nabstract contract ConcentratedLiquidityBasePriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\n  /**\n   * @notice Maps ERC20 token addresses to asset configs.\n   */\n  mapping(address => AssetConfig) public poolFeeds;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool public canAdminOverwrite;\n\n  struct AssetConfig {\n    address poolAddress;\n    uint256 twapWindow;\n    address baseToken;\n  }\n\n  address public WTOKEN;\n  address[] public SUPPORTED_BASE_TOKENS;\n\n  function initialize(address _wtoken, address[] memory _supportedBaseTokens) public initializer {\n    __SafeOwnable_init(msg.sender);\n    WTOKEN = _wtoken;\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param assetConfig The asset configuration which includes pool address and twap window.\n   */\n  function setPoolFeeds(address[] memory underlyings, AssetConfig[] memory assetConfig) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == assetConfig.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/config\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set asset config for underlying\n      require(\n        assetConfig[i].baseToken == WTOKEN || _isBaseTokenSupported(assetConfig[i].baseToken),\n        \"Base token must be supported\"\n      );\n      poolFeeds[underlying] = assetConfig[i];\n    }\n  }\n\n  /**\n   * @notice Get the token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for WTOKEN)\n   * @return Price denominated in NATIVE (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in NATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the price for a token from Uniswap v3\n   */\n  function _price(address token) internal view virtual returns (uint256);\n\n  function getPriceX96FromSqrtPriceX96(\n    address token0,\n    address priceToken,\n    uint160 sqrtPriceX96\n  ) public pure returns (uint256 price_) {\n    price_ = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**(96 * 2)) / 1e18);\n    if (token0 != priceToken) price_ = 1e36 / price_;\n  }\n\n  function _isBaseTokenSupported(address token) internal view returns (bool) {\n    for (uint256 i = 0; i < SUPPORTED_BASE_TOKENS.length; i++) {\n      if (SUPPORTED_BASE_TOKENS[i] == token) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _setSupportedBaseTokens(address[] memory _supportedBaseTokens) external onlyOwner {\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\n  }\n\n  function getSupportedBaseTokens() external view returns (address[] memory) {\n    return SUPPORTED_BASE_TOKENS;\n  }\n\n  function scalePrices(\n    address baseToken,\n    address token,\n    uint256 tokenPrice\n  ) internal view returns (uint256) {\n    uint256 baseTokenDecimals;\n    uint256 tokenPriceScaled;\n\n    if (baseToken == address(0) || baseToken == WTOKEN) {\n      baseTokenDecimals = 18;\n    } else {\n      baseTokenDecimals = uint256(ERC20Upgradeable(baseToken).decimals());\n    }\n\n    uint256 baseNativePrice = BasePriceOracle(msg.sender).price(baseToken);\n\n    // scale tokenPrice by 1e18\n    uint256 tokenDecimals = uint256(ERC20Upgradeable(token).decimals());\n    if (baseTokenDecimals > tokenDecimals) {\n      tokenPriceScaled = tokenPrice / (10**(baseTokenDecimals - tokenDecimals));\n    } else if (baseTokenDecimals < tokenDecimals) {\n      tokenPriceScaled = tokenPrice * (10**(tokenDecimals - baseTokenDecimals));\n    } else {\n      tokenPriceScaled = tokenPrice;\n    }\n    return (tokenPriceScaled * baseNativePrice) / 1e18;\n  }\n}\n"
    },
    "contracts/oracles/default/CurveLpTokenPriceOracleNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\n\nimport \"../../external/curve/ICurvePool.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracleNoRegistry\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract CurveLpTokenPriceOracleNoRegistry is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @dev Maps Curve LP token addresses to underlying token addresses.\n   */\n  mapping(address => address[]) public underlyingTokens;\n\n  /**\n   * @dev Maps Curve LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolOf;\n\n  address[] public lpTokens;\n\n  /**\n   * @dev Initializes an array of LP tokens and pools if desired.\n   * @param _lpTokens Array of LP token addresses.\n   * @param _pools Array of pool addresses.\n   * @param _poolUnderlyings The underlying token addresses of a pool\n   */\n  function initialize(\n    address[] memory _lpTokens,\n    address[] memory _pools,\n    address[][] memory _poolUnderlyings\n  ) public initializer {\n    require(\n      _lpTokens.length == _pools.length && _lpTokens.length == _poolUnderlyings.length,\n      \"No LP tokens supplied or array lengths not equal.\"\n    );\n\n    __SafeOwnable_init(msg.sender);\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\n      poolOf[_lpTokens[i]] = _pools[i];\n      underlyingTokens[_lpTokens[i]] = _poolUnderlyings[i];\n    }\n  }\n\n  function getAllLPTokens() public view returns (address[] memory) {\n    return lpTokens;\n  }\n\n  function getPoolForSwap(address inputToken, address outputToken)\n    public\n    view\n    returns (\n      ICurvePool,\n      int128,\n      int128\n    )\n  {\n    for (uint256 i = 0; i < lpTokens.length; i++) {\n      ICurvePool pool = ICurvePool(poolOf[lpTokens[i]]);\n      int128 inputIndex = -1;\n      int128 outputIndex = -1;\n      int128 j = 0;\n      while (true) {\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\n          if (coin == inputToken) inputIndex = j;\n          else if (coin == outputToken) outputIndex = j;\n          j++;\n        } catch {\n          break;\n        }\n\n        if (outputIndex > -1 && inputIndex > -1) {\n          return (pool, inputIndex, outputIndex);\n        }\n      }\n    }\n\n    return (ICurvePool(address(0)), 0, 0);\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n   * @param lpToken The LP token contract address for price retrieval.\n   */\n  function _price(address lpToken) internal view returns (uint256) {\n    address pool = poolOf[lpToken];\n    require(pool != address(0), \"LP token is not registered.\");\n    address[] memory tokens = underlyingTokens[lpToken];\n    uint256 minPx = type(uint256).max;\n    uint256 n = tokens.length;\n\n    for (uint256 i = 0; i < n; i++) {\n      address ulToken = tokens[i];\n      uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n\n    require(minPx != type(uint256).max, \"No minimum underlying token price found.\");\n    return (minPx * ICurvePool(pool).get_virtual_price()) / 1e18; // Use min underlying token prices\n  }\n\n  /**\n   * @dev Register the pool given LP token address and set the pool info.\n   * @param _lpToken LP token to find the corresponding pool.\n   * @param _pool Pool address.\n   * @param _underlyings Underlying addresses.\n   */\n  function registerPool(\n    address _lpToken,\n    address _pool,\n    address[] memory _underlyings\n  ) external onlyOwner {\n    poolOf[_lpToken] = _pool;\n    underlyingTokens[_lpToken] = _underlyings;\n\n    bool skip = false;\n    for (uint256 j = 0; j < lpTokens.length; j++) {\n      if (lpTokens[j] == _lpToken) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) lpTokens.push(_lpToken);\n  }\n\n  /**\n   * @dev getter for the underlying tokens\n   * @param lpToken the LP token address.\n   * @return _underlyings Underlying addresses.\n   */\n  function getUnderlyingTokens(address lpToken) public view returns (address[] memory) {\n    return underlyingTokens[lpToken];\n  }\n}\n"
    },
    "contracts/oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\nimport \"../../external/curve/ICurveV2Pool.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve V2 LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\ncontract CurveV2LpTokenPriceOracleNoRegistry is SafeOwnableUpgradeable, BasePriceOracle {\n  address public usdToken;\n  MasterPriceOracle public masterPriceOracle;\n  /**\n   * @dev Maps Curve LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolOf;\n\n  address[] public lpTokens;\n\n  /**\n   * @dev Initializes an array of LP tokens and pools if desired.\n   * @param _lpTokens Array of LP token addresses.\n   * @param _pools Array of pool addresses.\n   */\n  function initialize(address[] memory _lpTokens, address[] memory _pools) public initializer {\n    require(_lpTokens.length == _pools.length, \"No LP tokens supplied or array lengths not equal.\");\n    __SafeOwnable_init(msg.sender);\n\n    for (uint256 i = 0; i < _pools.length; i++) {\n      poolOf[_lpTokens[i]] = _pools[i];\n    }\n  }\n\n  function getAllLPTokens() public view returns (address[] memory) {\n    return lpTokens;\n  }\n\n  function getPoolForSwap(address inputToken, address outputToken)\n    public\n    view\n    returns (\n      ICurvePool,\n      int128,\n      int128\n    )\n  {\n    for (uint256 i = 0; i < lpTokens.length; i++) {\n      ICurvePool pool = ICurvePool(poolOf[lpTokens[i]]);\n      int128 inputIndex = -1;\n      int128 outputIndex = -1;\n      int128 j = 0;\n      while (true) {\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\n          if (coin == inputToken) inputIndex = j;\n          else if (coin == outputToken) outputIndex = j;\n          j++;\n        } catch {\n          break;\n        }\n\n        if (outputIndex > -1 && inputIndex > -1) {\n          return (pool, inputIndex, outputIndex);\n        }\n      }\n    }\n\n    return (ICurvePool(address(0)), int128(0), int128(0));\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token price from Curve, with 18 decimals of precision.\n   * @param lpToken The LP token contract address for price retrieval.\n   */\n  function _price(address lpToken) internal view returns (uint256) {\n    address pool = poolOf[lpToken];\n    require(address(pool) != address(0), \"LP token is not registered.\");\n\n    address baseToken = ICurvePool(pool).coins(0);\n    uint256 lpPrice = ICurveV2Pool(pool).lp_price();\n    uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\n    return (lpPrice * baseTokenPrice) / 10**18;\n  }\n\n  /**\n   * @dev Register the pool given LP token address and set the pool info.\n   * @param _lpToken LP token to find the corresponding pool.\n   * @param _pool Pool address.\n   */\n  function registerPool(address _lpToken, address _pool) external onlyOwner {\n    address pool = poolOf[_lpToken];\n    require(pool == address(0), \"This LP token is already registered.\");\n    poolOf[_lpToken] = _pool;\n\n    bool skip = false;\n    for (uint256 j = 0; j < lpTokens.length; j++) {\n      if (lpTokens[j] == _lpToken) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) lpTokens.push(_lpToken);\n  }\n}\n"
    },
    "contracts/oracles/default/CurveV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\n\nimport \"../../external/curve/ICurveV2Pool.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve V2 LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\ncontract CurveV2PriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @dev Maps Curve LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolFor;\n\n  address[] public tokens;\n\n  /**\n   * @dev Initializes an array of tokens and pools if desired.\n   * @param _tokens Array of token addresses.\n   * @param _pools Array of pool addresses.\n   */\n  function initialize(address[] memory _tokens, address[] memory _pools) public initializer {\n    require(_tokens.length == _pools.length, \"No LP tokens supplied or array lengths not equal.\");\n    __SafeOwnable_init(msg.sender);\n\n    for (uint256 i = 0; i < _pools.length; i++) {\n      try ICurvePool(_pools[i]).coins(2) returns (address) {\n        revert(\"!only two token pools\");\n      } catch {\n        // ignore error\n      }\n\n      poolFor[_tokens[i]] = _pools[i];\n    }\n  }\n\n  function getAllSupportedTokens() public view returns (address[] memory) {\n    return tokens;\n  }\n\n  function getPoolForSwap(address inputToken, address outputToken)\n    public\n    view\n    returns (\n      ICurvePool,\n      int128,\n      int128\n    )\n  {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      ICurvePool pool = ICurvePool(poolFor[tokens[i]]);\n      int128 inputIndex = -1;\n      int128 outputIndex = -1;\n      int128 j = 0;\n      while (true) {\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\n          if (coin == inputToken) inputIndex = j;\n          else if (coin == outputToken) outputIndex = j;\n          j++;\n        } catch {\n          break;\n        }\n\n        if (outputIndex > -1 && inputIndex > -1) {\n          return (pool, inputIndex, outputIndex);\n        }\n      }\n    }\n\n    return (ICurvePool(address(0)), int128(0), int128(0));\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token price from Curve, with 18 decimals of precision.\n   * @param token The LP token contract address for price retrieval.\n   */\n  function _price(address token) internal view returns (uint256) {\n    address pool = poolFor[token];\n    require(address(pool) != address(0), \"Token is not registered.\");\n\n    address baseToken;\n    // Returns always coin(1) / coin(0)  [ e.g. USDC (1) / eUSDC (1) ]\n    uint256 exchangeRate = ICurveV2Pool(pool).price_oracle();\n\n    if (ICurvePool(pool).coins(0) == token) {\n      baseToken = ICurvePool(pool).coins(1);\n      // USDC / ETH\n      uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\n      // USDC / ETH * eUSDC / USDC = eUSDC / ETH\n      return (baseTokenPrice * 10**18) / exchangeRate;\n    } else {\n      // if coin(1) is eUSDC, exchangeRate is USDC / eUSDC\n      baseToken = ICurvePool(pool).coins(0);\n      // USDC / ETH\n      uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\n      // (USDC / ETH) *  (1 / (USDC / eUSDC)) = eUSDC / ETH\n      return (baseTokenPrice * exchangeRate) / 10**18;\n    }\n  }\n\n  /**\n   * @dev Register the pool given token address and set the pool info.\n   * @param _token token to find the corresponding pool.\n   * @param _pool Pool address.\n   */\n  function registerPool(address _token, address _pool) external onlyOwner {\n    try ICurvePool(_pool).coins(2) returns (address) {\n      revert(\"!only two token pools\");\n    } catch {\n      // ignore error\n    }\n\n    address pool = poolFor[_token];\n    require(pool == address(0), \"This LP token is already registered.\");\n    poolFor[_token] = _pool;\n\n    bool skip = false;\n    for (uint256 j = 0; j < tokens.length; j++) {\n      if (tokens[j] == _token) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) tokens.push(_token);\n  }\n}\n"
    },
    "contracts/oracles/default/DiaPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IPriceOracle } from \"../../external/compound/IPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\n\ninterface DIAOracleV2 {\n  function getValue(string memory key) external view returns (uint128, uint128);\n}\n\n/**\n * @title DiaPriceOracle\n * @notice Returns prices from DIA.\n * @dev Implements `PriceOracle`.\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\n */\ncontract DiaPriceOracle is BasePriceOracle {\n  struct DiaOracle {\n    DIAOracleV2 feed;\n    string key;\n  }\n\n  /**\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n   */\n  mapping(address => DiaOracle) public priceFeeds;\n\n  /**\n   * @dev The administrator of this `MasterPriceOracle`.\n   */\n  address public admin;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool public immutable CAN_ADMIN_OVERWRITE;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public immutable WTOKEN;\n\n  /**\n   * @notice DIA NATIVE/USD price feed contracts.\n   */\n  DIAOracleV2 public immutable NATIVE_TOKEN_USD_PRICE_FEED;\n  string public NATIVE_TOKEN_USD_KEY;\n\n  /**\n   * @notice MasterPriceOracle for backup for USD price.\n   */\n  MasterPriceOracle public immutable MASTER_PRICE_ORACLE;\n  address public immutable USD_TOKEN; // token to use as USD price (i.e. USDC)\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  constructor(\n    address _admin,\n    bool canAdminOverwrite,\n    address wtoken,\n    DIAOracleV2 nativeTokenUsd,\n    string memory nativeTokenUsdKey,\n    MasterPriceOracle masterPriceOracle,\n    address usdToken\n  ) {\n    admin = _admin;\n    CAN_ADMIN_OVERWRITE = canAdminOverwrite;\n    WTOKEN = wtoken;\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\n    NATIVE_TOKEN_USD_KEY = nativeTokenUsdKey;\n    MASTER_PRICE_ORACLE = masterPriceOracle;\n    USD_TOKEN = usdToken;\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  /**\n   * @dev Event emitted when `admin` is changed.\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @dev Modifier that checks if `msg.sender == admin`.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Sender is not the admin.\");\n    _;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feeds The DIA price feed contract addresses for each of `underlyings`.\n   * @param keys The keys for each of `underlyings`, in the format \"ETH/USD\" for example\n   */\n  function setPriceFeeds(\n    address[] memory underlyings,\n    DIAOracleV2[] memory feeds,\n    string[] memory keys\n  ) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feeds.length && underlyings.length == keys.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n\n      // Check for existing oracle if !canAdminOverwrite\n      if (!CAN_ADMIN_OVERWRITE)\n        require(\n          address(priceFeeds[underlying].feed) == address(0),\n          \"Admin cannot overwrite existing assignments of price feeds to underlying tokens.\"\n        );\n\n      // Set feed and base currency\n      priceFeeds[underlying] = DiaOracle({ feed: feeds[i], key: keys[i] });\n    }\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   * Assumes price feeds are 8 decimals!\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WTOKEN\n    if (underlying == WTOKEN || underlying == address(0)) return 1e18;\n\n    // Get token/Native price from Oracle\n    DiaOracle memory feed = priceFeeds[underlying];\n    require(address(feed.feed) != address(0), \"No oracle price feed found for this underlying ERC20 token.\");\n\n    if (address(NATIVE_TOKEN_USD_PRICE_FEED) == address(0)) {\n      // Get price from MasterPriceOracle\n      uint256 usdNativeTokenPrice = MASTER_PRICE_ORACLE.price(USD_TOKEN);\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals\n      (uint128 tokenUsdPrice, ) = feed.feed.getValue(feed.key); // 8 decimals\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e28) / uint256(nativeTokenUsdPrice) : 0;\n    } else {\n      (uint128 nativeTokenUsdPrice, ) = NATIVE_TOKEN_USD_PRICE_FEED.getValue(NATIVE_TOKEN_USD_KEY);\n      if (nativeTokenUsdPrice <= 0) return 0;\n      (uint128 tokenUsdPrice, ) = feed.feed.getValue(feed.key); // 8 decimals\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\n    }\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    // Get price\n    uint256 oraclePrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/ERC4626Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IERC4626 } from \"../../compound/IERC4626.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\ncontract ERC4626Oracle is SafeOwnableUpgradeable, BasePriceOracle {\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n  }\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IERC4626 vault = IERC4626(underlying);\n    address asset = vault.asset();\n    uint256 redeemAmount = vault.previewRedeem(10**vault.decimals());\n    uint256 underlyingPrice = BasePriceOracle(msg.sender).price(asset);\n    return (redeemAmount * underlyingPrice) / 10**ERC20Upgradeable(asset).decimals();\n  }\n}\n"
    },
    "contracts/oracles/default/FixedNativePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedEthPriceOracle\n * @notice Returns fixed prices of 1 denominated in the chain's native token for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedNativePriceOracle is BasePriceOracle {\n  /**\n   * @dev Returns the price in native token of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return 1e18;\n  }\n\n  /**\n   * @notice Returns the price in native token of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in native token of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    return 1e18;\n  }\n}\n"
    },
    "contracts/oracles/default/FixedTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedTokenPriceOracle\n * @notice Returns token prices using the prices for another token.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedTokenPriceOracle is BasePriceOracle {\n  /**\n   * @dev The token to base prices on.\n   */\n  address public immutable baseToken;\n\n  /**\n   * @dev Sets the token to base prices on.\n   */\n  constructor(address _baseToken) {\n    baseToken = _baseToken;\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    return BasePriceOracle(msg.sender).price(baseToken);\n  }\n}\n"
    },
    "contracts/oracles/default/GammaPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\nimport { LiquidityAmounts } from \"../../external/uniswap/LiquidityAmounts.sol\";\nimport { TickMath } from \"../../external/uniswap/TickMath.sol\";\nimport { IUniswapV3Pool } from \"../../external/uniswap/IUniswapV3Pool.sol\";\nimport { IAlgebraPool } from \"../../external/algebra/IAlgebraPool.sol\";\nimport { IHypervisor } from \"../../external/gamma/IHypervisor.sol\";\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\n\n/**\n * @title GammaPoolBasePriceOracle\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\n * @notice GammaPoolBasePriceOracle is a base price oracle for Gamma wrapped LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\n\nabstract contract GammaPoolBasePriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public WTOKEN;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n\n  function initialize(address _wtoken) public initializer {\n    __SafeOwnable_init(msg.sender);\n    WTOKEN = _wtoken;\n  }\n\n  /**\n   * @dev Fetches the price for a token from Uniswap v3\n   */\n  function _price(address token) internal view virtual returns (uint256);\n\n  /**\n   * @notice Get the token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for WTOKEN)\n   * @return Price denominated in NATIVE (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in NATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fast square root function.\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n   */\n  function sqrt(uint256 x) internal pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n\n  /**\n   * @dev Converts uint256 to uint160.\n   */\n  function toUint160(uint256 x) internal pure returns (uint160 z) {\n    require((z = uint160(x)) == x, \"Overflow when converting uint256 into uint160.\");\n  }\n\n  function _amountsForLiquidityAtPrice(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 liquidity,\n    uint160 sqrtRatioX96\n  ) internal pure returns (uint256, uint256) {\n    return\n      LiquidityAmounts.getAmountsForLiquidity(\n        sqrtRatioX96,\n        TickMath.getSqrtRatioAtTick(tickLower),\n        TickMath.getSqrtRatioAtTick(tickUpper),\n        liquidity\n      );\n  }\n\n  function _getTotalAmountsAtPrice(\n    uint160 sqrtRatioX96,\n    int24 limitLower,\n    int24 limitUpper,\n    int24 baseLower,\n    int24 baseUpper,\n    address token,\n    address pool\n  ) internal view returns (uint256 total0, uint256 total1) {\n    (uint256 base0, uint256 base1) = _getPositionAtPrice(baseLower, baseUpper, sqrtRatioX96, token, pool);\n    (uint256 limit0, uint256 limit1) = _getPositionAtPrice(limitLower, limitUpper, sqrtRatioX96, token, pool);\n    return (base0 + limit0, base1 + limit1);\n  }\n\n  function _position(\n    address pool,\n    address token,\n    int24 lowerTick,\n    int24 upperTick\n  )\n    internal\n    view\n    virtual\n    returns (\n      uint128 liquidity,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n\n  function _getPositionAtPrice(\n    int24 tickLower,\n    int24 tickUpper,\n    uint160 sqrtRatioX96,\n    address token,\n    address pool\n  ) public view returns (uint256 amount0, uint256 amount1) {\n    (uint128 positionLiquidity, uint128 tokensOwed0, uint128 tokensOwed1) = _position(\n      pool,\n      token,\n      tickLower,\n      tickUpper\n    );\n    (amount0, amount1) = _amountsForLiquidityAtPrice(tickLower, tickUpper, positionLiquidity, sqrtRatioX96);\n    amount0 = amount0 + uint256(tokensOwed0);\n    amount1 = amount1 + uint256(tokensOwed1);\n  }\n}\n\n/**\n * @title GammaPoolAlgebraPriceOracle\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\n * @notice GammaPoolAlgebraPriceOracle is a price oracle for Gelato Gamma wrapped Algebra LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\n\ncontract GammaPoolAlgebraPriceOracle is GammaPoolBasePriceOracle {\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  function _price(address token) internal view override returns (uint256) {\n    // Get Gamma pool and underlying tokens\n    IHypervisor pool = IHypervisor(token);\n    ERC20Upgradeable token0 = ERC20Upgradeable(pool.token0());\n    ERC20Upgradeable token1 = ERC20Upgradeable(pool.token1());\n\n    // Get underlying token prices\n    uint256 p0 = BasePriceOracle(msg.sender).price(address(token0)); // * 10**uint256(18 - token0.decimals());\n    uint256 p1 = BasePriceOracle(msg.sender).price(address(token1)); // * 10**uint256(18 - token1.decimals());\n\n    uint160 sqrtPriceX96 = toUint160(\n      sqrt((p0 * (10**token0.decimals()) * (1 << 96)) / (p1 * (10**token1.decimals()))) << 48\n    );\n\n    // Get balances of the tokens in the pool given fair underlying token prices\n    (uint256 basePlusLimit0, uint256 basePlusLimit1) = _getTotalAmountsAtPrice(\n      sqrtPriceX96,\n      pool.limitLower(),\n      pool.limitUpper(),\n      pool.baseLower(),\n      pool.baseUpper(),\n      token,\n      pool.pool()\n    );\n\n    uint256 r0 = token0.balanceOf(address(token)) + basePlusLimit0;\n    uint256 r1 = token1.balanceOf(address(token)) + basePlusLimit1;\n\n    r0 = r0 * 10**(18 - uint256(token0.decimals()));\n    r1 = r1 * 10**(18 - uint256(token1.decimals()));\n\n    require(r0 > 0 || r1 > 0, \"Gamma underlying token balances not both greater than 0.\");\n\n    // Add the total value of each token together and divide by the totalSupply to get the unit price\n    return (p0 * r0 + p1 * r1) / ERC20Upgradeable(token).totalSupply();\n  }\n\n  function _position(\n    address pool,\n    address token,\n    int24 lowerTick,\n    int24 upperTick\n  )\n    internal\n    view\n    override\n    returns (\n      uint128 liquidity,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    )\n  {\n    bytes32 positionKey;\n    assembly {\n      positionKey := or(shl(24, or(shl(24, token), and(lowerTick, 0xFFFFFF))), and(upperTick, 0xFFFFFF))\n    }\n    (liquidity, , , , tokensOwed0, tokensOwed1) = IAlgebraPool(pool).positions(positionKey);\n  }\n}\n\ncontract GammaPoolUniswapV3PriceOracle is GammaPoolBasePriceOracle {\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  function _price(address token) internal view override returns (uint256) {\n    // Get Gamma pool and underlying tokens\n    IHypervisor pool = IHypervisor(token);\n    ERC20Upgradeable token0 = ERC20Upgradeable(pool.token0());\n    ERC20Upgradeable token1 = ERC20Upgradeable(pool.token1());\n\n    // Get underlying token prices\n    uint256 p0 = BasePriceOracle(msg.sender).price(address(token0)); // * 10**uint256(18 - token0.decimals());\n    uint256 p1 = BasePriceOracle(msg.sender).price(address(token1)); // * 10**uint256(18 - token1.decimals());\n\n    uint160 sqrtPriceX96 = toUint160(\n      sqrt((p0 * (10**token0.decimals()) * (1 << 96)) / (p1 * (10**token1.decimals()))) << 48\n    );\n\n    // Get balances of the tokens in the pool given fair underlying token prices\n    (uint256 basePlusLimit0, uint256 basePlusLimit1) = _getTotalAmountsAtPrice(\n      sqrtPriceX96,\n      pool.limitLower(),\n      pool.limitUpper(),\n      pool.baseLower(),\n      pool.baseUpper(),\n      token,\n      pool.pool()\n    );\n\n    uint256 r0 = token0.balanceOf(address(token)) + basePlusLimit0;\n    uint256 r1 = token1.balanceOf(address(token)) + basePlusLimit1;\n\n    r0 = r0 * 10**(18 - uint256(token0.decimals()));\n    r1 = r1 * 10**(18 - uint256(token1.decimals()));\n\n    require(r0 > 0 || r1 > 0, \"Gamma underlying token balances not both greater than 0.\");\n\n    // Add the total value of each token together and divide by the totalSupply to get the unit price\n    return (p0 * r0 + p1 * r1) / ERC20Upgradeable(token).totalSupply();\n  }\n\n  // see: https://polygonscan.com/address/0xe058e1ffff9b13d3fcd4803fdb55d1cc2fe07ddc#code\n  function _position(\n    address pool,\n    address token,\n    int24 lowerTick,\n    int24 upperTick\n  )\n    internal\n    view\n    override\n    returns (\n      uint128 liquidity,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    )\n  {\n    bytes32 positionKey = keccak256(abi.encodePacked(token, lowerTick, upperTick));\n    (liquidity, , , tokensOwed0, tokensOwed1) = IUniswapV3Pool(pool).positions(positionKey);\n  }\n}\n"
    },
    "contracts/oracles/default/GelatoGUniPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/gelato/GUniPool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title GelatoGUniPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice GelatoGUniPriceOracle is a price oracle for Gelato G-UNI wrapped Uniswap V3 LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract GelatoGUniPriceOracle is BasePriceOracle {\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public immutable WTOKEN;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  constructor(address wtoken) {\n    WTOKEN = wtoken;\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  function _price(address token) internal view virtual returns (uint256) {\n    // Get G-UNI pool and underlying tokens\n    GUniPool pool = GUniPool(token);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    // Get underlying token prices\n    uint256 p0 = token0 == WTOKEN ? 1e18 : BasePriceOracle(msg.sender).price(token0);\n    require(p0 > 0, \"Failed to retrieve price for G-UNI underlying token0.\");\n    uint256 p1 = token1 == WTOKEN ? 1e18 : BasePriceOracle(msg.sender).price(token1);\n    require(p1 > 0, \"Failed to retrieve price for G-UNI underlying token1.\");\n\n    // Get conversion factors\n    uint256 dec0 = uint256(ERC20Upgradeable(token0).decimals());\n    require(dec0 <= 18, \"G-UNI underlying token0 decimals greater than 18.\");\n    uint256 to18Dec0 = 10**(18 - dec0);\n    uint256 dec1 = uint256(ERC20Upgradeable(token1).decimals());\n    require(dec1 <= 18, \"G-UNI underlying token1 decimals greater than 18.\");\n    uint256 to18Dec1 = 10**(18 - dec1);\n\n    // Get square root of underlying token prices\n    // token1/token0\n    // = (p0 / 10^dec0) / (p1 / 10^dec1)\n    // = (p0 * 10^dec1) / (p1 * 10^dec0)\n    // [From Uniswap's definition] sqrtPriceX96\n    // = sqrt(token1/token0) * 2^96\n    // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^96\n    // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^48 * 2^48\n    // = sqrt((p0 * 10^dec1 * 2^96) / (p1 * 10^dec0)) * 2^48\n    uint160 sqrtPriceX96 = toUint160(sqrt((p0 * (10**dec1) * (1 << 96)) / (p1 * (10**dec0))) << 48);\n\n    // Get balances of the tokens in the pool given fair underlying token prices\n    (uint256 r0, uint256 r1) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);\n    require(r0 > 0 || r1 > 0, \"G-UNI underlying token balances not both greater than 0.\");\n\n    // Add the total value of each token together and divide by the totalSupply to get the unit price\n    return (p0 * r0 * to18Dec0 + p1 * r1 * to18Dec1) / ERC20Upgradeable(token).totalSupply();\n  }\n\n  /**\n   * @dev Fast square root function.\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n   */\n  function sqrt(uint256 x) internal pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n\n  /**\n   * @dev Converts uint256 to uint160.\n   */\n  function toUint160(uint256 x) internal pure returns (uint160 z) {\n    require((z = uint160(x)) == x, \"Overflow when converting uint256 into uint160.\");\n  }\n}\n"
    },
    "contracts/oracles/default/KyberSwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IPool } from \"../../external/kyber/IPool.sol\";\nimport { IPoolOracle } from \"../../external/kyber/IPoolOracle.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"./ConcentratedLiquidityBasePriceOracle.sol\";\n\nimport \"../../external/uniswap/TickMath.sol\";\nimport \"../../external/uniswap/FullMath.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title KyberSwapPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice KyberSwapPriceOracle is a price oracle for Kybet-style pairs.\n * @dev Implements the `BasePriceOracle` interface used by Ionic pools (and Compound v2).\n */\n\ncontract KyberSwapPriceOracle is ConcentratedLiquidityBasePriceOracle {\n  /**\n   * @dev Fetches the price for a token from Algebra pools.\n   */\n\n  function _price(address token) internal view override returns (uint256) {\n    uint32[] memory secondsAgos = new uint32[](2);\n    uint256 twapWindow = poolFeeds[token].twapWindow;\n    address baseToken = poolFeeds[token].baseToken;\n\n    secondsAgos[0] = 0;\n    secondsAgos[1] = uint32(twapWindow);\n\n    IPool pool = IPool(poolFeeds[token].poolAddress);\n    IPoolOracle poolOracle = IPoolOracle(pool.poolOracle());\n\n    int56[] memory tickCumulatives = poolOracle.observeFromPool(address(pool), secondsAgos);\n\n    int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(int256(twapWindow)));\n    uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n\n    uint256 baseTokenDecimals = uint256(ERC20Upgradeable(baseToken).decimals());\n    uint256 tokenDecimals = uint256(ERC20Upgradeable(token).decimals());\n\n    uint256 tokenPrice = getPriceX96FromSqrtPriceX96(baseToken, token, sqrtPriceX96);\n    uint256 tokenPriceScaled;\n\n    if (baseTokenDecimals > tokenDecimals) {\n      tokenPriceScaled = tokenPrice / (10**(baseTokenDecimals - tokenDecimals));\n    } else if (baseTokenDecimals < tokenDecimals) {\n      tokenPriceScaled = tokenPrice / (10**(tokenDecimals - baseTokenDecimals));\n    } else {\n      tokenPriceScaled = tokenPrice;\n    }\n\n    uint256 baseNativePrice = BasePriceOracle(msg.sender).price(baseToken);\n    return (tokenPriceScaled * baseNativePrice) / 1e18;\n  }\n}\n"
    },
    "contracts/oracles/default/PreferredPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../BasePriceOracle.sol\";\nimport \"../MasterPriceOracle.sol\";\nimport \"../default/ChainlinkPriceOracleV2.sol\";\n\n/**\n * @title PreferredPriceOracle\n * @notice Returns prices from MasterPriceOracle, ChainlinkPriceOracleV2, or prices from a tertiary oracle (in order of preference).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PreferredPriceOracle is BasePriceOracle {\n  /**\n   * @dev The primary `MasterPriceOracle`.\n   */\n  MasterPriceOracle public masterOracle;\n\n  /**\n   * @dev The secondary `ChainlinkPriceOracleV2`.\n   */\n  ChainlinkPriceOracleV2 public chainlinkOracleV2;\n\n  /**\n   * @dev The tertiary `PriceOracle`.\n   */\n  BasePriceOracle public tertiaryOracle;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev Constructor to set the primary `MasterPriceOracle`, the secondary `ChainlinkPriceOracleV2`, and the tertiary `PriceOracle`.\n   */\n  constructor(\n    MasterPriceOracle _masterOracle,\n    ChainlinkPriceOracleV2 _chainlinkOracleV2,\n    BasePriceOracle _tertiaryOracle,\n    address _wtoken\n  ) {\n    require(address(_masterOracle) != address(0), \"MasterPriceOracle not set.\");\n    require(address(_chainlinkOracleV2) != address(0), \"ChainlinkPriceOracleV2 not set.\");\n    require(address(_tertiaryOracle) != address(0), \"Tertiary price oracle not set.\");\n    masterOracle = _masterOracle;\n    chainlinkOracleV2 = _chainlinkOracleV2;\n    tertiaryOracle = _tertiaryOracle;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Try to get MasterPriceOracle price\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.price(underlying);\n\n    // Try to get ChainlinkPriceOracleV2 price\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0)) return chainlinkOracleV2.price(underlying);\n\n    // Otherwise, get price from tertiary oracle\n    return BasePriceOracle(address(tertiaryOracle)).price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying ERC20 token address\n    address underlying = cToken.underlying();\n\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Try to get MasterPriceOracle price\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.getUnderlyingPrice(cToken);\n\n    // Try to get ChainlinkPriceOracleV2 price\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0))\n      return chainlinkOracleV2.getUnderlyingPrice(cToken);\n\n    // Otherwise, get price from tertiary oracle\n    return tertiaryOracle.getUnderlyingPrice(cToken);\n  }\n}\n"
    },
    "contracts/oracles/default/PythPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title PythPriceOracle\n * @notice Returns prices from Pyth.\n * @dev Implements `PriceOracle`.\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\n */\ncontract PythPriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\n  /**\n   * @notice Maps ERC20 token addresses to Pyth price IDs.\n   */\n  mapping(address => bytes32) public priceFeedIds;\n\n  /**\n   * @notice DIA NATIVE/USD price feed contracts.\n   */\n  bytes32 public NATIVE_TOKEN_USD_FEED;\n\n  /**\n   * @notice MasterPriceOracle for backup for USD price.\n   */\n  address public USD_TOKEN; // token to use as USD price (i.e. USDC)\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n\n  IPyth public PYTH;\n\n  function initialize(\n    address pythAddress,\n    bytes32 nativeTokenUsdFeed,\n    address usdToken\n  ) public initializer {\n    __SafeOwnable_init(msg.sender);\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\n    USD_TOKEN = usdToken;\n    PYTH = IPyth(pythAddress);\n  }\n\n  function reinitialize(\n    address pythAddress,\n    bytes32 nativeTokenUsdFeed,\n    address usdToken\n  ) public onlyOwnerOrAdmin {\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\n    USD_TOKEN = usdToken;\n    PYTH = IPyth(pythAddress);\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feedIds The Pyth Network feed IDs`.\n   */\n  function setPriceFeeds(address[] memory underlyings, bytes32[] memory feedIds) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feedIds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set feed and base currency\n      priceFeedIds[underlying] = feedIds[i];\n    }\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   * Assumes price feeds are 8 decimals (TODO: doublecheck)\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Get token/native price from Oracle\n    bytes32 feed = priceFeedIds[underlying];\n    require(feed != \"\", \"No oracle price feed found for this underlying ERC20 token.\");\n\n    if (NATIVE_TOKEN_USD_FEED == \"\") {\n      // Get price from MasterPriceOracle\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals -- TODO: doublecheck\n      PythStructs.Price memory tokenUsdPrice = PYTH.getPriceUnsafe(feed); // 8 decimals ---  TODO: doublecheck\n      return\n        tokenUsdPrice.price >= 0 ? (uint256(uint64(tokenUsdPrice.price)) * 1e28) / uint256(nativeTokenUsdPrice) : 0;\n    } else {\n      uint128 nativeTokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(NATIVE_TOKEN_USD_FEED).price));\n      if (nativeTokenUsdPrice <= 0) return 0;\n      uint128 tokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(feed).price));\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\n    }\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    // Get price\n    uint256 oraclePrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/PythPriceOracleDmBTC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title PythPriceOracle\n * @notice Returns prices from Pyth.\n * @dev Implements `PriceOracle`.\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\n */\ncontract PythPriceOracleDmBTC is BasePriceOracle, SafeOwnableUpgradeable {\n  /**\n   * @notice Maps ERC20 token addresses to Pyth price IDs.\n   */\n  mapping(address => bytes32) public priceFeedIds;\n\n  /**\n   * @notice DIA NATIVE/USD price feed contracts.\n   */\n  bytes32 public NATIVE_TOKEN_USD_FEED;\n\n  /**\n   * @notice MasterPriceOracle for backup for USD price.\n   */\n  address public USD_TOKEN; // token to use as USD price (i.e. USDC)\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n\n  IPyth public PYTH;\n\n  address public DMBTC;\n\n  function initialize(\n    address pythAddress,\n    bytes32 nativeTokenUsdFeed,\n    address usdToken,\n    address dmBTC\n  ) public initializer {\n    __SafeOwnable_init(msg.sender);\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\n    USD_TOKEN = usdToken;\n    PYTH = IPyth(pythAddress);\n    DMBTC = dmBTC;\n  }\n\n  function reinitialize(\n    address pythAddress,\n    bytes32 nativeTokenUsdFeed,\n    address usdToken,\n    address dmBTC\n  ) public onlyOwnerOrAdmin {\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\n    USD_TOKEN = usdToken;\n    PYTH = IPyth(pythAddress);\n    DMBTC = dmBTC;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feedIds The Pyth Network feed IDs`.\n   */\n  function setPriceFeeds(address[] memory underlyings, bytes32[] memory feedIds) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feedIds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set feed and base currency\n      priceFeedIds[underlying] = feedIds[i];\n    }\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   * Assumes price feeds are 8 decimals (TODO: doublecheck)\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Get token/native price from Oracle\n    bytes32 feed = priceFeedIds[underlying];\n    require(feed != \"\", \"No oracle price feed found for this underlying ERC20 token.\");\n    uint256 normalizedPrice;\n    if (NATIVE_TOKEN_USD_FEED == \"\") {\n      // Get price from MasterPriceOracle\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals -- TODO: doublecheck\n      PythStructs.Price memory tokenUsdPrice = PYTH.getPriceUnsafe(feed); // 8 decimals ---  TODO: doublecheck\n      normalizedPrice = tokenUsdPrice.price >= 0 ? (uint256(uint64(tokenUsdPrice.price)) * 1e28) / uint256(nativeTokenUsdPrice) : 0;\n    } else {\n      uint128 nativeTokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(NATIVE_TOKEN_USD_FEED).price));\n      if (nativeTokenUsdPrice <= 0) return 0;\n      uint128 tokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(feed).price));\n      normalizedPrice = tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\n    }\n    if (underlying == DMBTC) {\n      return normalizedPrice / 100000;\n    }\n    return normalizedPrice;\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    // Get price\n    uint256 oraclePrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/RecursivePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\nimport \"../../external/compound/IComptroller.sol\";\n\n/**\n * @title RecursivePriceOracle\n * @notice Returns prices from other cTokens (from Ionic).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract RecursivePriceOracle is IPriceOracle {\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get cToken's underlying cToken\n    ICToken underlying = ICToken(ICErc20Compound(address(cToken)).underlying());\n\n    // Get Comptroller\n    IComptroller comptroller = IComptroller(underlying.comptroller());\n\n    // If cETH, return cETH/ETH exchange rate\n    if (underlying.isCEther()) {\n      return underlying.exchangeRateStored();\n    }\n\n    // Ionic cTokens: cToken/token price * token/ETH price = cToken/ETH price\n    return (underlying.exchangeRateStored() * comptroller.oracle().getUnderlyingPrice(underlying)) / 1e18;\n  }\n}\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/redstone/IRedstoneOracle.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title RedstoneAdapterPriceOracle\n * @notice Returns prices from Redstone.\n * @dev Implements `BasePriceOracle`.\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\n */\ncontract RedstoneAdapterPriceOracle is BasePriceOracle {\n  /**\n   * @notice The Redstone oracle contract\n   */\n  IRedstoneOracle public REDSTONE_ORACLE;\n\n  /**\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\n   * @param redstoneOracle The Redstone oracle contract address\n   */\n  constructor(address redstoneOracle) {\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\n  }\n\n  /**\n   * @notice Internal function returning the price in of `underlying`.\n   * @dev will return a price denominated in the native token\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\n  }\n\n  /**\n   * @notice Returns the price in of `underlying` either in the\n   * native token (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    uint256 oraclePrice = _price(underlying);\n\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracleWeETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/redstone/IRedstoneOracle.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title RedstoneAdapterPriceOracle\n * @notice Returns prices from Redstone.\n * @dev Implements `BasePriceOracle`.\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\n */\ncontract RedstoneAdapterPriceOracleWeETH is BasePriceOracle {\n  /**\n   * @notice The Redstone oracle contract\n   */\n  IRedstoneOracle public REDSTONE_ORACLE;\n\n  /**\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\n   * @param redstoneOracle The Redstone oracle contract address\n   */\n  constructor(address redstoneOracle) {\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\n  }\n\n  /**\n   * @notice Internal function returning the price in of `underlying`.\n   * @dev will return a price denominated in the native token\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // special case for wrsETH\n    // if input is wrsETH, we need to get the price of rsETH\n    if (underlying == 0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A) {\n      underlying = 0x028227c4dd1e5419d11Bb6fa6e661920c519D4F5;\n    }\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\n  }\n\n  /**\n   * @notice Returns the price in of `underlying` either in the\n   * native token (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    uint256 oraclePrice = _price(underlying);\n\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracleWrsETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/redstone/IRedstoneOracle.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title RedstoneAdapterPriceOracle\n * @notice Returns prices from Redstone.\n * @dev Implements `BasePriceOracle`.\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\n */\ncontract RedstoneAdapterPriceOracleWrsETH is BasePriceOracle {\n  /**\n   * @notice The Redstone oracle contract\n   */\n  IRedstoneOracle public REDSTONE_ORACLE;\n\n  /**\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\n   * @param redstoneOracle The Redstone oracle contract address\n   */\n  constructor(address redstoneOracle) {\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\n  }\n\n  /**\n   * @notice Internal function returning the price in of `underlying`.\n   * @dev will return a price denominated in the native token\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // special case for wrsETH\n    // if input is wrsETH, we need to get the price of rsETH\n    if (underlying == 0xe7903B1F75C534Dd8159b313d92cDCfbC62cB3Cd) {\n      underlying = 0x4186BFC76E2E237523CBC30FD220FE055156b41F;\n    }\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\n  }\n\n  /**\n   * @notice Returns the price in of `underlying` either in the\n   * native token (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    uint256 oraclePrice = _price(underlying);\n\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/SaddleLpPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\n\nimport \"../../external/saddle/ISwap.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title SaddleLpTokenPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice SaddleLpPriceOracle is a price oracle for Saddle LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\ncontract SaddleLpPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @dev Maps Saddle LP token addresses to underlying token addresses.\n   */\n  mapping(address => address[]) public underlyingTokens;\n\n  /**\n   * @dev Maps Saddle LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolOf;\n\n  /**\n   * @dev Initializes an array of LP tokens and pools if desired.\n   * @param _lpTokens Array of LP token addresses.\n   * @param _pools Array of pool addresses.\n   * @param _poolUnderlyings The underlying token addresses of a pool\n   */\n  function initialize(\n    address[] memory _lpTokens,\n    address[] memory _pools,\n    address[][] memory _poolUnderlyings\n  ) public initializer {\n    require(\n      _lpTokens.length == _pools.length && _lpTokens.length == _poolUnderlyings.length,\n      \"No LP tokens supplied or array lengths not equal.\"\n    );\n\n    __SafeOwnable_init(msg.sender);\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\n      poolOf[_lpTokens[i]] = _pools[i];\n      underlyingTokens[_lpTokens[i]] = _poolUnderlyings[i];\n    }\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Saddle, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n   * @param lpToken The LP token contract address for price retrieval.\n   */\n  function _price(address lpToken) internal view returns (uint256) {\n    address pool = poolOf[lpToken];\n    require(pool != address(0), \"LP token is not registered.\");\n    address[] memory tokens = underlyingTokens[lpToken];\n    uint256 minPx = type(uint256).max;\n    uint256 n = tokens.length;\n\n    for (uint256 i = 0; i < n; i++) {\n      address ulToken = tokens[i];\n      uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n\n    require(minPx != type(uint256).max, \"No minimum underlying token price found.\");\n    return (minPx * ISwap(pool).getVirtualPrice()) / 1e18; // Use min underlying token prices\n  }\n\n  /**\n   * @dev Register the pool given LP token address and set the pool info.\n   * @param _lpToken LP token to find the corresponding pool.\n   * @param _pool Pool address.\n   * @param _underlyings Underlying addresses.\n   */\n  function registerPool(\n    address _lpToken,\n    address _pool,\n    address[] memory _underlyings\n  ) external onlyOwner {\n    // require(pool == address(0), \"This LP token is already registered.\");\n    poolOf[_lpToken] = _pool;\n    underlyingTokens[_lpToken] = _underlyings;\n  }\n\n  /**\n   * @dev getter for the underlying tokens\n   * @param lpToken the LP token address.\n   * @return _underlyings Underlying addresses.\n   */\n  function getUnderlyingTokens(address lpToken) public view returns (address[] memory) {\n    return underlyingTokens[lpToken];\n  }\n}\n"
    },
    "contracts/oracles/default/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../BasePriceOracle.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\ncontract SimplePriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\n  mapping(address => uint256) prices;\n  event PricePosted(\n    address asset,\n    uint256 previousPriceMantissa,\n    uint256 requestedPriceMantissa,\n    uint256 newPriceMantissa\n  );\n\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\n      return 1e18;\n    } else {\n      address underlying = ICErc20(address(cToken)).underlying();\n      uint256 oraclePrice = prices[underlying];\n\n      uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n      return\n        underlyingDecimals <= 18\n          ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n          : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n    }\n  }\n\n  function setUnderlyingPrice(ICErc20 cToken, uint256 underlyingPriceMantissa) public onlyOwner {\n    address asset = ICErc20(address(cToken)).underlying();\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n    prices[asset] = underlyingPriceMantissa;\n  }\n\n  function setDirectPrice(address asset, uint256 _price) public onlyOwner {\n    emit PricePosted(asset, prices[asset], _price, _price);\n    prices[asset] = _price;\n  }\n\n  function price(address underlying) external view returns (uint256) {\n    return prices[address(underlying)];\n  }\n\n  // v1 price oracle interface for use as backing of proxy\n  function assetPrices(address asset) external view returns (uint256) {\n    return prices[asset];\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/oracles/default/SolidlyLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IPair } from \"../../external/solidly/IPair.sol\";\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\nimport { UniswapLikeLpTokenPriceOracle } from \"./UniswapLikeLpTokenPriceOracle.sol\";\n\n/**\n * @title SolidlyLpTokenPriceOracle\n * @author Carlo Mazzaferro, David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice SolidlyLpTokenPriceOracle is a price oracle for Solidly LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract SolidlyLpTokenPriceOracle is UniswapLikeLpTokenPriceOracle {\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  constructor(address _wtoken) UniswapLikeLpTokenPriceOracle(_wtoken) {}\n\n  // Same implementation as UniswapLpTokenPriceOracle\n  function _priceVolatile(address token) internal view virtual returns (uint256) {\n    IPair pair = IPair(token);\n    uint256 t_s = pair.totalSupply();\n    if (t_s == 0) return 0;\n    (uint256 r0, uint256 r1, ) = pair.getReserves();\n\n    r0 = r0 * 10**(18 - uint256(ERC20Upgradeable(pair.token0()).decimals()));\n    r1 = r1 * 10**(18 - uint256(ERC20Upgradeable(pair.token1()).decimals()));\n\n    address x = pair.token0();\n    address y = pair.token1();\n\n    // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n    uint256 P_x = x == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(x);\n    uint256 P_y = y == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(y);\n\n    // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\n    uint256 sqrtK = (sqrt(r0 * r1) * (2**112)) / t_s;\n    return (((sqrtK * 2 * sqrt(P_x)) / (2**56)) * sqrt(P_y)) / (2**56);\n  }\n\n  // Derivation: [...]\n  function _priceStable(address token) internal view virtual returns (uint256) {\n    IPair pair = IPair(token);\n    uint256 t_s = pair.totalSupply();\n\n    if (t_s == 0) return 0;\n    (uint256 r0, uint256 r1, ) = pair.getReserves();\n\n    r0 = r0 * 10**(18 - uint256(ERC20Upgradeable(pair.token0()).decimals()));\n    r1 = r1 * 10**(18 - uint256(ERC20Upgradeable(pair.token1()).decimals()));\n\n    // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n    uint256 P_x = pair.token0() == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(pair.token0());\n    uint256 P_y = pair.token1() == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(pair.token1());\n\n    uint256 sqrt4K = _sqrt4k(r0, r1, t_s);\n\n    uint256 denomFirstTerm = (P_x**2) * P_y + P_y**3;\n    uint256 denomSecondTerm = (P_y**2) * P_x + P_x**3;\n\n    // scale numerator up by sqrt(sqrt(10**16)) = 10**4 to avoid rounding errors\n    uint256 firstTerm = (P_x * sqrt(sqrt((10**16 * P_x**3) / denomFirstTerm))) / 10**4;\n    uint256 secondTerm = (P_y * sqrt(sqrt((10**16 * P_y**3) / denomSecondTerm))) / 10**4;\n\n    return (sqrt4K * (firstTerm + secondTerm)) / 1e18;\n  }\n\n  function _sqrt4k(\n    uint256 r0,\n    uint256 r1,\n    uint256 t_s\n  ) public pure returns (uint256) {\n    // sqrt4K = sqrt(sqrt((r0**3) * r1 + (r0**3) * r1)) / t_s;\n    uint256 r03r1 = ((((r0**2 / 10**18) * r0) / 10**18) * r1);\n    uint256 r13r0 = ((((r1**2 / 10**18) * r1) / 10**18) * r0);\n    uint256 sqrtK = 10**18 * sqrt(r03r1 + r13r0);\n    return (sqrt(sqrtK) * 1e18) / t_s;\n  }\n\n  function _price(address token) internal view virtual override returns (uint256) {\n    IPair pair = IPair(token);\n\n    if (pair.stable()) {\n      return _priceStable(token);\n    } else {\n      return _priceVolatile(token);\n    }\n  }\n}\n"
    },
    "contracts/oracles/default/SolidlyPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\nimport { IPair } from \"../../external/solidly/IPair.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title SolidlyOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice SolidlyOracle is a price oracle for Solidly-style pairs.\n * @dev Implements the `BasePriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract SolidlyPriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\n  /**\n   * @notice Maps ERC20 token addresses to UniswapV3Pool addresses.\n   */\n  mapping(address => AssetConfig) public poolFeeds;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool public canAdminOverwrite;\n\n  struct AssetConfig {\n    address poolAddress;\n    address baseToken;\n  }\n\n  address public WTOKEN;\n  address[] public SUPPORTED_BASE_TOKENS;\n\n  function initialize(address _wtoken, address[] memory _supportedBaseTokens) public initializer {\n    __SafeOwnable_init(msg.sender);\n    WTOKEN = _wtoken;\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param assetConfig The asset configuration which includes pool address and twap window.\n   */\n  function setPoolFeeds(address[] memory underlyings, AssetConfig[] memory assetConfig) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == assetConfig.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/config\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set asset config for underlying\n      require(\n        assetConfig[i].baseToken == WTOKEN || _isBaseTokenSupported(assetConfig[i].baseToken),\n        \"Underlying token must be supported\"\n      );\n      poolFeeds[underlying] = assetConfig[i];\n    }\n  }\n\n  /**\n   * @notice Get the token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for WTOKEN)\n   * @return Price denominated in NATIVE (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in NATIVE of the token underlying `cToken`.\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the price for a token from Solidly Pair\n   */\n  function _price(address token) internal view virtual returns (uint256) {\n    address baseToken = poolFeeds[token].baseToken;\n    IPair pair = IPair(poolFeeds[token].poolAddress);\n\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n\n    address quoteToken;\n\n    baseToken == token0 ? quoteToken = token1 : quoteToken = token0;\n\n    // get how many baseTokens (WNATIVE or STABLE) are needed to get us 1 quote token\n    // i.e: the ration X/WNATIVE or X/STABLE\n    uint256 baseTokensPerQuoteToken = pair.current(quoteToken, 10**uint256(ERC20Upgradeable(quoteToken).decimals()));\n    if (baseToken == WTOKEN) {\n      // No need to scale either, because WNATIVE is always 1e18\n      return baseTokensPerQuoteToken;\n    } else {\n      // base token is USD or another token\n      uint256 baseTokenNativePrice = BasePriceOracle(msg.sender).price(baseToken);\n      // scale tokenPrice by 1e18\n      uint256 baseTokenDecimals = uint256(ERC20Upgradeable(baseToken).decimals());\n      uint256 tokenPriceScaled;\n\n      if (baseTokenDecimals > 18) {\n        tokenPriceScaled = baseTokensPerQuoteToken / (10**(baseTokenDecimals - 18));\n      } else {\n        tokenPriceScaled = baseTokensPerQuoteToken * (10**(18 - baseTokenDecimals));\n      }\n\n      return (tokenPriceScaled * baseTokenNativePrice) / 1e18;\n    }\n  }\n\n  function _isBaseTokenSupported(address token) internal view returns (bool) {\n    for (uint256 i = 0; i < SUPPORTED_BASE_TOKENS.length; i++) {\n      if (SUPPORTED_BASE_TOKENS[i] == token) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _setSupportedBaseTokens(address[] memory _supportedBaseTokens) external onlyOwner {\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\n  }\n\n  function getSupportedBaseTokens() external view returns (address[] memory) {\n    return SUPPORTED_BASE_TOKENS;\n  }\n}\n"
    },
    "contracts/oracles/default/StkBNBPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IStakePool, ExchangeRateData } from \"../../external/pstake/IStakePool.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\n\ncontract StkBNBPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  IStakePool public stakingPool;\n  address public stkBnb;\n\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n    stakingPool = IStakePool(0xC228CefDF841dEfDbD5B3a18dFD414cC0dbfa0D8);\n    stkBnb = 0xc2E9d07F66A89c44062459A47a0D2Dc038E4fb16;\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n    require(underlying == stkBnb, \"Invalid underlying\");\n    // no need to scale as stkBNB has 18 decimals\n    return _price();\n  }\n\n  function price(address underlying) external view override returns (uint256) {\n    require(underlying == stkBnb, \"Invalid underlying\");\n    return _price();\n  }\n\n  function _price() internal view returns (uint256) {\n    // 1 stkBNB  = (totalWei / poolTokenSupply) BNB\n    ExchangeRateData memory exchangeRate = stakingPool.exchangeRate();\n    uint256 stkBNBPrice = (exchangeRate.totalWei * 1e18) / exchangeRate.poolTokenSupply;\n    return stkBNBPrice;\n  }\n}\n"
    },
    "contracts/oracles/default/SushiBarPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/sushi/SushiBar.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title SushiBarPriceOracle\n * @notice Returns prices for SushiBar (xSUSHI).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarPriceOracle is BasePriceOracle {\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    SushiBar sushiBar = SushiBar(token);\n    IERC20Upgradeable sushi = sushiBar.sushi();\n    uint256 sushiEthPrice = BasePriceOracle(msg.sender).price(address(sushi));\n    return (sushi.balanceOf(token) * sushiEthPrice) / sushiBar.totalSupply();\n  }\n}\n"
    },
    "contracts/oracles/default/UmbrellaPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IUmbrellaFeeds } from \"../../external/umbrella/IUmbrellaFeeds.sol\";\nimport { IRegistry } from \"../../external/umbrella/IRegistry.sol\";\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\n\n/**\n * @title UmbrellaPriceOracle\n * @notice Returns prices from Umbrella Network.\n * @dev Implements `PriceOracle`.\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n */\ncontract UmbrellaPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  /**\n   * @notice Maps ERC20 token addresses to ETH-based Flux price feed contracts.\n   */\n  mapping(address => string) public priceFeeds;\n\n  /**\n   * @notice Umbrella's NATIVE/USD price feed contracts.\n   */\n  string public NATIVE_TOKEN_USD_KEY;\n\n  /**\n   * @notice IUmbrellaFeeds address\n   */\n\n  IUmbrellaFeeds public UMBRELLA_FEEDS_ADDRESS;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  function initialize(string memory nativeTokenUsd, IRegistry registry) public initializer {\n    __SafeOwnable_init(msg.sender);\n    NATIVE_TOKEN_USD_KEY = nativeTokenUsd;\n    address umbrellaFeeds = registry.getAddressByString(\"UmbrellaFeeds\");\n    require(umbrellaFeeds != address(0), \"UmbrellaFeeds address not found\");\n    UMBRELLA_FEEDS_ADDRESS = IUmbrellaFeeds(umbrellaFeeds);\n  }\n\n  function reinitialize(string memory nativeTokenUsd, IRegistry registry) public onlyOwnerOrAdmin {\n    NATIVE_TOKEN_USD_KEY = nativeTokenUsd;\n    address umbrellaFeeds = registry.getAddressByString(\"UmbrellaFeeds\");\n    require(umbrellaFeeds != address(0), \"UmbrellaFeeds address not found\");\n    UMBRELLA_FEEDS_ADDRESS = IUmbrellaFeeds(umbrellaFeeds);\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feeds The Oracle price feed contract addresses for each of `underlyings`.\n   */\n  function setPriceFeeds(address[] memory underlyings, string[] memory feeds) external onlyOwner {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feeds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      // Set feed and base currency\n      priceFeeds[underlying] = feeds[i];\n    }\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   * Assumes price feeds are 8 decimals!\n   * https://docs.fluxprotocol.org/docs/live-data-feeds/fpo-live-networks-and-pairs#mainnet-2\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Get token/ETH price from feed\n    string memory feed = priceFeeds[underlying];\n    require(bytes(feed).length != 0, \"No Umbrella price feed found for this underlying ERC20 token.\");\n\n    // Get the NATIVE/USD price feed from Native Price Feed\n    // 8 decimals are used\n    IUmbrellaFeeds.PriceData memory nativeTokenUsdPriceData = UMBRELLA_FEEDS_ADDRESS.getPriceDataByName(\n      NATIVE_TOKEN_USD_KEY\n    );\n    uint256 nativeTokenUsdPrice = uint256(nativeTokenUsdPriceData.price);\n\n    if (nativeTokenUsdPriceData.price == 0) return 0;\n    // 8 decimals are used\n    IUmbrellaFeeds.PriceData memory priceData = UMBRELLA_FEEDS_ADDRESS.getPriceDataByName(feed);\n    // Umbrella price feed is 8 decimals:\n    return (uint256(priceData.price) * 1e18) / uint256(nativeTokenUsdPrice);\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = cToken.underlying();\n\n    // Get price\n    uint256 oraclePrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - underlyingDecimals))\n        : uint256(oraclePrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapLikeLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title UniswapLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\nabstract contract UniswapLikeLpTokenPriceOracle is BasePriceOracle {\n  /**\n   * @dev wtoken contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  constructor(address _wtoken) {\n    wtoken = _wtoken;\n  }\n\n  function _price(address token) internal view virtual returns (uint256);\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fast square root function.\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n   */\n  function sqrt(uint256 x) internal pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport { UniswapLikeLpTokenPriceOracle } from \"./UniswapLikeLpTokenPriceOracle.sol\";\n\n/**\n * @title UniswapLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract UniswapLpTokenPriceOracle is UniswapLikeLpTokenPriceOracle {\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  constructor(address _wtoken) UniswapLikeLpTokenPriceOracle(_wtoken) {}\n\n  function _price(address token) internal view virtual override returns (uint256) {\n    IUniswapV2Pair pair = IUniswapV2Pair(token);\n    uint256 totalSupply = pair.totalSupply();\n    if (totalSupply == 0) return 0;\n    (uint256 r0, uint256 r1, ) = pair.getReserves();\n\n    r0 = r0 * 10**(18 - uint256(ERC20Upgradeable(pair.token0()).decimals()));\n    r1 = r1 * 10**(18 - uint256(ERC20Upgradeable(pair.token1()).decimals()));\n\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n\n    // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n    uint256 token0FairPrice = token0 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token0);\n    uint256 token1FairPrice = token1 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token1);\n\n    // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\n    uint256 sqrtK = (sqrt(r0 * r1) * (2**112)) / totalSupply;\n    return (((sqrtK * 2 * sqrt(token0FairPrice)) / (2**56)) * sqrt(token1FairPrice)) / (2**56);\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"./UniswapTwapPriceOracleV2Root.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2 is Initializable, BasePriceOracle {\n  /**\n   * @dev wtoken token contract address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev UniswapTwapPriceOracleV2Root contract address.\n   */\n  UniswapTwapPriceOracleV2Root public rootOracle;\n\n  /**\n   * @dev UniswapV2Factory contract address.\n   */\n  address public uniswapV2Factory;\n\n  /**\n   * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\n   */\n  address public baseToken;\n\n  /**\n   * @dev Initalize that sets the UniswapTwapPriceOracleV2Root, UniswapV2Factory, and base token.\n   * @param _rootOracle Sets `UniswapTwapPriceOracleV2Root`\n   * @param _uniswapV2Factory Sets `UniswapV2Factory`\n   * @param _baseToken The token on which to base TWAPs (its price must be available via `msg.sender`).\n   * @param _wtoken The Wrapped native asset address\n   */\n  function initialize(\n    address _rootOracle,\n    address _uniswapV2Factory,\n    address _baseToken,\n    address _wtoken\n  ) external initializer {\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n    require(_uniswapV2Factory != address(0), \"UniswapV2Factory not defined.\");\n    rootOracle = UniswapTwapPriceOracleV2Root(_rootOracle);\n    uniswapV2Factory = _uniswapV2Factory;\n    wtoken = _wtoken;\n    baseToken = _baseToken == address(0) ? address(wtoken) : _baseToken;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying ERC20 token address\n    address underlying = cToken.underlying();\n\n    // Get price, format, and return\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (_price(underlying) * 1e18) / baseUnit;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Return root oracle ERC20/ETH TWAP\n    uint256 twap = rootOracle.price(underlying, baseToken, uniswapV2Factory);\n    return\n      baseToken == address(wtoken)\n        ? twap\n        : (twap * BasePriceOracle(msg.sender).price(baseToken)) / (10**uint256(ERC20Upgradeable(baseToken).decimals()));\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol\";\n\nimport \"./UniswapTwapPriceOracleV2.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Factory\n * @notice Deploys and catalogs UniswapTwapPriceOracleV2 contracts.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Factory {\n  /**\n   * @dev WETH token contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev `UniswapTwapPriceOracleV2Root` contract address.\n   */\n  address public immutable rootOracle;\n\n  /**\n   * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\n   */\n  address public immutable logic;\n\n  /**\n   * @notice Maps `UniswapV2Factory` contracts to base tokens to `UniswapTwapPriceOracleV2` contract addresses.\n   */\n  mapping(address => mapping(address => UniswapTwapPriceOracleV2)) public oracles;\n\n  /**\n   * @dev Constructor that sets the `UniswapTwapPriceOracleV2Root` and `UniswapTwapPriceOracleV2` implementation contract.\n   */\n  constructor(\n    address _rootOracle,\n    address _logic,\n    address _wtoken\n  ) {\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n    require(_logic != address(0), \"UniswapTwapPriceOracleV2 implementation/logic contract not defined.\");\n    rootOracle = _rootOracle;\n    logic = _logic;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @notice Deploys a `UniswapTwapPriceOracleV2`.\n   * @param uniswapV2Factory The `UniswapV2Factory` contract of the pairs for which this oracle will be used.\n   * @param baseToken The base token of the pairs for which this oracle will be used.\n   */\n  function deploy(address uniswapV2Factory, address baseToken) external returns (address) {\n    // Input validation\n    if (baseToken == address(0)) baseToken = address(wtoken);\n\n    // Return existing oracle if present\n    address currentOracle = address(oracles[uniswapV2Factory][baseToken]);\n    if (currentOracle != address(0)) return currentOracle;\n\n    // Deploy oracle\n    bytes32 salt = keccak256(abi.encodePacked(uniswapV2Factory, baseToken));\n    address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\n    UniswapTwapPriceOracleV2(oracle).initialize(rootOracle, uniswapV2Factory, baseToken, wtoken);\n\n    // Set oracle in state\n    oracles[uniswapV2Factory][baseToken] = UniswapTwapPriceOracleV2(oracle);\n\n    // Return oracle address\n    return oracle;\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Resolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IResolver } from \"ops/interfaces/IResolver.sol\";\nimport { UniswapTwapPriceOracleV2Root } from \"./UniswapTwapPriceOracleV2Root.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract UniswapTwapPriceOracleV2Resolver is IResolver, Ownable {\n  struct PairConfig {\n    address pair;\n    address baseToken;\n    uint256 minPeriod;\n    uint256 deviationThreshold;\n  }\n\n  // need to store as arrays for the UniswapTwapPriceOracleV2Root workable functions\n  address[] pairs;\n  address[] baseTokens;\n  uint256[] minPeriods;\n  uint256[] deviationThresholds;\n\n  UniswapTwapPriceOracleV2Root public root;\n  uint256 public lastUpdate;\n\n  constructor(PairConfig[] memory _pairConfigs, UniswapTwapPriceOracleV2Root _root) {\n    for (uint256 i = 0; i < _pairConfigs.length; i++) {\n      pairs[i] = _pairConfigs[i].pair;\n      baseTokens[i] = _pairConfigs[i].baseToken;\n      minPeriods[i] = _pairConfigs[i].minPeriod;\n      deviationThresholds[i] = _pairConfigs[i].deviationThreshold;\n    }\n    root = _root;\n  }\n\n  function getPairs() external view returns (PairConfig[] memory) {\n    PairConfig[] memory pairConfigs = new PairConfig[](pairs.length);\n    for (uint256 i = 0; i < pairs.length; i++) {\n      PairConfig memory pairConfig = PairConfig({\n        pair: pairs[i],\n        baseToken: baseTokens[i],\n        minPeriod: minPeriods[i],\n        deviationThreshold: deviationThresholds[i]\n      });\n      pairConfigs[i] = pairConfig;\n    }\n    return pairConfigs;\n  }\n\n  function changeRoot(UniswapTwapPriceOracleV2Root _root) external onlyOwner {\n    root = _root;\n  }\n\n  function removeFromPairs(uint256 index) external onlyOwner {\n    if (index >= pairs.length) return;\n\n    for (uint256 i = index; i < pairs.length - 1; i++) {\n      pairs[i] = pairs[i + 1];\n      baseTokens[i] = baseTokens[i + 1];\n      minPeriods[i] = minPeriods[i + 1];\n      deviationThresholds[i] = deviationThresholds[i + 1];\n    }\n    pairs.pop();\n    baseTokens.pop();\n    minPeriods.pop();\n    deviationThresholds.pop();\n  }\n\n  function addPair(PairConfig calldata pair) external onlyOwner {\n    pairs.push(pair.pair);\n    baseTokens.push(pair.baseToken);\n    minPeriods.push(pair.minPeriod);\n    deviationThresholds.push(pair.deviationThreshold);\n  }\n\n  function getWorkablePairs() public view returns (address[] memory) {\n    bool[] memory workable = root.workable(pairs, baseTokens, minPeriods, deviationThresholds);\n    uint256 workableCount = 0;\n    for (uint256 i = 0; i < workable.length; i += 1) {\n      if (workable[i]) {\n        workableCount += 1;\n      }\n    }\n\n    address[] memory workablePairs = new address[](workableCount);\n    uint256 j = 0;\n\n    for (uint256 i = 0; i < workable.length; i++) {\n      if (workable[i]) {\n        workablePairs[j++] = pairs[i];\n      }\n    }\n    return workablePairs;\n  }\n\n  function updatePairs(address[] calldata workablePairs) external {\n    if (workablePairs.length == 0) return;\n    root.update(workablePairs);\n  }\n\n  function checker() external view override returns (bool canExec, bytes memory execPayload) {\n    address[] memory workablePairs = getWorkablePairs();\n    if (workablePairs.length == 0) {\n      return (false, bytes(\"No workable pairs\"));\n    }\n\n    canExec = true;\n    execPayload = abi.encodeWithSelector(this.updatePairs.selector, workablePairs);\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Root.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Root\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Root {\n  /**\n   * @dev wtoken token contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev Minimum TWAP interval.\n   */\n  uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n  /**\n   * @dev Constructor to set wtoken address\n   */\n  constructor(address _wtoken) {\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price0.\n   */\n  function price0TWAP(address pair) internal view returns (uint256) {\n    uint256 length = observationCount[pair];\n    require(length > 0, \"No length-1 TWAP observation.\");\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"No length-2 TWAP observation.\");\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n    }\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n    uint256 currPx0Cumu = currentPx0Cumu(pair);\n    unchecked {\n      return (currPx0Cumu - lastObservation.price0Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price1.\n   */\n  function price1TWAP(address pair) internal view returns (uint256) {\n    uint256 length = observationCount[pair];\n    require(length > 0, \"No length-1 TWAP observation.\");\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"No length-2 TWAP observation.\");\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n    }\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n    uint256 currPx1Cumu = currentPx1Cumu(pair);\n    unchecked {\n      return (currPx1Cumu - lastObservation.price1Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Return the current price0 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price0 cumulative value.\n   */\n  function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != block.timestamp) {\n      unchecked {\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\n        px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n      }\n    }\n  }\n\n  /**\n   * @dev Return the current price1 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price1 cumulative value.\n   */\n  function currentPx1Cumu(address pair) internal view returns (uint256 px1Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      unchecked {\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\n        px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n      }\n    }\n  }\n\n  /**\n   * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\n   */\n  function price(\n    address underlying,\n    address baseToken,\n    address factory\n  ) external view returns (uint256) {\n    // Return ERC20/ETH TWAP\n    address pair = IUniswapV2Factory(factory).getPair(underlying, baseToken);\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (((underlying < baseToken ? price0TWAP(pair) : price1TWAP(pair)) / (2**56)) * baseUnit) / (2**56); // Scaled by 1e18, not 2 ** 112\n  }\n\n  /**\n   * @dev Struct for cumulative price observations.\n   */\n  struct Observation {\n    uint32 timestamp;\n    uint256 price0Cumulative;\n    uint256 price1Cumulative;\n  }\n\n  /**\n   * @dev Length after which observations roll over to index 0.\n   */\n  uint8 public constant OBSERVATION_BUFFER = 4;\n\n  /**\n   * @dev Total observation count for each pair.\n   */\n  mapping(address => uint256) public observationCount;\n\n  /**\n   * @dev Array of cumulative price observations for each pair.\n   */\n  mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\n\n  /// @notice Get pairs for token combinations.\n  function pairsFor(\n    address[] calldata tokenA,\n    address[] calldata tokenB,\n    address factory\n  ) external view returns (address[] memory) {\n    require(\n      tokenA.length > 0 && tokenA.length == tokenB.length,\n      \"Token array lengths must be equal and greater than 0.\"\n    );\n    address[] memory pairs = new address[](tokenA.length);\n    for (uint256 i = 0; i < tokenA.length; i++) pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\n    return pairs;\n  }\n\n  /// @notice Check which of multiple pairs are workable/updatable.\n  function workable(\n    address[] calldata pairs,\n    address[] calldata baseTokens,\n    uint256[] calldata minPeriods,\n    uint256[] calldata deviationThresholds\n  ) external view returns (bool[] memory) {\n    require(\n      pairs.length > 0 &&\n        pairs.length == baseTokens.length &&\n        pairs.length == minPeriods.length &&\n        pairs.length == deviationThresholds.length,\n      \"Array lengths must be equal and greater than 0.\"\n    );\n    bool[] memory answers = new bool[](pairs.length);\n    for (uint256 i = 0; i < pairs.length; i++)\n      answers[i] = _workable(pairs[i], baseTokens[i], minPeriods[i], deviationThresholds[i]);\n    return answers;\n  }\n\n  /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\n  function _workable(\n    address pair,\n    address baseToken,\n    uint256 minPeriod,\n    uint256 deviationThreshold\n  ) internal view returns (bool) {\n    // Workable if:\n    // 1) We have no observations\n    // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    if (observationCount[pair] <= 0) return true;\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    return\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\n      (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\n      lastTime != observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp &&\n      _deviation(pair, baseToken) >= deviationThreshold;\n  }\n\n  /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\n  function _deviation(address pair, address baseToken) internal view returns (uint256) {\n    // Get token base unit\n    address token0 = IUniswapV2Pair(pair).token0();\n    bool useToken0Price = token0 != baseToken;\n    address underlying = useToken0Price ? token0 : IUniswapV2Pair(pair).token1();\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n\n    // Get TWAP price\n    uint256 twapPrice = (((useToken0Price ? price0TWAP(pair) : price1TWAP(pair)) / (2**56)) * baseUnit) / (2**56); // Scaled by 1e18, not 2 ** 112\n\n    // Get spot price\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\n    uint256 spotPrice = useToken0Price ? (reserve1 * baseUnit) / reserve0 : (reserve0 * baseUnit) / reserve1;\n\n    // Get ratio and return deviation\n    uint256 ratio = (spotPrice * 1e18) / twapPrice;\n    return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\n  }\n\n  /// @dev Internal function to check if a pair is updatable at all.\n  function _updateable(address pair) internal view returns (bool) {\n    // Updateable if:\n    // 1) We have no observations\n    // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    return\n      observationCount[pair] <= 0 ||\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\n      MIN_TWAP_TIME;\n  }\n\n  /// @notice Update one pair.\n  function update(address pair) external {\n    require(_update(pair), \"Failed to update pair.\");\n  }\n\n  /// @notice Update multiple pairs at once.\n  function update(address[] calldata pairs) external {\n    bool worked = false;\n    for (uint256 i = 0; i < pairs.length; i++) if (_update(pairs[i])) worked = true;\n    require(worked, \"No pairs can be updated (yet).\");\n  }\n\n  /// @dev Internal function to update a single pair.\n  function _update(address pair) internal returns (bool) {\n    // Check if workable\n    if (!_updateable(pair)) return false;\n\n    // Get cumulative price(s)\n    uint256 price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    uint256 price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    observations[pair][observationCount[pair] % OBSERVATION_BUFFER] = Observation(\n      lastTime,\n      price0Cumulative,\n      price1Cumulative\n    );\n    observationCount[pair]++;\n    return true;\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapV3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"./ConcentratedLiquidityBasePriceOracle.sol\";\n\nimport \"../../external/uniswap/TickMath.sol\";\nimport \"../../external/uniswap/FullMath.sol\";\nimport \"../../external/uniswap/IUniswapV3Pool.sol\";\n\n/**\n * @title UniswapV3PriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice UniswapV3PriceOracle is a price oracle for Uniswap V3 pairs.\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\n */\ncontract UniswapV3PriceOracle is ConcentratedLiquidityBasePriceOracle {\n  /**\n   * @dev Fetches the price for a token from Algebra pools.\n   */\n\n  function _price(address token) internal view override returns (uint256) {\n    uint32[] memory secondsAgos = new uint32[](2);\n    uint256 twapWindow = poolFeeds[token].twapWindow;\n    address baseToken = poolFeeds[token].baseToken;\n\n    secondsAgos[0] = uint32(twapWindow);\n    secondsAgos[1] = 0;\n\n    IUniswapV3Pool pool = IUniswapV3Pool(poolFeeds[token].poolAddress);\n    (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);\n\n    int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(int256(twapWindow)));\n    uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\n\n    uint256 tokenPrice = getPriceX96FromSqrtPriceX96(pool.token0(), token, sqrtPriceX96);\n    return scalePrices(baseToken, token, tokenPrice);\n  }\n}\n"
    },
    "contracts/oracles/default/VelodromePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../BasePriceOracle.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface Prices {\n  function getRateToEth(address srcToken, bool useSrcWrappers) external view returns (uint256 weightedRate);\n}\n\ncontract VelodromePriceOracle is BasePriceOracle {\n  Prices immutable prices;\n\n  constructor(address _prices) {\n    prices = Prices(_prices);\n  }\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    return prices.getRateToEth(token, false);\n  }\n}\n"
    },
    "contracts/oracles/default/WombatLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\ninterface IWombatLpAsset {\n  function cash() external view returns (uint256);\n\n  function underlyingTokenBalance() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function underlyingToken() external view returns (address);\n\n  function pool() external view returns (address);\n\n  function liability() external view returns (uint256);\n}\n\ncontract WombatLpTokenPriceOracle is BasePriceOracle {\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address asset = cToken.underlying();\n\n    uint256 oraclePrice = _price(asset);\n\n    uint256 assetDecimals = uint256(ERC20Upgradeable(asset).decimals());\n\n    return\n      assetDecimals <= 18\n        ? uint256(oraclePrice) * (10**(18 - assetDecimals))\n        : uint256(oraclePrice) / (10**(assetDecimals - 18));\n  }\n\n  function _price(address asset) internal view returns (uint256) {\n    // total supply of vault token\n    uint256 assetTotalSupply = IWombatLpAsset(asset).totalSupply();\n\n    if (assetTotalSupply == 0) return 0;\n\n    address underlying = IWombatLpAsset(asset).underlyingToken();\n\n    // balance of underlying asset that vault contains\n    uint256 underlyingLiability = IWombatLpAsset(asset).liability();\n\n    uint256 underlyingPrice = BasePriceOracle(msg.sender).price(underlying);\n\n    return (underlyingPrice * underlyingLiability) / assetTotalSupply;\n  }\n\n  function price(address asset) external view override returns (uint256) {\n    return _price(asset);\n  }\n}\n"
    },
    "contracts/oracles/default/WSTEthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IWstETH } from \"../../external/lido/IWstETH.sol\";\n\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title WSTEthPriceOracle\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\n * @notice WSTEthPriceOracle is a price oracle for wstETH.\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\n */\ncontract WSTEthPriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    address underlying = cToken.underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    // (stETH / ETH) * (wstETH / stETH) = token / ETH\n    // From https://github.com/lidofinance/wsteth-eth-price-feed/blob/main/contracts/AAVECompatWstETHToETHPriceFeed.sol\n    return (BasePriceOracle(msg.sender).price(IWstETH(token).stETH()) * IWstETH(token).stEthPerToken()) / 1e18;\n  }\n}\n"
    },
    "contracts/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\n\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\nimport { BasePriceOracle } from \"./BasePriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, BasePriceOracle {\n  /**\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n   */\n  mapping(address => BasePriceOracle) public oracles;\n\n  /**\n   * @dev Default/fallback `PriceOracle`.\n   */\n  BasePriceOracle public defaultOracle;\n\n  /**\n   * @dev The administrator of this `MasterPriceOracle`.\n   */\n  address public admin;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool internal noAdminOverwrite;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n   */\n  mapping(address => BasePriceOracle) public fallbackOracles;\n\n  /**\n   * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  function canAdminOverwrite() external view returns (bool) {\n    return !noAdminOverwrite;\n  }\n\n  /**\n   * @dev Event emitted when `admin` is changed.\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @dev Event emitted when the default oracle is changed.\n   */\n  event NewDefaultOracle(address oldOracle, address newOracle);\n\n  /**\n   * @dev Event emitted when an underlying token's oracle is changed.\n   */\n  event NewOracle(address underlying, address oldOracle, address newOracle);\n\n  /**\n   * @dev  Initialize state variables.\n   * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n   * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n   * @param _defaultOracle The default `PriceOracle` contract to use.\n   * @param _admin The admin who can assign oracles to underlying tokens.\n   * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   * @param _wtoken The Wrapped native asset address\n   */\n  function initialize(\n    address[] memory underlyings,\n    BasePriceOracle[] memory _oracles,\n    BasePriceOracle _defaultOracle,\n    address _admin,\n    bool _canAdminOverwrite,\n    address _wtoken\n  ) external initializer {\n    // Input validation\n    require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\n\n    // Initialize state variables\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      BasePriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, address(0), address(newOracle));\n    }\n\n    defaultOracle = _defaultOracle;\n    admin = _admin;\n    noAdminOverwrite = !_canAdminOverwrite;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @dev Sets `_oracles` for `underlyings`.\n   */\n  function add(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == _oracles.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // Assign oracles to underlying tokens\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      address oldOracle = address(oracles[underlying]);\n      if (noAdminOverwrite)\n        require(\n          oldOracle == address(0),\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n        );\n      BasePriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, oldOracle, address(newOracle));\n    }\n  }\n\n  /**\n   * @dev Sets `_oracles` for `underlyings`.\n   */\n  function addFallbacks(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == _oracles.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // Assign oracles to underlying tokens\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      address oldOracle = address(fallbackOracles[underlying]);\n      if (noAdminOverwrite)\n        require(\n          oldOracle == address(0),\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n        );\n      BasePriceOracle newOracle = _oracles[i];\n      fallbackOracles[underlying] = newOracle;\n      emit NewOracle(underlying, oldOracle, address(newOracle));\n    }\n  }\n\n  /**\n   * @dev Changes the default price oracle\n   */\n  function setDefaultOracle(BasePriceOracle newOracle) external onlyAdmin {\n    BasePriceOracle oldOracle = defaultOracle;\n    defaultOracle = newOracle;\n    emit NewDefaultOracle(address(oldOracle), address(newOracle));\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  /**\n   * @dev Modifier that checks if `msg.sender == admin`.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Sender is not the admin.\");\n    _;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\n    // Get underlying ERC20 token address\n    address underlying = address(ICErc20(address(cToken)).underlying());\n\n    if (underlying == wtoken) return 1e18;\n\n    BasePriceOracle oracle = oracles[underlying];\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\n\n    if (address(oracle) != address(0)) {\n      try oracle.getUnderlyingPrice(cToken) returns (uint256 underlyingPrice) {\n        if (underlyingPrice == 0) {\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n        } else {\n          return underlyingPrice;\n        }\n      } catch {\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n      }\n    } else {\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\n    }\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n\n  /**\n   * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) public view override returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == wtoken) return 1e18;\n\n    // Get underlying price from assigned oracle\n    BasePriceOracle oracle = oracles[underlying];\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\n\n    if (address(oracle) != address(0)) {\n      try oracle.price(underlying) returns (uint256 underlyingPrice) {\n        if (underlyingPrice == 0) {\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n        } else {\n          return underlyingPrice;\n        }\n      } catch {\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n      }\n    } else {\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\n    }\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n}\n"
    },
    "contracts/PoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\nimport { Unitroller } from \"./compound/Unitroller.sol\";\nimport \"./ionic/SafeOwnableUpgradeable.sol\";\nimport \"./ionic/DiamondExtension.sol\";\n\n/**\n * @title PoolDirectory\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice PoolDirectory is a directory for Ionic interest rate pools.\n */\ncontract PoolDirectory is SafeOwnableUpgradeable {\n  /**\n   * @dev Initializes a deployer whitelist if desired.\n   * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\n   * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\n   */\n  function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\n    __SafeOwnable_init(msg.sender);\n    enforceDeployerWhitelist = _enforceDeployerWhitelist;\n    for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\n  }\n\n  /**\n   * @dev Struct for a Ionic interest rate pool.\n   */\n  struct Pool {\n    string name;\n    address creator;\n    address comptroller;\n    uint256 blockPosted;\n    uint256 timestampPosted;\n  }\n\n  /**\n   * @dev Array of Ionic interest rate pools.\n   */\n  Pool[] public pools;\n\n  /**\n   * @dev Maps Ethereum accounts to arrays of Ionic pool indexes.\n   */\n  mapping(address => uint256[]) private _poolsByAccount;\n\n  /**\n   * @dev Maps Ionic pool Comptroller addresses to bools indicating if they have been registered via the directory.\n   */\n  mapping(address => bool) public poolExists;\n\n  /**\n   * @dev Emitted when a new Ionic pool is added to the directory.\n   */\n  event PoolRegistered(uint256 index, Pool pool);\n\n  /**\n   * @dev Booleans indicating if the deployer whitelist is enforced.\n   */\n  bool public enforceDeployerWhitelist;\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\n   */\n  mapping(address => bool) public deployerWhitelist;\n\n  /**\n   * @dev Controls if the deployer whitelist is to be enforced.\n   * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\n   */\n  function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\n    enforceDeployerWhitelist = enforce;\n  }\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the deployer whitelist.\n   * @param deployers Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\n    require(deployers.length > 0, \"No deployers supplied.\");\n    for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\n  }\n\n  /**\n   * @dev Adds a new Ionic pool to the directory (without checking msg.sender).\n   * @param name The name of the pool.\n   * @param comptroller The pool's Comptroller proxy contract address.\n   * @return The index of the registered Ionic pool.\n   */\n  function _registerPool(string memory name, address comptroller) internal returns (uint256) {\n    require(!poolExists[comptroller], \"Pool already exists in the directory.\");\n    require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \"Sender is not on deployer whitelist.\");\n    require(bytes(name).length <= 100, \"No pool name supplied.\");\n    Pool memory pool = Pool(name, msg.sender, comptroller, block.number, block.timestamp);\n    pools.push(pool);\n    _poolsByAccount[msg.sender].push(pools.length - 1);\n    poolExists[comptroller] = true;\n    emit PoolRegistered(pools.length - 1, pool);\n    return pools.length - 1;\n  }\n\n  function _deprecatePool(address comptroller) external onlyOwner {\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller == comptroller) {\n        _deprecatePool(i);\n        break;\n      }\n    }\n  }\n\n  function _deprecatePool(uint256 index) public onlyOwner {\n    Pool storage ionicPool = pools[index];\n\n    require(ionicPool.comptroller != address(0), \"pool already deprecated\");\n\n    // swap with the last pool of the creator and delete\n    uint256[] storage creatorPools = _poolsByAccount[ionicPool.creator];\n    for (uint256 i = 0; i < creatorPools.length; i++) {\n      if (creatorPools[i] == index) {\n        creatorPools[i] = creatorPools[creatorPools.length - 1];\n        creatorPools.pop();\n        break;\n      }\n    }\n\n    // leave it to true to deny the re-registering of the same pool\n    poolExists[ionicPool.comptroller] = true;\n\n    // nullify the storage\n    ionicPool.comptroller = address(0);\n    ionicPool.creator = address(0);\n    ionicPool.name = \"\";\n    ionicPool.blockPosted = 0;\n    ionicPool.timestampPosted = 0;\n  }\n\n  /**\n   * @dev Deploys a new Ionic pool and adds to the directory.\n   * @param name The name of the pool.\n   * @param implementation The Comptroller implementation contract address.\n   * @param constructorData Encoded construction data for `Unitroller constructor()`\n   * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n   * @param closeFactor The pool's close factor (scaled by 1e18).\n   * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n   * @param priceOracle The pool's PriceOracle contract address.\n   * @return Index of the registered Ionic pool and the Unitroller proxy address.\n   */\n  function deployPool(\n    string memory name,\n    address implementation,\n    bytes calldata constructorData,\n    bool enforceWhitelist,\n    uint256 closeFactor,\n    uint256 liquidationIncentive,\n    address priceOracle\n  ) external returns (uint256, address) {\n    // Input validation\n    require(implementation != address(0), \"No Comptroller implementation contract address specified.\");\n    require(priceOracle != address(0), \"No PriceOracle contract address specified.\");\n\n    // Deploy Unitroller using msg.sender, name, and block.number as a salt\n    bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode, constructorData);\n    address proxy = Create2Upgradeable.deploy(\n      0,\n      keccak256(abi.encodePacked(msg.sender, name, ++poolsCounter)),\n      unitrollerCreationCode\n    );\n\n    // Setup the pool\n    IonicComptroller comptrollerProxy = IonicComptroller(proxy);\n    // Set up the extensions\n    comptrollerProxy._upgrade();\n\n    // Set pool parameters\n    require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \"Failed to set pool close factor.\");\n    require(\n      comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0,\n      \"Failed to set pool liquidation incentive.\"\n    );\n    require(comptrollerProxy._setPriceOracle(BasePriceOracle(priceOracle)) == 0, \"Failed to set pool price oracle.\");\n\n    // Whitelist\n    if (enforceWhitelist)\n      require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \"Failed to enforce supplier/borrower whitelist.\");\n\n    // Make msg.sender the admin\n    require(comptrollerProxy._setPendingAdmin(msg.sender) == 0, \"Failed to set pending admin on Unitroller.\");\n\n    // Register the pool with this PoolDirectory\n    return (_registerPool(name, proxy), proxy);\n  }\n\n  /**\n   * @notice Returns `ids` and directory information of all non-deprecated Ionic pools.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getActivePools() public view returns (uint256[] memory, Pool[] memory) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) count++;\n    }\n\n    Pool[] memory activePools = new Pool[](count);\n    uint256[] memory poolIds = new uint256[](count);\n\n    uint256 index = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) {\n        poolIds[index] = i;\n        activePools[index] = pools[i];\n        index++;\n      }\n    }\n\n    return (poolIds, activePools);\n  }\n\n  /**\n   * @notice Returns arrays of all Ionic pools' data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getAllPools() public view returns (Pool[] memory) {\n    uint256 count = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) count++;\n    }\n\n    Pool[] memory result = new Pool[](count);\n\n    uint256 index = 0;\n    for (uint256 i = 0; i < pools.length; i++) {\n      if (pools[i].comptroller != address(0)) {\n        result[index++] = pools[i];\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * @notice Returns arrays of all public Ionic pool indexes and data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPools() external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory publicPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n\n  /**\n   * @notice Returns arrays of all public Ionic pool indexes and data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPoolsOfUser(address user) external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\n        if (!isUsing) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory poolsOfUser = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\n        if (!isUsing) continue;\n      } catch {}\n\n      indexes[index] = i;\n      poolsOfUser[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, poolsOfUser);\n  }\n\n  /**\n   * @notice Returns arrays of Ionic pool indexes and data created by `account`.\n   */\n  function getPoolsByAccount(address account) external view returns (uint256[] memory, Pool[] memory) {\n    uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\n    Pool[] memory accountPools = new Pool[](_poolsByAccount[account].length);\n    (, Pool[] memory activePools) = getActivePools();\n\n    for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\n      indexes[i] = _poolsByAccount[account][i];\n      accountPools[i] = activePools[_poolsByAccount[account][i]];\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @notice Modify existing Ionic pool name.\n   */\n  function setPoolName(uint256 index, string calldata name) external {\n    IonicComptroller _comptroller = IonicComptroller(pools[index].comptroller);\n    require(\n      (msg.sender == _comptroller.admin() && _comptroller.adminHasRights()) || msg.sender == owner(),\n      \"!permission\"\n    );\n    pools[index].name = name;\n  }\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\n   */\n  mapping(address => bool) public adminWhitelist;\n\n  /**\n   * @dev used as salt for the creation of new pools\n   */\n  uint256 public poolsCounter;\n\n  /**\n   * @dev Event emitted when the admin whitelist is updated.\n   */\n  event AdminWhitelistUpdated(address[] admins, bool status);\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the admin whitelist.\n   * @param admins Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\n    require(admins.length > 0, \"No admins supplied.\");\n    for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\n    emit AdminWhitelistUpdated(admins, status);\n  }\n\n  /**\n   * @notice Returns arrays of all Ionic pool indexes and data with whitelisted admins.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPoolsByVerification(bool whitelistedAdmin) external view returns (uint256[] memory, Pool[] memory) {\n    uint256 arrayLength = 0;\n\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.admin() returns (address admin) {\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory publicPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.admin() returns (address admin) {\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n\n  /**\n   * @notice Returns arrays of all verified Ionic pool indexes and data for which the account is whitelisted\n   * @param account who is whitelisted in the returned verified whitelist-enabled pools.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getVerifiedPoolsOfWhitelistedAccount(address account)\n    external\n    view\n    returns (uint256[] memory, Pool[] memory)\n  {\n    uint256 arrayLength = 0;\n    (, Pool[] memory activePools) = getActivePools();\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    Pool[] memory accountWhitelistedPools = new Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < activePools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\n      } catch {}\n\n      indexes[index] = i;\n      accountWhitelistedPools[index] = activePools[i];\n      index++;\n    }\n\n    return (indexes, accountWhitelistedPools);\n  }\n}\n"
    },
    "contracts/PoolLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\n\nimport { PoolDirectory } from \"./PoolDirectory.sol\";\nimport { MasterPriceOracle } from \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title PoolLens\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice PoolLens returns data on Ionic interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract PoolLens is Initializable {\n  error ComptrollerError(uint256 errCode);\n\n  /**\n   * @notice Initialize the `PoolDirectory` contract object.\n   * @param _directory The PoolDirectory\n   * @param _name Name for the nativeToken\n   * @param _symbol Symbol for the nativeToken\n   * @param _hardcodedAddresses Underlying token addresses for a token like maker which are DSToken and/or use bytes32 for `symbol`\n   * @param _hardcodedNames Harcoded name for these tokens\n   * @param _hardcodedSymbols Harcoded symbol for these tokens\n   * @param _uniswapLPTokenNames Harcoded names for underlying uniswap LpToken\n   * @param _uniswapLPTokenSymbols Harcoded symbols for underlying uniswap LpToken\n   * @param _uniswapLPTokenDisplayNames Harcoded display names for underlying uniswap LpToken\n   */\n  function initialize(\n    PoolDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    address[] memory _hardcodedAddresses,\n    string[] memory _hardcodedNames,\n    string[] memory _hardcodedSymbols,\n    string[] memory _uniswapLPTokenNames,\n    string[] memory _uniswapLPTokenSymbols,\n    string[] memory _uniswapLPTokenDisplayNames\n  ) public initializer {\n    require(address(_directory) != address(0), \"PoolDirectory instance cannot be the zero address.\");\n    require(\n      _hardcodedAddresses.length == _hardcodedNames.length && _hardcodedAddresses.length == _hardcodedSymbols.length,\n      \"Hardcoded addresses lengths not equal.\"\n    );\n    require(\n      _uniswapLPTokenNames.length == _uniswapLPTokenSymbols.length &&\n        _uniswapLPTokenNames.length == _uniswapLPTokenDisplayNames.length,\n      \"Uniswap LP token names lengths not equal.\"\n    );\n\n    directory = _directory;\n    name = _name;\n    symbol = _symbol;\n    for (uint256 i = 0; i < _hardcodedAddresses.length; i++) {\n      hardcoded[_hardcodedAddresses[i]] = TokenData({ name: _hardcodedNames[i], symbol: _hardcodedSymbols[i] });\n    }\n\n    for (uint256 i = 0; i < _uniswapLPTokenNames.length; i++) {\n      uniswapData.push(\n        UniswapData({\n          name: _uniswapLPTokenNames[i],\n          symbol: _uniswapLPTokenSymbols[i],\n          displayName: _uniswapLPTokenDisplayNames[i]\n        })\n      );\n    }\n  }\n\n  string public name;\n  string public symbol;\n\n  struct TokenData {\n    string name;\n    string symbol;\n  }\n  mapping(address => TokenData) hardcoded;\n\n  struct UniswapData {\n    string name; // ie \"Uniswap V2\" or \"SushiSwap LP Token\"\n    string symbol; // ie \"UNI-V2\" or \"SLP\"\n    string displayName; // ie \"SushiSwap\" or \"Uniswap\"\n  }\n  UniswapData[] uniswapData;\n\n  /**\n   * @notice `PoolDirectory` contract object.\n   */\n  PoolDirectory public directory;\n\n  /**\n   * @dev Struct for Ionic pool summary data.\n   */\n  struct IonicPoolData {\n    uint256 totalSupply;\n    uint256 totalBorrow;\n    address[] underlyingTokens;\n    string[] underlyingSymbols;\n    bool whitelistedAdmin;\n  }\n\n  /**\n   * @notice Returns arrays of all public Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPublicPoolsWithData()\n    external\n    returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory)\n  {\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory publicPools) = directory.getPublicPools();\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n    return (indexes, publicPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of all whitelisted public Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPublicPoolsByVerificationWithData(\n    bool whitelistedAdmin\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory publicPools) = directory.getPublicPoolsByVerification(\n      whitelistedAdmin\n    );\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n    return (indexes, publicPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Ionic pools created by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsByAccountWithData(\n    address account\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory accountPools) = directory.getPoolsByAccount(account);\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n    return (indexes, accountPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Ionic pools used by `user`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsOIonicrWithData(\n    address user\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory userPools) = directory.getPoolsOfUser(user);\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(userPools);\n    return (indexes, userPools, data, errored);\n  }\n\n  /**\n   * @notice Internal function returning arrays of requested Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsData(PoolDirectory.Pool[] memory pools) internal returns (IonicPoolData[] memory, bool[] memory) {\n    IonicPoolData[] memory data = new IonicPoolData[](pools.length);\n    bool[] memory errored = new bool[](pools.length);\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try this.getPoolSummary(IonicComptroller(pools[i].comptroller)) returns (\n        uint256 _totalSupply,\n        uint256 _totalBorrow,\n        address[] memory _underlyingTokens,\n        string[] memory _underlyingSymbols,\n        bool _whitelistedAdmin\n      ) {\n        data[i] = IonicPoolData(_totalSupply, _totalBorrow, _underlyingTokens, _underlyingSymbols, _whitelistedAdmin);\n      } catch {\n        errored[i] = true;\n      }\n    }\n\n    return (data, errored);\n  }\n\n  /**\n   * @notice Returns total supply balance (in ETH), total borrow balance (in ETH), underlying token addresses, and underlying token symbols of a Ionic pool.\n   */\n  function getPoolSummary(\n    IonicComptroller comptroller\n  ) external returns (uint256, uint256, address[] memory, string[] memory, bool) {\n    uint256 totalBorrow = 0;\n    uint256 totalSupply = 0;\n    ICErc20[] memory cTokens = comptroller.getAllMarkets();\n    address[] memory underlyingTokens = new address[](cTokens.length);\n    string[] memory underlyingSymbols = new string[](cTokens.length);\n    BasePriceOracle oracle = comptroller.oracle();\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICErc20 cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n      cToken.accrueInterest();\n      uint256 assetTotalBorrow = cToken.totalBorrowsCurrent();\n      uint256 assetTotalSupply = cToken.getCash() +\n        assetTotalBorrow -\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalIonicFees());\n      uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n      totalBorrow = totalBorrow + (assetTotalBorrow * underlyingPrice) / 1e18;\n      totalSupply = totalSupply + (assetTotalSupply * underlyingPrice) / 1e18;\n\n      underlyingTokens[i] = ICErc20(address(cToken)).underlying();\n      (, underlyingSymbols[i]) = getTokenNameAndSymbol(underlyingTokens[i]);\n    }\n\n    bool whitelistedAdmin = directory.adminWhitelist(comptroller.admin());\n    return (totalSupply, totalBorrow, underlyingTokens, underlyingSymbols, whitelistedAdmin);\n  }\n\n  /**\n   * @dev Struct for a Ionic pool asset.\n   */\n  struct PoolAsset {\n    address cToken;\n    address underlyingToken;\n    string underlyingName;\n    string underlyingSymbol;\n    uint256 underlyingDecimals;\n    uint256 underlyingBalance;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 totalSupply;\n    uint256 totalBorrow;\n    uint256 supplyBalance;\n    uint256 borrowBalance;\n    uint256 liquidity;\n    bool membership;\n    uint256 exchangeRate; // Price of cTokens in terms of underlying tokens\n    uint256 underlyingPrice; // Price of underlying tokens in ETH (scaled by 1e18)\n    address oracle;\n    uint256 collateralFactor;\n    uint256 reserveFactor;\n    uint256 adminFee;\n    uint256 ionicFee;\n    bool borrowGuardianPaused;\n    bool mintGuardianPaused;\n  }\n\n  /**\n   * @notice Returns data on the specified assets of the specified Ionic pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptroller The Comptroller proxy contract address of the Ionic pool.\n   * @param cTokens The cToken contract addresses of the assets to query.\n   * @param user The user for which to get account data.\n   * @return An array of Ionic pool assets.\n   */\n  function getPoolAssetsWithData(\n    IonicComptroller comptroller,\n    ICErc20[] memory cTokens,\n    address user\n  ) internal returns (PoolAsset[] memory) {\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      (bool isListed, ) = comptroller.markets(address(cTokens[i]));\n      if (isListed) arrayLength++;\n    }\n\n    PoolAsset[] memory detailedAssets = new PoolAsset[](arrayLength);\n    uint256 index = 0;\n    BasePriceOracle oracle = BasePriceOracle(address(comptroller.oracle()));\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      // Check if market is listed and get collateral factor\n      (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokens[i]));\n      if (!isListed) continue;\n\n      // Start adding data to PoolAsset\n      PoolAsset memory asset;\n      ICErc20 cToken = cTokens[i];\n      asset.cToken = address(cToken);\n\n      cToken.accrueInterest();\n\n      // Get underlying asset data\n      asset.underlyingToken = ICErc20(address(cToken)).underlying();\n      ERC20Upgradeable underlying = ERC20Upgradeable(asset.underlyingToken);\n      (asset.underlyingName, asset.underlyingSymbol) = getTokenNameAndSymbol(asset.underlyingToken);\n      asset.underlyingDecimals = underlying.decimals();\n      asset.underlyingBalance = underlying.balanceOf(user);\n\n      // Get cToken data\n      asset.supplyRatePerBlock = cToken.supplyRatePerBlock();\n      asset.borrowRatePerBlock = cToken.borrowRatePerBlock();\n      asset.liquidity = cToken.getCash();\n      asset.totalBorrow = cToken.totalBorrowsCurrent();\n      asset.totalSupply =\n        asset.liquidity +\n        asset.totalBorrow -\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalIonicFees());\n      asset.supplyBalance = cToken.balanceOfUnderlying(user);\n      asset.borrowBalance = cToken.borrowBalanceCurrent(user);\n      asset.membership = comptroller.checkMembership(user, cToken);\n      asset.exchangeRate = cToken.exchangeRateCurrent(); // We would use exchangeRateCurrent but we already accrue interest above\n      asset.underlyingPrice = oracle.price(asset.underlyingToken);\n\n      // Get oracle for this cToken\n      asset.oracle = address(oracle);\n\n      try MasterPriceOracle(asset.oracle).oracles(asset.underlyingToken) returns (BasePriceOracle _oracle) {\n        asset.oracle = address(_oracle);\n      } catch {}\n\n      // More cToken data\n      asset.collateralFactor = collateralFactorMantissa;\n      asset.reserveFactor = cToken.reserveFactorMantissa();\n      asset.adminFee = cToken.adminFeeMantissa();\n      asset.ionicFee = cToken.ionicFeeMantissa();\n      asset.borrowGuardianPaused = comptroller.borrowGuardianPaused(address(cToken));\n      asset.mintGuardianPaused = comptroller.mintGuardianPaused(address(cToken));\n\n      // Add to assets array and increment index\n      detailedAssets[index] = asset;\n      index++;\n    }\n\n    return (detailedAssets);\n  }\n\n  function getBorrowCapsPerCollateral(\n    ICErc20 borrowedAsset,\n    IonicComptroller comptroller\n  )\n    internal\n    view\n    returns (\n      address[] memory collateral,\n      uint256[] memory borrowCapsAgainstCollateral,\n      bool[] memory borrowingBlacklistedAgainstCollateral\n    )\n  {\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\n\n    collateral = new address[](poolMarkets.length);\n    borrowCapsAgainstCollateral = new uint256[](poolMarkets.length);\n    borrowingBlacklistedAgainstCollateral = new bool[](poolMarkets.length);\n\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\n      address collateralAddress = address(poolMarkets[i]);\n      if (collateralAddress != address(borrowedAsset)) {\n        collateral[i] = collateralAddress;\n        borrowCapsAgainstCollateral[i] = comptroller.borrowCapForCollateral(address(borrowedAsset), collateralAddress);\n        borrowingBlacklistedAgainstCollateral[i] = comptroller.borrowingAgainstCollateralBlacklist(\n          address(borrowedAsset),\n          collateralAddress\n        );\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the `name` and `symbol` of `token`.\n   * Supports Uniswap V2 and SushiSwap LP tokens as well as MKR.\n   * @param token An ERC20 token contract object.\n   * @return The `name` and `symbol`.\n   */\n  function getTokenNameAndSymbol(address token) internal view returns (string memory, string memory) {\n    // i.e. MKR is a DSToken and uses bytes32\n    if (bytes(hardcoded[token].symbol).length != 0) {\n      return (hardcoded[token].name, hardcoded[token].symbol);\n    }\n\n    // Get name and symbol from token contract\n    ERC20Upgradeable tokenContract = ERC20Upgradeable(token);\n    string memory _name = tokenContract.name();\n    string memory _symbol = tokenContract.symbol();\n\n    return (_name, _symbol);\n  }\n\n  /**\n   * @notice Returns the assets of the specified Ionic pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptroller The Comptroller proxy contract of the Ionic pool.\n   * @return An array of Ionic pool assets.\n   */\n  function getPoolAssetsWithData(IonicComptroller comptroller) external returns (PoolAsset[] memory) {\n    return getPoolAssetsWithData(comptroller, comptroller.getAllMarkets(), msg.sender);\n  }\n\n  /**\n   * @dev Struct for a Ionic pool user.\n   */\n  struct IonicPoolUser {\n    address account;\n    uint256 totalBorrow;\n    uint256 totalCollateral;\n    uint256 health;\n  }\n\n  /**\n   * @notice Returns arrays of PoolAsset for a specific user\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPoolAssetsByUser(IonicComptroller comptroller, address user) public returns (PoolAsset[] memory) {\n    PoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(user), user);\n    return assets;\n  }\n\n  /**\n   * @notice returns the total supply cap for each asset in the pool\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getSupplyCapsForPool(IonicComptroller comptroller) public view returns (address[] memory, uint256[] memory) {\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\n\n    address[] memory assets = new address[](poolMarkets.length);\n    uint256[] memory supplyCapsPerAsset = new uint256[](poolMarkets.length);\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\n      assets[i] = address(poolMarkets[i]);\n      supplyCapsPerAsset[i] = comptroller.effectiveSupplyCaps(assets[i]);\n    }\n\n    return (assets, supplyCapsPerAsset);\n  }\n\n  /**\n   * @notice returns the total supply cap for each asset in the pool and the total non-whitelist supplied assets\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getSupplyCapsDataForPool(\n    IonicComptroller comptroller\n  ) public view returns (address[] memory, uint256[] memory, uint256[] memory) {\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\n\n    address[] memory assets = new address[](poolMarkets.length);\n    uint256[] memory supplyCapsPerAsset = new uint256[](poolMarkets.length);\n    uint256[] memory nonWhitelistedTotalSupply = new uint256[](poolMarkets.length);\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\n      assets[i] = address(poolMarkets[i]);\n      supplyCapsPerAsset[i] = comptroller.effectiveSupplyCaps(assets[i]);\n      uint256 assetTotalSupplied = poolMarkets[i].getTotalUnderlyingSupplied();\n      uint256 whitelistedSuppliersSupply = comptroller.getWhitelistedSuppliersSupply(assets[i]);\n      if (whitelistedSuppliersSupply >= assetTotalSupplied) nonWhitelistedTotalSupply[i] = 0;\n      else nonWhitelistedTotalSupply[i] = assetTotalSupplied - whitelistedSuppliersSupply;\n    }\n\n    return (assets, supplyCapsPerAsset, nonWhitelistedTotalSupply);\n  }\n\n  /**\n   * @notice returns the total borrow cap and the per collateral borrowing cap/blacklist for the asset\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getBorrowCapsForAsset(\n    ICErc20 asset\n  )\n    public\n    view\n    returns (\n      address[] memory collateral,\n      uint256[] memory borrowCapsPerCollateral,\n      bool[] memory collateralBlacklisted,\n      uint256 totalBorrowCap\n    )\n  {\n    IonicComptroller comptroller = IonicComptroller(asset.comptroller());\n    (collateral, borrowCapsPerCollateral, collateralBlacklisted) = getBorrowCapsPerCollateral(asset, comptroller);\n    totalBorrowCap = comptroller.effectiveBorrowCaps(address(asset));\n  }\n\n  /**\n   * @notice returns the total borrow cap, the per collateral borrowing cap/blacklist for the asset and the total non-whitelist borrows\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getBorrowCapsDataForAsset(\n    ICErc20 asset\n  )\n    public\n    view\n    returns (\n      address[] memory collateral,\n      uint256[] memory borrowCapsPerCollateral,\n      bool[] memory collateralBlacklisted,\n      uint256 totalBorrowCap,\n      uint256 nonWhitelistedTotalBorrows\n    )\n  {\n    IonicComptroller comptroller = IonicComptroller(asset.comptroller());\n    (collateral, borrowCapsPerCollateral, collateralBlacklisted) = getBorrowCapsPerCollateral(asset, comptroller);\n    totalBorrowCap = comptroller.effectiveBorrowCaps(address(asset));\n    uint256 totalBorrows = asset.totalBorrowsCurrent();\n    uint256 whitelistedBorrowersBorrows = comptroller.getWhitelistedBorrowersBorrows(address(asset));\n    if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\n    else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\n  }\n\n  /**\n   * @notice Returns arrays of Ionic pool indexes and data with a whitelist containing `account`.\n   * Note that the whitelist does not have to be enforced.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getWhitelistedPoolsByAccount(\n    address account\n  ) public view returns (uint256[] memory, PoolDirectory.Pool[] memory) {\n    (, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n\n      if (comptroller.whitelist(account)) arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    PoolDirectory.Pool[] memory accountPools = new PoolDirectory.Pool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n\n      if (comptroller.whitelist(account)) {\n        indexes[index] = i;\n        accountPools[index] = pools[i];\n        index++;\n        break;\n      }\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Ionic pools with a whitelist containing `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getWhitelistedPoolsByAccountWithData(\n    address account\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory accountPools) = getWhitelistedPoolsByAccount(account);\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n    return (indexes, accountPools, data, errored);\n  }\n\n  function getHealthFactor(address user, IonicComptroller pool) external view returns (uint256) {\n    return getHealthFactorHypothetical(pool, user, address(0), 0, 0, 0);\n  }\n\n  function getHealthFactorHypothetical(\n    IonicComptroller pool,\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount,\n    uint256 repayAmount\n  ) public view returns (uint256) {\n    (uint256 err, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getHypotheticalAccountLiquidity(\n      account,\n      cTokenModify,\n      redeemTokens,\n      borrowAmount,\n      repayAmount\n    );\n\n    if (err != 0) revert ComptrollerError(err);\n\n    if (shortfall > 0) {\n      // HF < 1.0\n      return (collateralValue * 1e18) / (collateralValue + shortfall);\n    } else {\n      // HF >= 1.0\n      if (collateralValue <= liquidity) return type(uint256).max;\n      else return (collateralValue * 1e18) / (collateralValue - liquidity);\n    }\n  }\n}\n"
    },
    "contracts/PoolLensSecondary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\nimport { IUniswapV2Pair } from \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport { PoolDirectory } from \"./PoolDirectory.sol\";\n\ninterface IRewardsDistributor_PLS {\n  function rewardToken() external view returns (address);\n\n  function compSupplySpeeds(address) external view returns (uint256);\n\n  function compBorrowSpeeds(address) external view returns (uint256);\n\n  function compAccrued(address) external view returns (uint256);\n\n  function flywheelPreSupplierAction(address cToken, address supplier) external;\n\n  function flywheelPreBorrowerAction(address cToken, address borrower) external;\n\n  function getAllMarkets() external view returns (ICErc20[] memory);\n}\n\n/**\n * @title PoolLensSecondary\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice PoolLensSecondary returns data on Ionic interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract PoolLensSecondary is Initializable {\n  /**\n   * @notice Constructor to set the `PoolDirectory` contract object.\n   */\n  function initialize(PoolDirectory _directory) public initializer {\n    require(address(_directory) != address(0), \"PoolDirectory instance cannot be the zero address.\");\n    directory = _directory;\n  }\n\n  /**\n   * @notice `PoolDirectory` contract object.\n   */\n  PoolDirectory public directory;\n\n  /**\n   * @notice Struct for ownership over a CToken.\n   */\n  struct CTokenOwnership {\n    address cToken;\n    address admin;\n    bool adminHasRights;\n    bool ionicAdminHasRights;\n  }\n\n  /**\n   * @notice Returns the admin, admin rights, Ionic admin (constant), Ionic admin rights, and an array of cTokens with differing properties.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolOwnership(IonicComptroller comptroller)\n    external\n    view\n    returns (\n      address,\n      bool,\n      bool,\n      CTokenOwnership[] memory\n    )\n  {\n    // Get pool ownership\n    address comptrollerAdmin = comptroller.admin();\n    bool comptrollerAdminHasRights = comptroller.adminHasRights();\n    bool comptrollerIonicAdminHasRights = comptroller.ionicAdminHasRights();\n\n    // Get cToken ownership\n    ICErc20[] memory cTokens = comptroller.getAllMarkets();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICErc20 cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n\n      address cTokenAdmin;\n      try cToken.admin() returns (address _cTokenAdmin) {\n        cTokenAdmin = _cTokenAdmin;\n      } catch {\n        continue;\n      }\n      bool cTokenAdminHasRights = cToken.adminHasRights();\n      bool cTokenIonicAdminHasRights = cToken.ionicAdminHasRights();\n\n      // If outlier, push to array\n      if (\n        cTokenAdmin != comptrollerAdmin ||\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\n        cTokenIonicAdminHasRights != comptrollerIonicAdminHasRights\n      ) arrayLength++;\n    }\n\n    CTokenOwnership[] memory outliers = new CTokenOwnership[](arrayLength);\n    uint256 arrayIndex = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICErc20 cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n\n      address cTokenAdmin;\n      try cToken.admin() returns (address _cTokenAdmin) {\n        cTokenAdmin = _cTokenAdmin;\n      } catch {\n        continue;\n      }\n      bool cTokenAdminHasRights = cToken.adminHasRights();\n      bool cTokenIonicAdminHasRights = cToken.ionicAdminHasRights();\n\n      // If outlier, push to array and increment array index\n      if (\n        cTokenAdmin != comptrollerAdmin ||\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\n        cTokenIonicAdminHasRights != comptrollerIonicAdminHasRights\n      ) {\n        outliers[arrayIndex] = CTokenOwnership(\n          address(cToken),\n          cTokenAdmin,\n          cTokenAdminHasRights,\n          cTokenIonicAdminHasRights\n        );\n        arrayIndex++;\n      }\n    }\n\n    return (comptrollerAdmin, comptrollerAdminHasRights, comptrollerIonicAdminHasRights, outliers);\n  }\n\n  /**\n   * @notice Determine the maximum redeem amount of a cToken.\n   * @param cTokenModify The market to hypothetically redeem in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum redeem amount.\n   */\n  function getMaxRedeem(address account, ICErc20 cTokenModify) external returns (uint256) {\n    return getMaxRedeemOrBorrow(account, cTokenModify, false);\n  }\n\n  /**\n   * @notice Determine the maximum borrow amount of a cToken.\n   * @param cTokenModify The market to hypothetically borrow in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum borrow amount.\n   */\n  function getMaxBorrow(address account, ICErc20 cTokenModify) external returns (uint256) {\n    return getMaxRedeemOrBorrow(account, cTokenModify, true);\n  }\n\n  /**\n   * @dev Internal function to determine the maximum borrow/redeem amount of a cToken.\n   * @param cTokenModify The market to hypothetically borrow/redeem in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum borrow/redeem amount.\n   */\n  function getMaxRedeemOrBorrow(\n    address account,\n    ICErc20 cTokenModify,\n    bool isBorrow\n  ) internal returns (uint256) {\n    IonicComptroller comptroller = IonicComptroller(cTokenModify.comptroller());\n    return comptroller.getMaxRedeemOrBorrow(account, cTokenModify, isBorrow);\n  }\n\n  /**\n   * @notice Returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n   * @param comptroller The Ionic pool Comptroller to check.\n   */\n  function getRewardSpeedsByPool(IonicComptroller comptroller)\n    public\n    view\n    returns (\n      ICErc20[] memory,\n      address[] memory,\n      address[] memory,\n      uint256[][] memory,\n      uint256[][] memory\n    )\n  {\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    address[] memory distributors;\n\n    try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\n      distributors = _distributors;\n    } catch {\n      distributors = new address[](0);\n    }\n\n    address[] memory rewardTokens = new address[](distributors.length);\n    uint256[][] memory supplySpeeds = new uint256[][](allMarkets.length);\n    uint256[][] memory borrowSpeeds = new uint256[][](allMarkets.length);\n\n    // Get reward tokens for each distributor\n    for (uint256 i = 0; i < distributors.length; i++) {\n      rewardTokens[i] = IRewardsDistributor_PLS(distributors[i]).rewardToken();\n    }\n\n    // Get reward speeds for each market for each distributor\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      address cToken = address(allMarkets[i]);\n      supplySpeeds[i] = new uint256[](distributors.length);\n      borrowSpeeds[i] = new uint256[](distributors.length);\n\n      for (uint256 j = 0; j < distributors.length; j++) {\n        IRewardsDistributor_PLS distributor = IRewardsDistributor_PLS(distributors[j]);\n        supplySpeeds[i][j] = distributor.compSupplySpeeds(cToken);\n        borrowSpeeds[i][j] = distributor.compBorrowSpeeds(cToken);\n      }\n    }\n\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n  }\n\n  /**\n   * @notice For each `Comptroller`, returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n   * @param comptrollers The Ionic pool Comptrollers to check.\n   */\n  function getRewardSpeedsByPools(IonicComptroller[] memory comptrollers)\n    external\n    view\n    returns (\n      ICErc20[][] memory,\n      address[][] memory,\n      address[][] memory,\n      uint256[][][] memory,\n      uint256[][][] memory\n    )\n  {\n    ICErc20[][] memory allMarkets = new ICErc20[][](comptrollers.length);\n    address[][] memory distributors = new address[][](comptrollers.length);\n    address[][] memory rewardTokens = new address[][](comptrollers.length);\n    uint256[][][] memory supplySpeeds = new uint256[][][](comptrollers.length);\n    uint256[][][] memory borrowSpeeds = new uint256[][][](comptrollers.length);\n    for (uint256 i = 0; i < comptrollers.length; i++)\n      (allMarkets[i], distributors[i], rewardTokens[i], supplySpeeds[i], borrowSpeeds[i]) = getRewardSpeedsByPool(\n        comptrollers[i]\n      );\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n  }\n\n  /**\n   * @notice Returns unaccrued rewards by `holder` from `cToken` on `distributor`.\n   * @param holder The address to check.\n   * @param distributor The RewardsDistributor to check.\n   * @param cToken The CToken to check.\n   * @return Unaccrued (unclaimed) supply-side rewards and unaccrued (unclaimed) borrow-side rewards.\n   */\n  function getUnaccruedRewards(\n    address holder,\n    IRewardsDistributor_PLS distributor,\n    ICErc20 cToken\n  ) internal returns (uint256, uint256) {\n    // Get unaccrued supply rewards\n    uint256 compAccruedPrior = distributor.compAccrued(holder);\n    distributor.flywheelPreSupplierAction(address(cToken), holder);\n    uint256 supplyRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\n\n    // Get unaccrued borrow rewards\n    compAccruedPrior = distributor.compAccrued(holder);\n    distributor.flywheelPreBorrowerAction(address(cToken), holder);\n    uint256 borrowRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\n\n    // Return both\n    return (supplyRewardsUnaccrued, borrowRewardsUnaccrued);\n  }\n\n  /**\n   * @notice Returns all unclaimed rewards accrued by the `holder` on `distributors`.\n   * @param holder The address to check.\n   * @param distributors The `RewardsDistributor` contracts to check.\n   * @return For each of `distributors`: total quantity of unclaimed rewards, array of cTokens, array of unaccrued (unclaimed) supply-side and borrow-side rewards per cToken, and quantity of funds available in the distributor.\n   */\n  function getUnclaimedRewardsByDistributors(address holder, IRewardsDistributor_PLS[] memory distributors)\n    external\n    returns (\n      address[] memory,\n      uint256[] memory,\n      ICErc20[][] memory,\n      uint256[2][][] memory,\n      uint256[] memory\n    )\n  {\n    address[] memory rewardTokens = new address[](distributors.length);\n    uint256[] memory compUnclaimedTotal = new uint256[](distributors.length);\n    ICErc20[][] memory allMarkets = new ICErc20[][](distributors.length);\n    uint256[2][][] memory rewardsUnaccrued = new uint256[2][][](distributors.length);\n    uint256[] memory distributorFunds = new uint256[](distributors.length);\n\n    for (uint256 i = 0; i < distributors.length; i++) {\n      IRewardsDistributor_PLS distributor = distributors[i];\n      rewardTokens[i] = distributor.rewardToken();\n      allMarkets[i] = distributor.getAllMarkets();\n      rewardsUnaccrued[i] = new uint256[2][](allMarkets[i].length);\n      for (uint256 j = 0; j < allMarkets[i].length; j++)\n        (rewardsUnaccrued[i][j][0], rewardsUnaccrued[i][j][1]) = getUnaccruedRewards(\n          holder,\n          distributor,\n          allMarkets[i][j]\n        );\n      compUnclaimedTotal[i] = distributor.compAccrued(holder);\n      distributorFunds[i] = IERC20Upgradeable(rewardTokens[i]).balanceOf(address(distributor));\n    }\n\n    return (rewardTokens, compUnclaimedTotal, allMarkets, rewardsUnaccrued, distributorFunds);\n  }\n\n  /**\n   * @notice Returns arrays of indexes, `Comptroller` proxy contracts, and `RewardsDistributor` contracts for Ionic pools supplied to by `account`.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getRewardsDistributorsBySupplier(address supplier)\n    external\n    view\n    returns (\n      uint256[] memory,\n      IonicComptroller[] memory,\n      address[][] memory\n    )\n  {\n    // Get array length\n    (, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try IonicComptroller(pools[i].comptroller).suppliers(supplier) returns (bool isSupplier) {\n        if (isSupplier) arrayLength++;\n      } catch {}\n    }\n\n    // Build array\n    uint256[] memory indexes = new uint256[](arrayLength);\n    IonicComptroller[] memory comptrollers = new IonicComptroller[](arrayLength);\n    address[][] memory distributors = new address[][](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n\n      try comptroller.suppliers(supplier) returns (bool isSupplier) {\n        if (isSupplier) {\n          indexes[index] = i;\n          comptrollers[index] = comptroller;\n\n          try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\n            distributors[index] = _distributors;\n          } catch {}\n\n          index++;\n        }\n      } catch {}\n    }\n\n    // Return distributors\n    return (indexes, comptrollers, distributors);\n  }\n\n  /**\n   * @notice The returned list of flywheels contains address(0) for flywheels for which the user has no rewards to claim\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getFlywheelsToClaim(address user)\n    external\n    view\n    returns (\n      uint256[] memory,\n      IonicComptroller[] memory,\n      address[][] memory\n    )\n  {\n    (uint256[] memory poolIds, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\n\n    IonicComptroller[] memory comptrollers = new IonicComptroller[](pools.length);\n    address[][] memory distributors = new address[][](pools.length);\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n      try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\n        comptrollers[i] = comptroller;\n        distributors[i] = flywheelsWithRewardsForPoolUser(user, _distributors);\n      } catch {}\n    }\n\n    return (poolIds, comptrollers, distributors);\n  }\n\n  function flywheelsWithRewardsForPoolUser(address user, address[] memory _distributors)\n    internal\n    view\n    returns (address[] memory)\n  {\n    address[] memory distributors = new address[](_distributors.length);\n    for (uint256 j = 0; j < _distributors.length; j++) {\n      if (IRewardsDistributor_PLS(_distributors[j]).compAccrued(user) > 0) {\n        distributors[j] = _distributors[j];\n      }\n    }\n\n    return distributors;\n  }\n}\n"
    },
    "contracts/test/abstracts/AbstractAssetTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { AbstractERC4626Test } from \"./AbstractERC4626Test.sol\";\nimport { ITestConfigStorage } from \"./ITestConfigStorage.sol\";\n\ncontract AbstractAssetTest is BaseTest {\n  AbstractERC4626Test public test;\n  ITestConfigStorage public testConfigStorage;\n\n  function setUpTestContract(bytes calldata testConfig) public virtual {\n    // test._setUp(MockERC20(address(IBeefyVault(testConfig.beefyVault).want())).symbol(), testConfig);\n  }\n\n  function runTest(function() external testFn) public {\n    if (shouldRunForChain(block.chainid)) {\n      for (uint8 i; i < testConfigStorage.getTestConfigLength(); i++) {\n        this.setUpTestContract(testConfigStorage.getTestConfig(i));\n        testFn();\n      }\n    }\n  }\n\n  function testInitializedValues() public virtual {\n    // for (uint8 i; i < testConfigStorage.getTestConfigLength(); i++) {\n    //   this.setUpTestContract(testConfigs[i]);\n    //   test.testInitializedValues(asset.name(), asset.symbol());\n    // }\n  }\n\n  function testPreviewDepositAndMintReturnTheSameValue() public {\n    this.runTest(test.testPreviewDepositAndMintReturnTheSameValue);\n  }\n\n  function testPreviewWithdrawAndRedeemReturnTheSameValue() public {\n    this.runTest(test.testPreviewWithdrawAndRedeemReturnTheSameValue);\n  }\n\n  function testDeposit() public {\n    this.runTest(test.testDeposit);\n  }\n\n  function testDepositWithIncreasedVaultValue() public virtual {\n    this.runTest(test.testDepositWithIncreasedVaultValue);\n  }\n\n  function testDepositWithDecreasedVaultValue() public virtual {\n    this.runTest(test.testDepositWithDecreasedVaultValue);\n  }\n\n  function testMultipleDeposit() public {\n    this.runTest(test.testMultipleDeposit);\n  }\n\n  function testMint() public {\n    this.runTest(test.testMint);\n  }\n\n  function testMultipleMint() public {\n    this.runTest(test.testMultipleMint);\n  }\n\n  function testWithdraw() public {\n    this.runTest(test.testWithdraw);\n  }\n\n  function testWithdrawWithIncreasedVaultValue() public virtual {\n    this.runTest(test.testWithdrawWithIncreasedVaultValue);\n  }\n\n  function testWithdrawWithDecreasedVaultValue() public virtual {\n    this.runTest(test.testWithdrawWithDecreasedVaultValue);\n  }\n\n  function testMultipleWithdraw() public {\n    this.runTest(test.testMultipleWithdraw);\n  }\n\n  function testRedeem() public {\n    this.runTest(test.testRedeem);\n  }\n\n  function testMultipleRedeem() public {\n    this.runTest(test.testMultipleRedeem);\n  }\n\n  function testPauseContract() public {\n    this.runTest(test.testPauseContract);\n  }\n\n  function testEmergencyWithdrawAndPause() public {\n    this.runTest(test.testEmergencyWithdrawAndPause);\n  }\n\n  function testEmergencyWithdrawAndRedeem() public {\n    this.runTest(test.testEmergencyWithdrawAndRedeem);\n  }\n}\n"
    },
    "contracts/test/abstracts/AbstractERC4626Test.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../helpers/WithPool.sol\";\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { IonicERC4626 } from \"../../ionic/strategies/IonicERC4626.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { Authority } from \"solmate/auth/Auth.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\nabstract contract AbstractERC4626Test is WithPool {\n  using FixedPointMathLib for uint256;\n\n  IonicERC4626 plugin;\n\n  string testPreFix;\n\n  uint256 public depositAmount = 100e18;\n  uint256 BPS_DENOMINATOR = 10_000;\n\n  uint256 initialStrategyBalance;\n  uint256 initialStrategySupply;\n\n  constructor() {\n    _forkAtBlock(uint128(block.chainid), block.number);\n  }\n\n  function _setUp(string memory _testPreFix, bytes calldata data) public virtual;\n\n  function deposit(address _owner, uint256 amount) public {\n    vm.startPrank(_owner);\n    underlyingToken.approve(address(plugin), amount);\n    plugin.deposit(amount, _owner);\n    vm.stopPrank();\n  }\n\n  function sendUnderlyingToken(uint256 amount, address recipient) public {\n    deal(address(underlyingToken), recipient, amount);\n  }\n\n  function increaseAssetsInVault() public virtual {}\n\n  function decreaseAssetsInVault() public virtual {}\n\n  function getDepositShares() public view virtual returns (uint256);\n\n  function getStrategyBalance() public view virtual returns (uint256);\n\n  function getExpectedDepositShares() public view virtual returns (uint256);\n\n  function testInitializedValues(string memory assetName, string memory assetSymbol) public virtual {\n    assertEq(\n      plugin.name(),\n      string(abi.encodePacked(\"Midas \", assetName, \" Vault\")),\n      string(abi.encodePacked(\"!name \", testPreFix))\n    );\n    assertEq(\n      plugin.symbol(),\n      string(abi.encodePacked(\"mv\", assetSymbol)),\n      string(abi.encodePacked(\"!symbol \", testPreFix))\n    );\n    assertEq(address(plugin.asset()), address(underlyingToken), string(abi.encodePacked(\"!asset \", testPreFix)));\n    // assertEq(\n    //   address(BeefyERC4626(address(plugin)).beefyVault()),\n    //   address(beefyVault),\n    //   string(abi.encodePacked(\"!beefyVault \", testPreFix))\n    // );\n  }\n\n  function testPreviewDepositAndMintReturnTheSameValue() public {\n    uint256 returnedShares = plugin.previewDeposit(depositAmount);\n    assertApproxEqAbs(\n      plugin.previewMint(returnedShares),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!previewMint \", testPreFix))\n    );\n  }\n\n  function testPreviewWithdrawAndRedeemReturnTheSameValue() public {\n    deposit(address(this), depositAmount);\n    uint256 withdrawalAmount = 10e18;\n    uint256 reqShares = plugin.previewWithdraw(withdrawalAmount);\n    assertApproxEqAbs(\n      plugin.previewRedeem(reqShares),\n      withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!previewRedeem \", testPreFix))\n    );\n  }\n\n  function testDeposit() public virtual {\n    uint256 expectedDepositShare = this.getExpectedDepositShares();\n    uint256 expectedErc4626Shares = plugin.previewDeposit(depositAmount);\n\n    deposit(address(this), depositAmount);\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      this.getStrategyBalance(),\n      initialStrategyBalance + depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!transfer \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    assertApproxEqAbs(\n      plugin.totalAssets(),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalAssets \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.convertToAssets(plugin.balanceOf(address(this))),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!balOfUnderlying \", testPreFix))\n    );\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      expectedErc4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!expectedShares \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      expectedErc4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      expectedDepositShare,\n      uint256(10),\n      string(abi.encodePacked(\"!depositShares \", testPreFix))\n    );\n  }\n\n  function testDepositWithIncreasedVaultValue() public {\n    // lpDepositor just mints the exact amount of depositShares as the user deposits in assets\n    uint256 oldExpectedDepositShare = this.getExpectedDepositShares();\n    uint256 oldExpected4626Shares = plugin.previewDeposit(depositAmount);\n\n    deposit(address(this), depositAmount);\n\n    // Increase the share price\n    increaseAssetsInVault();\n\n    uint256 expectedDepositShare = this.getExpectedDepositShares();\n    uint256 previewErc4626Shares = plugin.previewDeposit(depositAmount);\n    uint256 expected4626Shares = depositAmount.mulDivDown(plugin.totalSupply(), plugin.totalAssets());\n\n    sendUnderlyingToken(depositAmount, address(this));\n    deposit(address(this), depositAmount);\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      oldExpected4626Shares + previewErc4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!previewShares == oldExpectedShares \", testPreFix))\n    );\n\n    // Test that we got less shares on the second mint after assets in the vault increased\n    assertLe(\n      previewErc4626Shares,\n      oldExpected4626Shares,\n      string(abi.encodePacked(\"!new shares < old Shares \", testPreFix))\n    );\n    assertApproxEqAbs(\n      previewErc4626Shares,\n      expected4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!previewShares == expectedShares \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      oldExpectedDepositShare + expectedDepositShare,\n      uint256(10),\n      string(abi.encodePacked(\"!expectedShares \", testPreFix))\n    );\n  }\n\n  function testDepositWithDecreasedVaultValue() public {\n    // THIS TEST WILL ALWAYS FAIL\n    // A transfer out of the lpStaker will always fail.\n    // There also doesnt seem another way to reduce the balance of lpStaker so we cant test this scenario\n    /* =============== ACTUAL TEST =============== */\n    /*\n    uint256 oldExpecteDepositShares = depositAmount;\n    uint256 oldExpected4626Shares = plugin.previewDeposit(depositAmount);\n    deposit(address(this), depositAmount);\n    // Decrease the share price\n    decreaseAssetsInVault();\n    uint256 expectedDepositShare = depositAmount;\n    uint256 previewErc4626Shares = plugin.previewDeposit(depositAmount);\n    uint256 expected4626Shares = depositAmount.mulDivDown(plugin.totalSupply(), plugin.totalAssets());\n    sendUnderlyingToken(depositAmount, address(this));\n    deposit(address(this), depositAmount);\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(plugin.balanceOf(address(this)), oldExpected4626Shares + previewErc4626Shares);\n    // Test that we got less shares on the second mint after assets in the vault increased\n    assertGt(previewErc4626Shares, oldExpected4626Shares, \"!new shares > old Shares\");\n    assertApproxEqAbs(previewErc4626Shares, expected4626Shares, \"!previewShares == expectedShares\");\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(this.getDepositShares(), oldExpecteDepositShares + expectedDepositShare);\n    */\n  }\n\n  function testMultipleDeposit() public {\n    uint256 expectedDepositShare = this.getExpectedDepositShares();\n    uint256 expectedErc4626Shares = plugin.previewDeposit(depositAmount);\n\n    deposit(address(this), depositAmount);\n\n    sendUnderlyingToken(depositAmount, address(1));\n    deposit(address(1), depositAmount);\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      this.getStrategyBalance(),\n      initialStrategyBalance + depositAmount * 2,\n      uint256(10),\n      string(abi.encodePacked(\"!transfer \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    assertApproxEqAbs(\n      depositAmount * 2,\n      plugin.totalAssets(),\n      uint256(10),\n      string(abi.encodePacked(\"Total Assets should be same as sum of deposited amounts \", testPreFix))\n    );\n    assertApproxEqAbs(\n      depositAmount,\n      plugin.convertToAssets(plugin.balanceOf(address(this))),\n      uint256(10),\n      string(abi.encodePacked(\"Underlying token balance should be same as deposited amount \", testPreFix))\n    );\n    assertApproxEqAbs(\n      depositAmount,\n      plugin.convertToAssets(plugin.balanceOf(address(1))),\n      uint256(10),\n      string(abi.encodePacked(\"Underlying token balance should be same as deposited amount \", testPreFix))\n    );\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      expectedErc4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!expectedShares address(this) \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.balanceOf(address(1)),\n      expectedErc4626Shares,\n      uint256(10),\n      string(abi.encodePacked(\"!expectedShares address(1) \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      expectedErc4626Shares * 2,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      expectedDepositShare * 2,\n      uint256(10),\n      string(abi.encodePacked(\"!depositShare \", testPreFix))\n    );\n\n    // DotDot ERC4626 should not have underlyingToken after deposit\n    assertTrue(\n      underlyingToken.balanceOf(address(plugin)) <= 1,\n      string(abi.encodePacked(\"DotDot erc4626 locked amount checking \", testPreFix))\n    );\n  }\n\n  function testMint() public {\n    uint256 expectedDepositShare = this.getExpectedDepositShares();\n    uint256 mintAmount = plugin.previewDeposit(depositAmount);\n\n    underlyingToken.approve(address(plugin), depositAmount);\n    plugin.mint(mintAmount, address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      this.getStrategyBalance(),\n      initialStrategyBalance + depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!transfer \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    assertApproxEqAbs(\n      plugin.totalAssets(),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalAssets \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.convertToAssets(plugin.balanceOf(address(this))),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!balOfUnderlying \", testPreFix))\n    );\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!mint \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      expectedDepositShare,\n      uint256(10),\n      string(abi.encodePacked(\"!depositShare \", testPreFix))\n    );\n  }\n\n  function testMultipleMint() public {\n    uint256 expectedDepositShare = this.getExpectedDepositShares();\n    uint256 mintAmount = plugin.previewDeposit(depositAmount);\n\n    underlyingToken.approve(address(plugin), depositAmount);\n    plugin.mint(mintAmount, address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      this.getStrategyBalance(),\n      initialStrategyBalance + depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!transfer \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    assertApproxEqAbs(\n      plugin.totalAssets(),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalAssets \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.convertToAssets(plugin.balanceOf(address(this))),\n      depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!balOfUnderlying \", testPreFix))\n    );\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!mint \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      expectedDepositShare,\n      uint256(10),\n      string(abi.encodePacked(\"!depositShare \", testPreFix))\n    );\n\n    assertTrue(\n      underlyingToken.balanceOf(address(plugin)) <= 1,\n      string(abi.encodePacked(\"DotDot erc4626 locked amount checking \", testPreFix))\n    );\n\n    vm.startPrank(address(1));\n    underlyingToken.approve(address(plugin), depositAmount);\n    sendUnderlyingToken(depositAmount, address(1));\n    plugin.mint(mintAmount, address(1));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      this.getStrategyBalance(),\n      initialStrategyBalance + depositAmount + depositAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.transfer \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    assertApproxEqAbs(\n      depositAmount + depositAmount,\n      plugin.totalAssets(),\n      uint256(10),\n      string(abi.encodePacked(\"!2.totalAssets \", testPreFix))\n    );\n    assertApproxEqAbs(\n      depositAmount,\n      plugin.convertToAssets(plugin.balanceOf(address(1))),\n      uint256(10),\n      string(abi.encodePacked(\"!2.balOfUnderlying \", testPreFix))\n    );\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(1)),\n      mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.mint \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      mintAmount + mintAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.totalSupply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      expectedDepositShare * 2,\n      uint256(10),\n      string(abi.encodePacked(\"!2.depositShare \", testPreFix))\n    );\n\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(plugin)),\n      2,\n      uint256(2),\n      string(abi.encodePacked(\"2.DotDot erc4626 locked amount checking \", testPreFix))\n    );\n    vm.stopPrank();\n  }\n\n  function testWithdraw() public virtual {\n    uint256 depositShares = this.getExpectedDepositShares();\n\n    uint256 withdrawalAmount = 10e18;\n\n    deposit(address(this), depositAmount);\n\n    uint256 assetBalBefore = underlyingToken.balanceOf(address(this));\n    uint256 erc4626BalBefore = plugin.balanceOf(address(this));\n    uint256 expectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n    uint256 ExpectedDepositSharesNeeded = expectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n    );\n\n    plugin.withdraw(withdrawalAmount, address(this), address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!user asset bal \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      depositAmount - expectedErc4626SharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      erc4626BalBefore - expectedErc4626SharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!erc4626 supply \", testPreFix))\n    );\n    assertTrue(underlyingToken.balanceOf(address(plugin)) <= 1, string(abi.encodePacked(\"!0 \", testPreFix)));\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!dotDot share balance \", testPreFix))\n    );\n  }\n\n  function testWithdrawWithIncreasedVaultValue() public virtual {\n    uint256 depositShareBal = this.getExpectedDepositShares();\n\n    deposit(address(this), depositAmount);\n\n    uint256 withdrawalAmount = 10e18;\n\n    uint256 oldExpectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n    uint256 oldExpectedDepositSharesNeeded = oldExpectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n    );\n\n    plugin.withdraw(withdrawalAmount, address(this), address(this));\n\n    // Increase the share price\n    increaseAssetsInVault();\n\n    uint256 expectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n    uint256 ExpectedDepositSharesNeeded = expectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n    );\n\n    plugin.withdraw(withdrawalAmount, address(this), address(this));\n\n    // Test that we minted the correct amount of token\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      depositAmount - (oldExpectedErc4626SharesNeeded + expectedErc4626SharesNeeded),\n      uint256(10),\n      string(abi.encodePacked(\"!mint \", testPreFix))\n    );\n\n    // Test that we got less shares on the second mint after assets in the vault increased\n    assertLe(\n      expectedErc4626SharesNeeded,\n      oldExpectedErc4626SharesNeeded,\n      string(abi.encodePacked(\"!new shares < old Shares \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShareBal - (oldExpectedDepositSharesNeeded + ExpectedDepositSharesNeeded),\n      uint256(10),\n      string(abi.encodePacked(\"!depositShare \", testPreFix))\n    );\n  }\n\n  function testWithdrawWithDecreasedVaultValue() public {\n    // THIS TEST WILL ALWAYS FAIL\n    // A transfer out of the lpStaker will always fail.\n    // There also doesnt seem another way to reduce the balance of lpStaker so we cant test this scenario\n    /* =============== ACTUAL TEST =============== */\n    /*\n      sendUnderlyingToken(depositAmount, address(this));\n      uint256 depositShares = this.getExpectedDepositShares();\n      deposit(address(this), depositAmount);\n      uint256 withdrawalAmount = 10e18;\n      uint256 oldExpectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n      uint256 oldExpectedDepositSharesNeeded = oldExpectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n      );\n      plugin.withdraw(withdrawalAmount, address(this), address(this));\n      // Increase the share price\n      decreaseAssetsInVault();\n      uint256 expectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n      uint256 ExpectedDepositSharesNeeded = expectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n      );\n      plugin.withdraw(withdrawalAmount, address(this), address(this));\n      // Test that we minted the correct amount of token\n      assertApproxEqAbs(\n        plugin.balanceOf(address(this)),\n        depositAmount - (oldExpectedErc4626SharesNeeded + expectedErc4626SharesNeeded)\n      );\n      // Test that we got less shares on the second mint after assets in the vault increased\n      assertLe(expectedErc4626SharesNeeded, oldExpectedErc4626SharesNeeded, \"!new shares < old Shares\");\n      // Test that the ERC4626 holds the expected amount of dotDot shares\n      assertApproxEqAbs(\n        this.getDepositShares(),\n        depositShareBal - (oldExpectedDepositSharesNeeded + expectedDepositSharesNeeded)\n      );\n      */\n  }\n\n  function testMultipleWithdraw() public virtual {\n    uint256 depositShares = this.getExpectedDepositShares() * 2;\n\n    uint256 withdrawalAmount = 10e18;\n\n    deposit(address(this), depositAmount);\n\n    sendUnderlyingToken(depositAmount, address(1));\n    deposit(address(1), depositAmount);\n\n    uint256 assetBalBefore = underlyingToken.balanceOf(address(this));\n    uint256 erc4626BalBefore = plugin.balanceOf(address(this));\n    uint256 expectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n    uint256 ExpectedDepositSharesNeeded = expectedErc4626SharesNeeded.mulDivUp(\n      this.getDepositShares(),\n      plugin.totalSupply()\n    );\n\n    plugin.withdraw(10e18, address(this), address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!1.user asset bal\", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      depositAmount * 2 - expectedErc4626SharesNeeded,\n      plugin.totalSupply(),\n      10,\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      erc4626BalBefore - expectedErc4626SharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!1.erc4626 supply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!1.dotDot share balance \", testPreFix))\n    );\n\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(plugin)),\n      1,\n      1,\n      string(abi.encodePacked(\"1.DotDot erc4626 locked amount checking \", testPreFix))\n    );\n\n    uint256 totalSupplyBefore = depositAmount * 2 - expectedErc4626SharesNeeded;\n    depositShares = depositShares - ExpectedDepositSharesNeeded;\n    assetBalBefore = underlyingToken.balanceOf(address(1));\n    erc4626BalBefore = plugin.balanceOf(address(1));\n    expectedErc4626SharesNeeded = plugin.previewWithdraw(withdrawalAmount);\n    ExpectedDepositSharesNeeded = expectedErc4626SharesNeeded.mulDivUp(this.getDepositShares(), plugin.totalSupply());\n\n    vm.prank(address(1));\n    plugin.withdraw(10e18, address(1), address(1));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(1)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.user asset bal \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      totalSupplyBefore - expectedErc4626SharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!2.totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(1)),\n      erc4626BalBefore - expectedErc4626SharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!2.erc4626 supply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!2.dotDot share balance \", testPreFix))\n    );\n\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(plugin)),\n      2,\n      2,\n      string(abi.encodePacked(\"2.DotDot erc4626 locked amount checking \", testPreFix))\n    );\n  }\n\n  function testRedeem() public virtual {\n    uint256 depositShares = this.getExpectedDepositShares();\n\n    uint256 withdrawalAmount = 10e18;\n    uint256 redeemAmount = plugin.previewWithdraw(withdrawalAmount);\n\n    deposit(address(this), depositAmount);\n\n    uint256 assetBalBefore = underlyingToken.balanceOf(address(this));\n    uint256 erc4626BalBefore = plugin.balanceOf(address(this));\n    uint256 ExpectedDepositSharesNeeded = redeemAmount.mulDivUp(this.getDepositShares(), plugin.totalSupply());\n\n    plugin.withdraw(10e18, address(this), address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!user asset bal \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      depositAmount - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      erc4626BalBefore - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!erc4626 supply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!dotDot share balance \", testPreFix))\n    );\n  }\n\n  function testMultipleRedeem() public virtual {\n    uint256 depositShares = this.getExpectedDepositShares() * 2;\n\n    uint256 withdrawalAmount = 10e18;\n    uint256 redeemAmount = plugin.previewWithdraw(withdrawalAmount);\n\n    deposit(address(this), depositAmount);\n\n    sendUnderlyingToken(depositAmount, address(1));\n    deposit(address(1), depositAmount);\n\n    uint256 assetBalBefore = underlyingToken.balanceOf(address(this));\n    uint256 erc4626BalBefore = plugin.balanceOf(address(this));\n    uint256 ExpectedDepositSharesNeeded = redeemAmount.mulDivUp(this.getDepositShares(), plugin.totalSupply());\n\n    plugin.withdraw(10e18, address(this), address(this));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!1.user asset bal \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      depositAmount * 2 - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!1.totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      erc4626BalBefore - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!1.erc4626 supply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!1.dotDot share balance \", testPreFix))\n    );\n    assertTrue(\n      underlyingToken.balanceOf(address(plugin)) <= 1,\n      string(abi.encodePacked(\"1.DotDot erc4626 locked amount checking \", testPreFix))\n    );\n\n    uint256 totalSupplyBefore = depositAmount * 2 - redeemAmount;\n    depositShares -= ExpectedDepositSharesNeeded;\n    redeemAmount = plugin.previewWithdraw(withdrawalAmount);\n    assetBalBefore = underlyingToken.balanceOf(address(1));\n    erc4626BalBefore = plugin.balanceOf(address(1));\n    ExpectedDepositSharesNeeded = redeemAmount.mulDivUp(this.getDepositShares(), plugin.totalSupply());\n    vm.prank(address(1));\n    plugin.withdraw(10e18, address(1), address(1));\n\n    // Test that the actual transfers worked\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(1)),\n      assetBalBefore + withdrawalAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.user asset bal \", testPreFix))\n    );\n\n    // Test that the balance view calls work\n    // I just couldnt not calculate this properly. i was for some reason always ~ 1 BPS off\n    // uint256 expectedAssetsAfter = depositAmount - (ExpectedDepositSharesNeeded + (ExpectedDepositSharesNeeded / 1000));\n    //assertApproxEqAbs(plugin.totalAssets(), expectedAssetsAfter, \"!erc4626 asset bal\");\n    assertApproxEqAbs(\n      plugin.totalSupply(),\n      totalSupplyBefore - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.totalSupply \", testPreFix))\n    );\n\n    // Test that we burned the right amount of shares\n    assertApproxEqAbs(\n      plugin.balanceOf(address(1)),\n      erc4626BalBefore - redeemAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!2.erc4626 supply \", testPreFix))\n    );\n\n    // Test that the ERC4626 holds the expected amount of dotDot shares\n    assertApproxEqAbs(\n      this.getDepositShares(),\n      depositShares - ExpectedDepositSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!2.dotDot share balance \", testPreFix))\n    );\n    assertTrue(\n      underlyingToken.balanceOf(address(plugin)) <= 2,\n      string(abi.encodePacked(\"2.DotDot erc4626 locked amount checking \", testPreFix))\n    );\n  }\n\n  function testPauseContract() public {\n    uint256 withdrawAmount = 1e18;\n\n    deposit(address(this), depositAmount);\n\n    vm.warp(block.timestamp + 10);\n\n    plugin.emergencyWithdrawAndPause();\n\n    underlyingToken.approve(address(plugin), depositAmount);\n    vm.expectRevert(\"Pausable: paused\");\n    plugin.deposit(depositAmount, address(this));\n\n    vm.expectRevert(\"Pausable: paused\");\n    plugin.mint(depositAmount, address(this));\n\n    uint256 expectedSharesNeeded = withdrawAmount.mulDivDown(plugin.totalSupply(), plugin.totalAssets());\n    plugin.withdraw(withdrawAmount, address(this), address(this));\n\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      depositAmount - expectedSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!withdraw share bal \", testPreFix))\n    );\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      withdrawAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!withdraw asset bal \", testPreFix))\n    );\n\n    uint256 expectedAssets = withdrawAmount.mulDivUp(plugin.totalAssets(), plugin.totalSupply());\n    plugin.redeem(withdrawAmount, address(this), address(this));\n\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      depositAmount - withdrawAmount - expectedSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!redeem share bal \", testPreFix))\n    );\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      withdrawAmount + expectedAssets,\n      uint256(10),\n      string(abi.encodePacked(\"!redeem asset bal \", testPreFix))\n    );\n  }\n\n  function testEmergencyWithdrawAndPause() public virtual {\n    deposit(address(this), depositAmount);\n\n    uint256 expectedBal = plugin.previewRedeem(depositAmount);\n    assertEq(underlyingToken.balanceOf(address(plugin)), 0, string(abi.encodePacked(\"!init 0 \", testPreFix)));\n\n    plugin.emergencyWithdrawAndPause();\n\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(plugin)),\n      expectedBal,\n      uint256(10),\n      string(abi.encodePacked(\"!withdraws underlying \", testPreFix))\n    );\n    assertApproxEqAbs(\n      plugin.totalAssets(),\n      expectedBal,\n      uint256(10),\n      string(abi.encodePacked(\"!totalAssets == expectedBal \", testPreFix))\n    );\n  }\n\n  function testEmergencyWithdrawAndRedeem() public {\n    uint256 withdrawAmount = 1e18;\n\n    deposit(address(this), depositAmount);\n\n    vm.warp(block.timestamp + 10);\n\n    plugin.emergencyWithdrawAndPause();\n\n    uint256 expectedSharesNeeded = withdrawAmount.mulDivDown(plugin.totalSupply(), plugin.totalAssets());\n    plugin.withdraw(withdrawAmount, address(this), address(this));\n\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      depositAmount - expectedSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!withdraw share bal \", testPreFix))\n    );\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      withdrawAmount,\n      uint256(10),\n      string(abi.encodePacked(\"!withdraw asset bal \", testPreFix))\n    );\n\n    uint256 expectedAssets = withdrawAmount.mulDivUp(plugin.totalAssets(), plugin.totalSupply());\n    plugin.redeem(withdrawAmount, address(this), address(this));\n\n    assertApproxEqAbs(\n      plugin.balanceOf(address(this)),\n      depositAmount - withdrawAmount - expectedSharesNeeded,\n      uint256(10),\n      string(abi.encodePacked(\"!redeem share bal \", testPreFix))\n    );\n    assertApproxEqAbs(\n      underlyingToken.balanceOf(address(this)),\n      withdrawAmount + expectedAssets,\n      uint256(10),\n      string(abi.encodePacked(\"!redeem asset bal \", testPreFix))\n    );\n  }\n}\n"
    },
    "contracts/test/abstracts/ITestConfigStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ITestConfigStorage {\n  function getTestConfig(uint256 i) external view returns (bytes memory);\n\n  function getTestConfigLength() external view returns (uint256);\n}\n"
    },
    "contracts/test/AccountLiquidityTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { UpgradesBaseTest } from \"./UpgradesBaseTest.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { PoolLensSecondary } from \"../PoolLensSecondary.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\ncontract AccountLiquidityTest is UpgradesBaseTest {\n  IonicComptroller pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n  PoolLensSecondary lens2 = PoolLensSecondary(0x7Ea7BB80F3bBEE9b52e6Ed3775bA06C9C80D4154);\n\n  ICErc20 wethMarket;\n  ICErc20 usdcMarket;\n  ICErc20 usdtMarket;\n  ICErc20 wbtcMarket;\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    if (block.chainid == MODE_MAINNET) {\n      wethMarket = ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2);\n      usdcMarket = ICErc20(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038);\n      usdtMarket = ICErc20(0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3);\n      wbtcMarket = ICErc20(0xd70254C3baD29504789714A7c69d60Ec1127375C);\n    } else {\n      ICErc20[] memory markets = pool.getAllMarkets();\n      wethMarket = markets[0];\n      usdcMarket = markets[1];\n    }\n  }\n\n  function testModeAccountLiquidity() public debuggingOnly fork(MODE_MAINNET) {\n    _testAccountLiquidity(0x0C387030a5D3AcDcde1A8DDaF26df31BbC1CE763);\n  }\n\n  function _testAccountLiquidity(address borrower) internal {\n    (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(borrower);\n\n    emit log(\"\");\n    emit log_named_address(\"user\", borrower);\n    emit log_named_uint(\"collateralValue\", collateralValue);\n    if (liquidity > 0) emit log_named_uint(\"liquidity\", liquidity);\n    if (shortfall > 0) emit log_named_uint(\"SHORTFALL\", shortfall);\n  }\n\n  function testUserMaxWithdraw() public debuggingOnly forkAtBlock(MODE_MAINNET, 5890823) {\n    address user = 0xBf891E7eFCC98A8239385D3172bA10AD593c7886;\n\n    Unitroller asUnitroller = Unitroller(payable(address(pool)));\n    _upgradePoolWithExtension(asUnitroller);\n\n    {\n      _testAccountLiquidity(user);\n\n      uint256 maxRedeem = lens2.getMaxRedeem(user, wethMarket);\n      emit log_named_uint(\"maxRedeem\", maxRedeem);\n\n      bool isMember = pool.checkMembership(user, wethMarket);\n      emit log(isMember ? \"is member\" : \"NOT A MEMBER\");\n    }\n    //vm.rollFork(5891795);\n    // redeemed before liquidation at 5890822\n\n    // before withdraw call at block 5890821\n    //  user: 0xBf891E7eFCC98A8239385D3172bA10AD593c7886\n    //  collateralValue: 156238264982770748812\n    //  liquidity: 16428491404549045373\n    //  maxRedeem: 23469273435070064818\n    //  is member\n\n    // user calls withdraw with max(uint256) at block 5890822\n    //  user: 0xBf891E7eFCC98A8239385D3172bA10AD593c7886\n    //  collateralValue: 139809773853485792955\n    //  SHORTFALL: 257892668904\n    //  maxRedeem: 0\n    //  is member\n\n    // liquidated at 5890902\n    // https://explorer.mode.network/tx/0x424fd0504e7afb00382c6dcd25a2efdefd96c005c2333112be450fc7bd98cc88\n  }\n}\n"
    },
    "contracts/test/AccrueInterestTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { UpgradesBaseTest } from \"./UpgradesBaseTest.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { CTokenFirstExtension, DiamondExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { InterestRateModel } from \"../compound/InterestRateModel.sol\";\n\nstruct AccrualDiff {\n  uint256 borrowIndex;\n  uint256 totalBorrows;\n  uint256 totalReserves;\n  uint256 totalIonicFees;\n  uint256 totalAdminFees;\n}\n\ncontract AccrueInterestTest is UpgradesBaseTest {\n  // fork before the accrue interest refactoring\n  function testAccrueInterest() public debuggingOnly forkAtBlock(BSC_MAINNET, 26032460) {\n    address busdMarketAddress = 0xa7213deB44f570646Ea955771Cc7f39B58841363;\n    address wbnbMarketAddress = 0x57a64a77f8E4cFbFDcd22D5551F52D675cc5A956;\n\n    _testAccrueInterest(wbnbMarketAddress);\n  }\n\n  function _testAccrueInterest(address marketAddress) internal {\n    //CErc20Delegate market = CErc20Delegate(marketAddress);\n    CTokenFirstExtension marketAsExt = CTokenFirstExtension(marketAddress);\n    ICErc20 market = ICErc20(marketAddress);\n\n    uint256 adminFeeMantissa = market.adminFeeMantissa();\n    uint256 ionicFeeMantissa = market.ionicFeeMantissa();\n    uint256 reserveFactorMantissa = market.reserveFactorMantissa();\n\n    // test with the logic before the refactoring\n\n    AccrualDiff memory diffBefore;\n    // accrue at the latest block in order to have an equal/comparable accrual period\n    marketAsExt.accrueInterest();\n    {\n      CTokenFirstExtension.InterestAccrual memory accrualDataBefore;\n      CTokenFirstExtension.InterestAccrual memory accrualDataAfter;\n\n      accrualDataBefore.accrualBlockNumber = marketAsExt.accrualBlockNumber();\n      accrualDataBefore.borrowIndex = marketAsExt.borrowIndex();\n      accrualDataBefore.totalBorrows = marketAsExt.totalBorrows();\n      accrualDataBefore.totalReserves = marketAsExt.totalReserves();\n      accrualDataBefore.totalIonicFees = marketAsExt.totalIonicFees();\n      accrualDataBefore.totalAdminFees = marketAsExt.totalAdminFees();\n      accrualDataBefore.totalSupply = marketAsExt.totalSupply();\n\n      vm.roll(block.number + 1e6); // move 1M blocks forward\n      marketAsExt.accrueInterest();\n\n      accrualDataAfter.accrualBlockNumber = marketAsExt.accrualBlockNumber();\n      accrualDataAfter.borrowIndex = marketAsExt.borrowIndex();\n      accrualDataAfter.totalBorrows = marketAsExt.totalBorrows();\n      accrualDataAfter.totalReserves = marketAsExt.totalReserves();\n      accrualDataAfter.totalIonicFees = marketAsExt.totalIonicFees();\n      accrualDataAfter.totalAdminFees = marketAsExt.totalAdminFees();\n      accrualDataAfter.totalSupply = marketAsExt.totalSupply();\n\n      assertEq(\n        accrualDataBefore.accrualBlockNumber,\n        accrualDataAfter.accrualBlockNumber - 1e6,\n        \"!total supply old impl\"\n      );\n      assertLt(accrualDataBefore.borrowIndex, accrualDataAfter.borrowIndex, \"!borrow index old impl\");\n      assertLt(accrualDataBefore.totalBorrows, accrualDataAfter.totalBorrows, \"!total borrows old impl\");\n      if (reserveFactorMantissa > 0) {\n        assertLt(accrualDataBefore.totalReserves, accrualDataAfter.totalReserves, \"!total reserves old impl\");\n      }\n      if (ionicFeeMantissa > 0) {\n        assertLt(accrualDataBefore.totalIonicFees, accrualDataAfter.totalIonicFees, \"!total ionic fees old impl\");\n      }\n      if (adminFeeMantissa > 0) {\n        assertLt(accrualDataBefore.totalAdminFees, accrualDataAfter.totalAdminFees, \"!total admin fees old impl\");\n      }\n      assertEq(accrualDataBefore.totalSupply, accrualDataAfter.totalSupply, \"!total supply old impl\");\n\n      diffBefore.borrowIndex = accrualDataAfter.borrowIndex - accrualDataBefore.borrowIndex;\n      diffBefore.totalBorrows = accrualDataAfter.totalBorrows - accrualDataBefore.totalBorrows;\n      diffBefore.totalReserves = accrualDataAfter.totalReserves - accrualDataBefore.totalReserves;\n      diffBefore.totalIonicFees = accrualDataAfter.totalIonicFees - accrualDataBefore.totalIonicFees;\n      diffBefore.totalAdminFees = accrualDataAfter.totalAdminFees - accrualDataBefore.totalAdminFees;\n    }\n\n    // test with the logic after the refactoring\n    vm.rollFork(26032460);\n    afterForkSetUp();\n    _upgradeMarketWithExtension(market);\n\n    AccrualDiff memory diffAfter;\n    // accrue at the latest block in order to have an equal/comparable accrual period\n    marketAsExt.accrueInterest();\n    {\n      CTokenFirstExtension.InterestAccrual memory accrualDataBefore;\n      CTokenFirstExtension.InterestAccrual memory accrualDataAfter;\n\n      accrualDataBefore.accrualBlockNumber = marketAsExt.accrualBlockNumber();\n      accrualDataBefore.borrowIndex = marketAsExt.borrowIndex();\n      accrualDataBefore.totalBorrows = marketAsExt.totalBorrows();\n      accrualDataBefore.totalReserves = marketAsExt.totalReserves();\n      accrualDataBefore.totalIonicFees = marketAsExt.totalIonicFees();\n      accrualDataBefore.totalAdminFees = marketAsExt.totalAdminFees();\n      accrualDataBefore.totalSupply = marketAsExt.totalSupply();\n\n      vm.roll(block.number + 1e6); // move 1M blocks forward\n      marketAsExt.accrueInterest();\n\n      accrualDataAfter.accrualBlockNumber = marketAsExt.accrualBlockNumber();\n      accrualDataAfter.borrowIndex = marketAsExt.borrowIndex();\n      accrualDataAfter.totalBorrows = marketAsExt.totalBorrows();\n      accrualDataAfter.totalReserves = marketAsExt.totalReserves();\n      accrualDataAfter.totalIonicFees = marketAsExt.totalIonicFees();\n      accrualDataAfter.totalAdminFees = marketAsExt.totalAdminFees();\n      accrualDataAfter.totalSupply = marketAsExt.totalSupply();\n\n      assertEq(\n        accrualDataBefore.accrualBlockNumber,\n        accrualDataAfter.accrualBlockNumber - 1e6,\n        \"!total supply old impl\"\n      );\n      assertLt(accrualDataBefore.borrowIndex, accrualDataAfter.borrowIndex, \"!borrow index new impl\");\n      assertLt(accrualDataBefore.totalBorrows, accrualDataAfter.totalBorrows, \"!total borrows new impl\");\n      if (reserveFactorMantissa > 0) {\n        assertLt(accrualDataBefore.totalReserves, accrualDataAfter.totalReserves, \"!total reserves new impl\");\n      }\n      if (ionicFeeMantissa > 0) {\n        assertLt(accrualDataBefore.totalIonicFees, accrualDataAfter.totalIonicFees, \"!total ionic fees new impl\");\n      }\n      if (adminFeeMantissa > 0) {\n        assertLt(accrualDataBefore.totalAdminFees, accrualDataAfter.totalAdminFees, \"!total admin fees new impl\");\n      }\n      assertEq(accrualDataBefore.totalSupply, accrualDataAfter.totalSupply, \"!total supply new impl\");\n\n      diffAfter.borrowIndex = accrualDataAfter.borrowIndex - accrualDataBefore.borrowIndex;\n      diffAfter.totalBorrows = accrualDataAfter.totalBorrows - accrualDataBefore.totalBorrows;\n      diffAfter.totalReserves = accrualDataAfter.totalReserves - accrualDataBefore.totalReserves;\n      diffAfter.totalIonicFees = accrualDataAfter.totalIonicFees - accrualDataBefore.totalIonicFees;\n      diffAfter.totalAdminFees = accrualDataAfter.totalAdminFees - accrualDataBefore.totalAdminFees;\n    }\n\n    assertEq(diffBefore.borrowIndex, diffAfter.borrowIndex, \"!borrowIndexDiff\");\n    assertEq(diffBefore.totalBorrows, diffAfter.totalBorrows, \"!totalBorrowsDiff\");\n    assertEq(diffBefore.totalReserves, diffAfter.totalReserves, \"!totalReservesDiff\");\n    assertEq(diffBefore.totalIonicFees, diffAfter.totalIonicFees, \"!totalIonicFeesDiff\");\n    assertEq(diffBefore.totalAdminFees, diffAfter.totalAdminFees, \"!totalAdminFeesDiff\");\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function testMintGated() public fork(POLYGON_MAINNET) {\n    address newMarket = 0x71A7037a42D0fB9F905a76B7D16846b2EACC59Aa;\n    address assetWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n    // approve spending\n    vm.startPrank(assetWhale);\n    IERC20Upgradeable(CErc20Delegate(newMarket).underlying()).approve(newMarket, 1e6);\n    require(CErc20Delegate(newMarket).mint(1e6) == 0, \"!mint failed\");\n    vm.stopPrank();\n  }\n\n  function testDeployCToken() public debuggingOnly fork(POLYGON_MAINNET) {\n    CErc20Delegate cErc20Delegate = new CErc20Delegate();\n    IonicComptroller pool = IonicComptroller(0x69617fE545804BcDfE853626B4C8EF23475Ac54B);\n    emit log_named_address(\"admin\", pool.admin());\n    pool.adminHasRights();\n    vm.startPrank(0x9308dddeC9B5cCd8a2685A46E913C892FE31C826);\n    pool._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(0xb5DFABd7fF7F83BAB83995E72A52B97ABb7bcf63),\n        0x69617fE545804BcDfE853626B4C8EF23475Ac54B,\n        payable(address(0x62E27eA8d0389390039277CFfD83Ca18ce9B2D9c)),\n        InterestRateModel(address(0xA433B7d3a8A87D8fd40dA68A424007Dd8a21Ce41)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(0),\n        uint256(0)\n      ),\n      \"\",\n      0.72e18\n    );\n    vm.stopPrank();\n    // _functionCall(0xC40119C7269A5FA813d878BF83d14E3462fC8Fde, hex\"8f93bfba\", \"raw liquidation failed\");\n  }\n\n  function testDeployNeonPool() public debuggingOnly fork(NEON_MAINNET) {\n    PoolDirectory poolDirectory = PoolDirectory(0x297a15F615aCdf87580af1Fc497EE57424975Dae);\n    FeeDistributor ionicAdmin = FeeDistributor(payable(0x62E27eA8d0389390039277CFfD83Ca18ce9B2D9c));\n    Comptroller tempComptroller = new Comptroller();\n    vm.prank(ionicAdmin.owner());\n    ionicAdmin._setLatestComptrollerImplementation(address(0), address(tempComptroller));\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = new ComptrollerFirstExtension();\n    extensions[1] = tempComptroller;\n    vm.prank(ionicAdmin.owner());\n    ionicAdmin._setComptrollerExtensions(address(tempComptroller), extensions);\n    vm.prank(ionicAdmin.owner());\n    (, address comptrollerAddress) = poolDirectory.deployPool(\n      \"TestPool\",\n      address(tempComptroller),\n      abi.encode(payable(address(ionicAdmin))), // FD\n      false,\n      0.1e18,\n      1.1e18,\n      0xBAAb9986A7002ad67cb5a9C1761210C2Cdd98BFa // MPO\n    );\n  }\n}\n"
    },
    "contracts/test/AnyLiquidationTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { IonicLiquidator, ILiquidator } from \"../IonicLiquidator.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\nimport { CurveLpTokenPriceOracleNoRegistry } from \"../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\nimport { CurveV2LpTokenPriceOracleNoRegistry } from \"../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\nimport { ICurvePool } from \"../external/curve/ICurvePool.sol\";\nimport { IFundsConversionStrategy } from \"../liquidators/IFundsConversionStrategy.sol\";\nimport { IRedemptionStrategy } from \"../liquidators/IRedemptionStrategy.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { IUniswapV2Router02 } from \"../external/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV2Pair } from \"../external/uniswap/IUniswapV2Pair.sol\";\nimport { IUniswapV2Factory } from \"../external/uniswap/IUniswapV2Factory.sol\";\n\ncontract AnyLiquidationTest is BaseTest {\n  IonicLiquidator fsl;\n  address uniswapRouter;\n  mapping(address => address) assetSpecificRouters;\n\n  IFundsConversionStrategy[] fundingStrategies;\n  bytes[] fundingDatas;\n\n  IRedemptionStrategy[] redemptionStrategies;\n  bytes[] redemptionDatas;\n\n  IUniswapV2Pair mostLiquidPair1;\n  IUniswapV2Pair mostLiquidPair2;\n\n  CurveLpTokenPriceOracleNoRegistry curveV1Oracle;\n  CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle;\n\n  function upgradeAp() internal {\n    AddressesProvider newImpl = new AddressesProvider();\n    newImpl.initialize(address(this));\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(ap)));\n    bytes32 bytesAtSlot = vm.load(address(proxy), _ADMIN_SLOT);\n    address admin = address(uint160(uint256(bytesAtSlot)));\n    vm.prank(admin);\n    proxy.upgradeTo(address(newImpl));\n  }\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uniswapRouter = ap.getAddress(\"IUniswapV2Router02\");\n    curveV1Oracle = CurveLpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\"));\n    curveV2Oracle = CurveV2LpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveV2LpTokenPriceOracleNoRegistry\"));\n\n    if (block.chainid == BSC_MAINNET) {\n      mostLiquidPair1 = IUniswapV2Pair(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16); // WBNB-BUSD\n      mostLiquidPair2 = IUniswapV2Pair(0x61EB789d75A95CAa3fF50ed7E47b96c132fEc082); // WBNB-BTCB\n      fsl = IonicLiquidator(payable(ap.getAddress(\"IonicLiquidator\")));\n      //      fsl = new IonicLiquidator();\n      //      fsl.initialize(\n      //        ap.getAddress(\"wtoken\"),\n      //        uniswapRouter,\n      //        ap.getAddress(\"stableToken\"),\n      //        ap.getAddress(\"wBTCToken\"),\n      //        \"0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\",\n      //        25\n      //      );\n\n      // TODO configure in the AP?\n      address bnbx = 0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275;\n      address apeSwapRouter = 0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7;\n      assetSpecificRouters[bnbx] = apeSwapRouter;\n    } else if (block.chainid == POLYGON_MAINNET) {\n      mostLiquidPair1 = IUniswapV2Pair(0x6e7a5FAFcec6BB1e78bAE2A1F0B612012BF14827); // USDC/WMATIC\n      mostLiquidPair2 = IUniswapV2Pair(0x369582d2010B6eD950B571F4101e3bB9b554876F); // SAND/WMATIC\n      fsl = IonicLiquidator(payable(ap.getAddress(\"IonicLiquidator\")));\n      //      fsl = new IonicLiquidator();\n      //      fsl.initialize(\n      //        ap.getAddress(\"wtoken\"),\n      //        uniswapRouter,\n      //        ap.getAddress(\"stableToken\"),\n      //        ap.getAddress(\"wBTCToken\"),\n      //        \"0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\",\n      //        30\n      //      );\n    }\n  }\n\n  function testSpecificRandom() public debuggingOnly {\n    testPolygonAnyLiquidation(14341);\n    //    testPolygonAnyLiquidation(101);\n  }\n\n  function testBscAnyLiquidation(uint256 random) public fork(BSC_MAINNET) {\n    vm.assume(random > 100 && random < type(uint64).max);\n    doTestAnyLiquidation(random);\n  }\n\n  function testPolygonAnyLiquidation(uint256 random) public fork(POLYGON_MAINNET) {\n    vm.assume(random > 100 && random < type(uint64).max);\n    doTestAnyLiquidation(random);\n  }\n\n  struct LiquidationData {\n    IRedemptionStrategy[] strategies;\n    bytes[] redemptionDatas;\n    ICErc20[] markets;\n    address[] borrowers;\n    IonicLiquidator liquidator;\n    IFundsConversionStrategy[] fundingStrategies;\n    bytes[] fundingDatas;\n    ICErc20 debtMarket;\n    ICErc20 collateralMarket;\n    IonicComptroller comptroller;\n    address borrower;\n    uint256 repayAmount;\n    address flashSwapFundingToken;\n    IUniswapV2Pair flashSwapPair;\n  }\n\n  function getPoolAndBorrower(uint256 random, PoolDirectory.Pool[] memory pools)\n    internal\n    view\n    returns (IonicComptroller, address)\n  {\n    if (pools.length == 0) revert(\"no pools to pick from\");\n\n    uint256 i = random % pools.length; // random pool\n    IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n\n    address bscBombPool = 0x5373C052Df65b317e48D6CAD8Bb8AC50995e9459;\n    if (address(comptroller) == bscBombPool) {\n      // we don't want to deal with the bomb liquidations\n      return (IonicComptroller(address(0)), address(0));\n    }\n\n    address[] memory borrowers = comptroller.getAllBorrowers();\n\n    if (borrowers.length == 0) {\n      return (IonicComptroller(address(0)), address(0));\n    } else {\n      uint256 k = random % borrowers.length; // random borrower\n      address borrower = borrowers[k];\n\n      return (comptroller, borrower);\n    }\n  }\n\n  function setUpDebtAndCollateralMarkets(uint256 random, LiquidationData memory vars)\n    internal\n    returns (\n      ICErc20 debtMarket,\n      ICErc20 collateralMarket,\n      uint256 borrowAmount\n    )\n  {\n    // find a debt market in which the borrower has borrowed\n    for (uint256 m = 0; m < vars.markets.length; m++) {\n      uint256 marketIndexWithOffset = (random + m) % vars.markets.length;\n      ICErc20 randomMarket = vars.markets[marketIndexWithOffset];\n      borrowAmount = randomMarket.borrowBalanceCurrent(vars.borrower);\n      if (borrowAmount > 0) {\n        debtMarket = ICErc20(address(randomMarket));\n        break;\n      }\n    }\n\n    if (address(debtMarket) != address(0)) {\n      emit log(\"debt market is\");\n      emit log_address(address(debtMarket));\n\n      uint256 shortfall = 0;\n      // reduce the price of the collateral for each market where the borrower has supplied\n      // until there is shortfall for which to be liquidated\n      for (uint256 m = 0; m < vars.markets.length; m++) {\n        uint256 marketIndexWithOffset = (random - m) % vars.markets.length;\n        ICErc20 randomMarket = vars.markets[marketIndexWithOffset];\n        uint256 borrowerCollateral = randomMarket.balanceOf(vars.borrower);\n        if (borrowerCollateral > 0) {\n          if (address(randomMarket) == address(debtMarket)) continue;\n\n          // the collateral prices change\n          BasePriceOracle mpo = vars.comptroller.oracle();\n          uint256 priceCollateral = mpo.getUnderlyingPrice(randomMarket);\n          vm.mockCall(\n            address(mpo),\n            abi.encodeWithSelector(mpo.getUnderlyingPrice.selector, randomMarket),\n            abi.encode(priceCollateral / 5)\n          );\n\n          uint256 collateralValue = borrowerCollateral * (priceCollateral / 5);\n          uint256 borrowValue = borrowAmount * mpo.getUnderlyingPrice(debtMarket);\n\n          if (collateralValue < borrowValue) {\n            emit log(\"collateral position too small\");\n            continue;\n          }\n\n          (, , , shortfall) = vars.comptroller.getAccountLiquidity(vars.borrower);\n          if (shortfall == 0) {\n            emit log(\"collateral still enough\");\n            continue;\n          } else {\n            emit log(\"has shortfall\");\n            collateralMarket = ICErc20(address(randomMarket));\n            break;\n          }\n        }\n      }\n      if (shortfall == 0) {\n        return (ICErc20(address(0)), ICErc20(address(0)), 0);\n      }\n    }\n  }\n\n  function doTestAnyLiquidation(uint256 random) internal {\n    LiquidationData memory vars;\n    vars.liquidator = fsl;\n\n    (, PoolDirectory.Pool[] memory pools) = PoolDirectory(ap.getAddress(\"PoolDirectory\")).getActivePools();\n\n    uint256 initRandom = random;\n    while (true) {\n      // get a random pool and a random borrower from it\n      (vars.comptroller, vars.borrower) = getPoolAndBorrower(random, pools);\n\n      if (address(vars.comptroller) != address(0) && vars.borrower != address(0)) {\n        // find a market in which the borrower has debt and reduce his collateral price\n        vars.markets = vars.comptroller.getAllMarkets();\n        (vars.debtMarket, vars.collateralMarket, vars.repayAmount) = setUpDebtAndCollateralMarkets(random, vars);\n\n        if (address(vars.debtMarket) != address(0) && address(vars.collateralMarket) != address(0)) {\n          if (vars.debtMarket.underlying() != ap.getAddress(\"wtoken\")) {\n            emit log(\"found testable markets at random number\");\n            emit log_uint(random);\n            break;\n          }\n        }\n      }\n      // fail gracefully when there are no positions to liquidate\n      if (random - initRandom < 100) return;\n      random++;\n    }\n\n    vars.repayAmount = vars.repayAmount / 100;\n    liquidateSpecificPosition(vars);\n  }\n\n  function liquidateSpecificPosition(LiquidationData memory vars) internal {\n    emit log(\"debt and collateral markets\");\n    emit log_address(address(vars.debtMarket));\n    emit log_address(address(vars.collateralMarket));\n\n    // prepare the liquidation\n\n    // add funding strategies\n    {\n      address debtTokenToFund = vars.debtMarket.underlying();\n      uint256 i = 0;\n      while (true) {\n        emit log(\"funding token\");\n        emit log_address(debtTokenToFund);\n        if (i++ > 10) revert(\"endless loop bad\");\n\n        AddressesProvider.FundingStrategy memory strategy = ap.getFundingStrategy(debtTokenToFund);\n        if (strategy.addr == address(0)) break;\n\n        debtTokenToFund = addFundingStrategy(\n          vars,\n          IFundsConversionStrategy(strategy.addr),\n          debtTokenToFund,\n          strategy.contractInterface,\n          strategy.inputToken\n        );\n      }\n\n      vars.flashSwapFundingToken = debtTokenToFund;\n      if (vars.flashSwapFundingToken != ap.getAddress(\"wtoken\")) {\n        IUniswapV2Router02 router = IUniswapV2Router02(uniswapRouter);\n        address pairAddress = IUniswapV2Factory(router.factory()).getPair(\n          vars.flashSwapFundingToken,\n          ap.getAddress(\"wtoken\")\n        );\n        if (pairAddress != address(0)) {\n          vars.flashSwapPair = IUniswapV2Pair(pairAddress);\n        } else {\n          revert(\"no pair for flash swap funding\");\n        }\n      } else {\n        vars.flashSwapPair = IUniswapV2Pair(mostLiquidPair1);\n      }\n\n      vars.fundingStrategies = fundingStrategies;\n      vars.fundingDatas = fundingDatas;\n    }\n\n    emit log(\"flash swap funding token is\");\n    emit log_address(vars.flashSwapFundingToken);\n\n    address exchangeCollateralTo = vars.flashSwapFundingToken;\n\n    // add the redemption strategies\n    if (exchangeCollateralTo != address(0)) {\n      address collateralTokenToRedeem = vars.collateralMarket.underlying();\n      while (collateralTokenToRedeem != exchangeCollateralTo) {\n        // TODO\n        AddressesProvider.RedemptionStrategy memory strategy = ap.getRedemptionStrategy(collateralTokenToRedeem);\n        if (strategy.addr == address(0)) break;\n        collateralTokenToRedeem = addRedemptionStrategy(\n          vars,\n          IRedemptionStrategy(strategy.addr),\n          strategy.contractInterface,\n          collateralTokenToRedeem,\n          strategy.outputToken\n        );\n      }\n      vars.redemptionDatas = redemptionDatas;\n      vars.strategies = redemptionStrategies;\n    }\n\n    // liquidate\n    vm.prank(ap.owner());\n    try\n      vars.liquidator.safeLiquidateToTokensWithFlashLoan(\n        ILiquidator.LiquidateToTokensWithFlashSwapVars(\n          vars.borrower,\n          vars.repayAmount,\n          ICErc20(address(vars.debtMarket)),\n          ICErc20(address(vars.collateralMarket)),\n          address(vars.flashSwapPair),\n          0,\n          vars.strategies,\n          vars.redemptionDatas,\n          vars.fundingStrategies,\n          vars.fundingDatas\n        )\n      )\n    {\n      // noop\n    } catch Error(string memory reason) {\n      if (compareStrings(reason, \"Number of tokens less than minimum limit\")) {\n        emit log(\"jarvis pool failing, that's ok\");\n      } else {\n        revert(reason);\n      }\n    }\n  }\n\n  function getUniswapV2Router(address inputToken) internal view returns (address) {\n    address router = assetSpecificRouters[inputToken];\n    return router != address(0) ? router : uniswapRouter;\n  }\n\n  function toggleFlashSwapPair(LiquidationData memory vars) internal view {\n    if (address(vars.flashSwapPair) == address(mostLiquidPair1)) {\n      vars.flashSwapPair = mostLiquidPair2;\n    } else {\n      vars.flashSwapPair = mostLiquidPair1;\n    }\n  }\n\n  function addRedemptionStrategy(\n    LiquidationData memory vars,\n    IRedemptionStrategy strategy,\n    string memory strategyContract,\n    address inputToken,\n    address strategyOutputToken\n  ) internal returns (address) {\n    address outputToken;\n    bytes memory strategyData;\n\n    if (compareStrings(strategyContract, \"CurveLpTokenLiquidatorNoRegistry\")) {\n      address[] memory underlyingTokens = curveV1Oracle.getUnderlyingTokens(inputToken);\n      (address preferredOutputToken, uint8 outputTokenIndex) = pickPreferredToken(\n        underlyingTokens,\n        strategyOutputToken\n      );\n      emit log(\"preferred token\");\n      emit log_address(preferredOutputToken);\n      emit log_uint(outputTokenIndex);\n      outputToken = preferredOutputToken;\n      if (outputToken == address(0) || outputToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n        outputToken = ap.getAddress(\"wtoken\");\n      }\n\n      strategyData = abi.encode(preferredOutputToken, ap.getAddress(\"wtoken\"), address(curveV1Oracle));\n    } else if (compareStrings(strategyContract, \"SaddleLpTokenLiquidator\")) {\n      address[] memory underlyingTokens = curveV1Oracle.getUnderlyingTokens(inputToken);\n      (address preferredOutputToken, ) = pickPreferredToken(underlyingTokens, strategyOutputToken);\n      outputToken = preferredOutputToken;\n      if (outputToken == address(0) || outputToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n        outputToken = ap.getAddress(\"wtoken\");\n      }\n      strategyData = abi.encode(preferredOutputToken, curveV1Oracle, ap.getAddress(\"wtoken\"));\n    } else if (\n      compareStrings(strategyContract, \"UniswapLpTokenLiquidator\") ||\n      compareStrings(strategyContract, \"GelatoGUniLiquidator\")\n    ) {\n      IUniswapV2Pair pair = IUniswapV2Pair(inputToken);\n      address[] memory swapToken0Path;\n      address[] memory swapToken1Path;\n\n      if (pair.token0() == strategyOutputToken) {\n        swapToken0Path = new address[](0);\n        swapToken1Path = new address[](2);\n\n        swapToken1Path[0] = pair.token1();\n        swapToken1Path[1] = pair.token0();\n        outputToken = swapToken1Path[1];\n      } else {\n        swapToken0Path = new address[](2);\n        swapToken1Path = new address[](0);\n\n        swapToken0Path[0] = pair.token0();\n        swapToken0Path[1] = pair.token1();\n        outputToken = swapToken0Path[1];\n      }\n\n      strategyData = abi.encode(uniswapRouter, swapToken0Path, swapToken1Path);\n\n      if (address(vars.flashSwapPair) == address(pair)) {\n        emit log(\"toggling the flashswap pair\");\n        emit log_address(address(pair));\n        toggleFlashSwapPair(vars);\n      }\n    } else if (compareStrings(strategyContract, \"UniswapV2LiquidatorFunder\")) {\n      outputToken = strategyOutputToken;\n\n      address[] memory swapPath = new address[](2);\n      swapPath[0] = inputToken;\n      swapPath[1] = outputToken;\n\n      strategyData = abi.encode(getUniswapV2Router(inputToken), swapPath);\n    } else if (compareStrings(strategyContract, \"JarvisLiquidatorFunder\")) {\n      AddressesProvider.JarvisPool[] memory pools = ap.getJarvisPools();\n      for (uint256 i = 0; i < pools.length; i++) {\n        AddressesProvider.JarvisPool memory pool = pools[i];\n        if (pool.syntheticToken == inputToken) {\n          strategyData = abi.encode(pool.syntheticToken, pool.liquidityPool, pool.expirationTime);\n          outputToken = pool.collateralToken;\n          break;\n        }\n      }\n    } else if (compareStrings(strategyContract, \"CurveSwapLiquidator\")) {\n      outputToken = strategyOutputToken;\n      strategyData = abi.encode(curveV1Oracle, curveV2Oracle, inputToken, outputToken, ap.getAddress(\"wtoken\"));\n    } else if (compareStrings(strategyContract, \"BalancerLpTokenLiquidator\")) {\n      outputToken = strategyOutputToken;\n      strategyData = abi.encode(outputToken);\n    } else if (compareStrings(strategyContract, \"XBombLiquidatorFunder\")) {\n      outputToken = strategyOutputToken;\n      address xbomb = inputToken;\n      address bomb = outputToken;\n      strategyData = abi.encode(inputToken, xbomb, bomb);\n    } else if (compareStrings(strategyContract, \"AlgebraSwapLiquidator\")) {\n      address ALGEBRA_SWAP_ROUTER = 0x327Dd3208f0bCF590A66110aCB6e5e6941A4EfA0;\n      outputToken = strategyOutputToken;\n      strategyData = abi.encode(outputToken, ALGEBRA_SWAP_ROUTER);\n    } else {\n      emit log(strategyContract);\n      emit log_address(address(strategy));\n      revert(\"unknown collateral\");\n    }\n\n    vm.prank(vars.liquidator.owner());\n    vars.liquidator._whitelistRedemptionStrategy(strategy, true);\n    redemptionStrategies.push(strategy);\n    redemptionDatas.push(strategyData);\n\n    assertEq(outputToken, strategyOutputToken, \"!expected output token\");\n    return outputToken;\n  }\n\n  //  function getCurvePoolUnderlyingTokens(address lpTokenAddress) internal view returns (address[] memory) {\n  //    ICurvePool curvePool = ICurvePool(lpTokenAddress);\n  //    uint8 i = 0;\n  //    while (true) {\n  //      try curvePool.coins(i) {\n  //        i++;\n  //      } catch {\n  //        break;\n  //      }\n  //    }\n  //    address[] memory tokens = new address[](i);\n  //    for (uint8 j = 0; j < i; j++) {\n  //      tokens[j] = curvePool.coins(j);\n  //    }\n  //    return tokens;\n  //  }\n\n  function pickPreferredToken(address[] memory tokens, address strategyOutputToken)\n    internal\n    view\n    returns (address, uint8)\n  {\n    address wtoken = ap.getAddress(\"wtoken\");\n    address stable = ap.getAddress(\"stableToken\");\n    address wbtc = ap.getAddress(\"wBTCToken\");\n\n    for (uint8 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == strategyOutputToken) return (strategyOutputToken, i);\n    }\n    for (uint8 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == wtoken) return (wtoken, i);\n    }\n    for (uint8 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == stable) return (stable, i);\n    }\n    for (uint8 i = 0; i < tokens.length; i++) {\n      if (tokens[i] == wbtc) return (wbtc, i);\n    }\n    return (tokens[0], 0);\n  }\n\n  function addFundingStrategy(\n    LiquidationData memory vars,\n    IFundsConversionStrategy strategy,\n    address debtToken,\n    string memory strategyContract,\n    address strategyInputToken\n  ) internal returns (address) {\n    address inputToken;\n    bytes memory strategyData;\n\n    if (compareStrings(strategyContract, \"JarvisLiquidatorFunder\")) {\n      AddressesProvider.JarvisPool[] memory pools = ap.getJarvisPools();\n      for (uint256 i = 0; i < pools.length; i++) {\n        AddressesProvider.JarvisPool memory pool = pools[i];\n        if (pool.syntheticToken == debtToken) {\n          strategyData = abi.encode(pool.collateralToken, pool.liquidityPool, pool.expirationTime);\n          inputToken = pool.collateralToken;\n          break;\n        }\n      }\n\n      // } else if (compareStrings(strategyContract, \"SomeOtherFunder\")) {\n      // bytes memory strategyData = abi.encode(strategySpecificParams);\n      // (IERC20Upgradeable inputToken, uint256 inputAmount) = IFundsConversionStrategy(addr).estimateInputAmount(10**(debtToken.decimals()), strategyData);\n      // fundingStrategies.push(new SomeOtherFunder());\n      // return inputToken;\n    } else if (compareStrings(strategyContract, \"CurveSwapLiquidatorFunder\")) {\n      inputToken = strategyInputToken;\n      strategyData = abi.encode(curveV1Oracle, curveV2Oracle, inputToken, debtToken, ap.getAddress(\"wtoken\"));\n    } else if (compareStrings(strategyContract, \"UniswapV3LiquidatorFunder\")) {\n      inputToken = strategyInputToken;\n\n      uint24 fee = 1000;\n      address quoter = ap.getAddress(\"Quoter\");\n      address swapRouter;\n      {\n        // TODO\n        // polygon config // 0x1F98431c8aD98523631AE4a59f267346ea31F984\n        address polygonSwapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n        swapRouter = polygonSwapRouter;\n        fee = 500;\n      }\n\n      strategyData = abi.encode(inputToken, debtToken, fee, swapRouter, quoter);\n    } else {\n      emit log(strategyContract);\n      emit log_address(debtToken);\n      revert(\"unknown debt token\");\n    }\n\n    fundingDatas.push(strategyData);\n\n    vm.prank(vars.liquidator.owner());\n    vars.liquidator._whitelistRedemptionStrategy(strategy, true);\n    fundingStrategies.push(strategy);\n\n    assertEq(strategyInputToken, inputToken, \"!expected input token\");\n    return inputToken;\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function testRawLiquidation() public debuggingOnly fork(MODE_MAINNET) {\n    vm.prank(0x1110DECC92083fbcae218a8478F75B2Ad1b9AEe6);\n    _functionCall(\n      0xa12c1E460c06B1745EFcbfC9A1f666a8749B0e3A,\n      hex\"55e9e8fe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000fda4ac09a12c10fae30e429f4d6b47c9a83c87e00000000000000000000000000000000000000000000000001797af2fe6e167700000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d200000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000468cc91df6f669cae6cdce766995bd7874052fbc0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000000010000000000000000000000005ca3fd2c285c4138185ef1bda7573d415020f3c80000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000400000000000000000000000004200000000000000000000000000000000000006000000000000000000000000ac48fcf1049668b285f3dc72483df5ae2162f7e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n      \"raw liquidation failed\"\n    );\n  }\n}\n"
    },
    "contracts/test/AuthoritiesRegistryTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport \"../ionic/AuthoritiesRegistry.sol\";\nimport \"./helpers/WithPool.sol\";\nimport { RolesAuthority, Authority } from \"solmate/auth/authorities/RolesAuthority.sol\";\n\ncontract AuthoritiesRegistryTest is WithPool {\n  AuthoritiesRegistry registry;\n\n  function afterForkSetUp() internal override {\n    registry = AuthoritiesRegistry(ap.getAddress(\"AuthoritiesRegistry\"));\n    if (address(registry) == address(0)) {\n      address proxyAdmin = address(999);\n      AuthoritiesRegistry impl = new AuthoritiesRegistry();\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), proxyAdmin, \"\");\n      registry = AuthoritiesRegistry(address(proxy));\n      registry.initialize(address(1023));\n    }\n\n    super.setUpWithPool(\n      MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\")),\n      ERC20Upgradeable(ap.getAddress(\"wtoken\"))\n    );\n\n    setUpPool(\"auth-reg-test\", false, 0.1e18, 1.1e18);\n  }\n\n  function testRegistry() public fork(POLYGON_MAINNET) {\n    PoolRolesAuthority auth;\n\n    vm.prank(address(555));\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n    auth = registry.createPoolAuthority(address(comptroller));\n\n    vm.prank(registry.owner());\n    auth = registry.createPoolAuthority(address(comptroller));\n\n    assertEq(auth.owner(), registry.owner(), \"!same owner\");\n  }\n\n  function testAuthReconfigurePermissions() public fork(POLYGON_MAINNET) {\n    vm.prank(registry.owner());\n    PoolRolesAuthority auth = registry.createPoolAuthority(address(comptroller));\n\n    vm.prank(address(8283));\n    vm.expectRevert(\"not owner or pool\");\n    registry.reconfigureAuthority(address(comptroller));\n\n    vm.prank(registry.owner());\n    registry.reconfigureAuthority(address(comptroller));\n  }\n\n  function upgradeRegistry() internal {\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(registry)));\n    AuthoritiesRegistry newImpl = new AuthoritiesRegistry();\n    vm.startPrank(dpa.owner());\n    dpa.upgradeAndCall(\n      proxy,\n      address(newImpl),\n      abi.encodeWithSelector(AuthoritiesRegistry.reinitialize.selector, registry.leveredPositionsFactory())\n    );\n    vm.stopPrank();\n  }\n\n  function upgradeAuth(PoolRolesAuthority auth) internal {\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(auth)));\n    PoolRolesAuthority newImpl = new PoolRolesAuthority();\n    vm.prank(dpa.owner());\n    dpa.upgrade(proxy, address(newImpl));\n  }\n\n  function testAuthPermissions() public debuggingOnly fork(BSC_CHAPEL) {\n    address pool = 0xa4bc2fCF2F9d87EB349f74f8729024F92A030330;\n    registry = AuthoritiesRegistry(0xa5E190Fa38F325617381e835da8b2DB2D12cE5eb);\n    //upgradeRegistry();\n\n    PoolRolesAuthority auth = PoolRolesAuthority(0xFe5AfFFC8b55A2d139cb2ef76699C8B58c1EA299);\n    //upgradeAuth(auth);\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(auth)));\n\n    vm.prank(address(dpa));\n    emit log_named_address(\"proxy.implementation\", proxy.implementation());\n\n    emit log_named_address(\"registry.poolAuthLogic\", address(registry.poolAuthLogic()));\n    //vm.prank(registry.owner());\n    //registry.reconfigureAuthority(pool);\n\n    bool isReg = auth.doesUserHaveRole(address(registry), auth.REGISTRY_ROLE());\n    assertEq(isReg, true, \"!not registry role\");\n\n    bool canCall = auth.canCall(address(registry), address(auth), RolesAuthority.setUserRole.selector);\n    assertEq(canCall, true, \"!cannot call setUserRol\");\n  }\n}\n"
    },
    "contracts/test/caps/AdrastiaPrudentiaCapsTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { Comptroller } from \"../../compound/Comptroller.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { Unitroller } from \"../../compound/Unitroller.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { CErc20Delegate } from \"../../compound/CErc20Delegate.sol\";\nimport { JumpRateModel } from \"../../compound/JumpRateModel.sol\";\nimport { ComptrollerPrudentiaCapsExt, DiamondExtension } from \"../../compound/ComptrollerPrudentiaCapsExt.sol\";\nimport { FeeDistributor } from \"../../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../../PoolDirectory.sol\";\nimport { InterestRateModel } from \"../../compound/InterestRateModel.sol\";\nimport { CTokenFirstExtension } from \"../../compound/CTokenFirstExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../../compound/ComptrollerFirstExtension.sol\";\nimport { ComptrollerV4Storage } from \"../../compound/ComptrollerStorage.sol\";\nimport { AuthoritiesRegistry } from \"../../ionic/AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../../ionic/PoolRolesAuthority.sol\";\nimport { PrudentiaLib } from \"../../adrastia/PrudentiaLib.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { MockPriceOracle } from \"../../oracles/1337/MockPriceOracle.sol\";\n\nimport \"adrastia-periphery/rates/IHistoricalRates.sol\";\n\nabstract contract HistoricalRates is IHistoricalRates {\n  struct BufferMetadata {\n    uint8 start;\n    uint8 end;\n    uint8 size;\n    uint8 maxSize;\n    bool pauseUpdates; // Note: this is left for extentions, but is not used in this contract.\n  }\n\n  /// @notice Event emitted when a rate buffer's capacity is increased past the initial capacity.\n  /// @dev Buffer initialization does not emit an event.\n  /// @param token The token for which the rate buffer's capacity was increased.\n  /// @param oldCapacity The previous capacity of the rate buffer.\n  /// @param newCapacity The new capacity of the rate buffer.\n  event RatesCapacityIncreased(address indexed token, uint256 oldCapacity, uint256 newCapacity);\n\n  /// @notice Event emitted when a rate buffer's capacity is initialized.\n  /// @param token The token for which the rate buffer's capacity was initialized.\n  /// @param capacity The capacity of the rate buffer.\n  event RatesCapacityInitialized(address indexed token, uint256 capacity);\n\n  /// @notice Event emitted when a new rate is pushed to the rate buffer.\n  /// @param token The token for which the rate was pushed.\n  /// @param target The target rate.\n  /// @param current The current rate, which may be different from the target rate if the rate change is capped.\n  /// @param timestamp The timestamp at which the rate was pushed.\n  event RateUpdated(address indexed token, uint256 target, uint256 current, uint256 timestamp);\n\n  /// @notice An error that is thrown if we try to initialize a rate buffer that has already been initialized.\n  /// @param token The token for which we tried to initialize the rate buffer.\n  error BufferAlreadyInitialized(address token);\n\n  /// @notice An error that is thrown if we try to retrieve a rate at an invalid index.\n  /// @param token The token for which we tried to retrieve the rate.\n  /// @param index The index of the rate that we tried to retrieve.\n  /// @param size The size of the rate buffer.\n  error InvalidIndex(address token, uint256 index, uint256 size);\n\n  /// @notice An error that is thrown if we try to decrease the capacity of a rate buffer.\n  /// @param token The token for which we tried to decrease the capacity of the rate buffer.\n  /// @param amount The capacity that we tried to decrease the rate buffer to.\n  /// @param currentCapacity The current capacity of the rate buffer.\n  error CapacityCannotBeDecreased(address token, uint256 amount, uint256 currentCapacity);\n\n  /// @notice An error that is thrown if we try to increase the capacity of a rate buffer past the maximum capacity.\n  /// @param token The token for which we tried to increase the capacity of the rate buffer.\n  /// @param amount The capacity that we tried to increase the rate buffer to.\n  /// @param maxCapacity The maximum capacity of the rate buffer.\n  error CapacityTooLarge(address token, uint256 amount, uint256 maxCapacity);\n\n  /// @notice An error that is thrown if we try to retrieve more rates than are available in the rate buffer.\n  /// @param token The token for which we tried to retrieve the rates.\n  /// @param size The size of the rate buffer.\n  /// @param minSizeRequired The minimum size of the rate buffer that we require.\n  error InsufficientData(address token, uint256 size, uint256 minSizeRequired);\n\n  /// @notice The initial capacity of the rate buffer.\n  uint8 internal immutable initialBufferCardinality;\n\n  /// @notice Maps a token to its metadata.\n  mapping(address => BufferMetadata) internal rateBufferMetadata;\n\n  /// @notice Maps a token to a buffer of rates.\n  mapping(address => RateLibrary.Rate[]) internal rateBuffers;\n\n  /**\n   * @notice Constructs the HistoricalRates contract with a specified initial buffer capacity.\n   * @param initialBufferCardinality_ The initial capacity of the rate buffer.\n   */\n  constructor(uint8 initialBufferCardinality_) {\n    initialBufferCardinality = initialBufferCardinality_;\n  }\n\n  /// @inheritdoc IHistoricalRates\n  function getRateAt(address token, uint256 index) external view virtual override returns (RateLibrary.Rate memory) {\n    BufferMetadata memory meta = rateBufferMetadata[token];\n\n    if (index >= meta.size) {\n      revert InvalidIndex(token, index, meta.size);\n    }\n\n    uint256 bufferIndex = meta.end < index ? meta.end + meta.size - index : meta.end - index;\n\n    return rateBuffers[token][bufferIndex];\n  }\n\n  /// @inheritdoc IHistoricalRates\n  function getRates(address token, uint256 amount) external view virtual override returns (RateLibrary.Rate[] memory) {\n    return _getRates(token, amount, 0, 1);\n  }\n\n  /// @inheritdoc IHistoricalRates\n  function getRates(\n    address token,\n    uint256 amount,\n    uint256 offset,\n    uint256 increment\n  ) external view virtual override returns (RateLibrary.Rate[] memory) {\n    return _getRates(token, amount, offset, increment);\n  }\n\n  /// @inheritdoc IHistoricalRates\n  function getRatesCount(address token) external view override returns (uint256) {\n    return rateBufferMetadata[token].size;\n  }\n\n  /// @inheritdoc IHistoricalRates\n  function getRatesCapacity(address token) external view virtual override returns (uint256) {\n    uint256 maxSize = rateBufferMetadata[token].maxSize;\n    if (maxSize == 0) return initialBufferCardinality;\n\n    return maxSize;\n  }\n\n  /// @param amount The new capacity of rates for the token. Must be greater than the current capacity, but\n  ///   less than 256.\n  /// @inheritdoc IHistoricalRates\n  function setRatesCapacity(address token, uint256 amount) external virtual {\n    _setRatesCapacity(token, amount);\n  }\n\n  /**\n   * @dev Internal function to set the capacity of the rate buffer for a token.\n   * @param token The token for which to set the new capacity.\n   * @param amount The new capacity of rates for the token. Must be greater than the current capacity, but\n   * less than 256.\n   */\n  function _setRatesCapacity(address token, uint256 amount) internal virtual {\n    BufferMetadata storage meta = rateBufferMetadata[token];\n\n    if (amount < meta.maxSize) revert CapacityCannotBeDecreased(token, amount, meta.maxSize);\n    if (amount > type(uint8).max) revert CapacityTooLarge(token, amount, type(uint8).max);\n\n    RateLibrary.Rate[] storage rateBuffer = rateBuffers[token];\n\n    // Add new slots to the buffer\n    uint256 capacityToAdd = amount - meta.maxSize;\n    for (uint256 i = 0; i < capacityToAdd; ++i) {\n      // Push a dummy rate with non-zero values to put most of the gas cost on the caller\n      rateBuffer.push(RateLibrary.Rate({ target: 1, current: 1, timestamp: 1 }));\n    }\n\n    if (meta.maxSize != amount) {\n      emit RatesCapacityIncreased(token, meta.maxSize, amount);\n\n      // Update the metadata\n      meta.maxSize = uint8(amount);\n    }\n  }\n\n  /**\n   * @dev Internal function to get historical rates with specified amount, offset, and increment.\n   * @param token The token for which to retrieve the rates.\n   * @param amount The number of historical rates to retrieve.\n   * @param offset The number of rates to skip before starting to collect the rates.\n   * @param increment The step size between the rates to collect.\n   * @return observations An array of Rate structs containing the retrieved historical rates.\n   */\n  function _getRates(\n    address token,\n    uint256 amount,\n    uint256 offset,\n    uint256 increment\n  ) internal view virtual returns (RateLibrary.Rate[] memory) {\n    if (amount == 0) return new RateLibrary.Rate[](0);\n\n    BufferMetadata memory meta = rateBufferMetadata[token];\n    if (meta.size <= (amount - 1) * increment + offset)\n      revert InsufficientData(token, meta.size, (amount - 1) * increment + offset + 1);\n\n    RateLibrary.Rate[] memory observations = new RateLibrary.Rate[](amount);\n\n    uint256 count = 0;\n\n    for (\n      uint256 i = meta.end < offset ? meta.end + meta.size - offset : meta.end - offset;\n      count < amount;\n      i = (i < increment) ? (i + meta.size) - increment : i - increment\n    ) {\n      observations[count++] = rateBuffers[token][i];\n    }\n\n    return observations;\n  }\n\n  /**\n   * @dev Internal function to initialize rate buffers for a token.\n   * @param token The token for which to initialize the rate buffer.\n   */\n  function initializeBuffers(address token) internal virtual {\n    if (rateBuffers[token].length != 0) {\n      revert BufferAlreadyInitialized(token);\n    }\n\n    BufferMetadata storage meta = rateBufferMetadata[token];\n\n    // Initialize the buffers\n    RateLibrary.Rate[] storage observationBuffer = rateBuffers[token];\n\n    for (uint256 i = 0; i < initialBufferCardinality; ++i) {\n      observationBuffer.push();\n    }\n\n    // Initialize the metadata\n    meta.start = 0;\n    meta.end = 0;\n    meta.size = 0;\n    meta.maxSize = initialBufferCardinality;\n    meta.pauseUpdates = false;\n\n    emit RatesCapacityInitialized(token, meta.maxSize);\n  }\n\n  /**\n   * @dev Internal function to push a new rate data into the rate buffer and update metadata accordingly.\n   * @param token The token for which to push the new rate data.\n   * @param rate The Rate struct containing target rate, current rate, and timestamp data to be pushed.\n   */\n  function push(address token, RateLibrary.Rate memory rate) internal virtual {\n    BufferMetadata storage meta = rateBufferMetadata[token];\n\n    if (meta.size == 0) {\n      if (meta.maxSize == 0) {\n        // Initialize the buffers\n        initializeBuffers(token);\n      }\n    } else {\n      meta.end = (meta.end + 1) % meta.maxSize;\n    }\n\n    rateBuffers[token][meta.end] = rate;\n\n    emit RateUpdated(token, rate.target, rate.current, block.timestamp);\n\n    if (meta.size < meta.maxSize && meta.end == meta.size) {\n      // We are at the end of the array and we have not yet filled it\n      meta.size++;\n    } else {\n      // start was just overwritten\n      meta.start = (meta.start + 1) % meta.size;\n    }\n  }\n}\n\ncontract PrudentiaStub is HistoricalRates {\n  constructor() HistoricalRates(2) {}\n\n  function stubPush(address underlyingToken, uint64 rate) public {\n    push(underlyingToken, RateLibrary.Rate({ target: rate, current: rate, timestamp: uint32(block.timestamp) }));\n  }\n}\n\ncontract AdrastiaPrudentiaCapsTest is BaseTest {\n  FeeDistributor ionicAdmin;\n  PoolDirectory poolDirectory;\n\n  IonicComptroller comptroller;\n\n  InterestRateModel interestModel;\n  MockPriceOracle priceOracle;\n\n  MockERC20 underlyingToken1;\n  ICErc20 cToken1;\n\n  MockERC20 underlyingToken2;\n  ICErc20 cToken2;\n\n  MockERC20 underlyingToken3;\n  ICErc20 cToken3;\n\n  CErc20Delegate cErc20Delegate;\n\n  PrudentiaStub prudentia;\n\n  function setUp() public {\n    // Deploy admin contracts\n    ionicAdmin = new FeeDistributor();\n    ionicAdmin.initialize(1e16);\n    poolDirectory = new PoolDirectory();\n    poolDirectory.initialize(false, new address[](0));\n\n    // Deploy comptroller logic\n    Comptroller comptrollerLogic = new Comptroller();\n\n    // Deploy underlying tokens\n    underlyingToken1 = new MockERC20(\"UnderlyingToken1\", \"UT1\", 18);\n    underlyingToken1.mint(address(this), 1000000e18); // 1M tokens\n    underlyingToken2 = new MockERC20(\"UnderlyingToken2\", \"UT2\", 18);\n    underlyingToken2.mint(address(this), 1000000e18); // 1M tokens\n    underlyingToken3 = new MockERC20(\"UnderlyingToken3\", \"UT3\", 6);\n    underlyingToken3.mint(address(this), 1000000e6); // 1M tokens\n\n    // Deploy cToken delegates\n    cErc20Delegate = new CErc20Delegate();\n\n    // Deploy price oracle\n    priceOracle = new MockPriceOracle(10);\n\n    // Deploy IRM\n    interestModel = new JumpRateModel(2343665, 1e18, 1e18, 4e18, 0.8e18);\n\n    // Deploy comptroller\n    address[] memory unitroller = new address[](1);\n    unitroller[0] = address(comptrollerLogic);\n    address[] memory addressZero = new address[](1);\n    addressZero[0] = address(0);\n    bool[] memory boolTrue = new bool[](1);\n    boolTrue[0] = true;\n    bool[] memory boolFalse = new bool[](1);\n    boolFalse[0] = false;\n    ionicAdmin._setLatestComptrollerImplementation(address(0), address(comptrollerLogic));\n    DiamondExtension[] memory extensions = new DiamondExtension[](3);\n    extensions[0] = new ComptrollerFirstExtension();\n    extensions[1] = new ComptrollerPrudentiaCapsExt();\n    extensions[2] = comptrollerLogic;\n    ionicAdmin._setComptrollerExtensions(address(comptrollerLogic), extensions);\n    (, address comptrollerAddress) = poolDirectory.deployPool(\n      \"TestPool\", // name\n      address(comptrollerLogic), // implementation address\n      abi.encode(payable(address(ionicAdmin))), // constructor args\n      false, // whitelist enforcement\n      0.1e18, // close factor = 10%\n      1.1e18, // liquidation incentive = 110%\n      address(priceOracle) // price oracle\n    );\n    Unitroller(payable(comptrollerAddress))._acceptAdmin();\n    comptroller = IonicComptroller(comptrollerAddress);\n\n    AuthoritiesRegistry impl = new AuthoritiesRegistry();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n    AuthoritiesRegistry newAr = AuthoritiesRegistry(address(proxy));\n    newAr.initialize(address(321));\n    ionicAdmin.reinitialize(newAr);\n    PoolRolesAuthority poolAuth = newAr.createPoolAuthority(comptrollerAddress);\n    newAr.setUserRole(comptrollerAddress, address(this), poolAuth.BORROWER_ROLE(), true);\n    newAr.setUserRole(comptrollerAddress, address(ionicAdmin), poolAuth.SUPPLIER_ROLE(), true);\n\n    // Setup CErc20Delegate whitelist\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](1);\n    cErc20DelegateExtensions[0] = new CTokenFirstExtension();\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20Delegate), cErc20DelegateExtensions);\n    address[] memory oldCErc20Implementations = new address[](1);\n    oldCErc20Implementations[0] = address(0);\n    address[] memory newCErc20Implementations = new address[](1);\n    newCErc20Implementations[0] = address(cErc20Delegate);\n    ionicAdmin._setLatestCErc20Delegate(cErc20Delegate.delegateType(), address(cErc20Delegate), \"\");\n\n    // Deploy cToken1\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken1), // underlying token\n        comptroller, // comptroller\n        payable(address(ionicAdmin)), // admin\n        InterestRateModel(address(interestModel)), // interest rate model\n        \"cToken 1\", // cToken name\n        \"CT1\", // cToken symbol\n        uint256(1), // reserve factor\n        uint256(0) // admin fee\n      ),\n      \"\",\n      0.9e18 // collateral factor = 90%\n    );\n\n    // Deploy cToken2\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken2), // underlying token\n        comptroller, // comptroller\n        payable(address(ionicAdmin)), // admin\n        InterestRateModel(address(interestModel)), // interest rate model\n        \"cToken 2\", // cToken name\n        \"CT2\", // cToken symbol\n        uint256(1), // reserve factor\n        uint256(0) // admin fee\n      ),\n      \"\",\n      0.9e18 // collateral factor = 90%\n    );\n\n    // Deploy cToken3\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken3), // underlying token\n        comptroller, // comptroller\n        payable(address(ionicAdmin)), // admin\n        InterestRateModel(address(interestModel)), // interest rate model\n        \"cToken 3\", // cToken name\n        \"CT3\", // cToken symbol\n        uint256(1), // reserve factor\n        uint256(0) // admin fee\n      ),\n      \"\",\n      0.9e18 // collateral factor = 90%\n    );\n\n    // Store the cToken addresses\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    assertEq(allMarkets.length, 3);\n    cToken1 = allMarkets[0];\n    cToken2 = allMarkets[1];\n    cToken3 = allMarkets[2];\n\n    // Deploy Prudentia\n    prudentia = new PrudentiaStub();\n  }\n\n  function test_NativeCaps_UnrestrictedSupply() public {\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), 0); // No supply cap set (unrestricted)\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n  }\n\n  function test_NativeCaps_RestrictedSupply() public {\n    uint256 cap = 9999e18; // supply cap of 9,999\n    uint256 mintAmount = 10000e18; // mint of 10,000\n\n    // Set a native supply cap for cToken1\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = cap;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cTokens[0])), supplyCaps[0]);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_NativeCaps_UnrestrictedBorrow() public {\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken1)), 0); // No borrow cap set (unrestricted)\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Borrow\n    cToken2.borrow(1000e18); // Borrow 1,000 cToken2\n  }\n\n  function test_NativeCaps_RestrictedBorrow() public {\n    uint256 cap = 999e18; // borrow cap of 999\n    uint256 borrowAmount = 1000e18; // borrow of 1,000\n\n    // Set a native borrow cap for cToken2\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = cap;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cTokens[0])), borrowCaps[0]);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0\n   */\n\n  function test_Prudentia_Supply_Unrestricted() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_MissingRate() public {\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Note: Prudentia doesn't have a supply cap for cToken1\n\n    vm.expectRevert();\n    comptroller.effectiveSupplyCaps(address(cToken1)); // FAIL: Supply cap\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Supply_MissingRate_WithRateConfiguredForAnotherCToken() public {\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), 0); // Unrestricted supply cap for cToken2\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken2)), 0); // Unrestricted\n\n    // Note: Prudentia doesn't have a supply cap for cToken1\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Supply_LessThanCap() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e18);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 10001e18; // mint of 10,001\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e18);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Borrow_LessThanCap() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e18);\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_Unrestricted() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), cap); // Unrestricted\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_MissingRate() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    vm.expectRevert();\n    comptroller.effectiveBorrowCaps(address(cToken2)); // FAIL: Missing rate\n\n    // Note: Prudentia doesn't have a borrow cap for cToken2\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  function test_Prudentia_Borrow_MissingRate_WithRateConfiguredForAnotherCToken() public {\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), 0); // Unrestricted borrow cap for cToken1\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken1)), 0); // Unrestricted\n\n    // Note: Prudentia doesn't have a borrow cap for cToken2\n\n    vm.expectRevert();\n    comptroller.effectiveBorrowCaps(address(cToken2)); // FAIL: Missing rate\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e18; // borrow of 1,001\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e18);\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0 and a decimal shift of 1\n   */\n\n  function test_Prudentia_Supply_Unrestricted_DecShiftPos1() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_MissingRate_DecShiftPos1() public {\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Note: Prudentia doesn't have a supply cap for cToken1\n\n    vm.expectRevert();\n    comptroller.effectiveSupplyCaps(address(cToken1)); // FAIL: Missing rate\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Supply_LessThanCap_DecShiftPos1() public {\n    uint64 cap = 10000 / 10; // supply cap of 10,000\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e19);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_DecShiftPos1() public {\n    uint64 cap = 10000 / 10; // supply cap of 10,000\n    uint256 mintAmount = 10001e18; // mint of 10,001\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e19);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_DecShiftPos1() public {\n    uint64 cap = 1000 / 10; // borrow cap of 1,000\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e19);\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_DecShiftPos1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), cap); // Unrestricted\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_MissingRate_DecShiftPos1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Note: Prudentia doesn't have a borrow cap for cToken2\n\n    vm.expectRevert();\n    comptroller.effectiveBorrowCaps(address(cToken2)); // FAIL: Missing rate\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_DecShiftPos1() public {\n    uint64 cap = 1000 / 10; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e18; // borrow of 1,001\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e19);\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0 and a decimal shift of -1\n   */\n\n  function test_Prudentia_Supply_Unrestricted_DecShiftNeg1() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_MissingRate_DecShiftNeg1() public {\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Note: Prudentia doesn't have a supply cap for cToken1\n\n    vm.expectRevert();\n    comptroller.effectiveSupplyCaps(address(cToken1)); // FAIL: Missing rate\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Supply_LessThanCap_DecShiftNeg1() public {\n    uint64 cap = 10000 * 10; // supply cap of 10,000\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e17);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_DecShiftNeg1() public {\n    uint64 cap = 10000 * 10; // supply cap of 10,000\n    uint256 mintAmount = 10001e18; // mint of 10,001\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e17);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_DecShiftNeg1() public {\n    uint64 cap = 1000 * 10; // borrow cap of 1,000\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e17);\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_DecShiftNeg1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), cap); // Unrestricted\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_MissingRate_DecShiftNeg1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Note: Prudentia doesn't have a borrow cap for cToken2\n\n    vm.expectRevert();\n    comptroller.effectiveBorrowCaps(address(cToken2)); // FAIL: Missing rate\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_DecShiftNeg1() public {\n    uint64 cap = 1000 * 10; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e18; // borrow of 1,001\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e17);\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0 and using a cToken with the underlying token having 6 decimals\n   */\n\n  function test_Prudentia_Supply_Unrestricted_6UnderlyingDecimals() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_LessThanCap_6UnderlyingDecimals() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e6);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_6UnderlyingDecimals() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 10001e6; // mint of 10,001\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e6);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken3.mint(mintAmount); // FAIL: Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 0);\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_6UnderlyingDecimals() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e6);\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_6UnderlyingDecimals() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), cap); // Unrestricted\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_6UnderlyingDecimals() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e6; // borrow of 1,001\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e6);\n\n    // Borrow\n    vm.expectRevert();\n    cToken3.borrow(borrowAmount); // FAIL: Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6);\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0, using a cToken with the underlying token having 6 decimals,\n   * and a decimalShift of 1\n   */\n\n  function test_Prudentia_Supply_Unrestricted_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_LessThanCap_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 10000 / 10; // supply cap of 10,000\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e7);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 10000 / 10; // supply cap of 10,000\n    uint256 mintAmount = 10001e6; // mint of 10,001\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e7);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken3.mint(mintAmount); // FAIL: Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 0);\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 1000 / 10; // borrow cap of 1,000\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e7);\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), cap); // Unrestricted\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_6UnderlyingDecimals_DecShiftPos1() public {\n    uint64 cap = 1000 / 10; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e6; // borrow of 1,001\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: 1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e7);\n\n    // Borrow\n    vm.expectRevert();\n    cToken3.borrow(borrowAmount); // FAIL: Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6);\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 0, using a cToken with the underlying token having 6 decimals,\n   * and a decimalShift of -1\n   */\n\n  function test_Prudentia_Supply_Unrestricted_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_LessThanCap_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 10000 * 10; // supply cap of 10,000\n    uint256 mintAmount = 9999e6; // mint of 9,999\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e5);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(mintAmount); // Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), mintAmount);\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 10000 * 10; // supply cap of 10,000\n    uint256 mintAmount = 10001e6; // mint of 10,001\n\n    // Set a native supply cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia supply cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken3)), uint256(cap) * 1e5);\n\n    // Mint\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken3.mint(mintAmount); // FAIL: Mint\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 0);\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 1000 * 10; // borrow cap of 1,000\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e5);\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e6; // borrow of 999\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), cap); // Unrestricted\n\n    // Borrow\n    cToken3.borrow(borrowAmount); // Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6 - borrowAmount);\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_6UnderlyingDecimals_DecShiftNeg1() public {\n    uint64 cap = 1000 * 10; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e6; // borrow of 1,001\n\n    // Set a native borrow cap for cToken3\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken3;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken3\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken3.approve(address(cToken3), type(uint256).max); // Approve max\n    cToken3.mint(10000e6); // Mint 10,000 cToken3\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 0, decimalShift: -1 })\n    );\n\n    // Set Prudentia borrow cap for cToken3\n    prudentia.stubPush(address(underlyingToken3), cap);\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken3)), uint256(cap) * 1e5);\n\n    // Borrow\n    vm.expectRevert();\n    cToken3.borrow(borrowAmount); // FAIL: Borrow\n\n    assertEq(underlyingToken3.balanceOf(address(cToken3)), 10000e6);\n  }\n\n  /*\n   * Prudentia caps tests with an offset of 1\n   */\n\n  function test_Prudentia_Supply_Unrestricted_Offset1() public {\n    uint64 cap = 0; // Unrestricted supply cap\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap); // Unrestricted cap at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken1), 1); // Highly restrictive cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), cap); // Unrestricted\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_MissingRate_Offset1() public {\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Note: Prudentia doesn't have a supply cap for cToken1 at index 1 (the offset)\n    prudentia.stubPush(address(underlyingToken1), 0); // Unrestricted cap at index 0. If this cap is used, the test should fail.\n\n    vm.expectRevert();\n    comptroller.effectiveSupplyCaps(address(cToken1)); // FAIL: Missing rate\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Supply_LessThanCap_Offset1() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 9999e18; // mint of 9,999\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap); // The cap we're using at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken1), 1); // Highly restrictive cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e18);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(mintAmount); // Mint\n  }\n\n  function test_Prudentia_Supply_GreaterThanCap_Offset1() public {\n    uint64 cap = 10000; // supply cap of 10,000\n    uint256 mintAmount = 10001e18; // mint of 10,001\n\n    // Set a native supply cap for cToken1\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken1;\n    uint256[] memory supplyCaps = new uint256[](1);\n    supplyCaps[0] = 1;\n    comptroller._setMarketSupplyCaps(cTokens, supplyCaps);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia supply cap for cToken1\n    prudentia.stubPush(address(underlyingToken1), cap); // The cap we're using at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken1), 0); // Unrestricted cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveSupplyCaps(address(cToken1)), uint256(cap) * 1e18);\n\n    // Mint\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    vm.expectRevert();\n    cToken1.mint(mintAmount); // FAIL: Mint\n  }\n\n  function test_Prudentia_Borrow_LessThanCap_Offset1() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap); // The cap we're using at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken2), 1); // Highly restrictive cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e18);\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_Unrestricted_Offset1() public {\n    uint64 cap = 0; // Unrestricted borrow cap\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap); // The cap we're using at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken2), 1); // Highly restrictive cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), cap); // Unrestricted\n\n    // Borrow\n    cToken2.borrow(borrowAmount); // Borrow\n  }\n\n  function test_Prudentia_Borrow_MissingRate_Offset1() public {\n    uint256 borrowAmount = 999e18; // borrow of 999\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Note: Prudentia doesn't have a borrow cap for cToken2 at index 1 (the offset)\n    prudentia.stubPush(address(underlyingToken2), 0); // Unrestricted cap at index 0. If this cap is used, the test should fail.\n\n    vm.expectRevert();\n    comptroller.effectiveBorrowCaps(address(cToken2)); // FAIL: Missing rate\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  function test_Prudentia_Borrow_GreaterThanCap_Offset1() public {\n    uint64 cap = 1000; // borrow cap of 1,000\n    uint256 borrowAmount = 1001e18; // borrow of 1,001\n\n    // Set a native borrow cap for cToken2\n    // This should be ignored since we're using Prudentia\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = cToken2;\n    uint256[] memory borrowCaps = new uint256[](1);\n    borrowCaps[0] = 1;\n    comptroller._setMarketBorrowCaps(cTokens, borrowCaps);\n\n    // Mint cToken1 and cToken2\n    underlyingToken1.approve(address(cToken1), type(uint256).max); // Approve max\n    cToken1.mint(10000e18); // Mint 10,000 cToken1\n    underlyingToken2.approve(address(cToken2), type(uint256).max); // Approve max\n    cToken2.mint(10000e18); // Mint 10,000 cToken2\n\n    // Use cToken1 as collateral\n    address[] memory enterMarkets = new address[](1);\n    enterMarkets[0] = address(cToken1);\n    comptroller.enterMarkets(enterMarkets);\n\n    // Enable Prudentia\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(\n      PrudentiaLib.PrudentiaConfig({ controller: address(prudentia), offset: 1, decimalShift: 0 })\n    );\n\n    // Set Prudentia borrow cap for cToken2\n    prudentia.stubPush(address(underlyingToken2), cap); // The cap we're using at index 1 (this should be used)\n    prudentia.stubPush(address(underlyingToken2), 0); // Unrestricted cap at index 0. If this cap is used, the test should fail.\n\n    assertEq(comptroller.effectiveBorrowCaps(address(cToken2)), uint256(cap) * 1e18);\n\n    // Borrow\n    vm.expectRevert();\n    cToken2.borrow(borrowAmount); // FAIL: Borrow\n  }\n\n  /*\n  Additional ComptrollerPrudentiaCapsExt tests\n  */\n\n  event NewBorrowCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\n\n  event NewSupplyCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\n\n  function test_Prudentia_SupplyCapConfig() public {\n    PrudentiaLib.PrudentiaConfig memory oldConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(0),\n      offset: 0,\n      decimalShift: 0\n    });\n    PrudentiaLib.PrudentiaConfig memory newConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(prudentia),\n      offset: 0,\n      decimalShift: 0\n    });\n\n    // Setup expectation of the following event\n    vm.expectEmit(false, false, false, true);\n    emit NewSupplyCapConfig(oldConfig, newConfig);\n\n    // Set supply cap config\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(newConfig);\n\n    // Get the supply cap config\n    PrudentiaLib.PrudentiaConfig memory current = ComptrollerPrudentiaCapsExt(address(comptroller))\n      .getSupplyCapConfig();\n\n    assertEq(newConfig.controller, current.controller, \"controller\");\n    assertEq(newConfig.offset, current.offset, \"offset\");\n  }\n\n  function test_Prudentia_BorrowCapConfig() public {\n    PrudentiaLib.PrudentiaConfig memory oldConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(0),\n      offset: 0,\n      decimalShift: 0\n    });\n    PrudentiaLib.PrudentiaConfig memory newConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(prudentia),\n      offset: 0,\n      decimalShift: 0\n    });\n\n    // Setup expectation of the following event\n    vm.expectEmit(false, false, false, true);\n    emit NewBorrowCapConfig(oldConfig, newConfig);\n\n    // Set borrow cap config\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(newConfig);\n\n    // Get the borrow cap config\n    PrudentiaLib.PrudentiaConfig memory current = ComptrollerPrudentiaCapsExt(address(comptroller))\n      .getBorrowCapConfig();\n\n    assertEq(newConfig.controller, current.controller, \"controller\");\n    assertEq(newConfig.offset, current.offset, \"offset\");\n  }\n\n  function test_Prudentia_SetSupplyCapConfig_OnlyAdmin() public {\n    PrudentiaLib.PrudentiaConfig memory newConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(prudentia),\n      offset: 0,\n      decimalShift: 0\n    });\n\n    // Set supply cap config\n    vm.prank(address(7));\n    vm.expectRevert(\"!admin\");\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setSupplyCapConfig(newConfig);\n  }\n\n  function test_Prudentia_SetBorrowCapConfig_OnlyAdmin() public {\n    PrudentiaLib.PrudentiaConfig memory newConfig = PrudentiaLib.PrudentiaConfig({\n      controller: address(prudentia),\n      offset: 0,\n      decimalShift: 0\n    });\n\n    // Set supply cap config\n    vm.prank(address(7));\n    vm.expectRevert(\"!admin\");\n    ComptrollerPrudentiaCapsExt(address(comptroller))._setBorrowCapConfig(newConfig);\n  }\n}\n"
    },
    "contracts/test/ComptrollerTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\nimport { IonicFlywheel } from \"../ionic/strategies/flywheel/IonicFlywheel.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { ComptrollerErrorReporter } from \"../compound/ErrorReporter.sol\";\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\n\nimport { IFlywheelBooster } from \"../ionic/strategies/flywheel/IFlywheelBooster.sol\";\nimport { IFlywheelRewards } from \"../ionic/strategies/flywheel/rewards/IFlywheelRewards.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ComptrollerTest is BaseTest {\n  IonicComptroller internal comptroller;\n  IonicFlywheel internal flywheel;\n  address internal nonOwner = address(0x2222);\n\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  function setUp() public {\n    {\n      Unitroller proxy = new Unitroller(payable(address(this)));\n      proxy._registerExtension(new Comptroller(), DiamondExtension(address(0)));\n      comptroller = IonicComptroller(address(proxy));\n    }\n    {\n      ERC20 rewardToken = new MockERC20(\"RewardToken\", \"RT\", 18);\n      IonicFlywheel impl = new IonicFlywheel();\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(dpa), \"\");\n      flywheel = IonicFlywheel(address(proxy));\n      flywheel.initialize(rewardToken, IFlywheelRewards(address(2)), IFlywheelBooster(address(3)), address(this));\n    }\n  }\n\n  function test__setFlywheel() external {\n    vm.prank(comptroller.admin());\n    comptroller._addRewardsDistributor(address(flywheel));\n    assertEq(comptroller.rewardsDistributors(0), address(flywheel));\n  }\n\n  function test__setFlywheelRevertsIfNonOwner() external {\n    vm.startPrank(nonOwner);\n    vm.expectRevert(\"!admin\");\n    comptroller._addRewardsDistributor(address(flywheel));\n  }\n\n  function testBscInflationProtection() public debuggingOnly fork(BSC_MAINNET) {\n    _testInflationProtection();\n  }\n\n  function testPolygonInflationProtection() public debuggingOnly fork(POLYGON_MAINNET) {\n    _testInflationProtection();\n  }\n\n  function testModeInflationProtection() public debuggingOnly fork(MODE_MAINNET) {\n    _testInflationProtection();\n  }\n\n  function _testInflationProtection() internal {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    PoolDirectory.Pool[] memory pools = fpd.getAllPools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      ICErc20[] memory markets = pool.getAllMarkets();\n      for (uint256 j = 0; j < markets.length; j++) {\n        ICErc20 market = markets[j];\n        uint256 totalSupply = market.totalSupply();\n        if (totalSupply > 0) {\n          if (totalSupply < 1000) {\n            emit log_named_address(\"low ts market\", address(markets[j]));\n            emit log_named_uint(\"ts\", totalSupply);\n          } else {\n            assertEq(\n              pool.redeemAllowed(address(markets[j]), address(0), totalSupply - 980),\n              uint256(ComptrollerErrorReporter.Error.REJECTION),\n              \"low ts not rejected\"\n            );\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/config/BaseTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"forge-std/Vm.sol\";\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport { AddressesProvider } from \"../../ionic/AddressesProvider.sol\";\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\nabstract contract BaseTest is Test {\n  uint128 constant ETHEREUM_MAINNET = 1;\n  uint128 constant BSC_MAINNET = 56;\n  uint128 constant POLYGON_MAINNET = 137;\n  uint128 constant ARBITRUM_ONE = 42161;\n\n  uint128 constant BSC_CHAPEL = 97;\n  uint128 constant NEON_MAINNET = 245022934;\n  uint128 constant LINEA_MAINNET = 59144;\n  uint128 constant ZKEVM_MAINNET = 1101;\n  uint128 constant MODE_MAINNET = 34443;\n  uint128 constant BASE_MAINNET = 8453;\n\n  // taken from ERC1967Upgrade\n  bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  AddressesProvider public ap;\n  ProxyAdmin public dpa;\n\n  mapping(uint128 => uint256) private forkIds;\n\n  constructor() {\n    configureAddressesProvider(0);\n  }\n\n  uint256 constant CRITICAL = 100;\n  uint256 constant NORMAL = 90;\n  uint256 constant LOW = 80;\n\n  modifier importance(uint256 testImportance) {\n    uint256 runLevel = NORMAL;\n\n    try vm.envUint(\"TEST_RUN_LEVEL\") returns (uint256 level) {\n      runLevel = level;\n    } catch {\n      emit log(\"failed to get env param TEST_RUN_LEVEL\");\n    }\n\n    if (testImportance >= runLevel) {\n      _;\n    } else {\n      emit log(\"not running the test\");\n    }\n  }\n\n  modifier debuggingOnly() {\n    try vm.envBool(\"LOCAL_FORGE_ENV\") returns (bool run) {\n      if (run) _;\n    } catch {\n      emit log(\"skipping this test in the CI/CD - add LOCAL_FORGE_ENV=true to your .env file to run locally\");\n    }\n  }\n\n  modifier fork(uint128 chainid) {\n    if (shouldRunForChain(chainid)) {\n      _forkAtBlock(chainid, 0);\n      _;\n    }\n  }\n\n  modifier forkAtBlock(uint128 chainid, uint256 blockNumber) {\n    if (shouldRunForChain(chainid)) {\n      _forkAtBlock(chainid, blockNumber);\n      _;\n    }\n  }\n\n  modifier whenForking() {\n    try vm.activeFork() returns (uint256) {\n      _;\n    } catch {}\n  }\n\n  function shouldRunForChain(uint256 chainid) internal returns (bool) {\n    bool run = true;\n    try vm.envUint(\"TEST_RUN_CHAINID\") returns (uint256 envChainId) {\n      run = envChainId == chainid;\n    } catch {\n      emit log(\"failed to get env param TEST_RUN_CHAINID\");\n    }\n    return run;\n  }\n\n  function _forkAtBlock(uint128 chainid, uint256 blockNumber) internal {\n    if (block.chainid != chainid) {\n      if (blockNumber != 0) {\n        vm.selectFork(getArchiveForkId(chainid));\n        vm.rollFork(blockNumber);\n      } else {\n        vm.selectFork(getForkId(chainid));\n      }\n    }\n    configureAddressesProvider(chainid);\n    afterForkSetUp();\n  }\n\n  function getForkId(uint128 chainid, bool archive) private returns (uint256) {\n    return archive ? getForkId(chainid) : getArchiveForkId(chainid);\n  }\n\n  function getForkId(uint128 chainid) private returns (uint256) {\n    if (forkIds[chainid] == 0) {\n      if (chainid == BSC_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"bsc\")) + 100;\n      } else if (chainid == BSC_CHAPEL) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"bsc_chapel\")) + 100;\n      } else if (chainid == POLYGON_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"polygon\")) + 100;\n      } else if (chainid == NEON_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"neon\")) + 100;\n      } else if (chainid == ARBITRUM_ONE) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"arbitrum\")) + 100;\n      } else if (chainid == ETHEREUM_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"ethereum\")) + 100;\n      } else if (chainid == LINEA_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"linea\")) + 100;\n      } else if (chainid == ZKEVM_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"zkevm\")) + 100;\n      } else if (chainid == MODE_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"mode\")) + 100;\n      } else if (chainid == BASE_MAINNET) {\n        forkIds[chainid] = vm.createFork(vm.rpcUrl(\"base\")) + 100;\n      }\n    }\n\n    return forkIds[chainid] - 100;\n  }\n\n  function getArchiveForkId(uint128 chainid) private returns (uint256) {\n    // store the archive rpc urls in the forkIds mapping at an offset\n    uint128 chainidWithOffset = chainid + type(uint64).max;\n    if (forkIds[chainidWithOffset] == 0) {\n      if (chainid == BSC_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"bsc_archive\")) + 100;\n      } else if (chainid == BSC_CHAPEL) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"bsc_chapel_archive\")) + 100;\n      } else if (chainid == POLYGON_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"polygon_archive\")) + 100;\n      } else if (chainid == NEON_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"neon_archive\")) + 100;\n      } else if (chainid == ARBITRUM_ONE) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"arbitrum_archive\")) + 100;\n      } else if (chainid == ETHEREUM_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"ethereum_archive\")) + 100;\n      } else if (chainid == LINEA_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"linea_archive\")) + 100;\n      } else if (chainid == ZKEVM_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"zkevm_archive\")) + 100;\n      } else if (chainid == MODE_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"mode_archive\")) + 100;\n      } else if (chainid == BASE_MAINNET) {\n        forkIds[chainidWithOffset] = vm.createFork(vm.rpcUrl(\"base_archive\")) + 100;\n      }\n    }\n    return forkIds[chainidWithOffset] - 100;\n  }\n\n  function afterForkSetUp() internal virtual {}\n\n  function configureAddressesProvider(uint128 chainid) private {\n    if (chainid == BSC_MAINNET) {\n      ap = AddressesProvider(address(0));\n    } else if (chainid == BSC_CHAPEL) {\n      ap = AddressesProvider(0x3dc8CE9f581e49B9E5304CF580940ad341F64c3f);\n    } else if (block.chainid == POLYGON_MAINNET) {\n      ap = AddressesProvider(0xE31baC0B582AA248c0017F87F24087cEa7A55E26);\n    } else if (chainid == NEON_MAINNET) {\n      ap = AddressesProvider(0xF4C60F6ac6b3AF54044757a1a54D76EEe28244CE);\n    } else if (chainid == ARBITRUM_ONE) {\n      ap = AddressesProvider(0x3B12BA992259Fb3855C4E1D452a754dCa2E276fC);\n    } else if (chainid == LINEA_MAINNET) {\n      ap = AddressesProvider(0x914694DA0bED80e74ef1a28029f016119782C0f1);\n    } else if (chainid == ZKEVM_MAINNET) {\n      ap = AddressesProvider(0x27aA55A3D55959261e119d75256aadAB79aE897C);\n    } else if (chainid == MODE_MAINNET) {\n      ap = AddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n    } else if (chainid == BASE_MAINNET) {\n      ap = AddressesProvider(0xcD4D7c8e2bA627684a9B18F7fe88239341D3ba5c);\n    } else {\n      dpa = new ProxyAdmin();\n      AddressesProvider logic = new AddressesProvider();\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(\n        address(logic),\n        address(dpa),\n        abi.encodeWithSelector(ap.initialize.selector, address(this))\n      );\n      ap = AddressesProvider(address(proxy));\n      ap.setAddress(\"DefaultProxyAdmin\", address(dpa));\n    }\n    dpa = ProxyAdmin(ap.getAddress(\"DefaultProxyAdmin\"));\n    if (ap.owner() == address(0)) {\n      ap.initialize(address(this));\n    }\n    if (ap.getAddress(\"deployer\") == address(0)) {\n      vm.prank(ap.owner());\n      ap.setAddress(\"deployer\", 0x1155b614971f16758C92c4890eD338C9e3ede6b7);\n    }\n  }\n\n  function diff(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a > b) {\n      return a - b;\n    } else {\n      return b - a;\n    }\n  }\n\n  function compareStrings(string memory a, string memory b) public pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function asArray(address value) public pure returns (address[] memory) {\n    address[] memory array = new address[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(address value0, address value1) public pure returns (address[] memory) {\n    address[] memory array = new address[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(\n    address value0,\n    address value1,\n    address value2\n  ) public pure returns (address[] memory) {\n    address[] memory array = new address[](3);\n    array[0] = value0;\n    array[1] = value1;\n    array[2] = value2;\n    return array;\n  }\n\n  function asArray(bool value) public pure returns (bool[] memory) {\n    bool[] memory array = new bool[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(uint256 value0, uint256 value1) public pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(uint256 value) public pure returns (uint256[] memory) {\n    uint256[] memory array = new uint256[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(bytes memory value) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](1);\n    array[0] = value;\n    return array;\n  }\n\n  function asArray(bytes memory value0, bytes memory value1) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](2);\n    array[0] = value0;\n    array[1] = value1;\n    return array;\n  }\n\n  function asArray(\n    bytes memory value0,\n    bytes memory value1,\n    bytes memory value2\n  ) public pure returns (bytes[] memory) {\n    bytes[] memory array = new bytes[](3);\n    array[0] = value0;\n    array[1] = value1;\n    array[2] = value2;\n    return array;\n  }\n\n  function sqrt(uint256 x) public pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n}\n"
    },
    "contracts/test/config/MarketsTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"./BaseTest.t.sol\";\nimport { FeeDistributor } from \"../../FeeDistributor.sol\";\nimport { CErc20Delegate } from \"../../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../../compound/CErc20PluginDelegate.sol\";\nimport { CErc20RewardsDelegate } from \"../../compound/CErc20RewardsDelegate.sol\";\nimport { CErc20PluginRewardsDelegate } from \"../../compound/CErc20PluginRewardsDelegate.sol\";\nimport { DiamondExtension } from \"../../ionic/DiamondExtension.sol\";\nimport { CTokenFirstExtension } from \"../../compound/CTokenFirstExtension.sol\";\nimport { Comptroller } from \"../../compound/Comptroller.sol\";\nimport { Unitroller } from \"../../compound/Unitroller.sol\";\nimport { ComptrollerFirstExtension } from \"../../compound/ComptrollerFirstExtension.sol\";\nimport { AuthoritiesRegistry } from \"../../ionic/AuthoritiesRegistry.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract MarketsTest is BaseTest {\n  FeeDistributor internal ffd;\n\n  CErc20Delegate internal cErc20Delegate;\n  CErc20PluginDelegate internal cErc20PluginDelegate;\n  CErc20RewardsDelegate internal cErc20RewardsDelegate;\n  CErc20PluginRewardsDelegate internal cErc20PluginRewardsDelegate;\n  CTokenFirstExtension internal newCTokenExtension;\n\n  address payable internal latestComptrollerImplementation;\n  ComptrollerFirstExtension internal comptrollerExtension;\n\n  function afterForkSetUp() internal virtual override {\n    ffd = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    upgradeFfd();\n    cErc20Delegate = new CErc20Delegate();\n    cErc20PluginDelegate = new CErc20PluginDelegate();\n    cErc20RewardsDelegate = new CErc20RewardsDelegate();\n    cErc20PluginRewardsDelegate = new CErc20PluginRewardsDelegate();\n    newCTokenExtension = new CTokenFirstExtension();\n\n    comptrollerExtension = new ComptrollerFirstExtension();\n    Comptroller newComptrollerImplementation = new Comptroller();\n    latestComptrollerImplementation = payable(address(newComptrollerImplementation));\n  }\n\n  function upgradeFfd() internal {\n    {\n      FeeDistributor newImpl = new FeeDistributor();\n      TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(ffd)));\n      bytes32 bytesAtSlot = vm.load(address(proxy), 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\n      address admin = address(uint160(uint256(bytesAtSlot)));\n      vm.prank(admin);\n      proxy.upgradeTo(address(newImpl));\n    }\n\n    if (address(ffd.authoritiesRegistry()) == address(0)) {\n      AuthoritiesRegistry impl = new AuthoritiesRegistry();\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n      AuthoritiesRegistry newAr = AuthoritiesRegistry(address(proxy));\n      newAr.initialize(address(321));\n      vm.prank(ffd.owner());\n      ffd.reinitialize(newAr);\n    }\n  }\n\n  function _prepareCTokenUpgrade(ICErc20 market) internal returns (address) {\n    address implBefore = market.implementation();\n    //emit log(\"implementation before\");\n    //emit log_address(implBefore);\n\n    CErc20Delegate newImpl;\n    if (market.delegateType() == 1) {\n      newImpl = cErc20Delegate;\n    } else if (market.delegateType() == 2) {\n      newImpl = cErc20PluginDelegate;\n    } else if (market.delegateType() == 3) {\n      newImpl = cErc20RewardsDelegate;\n    } else {\n      newImpl = cErc20PluginRewardsDelegate;\n    }\n\n    // set the new ctoken delegate as the latest\n    uint8 delegateType = market.delegateType();\n    vm.prank(ffd.owner());\n    ffd._setLatestCErc20Delegate(delegateType, address(newImpl), abi.encode(address(0)));\n\n    // add the extension to the auto upgrade config\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](2);\n    cErc20DelegateExtensions[0] = DiamondExtension(newImpl);\n    cErc20DelegateExtensions[1] = newCTokenExtension;\n    vm.prank(ffd.owner());\n    ffd._setCErc20DelegateExtensions(address(newImpl), cErc20DelegateExtensions);\n\n    return address(newImpl);\n  }\n\n  function _upgradeMarket(ICErc20 market) internal {\n    address newDelegate = _prepareCTokenUpgrade(market);\n\n    bytes memory becomeImplData = (address(newDelegate) == address(cErc20Delegate))\n      ? bytes(\"\")\n      : abi.encode(address(0));\n    vm.prank(market.ionicAdmin());\n    market._setImplementationSafe(newDelegate, becomeImplData);\n  }\n\n  function _prepareComptrollerUpgrade(address oldCompImpl) internal {\n    vm.startPrank(ffd.owner());\n    ffd._setLatestComptrollerImplementation(oldCompImpl, latestComptrollerImplementation);\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = comptrollerExtension;\n    extensions[1] = Comptroller(latestComptrollerImplementation);\n    ffd._setComptrollerExtensions(latestComptrollerImplementation, extensions);\n    vm.stopPrank();\n  }\n\n  function _upgradeExistingPool(address poolAddress) internal {\n    Unitroller asUnitroller = Unitroller(payable(poolAddress));\n    // change the implementation to the new that can add extensions\n    address oldComptrollerImplementation = asUnitroller.comptrollerImplementation();\n\n    _prepareComptrollerUpgrade(oldComptrollerImplementation);\n\n    // upgrade to the new comptroller\n    vm.startPrank(asUnitroller.admin());\n    asUnitroller._upgrade();\n    vm.stopPrank();\n  }\n}\n"
    },
    "contracts/test/ContractsUpgradesTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { ComptrollerFirstExtension, DiamondExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { IonicFlywheelCore } from \"../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\nimport { IonicFlywheel } from \"../ionic/strategies/flywheel/IonicFlywheel.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { DiamondExtension, DiamondBase } from \"../ionic/DiamondExtension.sol\";\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\ncontract ContractsUpgradesTest is BaseTest {\n  function testPoolDirectoryUpgrade() public fork(BSC_MAINNET) {\n    address contractToTest = ap.getAddress(\"PoolDirectory\"); // PoolDirectory proxy\n\n    // before upgrade\n    PoolDirectory fpdBefore = PoolDirectory(contractToTest);\n    PoolDirectory.Pool[] memory poolsBefore = fpdBefore.getAllPools();\n    address ownerBefore = fpdBefore.owner();\n    emit log_address(ownerBefore);\n\n    uint256 lenBefore = poolsBefore.length;\n    emit log_uint(lenBefore);\n\n    // upgrade\n    {\n      PoolDirectory newImpl = new PoolDirectory();\n      TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(contractToTest));\n      bytes32 bytesAtSlot = vm.load(address(proxy), _ADMIN_SLOT);\n      address admin = address(uint160(uint256(bytesAtSlot)));\n      vm.prank(admin);\n      proxy.upgradeTo(address(newImpl));\n    }\n\n    // after upgrade\n    PoolDirectory fpd = PoolDirectory(contractToTest);\n    address ownerAfter = fpd.owner();\n    emit log_address(ownerAfter);\n\n    (, PoolDirectory.Pool[] memory poolsAfter) = fpd.getActivePools();\n    uint256 lenAfter = poolsAfter.length;\n    emit log_uint(poolsAfter.length);\n\n    assertEq(lenBefore, lenAfter, \"pools count does not match\");\n    assertEq(ownerBefore, ownerAfter, \"owner mismatch\");\n  }\n\n  function testFeeDistributorUpgrade() public fork(BSC_MAINNET) {\n    // TODO use an already deployed market\n    CErc20Delegate oldCercDelegate = new CErc20Delegate();\n\n    // before upgrade\n    FeeDistributor ffdProxy = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    uint256 marketsCounterBefore = ffdProxy.marketsCounter();\n    address ownerBefore = ffdProxy.owner();\n\n    (address latestCErc20DelegateBefore, ) = ffdProxy.latestCErc20Delegate(oldCercDelegate.delegateType());\n\n    emit log_uint(marketsCounterBefore);\n    emit log_address(ownerBefore);\n\n    // upgrade\n    {\n      FeeDistributor newImpl = new FeeDistributor();\n      TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(ffdProxy)));\n      bytes32 bytesAtSlot = vm.load(address(proxy), _ADMIN_SLOT);\n      address admin = address(uint160(uint256(bytesAtSlot)));\n      vm.prank(admin);\n      proxy.upgradeTo(address(newImpl));\n    }\n\n    // after upgrade\n    FeeDistributor ffd = FeeDistributor(payable(address(ffdProxy)));\n\n    uint256 marketsCounterAfter = ffd.marketsCounter();\n    address ownerAfter = ffd.owner();\n    (address latestCErc20DelegateAfter, ) = ffd.latestCErc20Delegate(oldCercDelegate.delegateType());\n\n    emit log_uint(marketsCounterAfter);\n    emit log_address(ownerAfter);\n\n    assertEq(latestCErc20DelegateBefore, latestCErc20DelegateAfter, \"latest delegates do not match\");\n    assertEq(marketsCounterBefore, marketsCounterAfter, \"markets counter does not match\");\n\n    assertEq(ownerBefore, ownerAfter, \"owner mismatch\");\n  }\n\n  function testMarketsLatestImplementationsChapel() public fork(BSC_CHAPEL) {\n    _testMarketsLatestImplementations();\n  }\n\n  function testMarketsLatestImplementationsBsc() public fork(BSC_MAINNET) {\n    _testMarketsLatestImplementations();\n  }\n\n  function testMarketsLatestImplementationsPolygon() public fork(POLYGON_MAINNET) {\n    _testMarketsLatestImplementations();\n  }\n\n  function testMarketsLatestImplementationsArbitrum() public fork(ARBITRUM_ONE) {\n    _testMarketsLatestImplementations();\n  }\n\n  function testMarketsLatestImplementationsEth() public fork(ETHEREUM_MAINNET) {\n    _testMarketsLatestImplementations();\n  }\n\n  function _testMarketsLatestImplementations() internal {\n    FeeDistributor ffd = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    if (address(fpd) != address(0)) {\n      (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n      for (uint8 i = 0; i < pools.length; i++) {\n        IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n        ICErc20[] memory markets = pool.getAllMarkets();\n        for (uint8 j = 0; j < markets.length; j++) {\n          ICErc20 market = markets[j];\n\n          uint8 currentDelegateType = market.delegateType();\n          (address upgradeToImpl, ) = ffd.latestCErc20Delegate(currentDelegateType);\n\n          address currentImpl = market.implementation();\n          if (currentImpl != upgradeToImpl) emit log_address(address(market));\n          assertEq(currentImpl, upgradeToImpl, \"market needs to be upgraded\");\n\n          DiamondBase asBase = DiamondBase(address(markets[j]));\n          try asBase._listExtensions() returns (address[] memory extensions) {\n            assertEq(extensions.length, 2, \"market is missing an extension\");\n          } catch {\n            emit log(\"market that is not yet upgraded to the extensions upgrade\");\n            emit log_address(address(market));\n            emit log(\"implementation\");\n            emit log_address(currentImpl);\n            emit log(\"pool\");\n            emit log_address(pools[i].comptroller);\n            emit log(\"\");\n          }\n        }\n      }\n    }\n  }\n\n  function testPauseGuardiansBsc() public debuggingOnly fork(BSC_MAINNET) {\n    _testPauseGuardians();\n  }\n\n  // TODO redeploy to polygon to fix\n  function testPauseGuardiansPolygon() public debuggingOnly fork(POLYGON_MAINNET) {\n    _testPauseGuardians();\n  }\n\n  function _testPauseGuardians() internal {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    address deployer = ap.getAddress(\"deployer\");\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      address pauseGuardian = pool.pauseGuardian();\n      if (pauseGuardian != address(0) && pauseGuardian != deployer) {\n        emit log_named_address(\"pool\", address(pool));\n        emit log_named_address(\"unknown pause guardian\", pauseGuardian);\n        emit log(\"\");\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/DeployMarkets.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"forge-std/Test.sol\";\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { IonicFlywheelDynamicRewardsPlugin } from \"../ionic/strategies/flywheel/rewards/IonicFlywheelDynamicRewardsPlugin.sol\";\nimport { IFlywheelBooster } from \"../ionic/strategies/flywheel/IFlywheelBooster.sol\";\nimport { IFlywheelRewards } from \"../ionic/strategies/flywheel/rewards/IFlywheelRewards.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { ICErc20, ICErc20Plugin, ICErc20PluginRewards } from \"../compound/CTokenInterfaces.sol\";\nimport { JumpRateModel } from \"../compound/JumpRateModel.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { CTokenFirstExtension, DiamondExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../compound/CErc20PluginDelegate.sol\";\nimport { CErc20PluginRewardsDelegate } from \"../compound/CErc20PluginRewardsDelegate.sol\";\nimport { CErc20 } from \"../compound/CToken.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { InterestRateModel } from \"../compound/InterestRateModel.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { AuthoritiesRegistry } from \"../ionic/AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\nimport { IonicFlywheelCore } from \"../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\n\nimport { MockPriceOracle } from \"../oracles/1337/MockPriceOracle.sol\";\nimport { MockERC4626 } from \"../ionic/strategies/MockERC4626.sol\";\nimport { MockERC4626Dynamic } from \"../ionic/strategies/MockERC4626Dynamic.sol\";\n\ncontract DeployMarketsTest is Test {\n  MockERC20 underlyingToken;\n  MockERC20 rewardToken;\n\n  JumpRateModel interestModel;\n  IonicComptroller comptroller;\n\n  CErc20Delegate cErc20Delegate;\n  CErc20PluginDelegate cErc20PluginDelegate;\n  CErc20PluginRewardsDelegate cErc20PluginRewardsDelegate;\n\n  MockERC4626 mockERC4626;\n  MockERC4626Dynamic mockERC4626Dynamic;\n\n  FeeDistributor ionicAdmin;\n  PoolDirectory poolDirectory;\n\n  IonicFlywheelDynamicRewardsPlugin rewards;\n\n  address[] markets;\n  bool[] t;\n  bool[] f;\n  IonicFlywheelCore[] flywheelsToClaim;\n\n  function setUpBaseContracts() public {\n    underlyingToken = new MockERC20(\"UnderlyingToken\", \"UT\", 18);\n    rewardToken = new MockERC20(\"RewardToken\", \"RT\", 18);\n    interestModel = new JumpRateModel(2343665, 1e18, 1e18, 4e18, 0.8e18);\n    ionicAdmin = new FeeDistributor();\n    ionicAdmin.initialize(1e16);\n    poolDirectory = new PoolDirectory();\n    poolDirectory.initialize(false, new address[](0));\n  }\n\n  function setUpExtensions() public {\n    cErc20Delegate = new CErc20Delegate();\n    cErc20PluginDelegate = new CErc20PluginDelegate();\n    cErc20PluginRewardsDelegate = new CErc20PluginRewardsDelegate();\n\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](2);\n    cErc20DelegateExtensions[0] = cErc20Delegate;\n    cErc20DelegateExtensions[1] = new CTokenFirstExtension();\n    ionicAdmin._setCErc20DelegateExtensions(address(0), cErc20DelegateExtensions);\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20Delegate), cErc20DelegateExtensions);\n\n    cErc20DelegateExtensions[0] = cErc20PluginDelegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20PluginDelegate), cErc20DelegateExtensions);\n\n    cErc20DelegateExtensions[0] = cErc20PluginRewardsDelegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20PluginRewardsDelegate), cErc20DelegateExtensions);\n\n    ionicAdmin._setLatestCErc20Delegate(cErc20Delegate.delegateType(), address(cErc20Delegate), \"\");\n\n    ionicAdmin._setLatestCErc20Delegate(\n      cErc20PluginDelegate.delegateType(),\n      address(cErc20PluginDelegate),\n      abi.encode(address(0))\n    );\n\n    ionicAdmin._setLatestCErc20Delegate(\n      cErc20PluginRewardsDelegate.delegateType(),\n      address(cErc20PluginRewardsDelegate),\n      abi.encode(address(0))\n    );\n  }\n\n  function setUpPool() public {\n    underlyingToken.mint(address(this), 100e36);\n\n    MockPriceOracle priceOracle = new MockPriceOracle(10);\n    Comptroller tempComptroller = new Comptroller();\n    ionicAdmin._setLatestComptrollerImplementation(address(0), address(tempComptroller));\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = new ComptrollerFirstExtension();\n    extensions[1] = tempComptroller;\n    ionicAdmin._setComptrollerExtensions(address(tempComptroller), extensions);\n    (, address comptrollerAddress) = poolDirectory.deployPool(\n      \"TestPool\",\n      address(tempComptroller),\n      abi.encode(payable(address(ionicAdmin))),\n      false,\n      0.1e18,\n      1.1e18,\n      address(priceOracle)\n    );\n\n    Unitroller(payable(comptrollerAddress))._acceptAdmin();\n    comptroller = IonicComptroller(comptrollerAddress);\n\n    AuthoritiesRegistry impl = new AuthoritiesRegistry();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n    AuthoritiesRegistry newAr = AuthoritiesRegistry(address(proxy));\n    newAr.initialize(address(321));\n    ionicAdmin.reinitialize(newAr);\n    PoolRolesAuthority poolAuth = newAr.createPoolAuthority(comptrollerAddress);\n    newAr.setUserRole(comptrollerAddress, address(this), poolAuth.BORROWER_ROLE(), true);\n    newAr.setUserRole(comptrollerAddress, address(ionicAdmin), poolAuth.SUPPLIER_ROLE(), true);\n  }\n\n  function setUp() public {\n    setUpBaseContracts();\n    setUpPool();\n    setUpExtensions();\n    vm.roll(1);\n  }\n\n  function testDeployCErc20Delegate() public {\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      \"\",\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20 cToken = allMarkets[allMarkets.length - 1];\n    assertEq(cToken.name(), \"cUnderlyingToken\");\n    underlyingToken.approve(address(cToken), 1e36);\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = address(cToken);\n    comptroller.enterMarkets(cTokens);\n    vm.roll(1);\n    require(cToken.mint(10e18) == 0, \"mint failed\");\n    assertEq(cToken.totalSupply(), 10e18 * 5);\n    assertEq(underlyingToken.balanceOf(address(cToken)), 10e18);\n  }\n\n  function testDeployCErc20PluginDelegate() public {\n    mockERC4626 = new MockERC4626(ERC20(address(underlyingToken)));\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20PluginDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(mockERC4626),\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20Plugin cToken = ICErc20Plugin(address(allMarkets[allMarkets.length - 1]));\n\n    assertEq(address(cToken.plugin()), address(mockERC4626), \"!plugin == erc4626\");\n\n    underlyingToken.approve(address(cToken), 1e36);\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = address(cToken);\n    comptroller.enterMarkets(cTokens);\n    vm.roll(1);\n\n    cToken.mint(10e18);\n    assertEq(cToken.totalSupply(), 10e18 * 5);\n    assertEq(mockERC4626.balanceOf(address(cToken)), 10e18);\n    assertEq(underlyingToken.balanceOf(address(mockERC4626)), 10e18);\n  }\n\n  function testDeployCErc20PluginRewardsDelegate() public {\n    IonicFlywheelCore impl = new IonicFlywheelCore();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n    IonicFlywheelCore flywheel = IonicFlywheelCore(address(proxy));\n    flywheel.initialize(underlyingToken, IFlywheelRewards(address(0)), IFlywheelBooster(address(0)), address(this));\n    IonicFlywheelCore asFlywheelCore = IonicFlywheelCore(address(flywheel));\n    rewards = new IonicFlywheelDynamicRewardsPlugin(asFlywheelCore, 1);\n    flywheel.setFlywheelRewards(rewards);\n\n    mockERC4626Dynamic = new MockERC4626Dynamic(ERC20(address(underlyingToken)), asFlywheelCore);\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20PluginRewardsDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(address(mockERC4626Dynamic), address(flywheel), address(underlyingToken)),\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20PluginRewards cToken = ICErc20PluginRewards(address(allMarkets[allMarkets.length - 1]));\n\n    flywheel.addStrategyForRewards(ERC20(address(cToken)));\n\n    assertEq(address(cToken.plugin()), address(mockERC4626Dynamic), \"!plugin == erc4626\");\n    assertEq(underlyingToken.allowance(address(cToken), address(mockERC4626Dynamic)), type(uint256).max);\n    assertEq(underlyingToken.allowance(address(cToken), address(flywheel)), 0);\n\n    cToken.approve(address(rewardToken), address(flywheel));\n    assertEq(rewardToken.allowance(address(cToken), address(flywheel)), type(uint256).max);\n\n    underlyingToken.approve(address(cToken), 1e36);\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = address(cToken);\n    comptroller.enterMarkets(cTokens);\n    vm.roll(1);\n\n    cToken.mint(10000000);\n    assertEq(cToken.totalSupply(), 10000000 * 5);\n    assertEq(mockERC4626Dynamic.balanceOf(address(cToken)), 10000000);\n    assertEq(underlyingToken.balanceOf(address(mockERC4626Dynamic)), 10000000);\n  }\n\n  function testAutoImplementationCErc20Delegate() public {\n    mockERC4626 = new MockERC4626(ERC20(address(underlyingToken)));\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20PluginDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(mockERC4626),\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20Plugin cToken = ICErc20Plugin(address(allMarkets[allMarkets.length - 1]));\n\n    assertEq(address(cToken.plugin()), address(mockERC4626), \"!plugin == erc4626\");\n\n    address implBefore = cToken.implementation();\n    // just testing to replace the plugin delegate with the plugin rewards delegate\n    ionicAdmin._setLatestCErc20Delegate(\n      cToken.delegateType(),\n      address(cErc20PluginRewardsDelegate),\n      abi.encode(address(0)) // should trigger use of latest implementation\n    );\n\n    // run the upgrade\n    vm.prank(ionicAdmin.owner());\n    ionicAdmin.autoUpgradePool(comptroller);\n\n    address implAfter = cToken.implementation();\n\n    assertEq(implBefore, address(cErc20PluginDelegate), \"the old impl should be the plugin delegate\");\n    assertEq(implAfter, address(cErc20PluginRewardsDelegate), \"the new impl should be the plugin rewards delegate\");\n  }\n\n  function testAutoImplementationPlugin() public {\n    MockERC4626 pluginA = new MockERC4626(ERC20(address(underlyingToken)));\n    MockERC4626 pluginB = new MockERC4626(ERC20(address(underlyingToken)));\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20PluginDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(pluginA),\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20Plugin cToken = ICErc20Plugin(address(allMarkets[allMarkets.length - 1]));\n\n    assertEq(address(cToken.plugin()), address(pluginA), \"!plugin == erc4626\");\n\n    address pluginImplBefore = address(cToken.plugin());\n    ionicAdmin._setLatestPluginImplementation(address(pluginA), address(pluginB));\n    ionicAdmin._upgradePluginToLatestImplementation(address(cToken));\n    address pluginImplAfter = address(cToken.plugin());\n\n    assertEq(pluginImplBefore, address(pluginA), \"the old impl should be the A plugin\");\n    assertEq(pluginImplAfter, address(pluginB), \"the new impl should be the B plugin\");\n  }\n\n  function testAutoImplementationCErc20PluginDelegate() public {\n    MockERC4626 pluginA = new MockERC4626(ERC20(address(underlyingToken)));\n    MockERC4626 pluginB = new MockERC4626(ERC20(address(underlyingToken)));\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20PluginDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(pluginA),\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20Plugin cToken = ICErc20Plugin(address(allMarkets[allMarkets.length - 1]));\n\n    assertEq(address(cToken.plugin()), address(pluginA), \"!plugin == erc4626\");\n\n    address pluginImplBefore = address(cToken.plugin());\n    address implBefore = cToken.implementation();\n    uint8 delegateType = cToken.delegateType();\n\n    // just testing to replace the plugin delegate with the plugin rewards delegate\n    ionicAdmin._setLatestCErc20Delegate(\n      delegateType,\n      address(cErc20PluginRewardsDelegate),\n      abi.encode(address(0)) // should trigger use of latest implementation\n    );\n    ionicAdmin._setLatestPluginImplementation(address(pluginA), address(pluginB));\n\n    // run the upgrade\n    vm.prank(ionicAdmin.owner());\n    ionicAdmin.autoUpgradePool(comptroller);\n\n    address pluginImplAfter = address(cToken.plugin());\n    address implAfter = cToken.implementation();\n\n    assertEq(pluginImplBefore, address(pluginA), \"the old impl should be the A plugin\");\n    assertEq(pluginImplAfter, address(pluginB), \"the new impl should be the B plugin\");\n    assertEq(implBefore, address(cErc20PluginDelegate), \"the old impl should be the plugin delegate\");\n    assertEq(implAfter, address(cErc20PluginRewardsDelegate), \"the new impl should be the plugin rewards delegate\");\n  }\n\n  function testInflateExchangeRate() public {\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      \"\",\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20 cToken = allMarkets[allMarkets.length - 1];\n    assertEq(cToken.name(), \"cUnderlyingToken\");\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = address(cToken);\n    comptroller.enterMarkets(cTokens);\n    vm.roll(1);\n\n    // mint just 2 wei\n    underlyingToken.approve(address(cToken), 1e36);\n    cToken.mint(2);\n    assertEq(cToken.totalSupply(), 10);\n    assertEq(underlyingToken.balanceOf(address(cToken)), 2, \"!total supply 2\");\n\n    uint256 exchRateBefore = cToken.exchangeRateCurrent();\n    emit log_named_uint(\"exch rate\", exchRateBefore);\n    assertEq(exchRateBefore, 2e17, \"!default exch rate\");\n\n    // donate\n    underlyingToken.transfer(address(cToken), 1e36);\n\n    uint256 exchRateAfter = cToken.exchangeRateCurrent();\n    emit log_named_uint(\"exch rate after\", exchRateAfter);\n    assertGt(exchRateAfter, 1e30, \"!inflated exch rate\");\n\n    // the market should own 1e36 + 2 underlying assets\n    assertEq(underlyingToken.balanceOf(address(cToken)), 1e36 + 2, \"!total underlying\");\n\n    // 50% + 1\n    uint256 errCode = cToken.redeemUnderlying(0.5e36 + 2);\n    assertEq(errCode, 0, \"!redeem underlying\");\n\n    assertEq(cToken.totalSupply(), 0, \"!should have redeemed all ctokens for 50% + 1 of the underlying\");\n  }\n\n  function testSupplyCapInflatedExchangeRate() public {\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      \"\",\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    ICErc20 cToken = allMarkets[allMarkets.length - 1];\n    assertEq(cToken.name(), \"cUnderlyingToken\");\n    address[] memory cTokens = new address[](1);\n    cTokens[0] = address(cToken);\n    comptroller.enterMarkets(cTokens);\n    vm.roll(1);\n\n    // mint 1e18\n    underlyingToken.approve(address(cToken), 1e18);\n    cToken.mint(1e18);\n    assertEq(cToken.totalSupply(), 5 * 1e18, \"!total supply 5\");\n    assertEq(underlyingToken.balanceOf(address(cToken)), 1e18, \"!market underlying balance 1\");\n\n    (, , uint256 liqBefore, uint256 sfBefore) = comptroller.getAccountLiquidity(address(this));\n\n    uint256[] memory caps = new uint256[](1);\n    caps[0] = 25e18;\n    ICErc20[] memory marketArray = new ICErc20[](1);\n    marketArray[0] = cToken;\n    vm.prank(comptroller.admin());\n    comptroller._setMarketSupplyCaps(marketArray, caps);\n\n    // donate 100e18\n    underlyingToken.transfer(address(cToken), 100e18);\n    assertEq(underlyingToken.balanceOf(address(cToken)), 101e18, \"!market balance 101\");\n    assertEq(cToken.balanceOfUnderlying(address(this)), 101e18, \"!user balance 101\");\n\n    (, , uint256 liqAfter, uint256 sfAfter) = comptroller.getAccountLiquidity(address(this));\n    emit log_named_uint(\"liqBefore\", liqBefore);\n    emit log_named_uint(\"liqAfter\", liqAfter);\n\n    assertEq(liqAfter / liqBefore, 25, \"liquidity should increase only 25x\");\n  }\n}\n"
    },
    "contracts/test/DevTesting.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport \"./config/BaseTest.t.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { CErc20PluginRewardsDelegate } from \"../compound/CErc20PluginRewardsDelegate.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { ISwapRouter } from \"../external/uniswap/ISwapRouter.sol\";\nimport { RedstoneAdapterPriceOracle } from \"../oracles/default/RedstoneAdapterPriceOracle.sol\";\nimport { RedstoneAdapterPriceOracleWrsETH } from \"../oracles/default/RedstoneAdapterPriceOracleWrsETH.sol\";\nimport { RedstoneAdapterPriceOracleWeETH } from \"../oracles/default/RedstoneAdapterPriceOracleWeETH.sol\";\nimport { MasterPriceOracle, BasePriceOracle } from \"../oracles/MasterPriceOracle.sol\";\nimport { PoolLens } from \"../PoolLens.sol\";\nimport { PoolLensSecondary } from \"../PoolLensSecondary.sol\";\nimport { JumpRateModel } from \"../compound/JumpRateModel.sol\";\nimport { LeveredPositionsLens } from \"../ionic/levered/LeveredPositionsLens.sol\";\nimport { IonicFlywheelLensRouter, IonicComptroller, ICErc20, ERC20, IPriceOracle_IFLR } from \"../ionic/strategies/flywheel/IonicFlywheelLensRouter.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\n\nimport \"forge-std/console.sol\";\n\nstruct HealthFactorVars {\n  uint256 usdcSupplied;\n  uint256 wethSupplied;\n  uint256 ezEthSuppled;\n  uint256 stoneSupplied;\n  uint256 wbtcSupplied;\n  uint256 weEthSupplied;\n  uint256 merlinBTCSupplied;\n  uint256 usdcBorrowed;\n  uint256 wethBorrowed;\n  uint256 ezEthBorrowed;\n  uint256 stoneBorrowed;\n  uint256 wbtcBorrowed;\n  uint256 weEthBorrowed;\n  uint256 merlinBTCBorrowed;\n  ICErc20 testCToken;\n  address testUnderlying;\n  uint256 amountBorrow;\n}\n\ncontract DevTesting is BaseTest {\n  IonicComptroller pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n  PoolLensSecondary lens2 = PoolLensSecondary(0x7Ea7BB80F3bBEE9b52e6Ed3775bA06C9C80D4154);\n  PoolLens lens = PoolLens(0x70BB19a56BfAEc65aE861E6275A90163AbDF36a6);\n  LeveredPositionsLens levPosLens;\n\n  address deployer = 0x1155b614971f16758C92c4890eD338C9e3ede6b7;\n  address multisig = 0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2;\n\n  ICErc20 wethMarket;\n  ICErc20 usdcMarket;\n  ICErc20 usdtMarket;\n  ICErc20 wbtcMarket;\n  ICErc20 ezEthMarket;\n  ICErc20 stoneMarket;\n  ICErc20 weEthMarket;\n  ICErc20 merlinBTCMarket;\n\n  // mode mainnet assets\n  address WETH = 0x4200000000000000000000000000000000000006;\n  address USDC = 0xd988097fb8612cc24eeC14542bC03424c656005f;\n  address USDT = 0xf0F161fDA2712DB8b566946122a5af183995e2eD;\n  address WBTC = 0xcDd475325D6F564d27247D1DddBb0DAc6fA0a5CF;\n  address UNI = 0x3e7eF8f50246f725885102E8238CBba33F276747;\n  address SNX = 0x9e5AAC1Ba1a2e6aEd6b32689DFcF62A509Ca96f3;\n  address LINK = 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb;\n  address DAI = 0xE7798f023fC62146e8Aa1b36Da45fb70855a77Ea;\n  address BAL = 0xD08a2917653d4E460893203471f0000826fb4034;\n  address AAVE = 0x7c6b91D9Be155A6Db01f749217d76fF02A7227F2;\n  address weETH = 0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A;\n  address merlinBTC = 0x59889b7021243dB5B1e065385F918316cD90D46c;\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    if (block.chainid == MODE_MAINNET) {\n      wethMarket = ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2);\n      usdcMarket = ICErc20(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038);\n      usdtMarket = ICErc20(0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3);\n      wbtcMarket = ICErc20(0xd70254C3baD29504789714A7c69d60Ec1127375C);\n      ezEthMarket = ICErc20(0x59e710215d45F584f44c0FEe83DA6d43D762D857);\n      stoneMarket = ICErc20(0x959FA710CCBb22c7Ce1e59Da82A247e686629310);\n      weEthMarket = ICErc20(0xA0D844742B4abbbc43d8931a6Edb00C56325aA18);\n      merlinBTCMarket = ICErc20(0x19F245782b1258cf3e11Eda25784A378cC18c108);\n    } else {\n      ICErc20[] memory markets = pool.getAllMarkets();\n      wethMarket = markets[0];\n      usdcMarket = markets[1];\n    }\n    levPosLens = LeveredPositionsLens(ap.getAddress(\"LeveredPositionsLens\"));\n  }\n\n  function testModePoolBorrowers() public debuggingOnly fork(MODE_MAINNET) {\n    emit log_named_array(\"borrowers\", pool.getAllBorrowers());\n  }\n\n  function testModeLiquidationShortfall() public debuggingOnly fork(MODE_MAINNET) {\n    (uint256 err, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(\n      0xa75F9C8246f7269279bE4c969e7Bc6Eb619cC204\n    );\n\n    emit log_named_uint(\"err\", err);\n    emit log_named_uint(\"collateralValue\", collateralValue);\n    emit log_named_uint(\"liquidity\", liquidity);\n    emit log_named_uint(\"shortfall\", shortfall);\n  }\n\n  function testModeHealthFactor() public debuggingOnly fork(MODE_MAINNET) {\n    address rahul = 0x5A9e792143bf2708b4765C144451dCa54f559a19;\n\n    uint256 wethSupplied = wethMarket.balanceOfUnderlying(rahul);\n    uint256 usdcSupplied = usdcMarket.balanceOfUnderlying(rahul);\n    uint256 usdtSupplied = usdtMarket.balanceOfUnderlying(rahul);\n    uint256 wbtcSupplied = wbtcMarket.balanceOfUnderlying(rahul);\n    // emit log_named_uint(\"wethSupplied\", wethSupplied);\n    emit log_named_uint(\"usdcSupplied\", usdcSupplied);\n    emit log_named_uint(\"usdtSupplied\", usdtSupplied);\n    emit log_named_uint(\"wbtcSupplied\", wbtcSupplied);\n    emit log_named_uint(\"value of wethSupplied\", wethSupplied * pool.oracle().getUnderlyingPrice(wethMarket));\n    emit log_named_uint(\"value of usdcSupplied\", usdcSupplied * pool.oracle().getUnderlyingPrice(usdcMarket));\n    emit log_named_uint(\"value of usdtSupplied\", usdtSupplied * pool.oracle().getUnderlyingPrice(usdtMarket));\n    emit log_named_uint(\"value of wbtcSupplied\", wbtcSupplied * pool.oracle().getUnderlyingPrice(wbtcMarket));\n\n    PoolLens newImpl = new PoolLens();\n    //    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(lens)));\n    //    vm.prank(dpa.owner());\n    //    proxy.upgradeTo(address(newImpl));\n\n    uint256 hf = newImpl.getHealthFactor(rahul, pool);\n\n    emit log_named_uint(\"hf\", hf);\n  }\n\n  function testNetAprMode() public debuggingOnly forkAtBlock(MODE_MAINNET, 8479829) {\n    address user = 0x30D5047e839f079bDE1Ab16b34668f57391DacB3;\n    int256 blocks = 30 * 24 * 365 * 60;\n    IonicFlywheelLensRouter lensRouter = new IonicFlywheelLensRouter(\n      PoolDirectory(0x39C353Cf9041CcF467A04d0e78B63d961E81458a)\n    );\n    int256 apr = lensRouter.getUserNetApr(user, blocks);\n\n    emit log_named_int(\"apr\", apr);\n  }\n\n  function testModeUsdcBorrowCaps() public debuggingOnly fork(MODE_MAINNET) {\n    _testModeBorrowCaps(usdcMarket);\n  }\n\n  function testHypotheticalPosition() public debuggingOnly forkAtBlock(MODE_MAINNET, 8028296) {\n    HealthFactorVars memory vars;\n\n    address wolfy = 0x7d922bf0975424b3371074f54cC784AF738Dac0D;\n    address usdcWhale = 0x70FF197c32E922700d3ff2483D250c645979855d;\n    address wbtcWhale = 0xBD8CCf3ebE4CC2D57962cdC2756B143ce0135a6B;\n    address wethWhale = 0xD746A2a6048C5D3AFF5766a8c4A0C8cFD2311745;\n\n    address whale = wbtcWhale;\n    vars.testCToken = wethMarket;\n    vars.testUnderlying = WETH;\n    vars.amountBorrow = 1e18 / 2;\n\n    address[] memory cTokens = new address[](1);\n\n    vm.startPrank(usdcWhale);\n    ERC20(USDC).transfer(wolfy, ERC20(USDC).balanceOf(usdcWhale));\n    vm.stopPrank();\n\n    vm.startPrank(wbtcWhale);\n    ERC20(WBTC).transfer(wolfy, ERC20(WBTC).balanceOf(wbtcWhale));\n    vm.stopPrank();\n\n    vm.startPrank(wethWhale);\n    ERC20(WETH).transfer(wolfy, ERC20(WETH).balanceOf(wethWhale));\n    vm.stopPrank();\n\n    // emit log_named_uint(\"USDC balance\", ERC20(USDC).balanceOf(wolfy));\n    // emit log_named_uint(\"WBTC balance\", ERC20(WBTC).balanceOf(wolfy));\n    // emit log_named_uint(\"WETH balance\", ERC20(WETH).balanceOf(wolfy));\n\n    vm.startPrank(wolfy);\n\n    ERC20(USDC).approve(address(usdcMarket), ERC20(USDC).balanceOf(wolfy));\n    usdcMarket.mint(ERC20(USDC).balanceOf(wolfy));\n    cTokens[0] = address(usdcMarket);\n    pool.enterMarkets(cTokens);\n\n    ERC20(WBTC).approve(address(wbtcMarket), ERC20(WBTC).balanceOf(wolfy));\n    wbtcMarket.mint(ERC20(WBTC).balanceOf(wolfy));\n    cTokens[0] = address(wbtcMarket);\n    pool.enterMarkets(cTokens);\n\n    ERC20(WETH).approve(address(wethMarket), ERC20(WETH).balanceOf(wolfy));\n    wethMarket.mint(ERC20(WETH).balanceOf(wolfy));\n    cTokens[0] = address(wethMarket);\n    pool.enterMarkets(cTokens);\n\n    wethMarket.borrow(1e18);\n\n    vm.stopPrank();\n\n    vars.usdcSupplied = usdcMarket.balanceOfUnderlying(wolfy);\n    vars.wethSupplied = wethMarket.balanceOfUnderlying(wolfy);\n    vars.ezEthSuppled = ezEthMarket.balanceOfUnderlying(wolfy);\n    vars.stoneSupplied = stoneMarket.balanceOfUnderlying(wolfy);\n    vars.wbtcSupplied = wbtcMarket.balanceOfUnderlying(wolfy);\n    vars.weEthSupplied = weEthMarket.balanceOfUnderlying(wolfy);\n    vars.merlinBTCSupplied = merlinBTCMarket.balanceOfUnderlying(wolfy);\n\n    vars.usdcBorrowed = usdcMarket.borrowBalanceCurrent(wolfy);\n    vars.wethBorrowed = wethMarket.borrowBalanceCurrent(wolfy);\n    vars.ezEthBorrowed = ezEthMarket.borrowBalanceCurrent(wolfy);\n    vars.stoneBorrowed = stoneMarket.borrowBalanceCurrent(wolfy);\n    vars.wbtcBorrowed = wbtcMarket.borrowBalanceCurrent(wolfy);\n    vars.weEthBorrowed = weEthMarket.borrowBalanceCurrent(wolfy);\n    vars.merlinBTCBorrowed = merlinBTCMarket.borrowBalanceCurrent(wolfy);\n\n    emit log_named_uint(\"usdcSupplied\", vars.usdcSupplied);\n    emit log_named_uint(\"wethSupplied\", vars.wethSupplied);\n    emit log_named_uint(\"ezEthSupplied\", vars.ezEthSuppled);\n    emit log_named_uint(\"stoneSupplied\", vars.stoneSupplied);\n    emit log_named_uint(\"wbtcSupplied\", vars.wbtcSupplied);\n    emit log_named_uint(\"weEthSupplied\", vars.weEthSupplied);\n    emit log_named_uint(\"merlinBTCSupplied\", vars.merlinBTCSupplied);\n\n    emit log_named_uint(\"-------------------------------------------------\", 0);\n    emit log_named_uint(\"usdcBorrowed\", vars.usdcBorrowed);\n    emit log_named_uint(\"wethBorrowed\", vars.wethBorrowed);\n    emit log_named_uint(\"ezEthBorrowed\", vars.ezEthBorrowed);\n    emit log_named_uint(\"stoneBorrowed\", vars.stoneBorrowed);\n    emit log_named_uint(\"wbtcBorrowed\", vars.wbtcBorrowed);\n    emit log_named_uint(\"weEthBorrowed\", vars.weEthBorrowed);\n    emit log_named_uint(\"merlinBTCBorrowed\", vars.merlinBTCBorrowed);\n\n    // emit log_named_uint(\"value of usdcSupplied\", vars.usdcSupplied * pool.oracle().getUnderlyingPrice(usdcMarket));\n    // emit log_named_uint(\"value of wethSupplied\", vars.wethSupplied * pool.oracle().getUnderlyingPrice(wethMarket));\n    // emit log_named_uint(\"value of ezEthSupplied\", vars.ezEthSuppled * pool.oracle().getUnderlyingPrice(ezEthMarket));\n    // emit log_named_uint(\"value of stoneSupplied\", vars.stoneSupplied * pool.oracle().getUnderlyingPrice(stoneMarket));\n    // emit log_named_uint(\"value of wbtcSupplied\", vars.wbtcSupplied * pool.oracle().getUnderlyingPrice(wbtcMarket));\n\n    // emit log_named_uint(\"value of usdcBorrowed\", vars.usdcBorrowed * pool.oracle().getUnderlyingPrice(usdcMarket));\n    // emit log_named_uint(\"value of wethBorrowed\", vars.wethBorrowed * pool.oracle().getUnderlyingPrice(wethMarket));\n    // emit log_named_uint(\"value of ezEthBorrowed\", vars.ezEthBorrowed * pool.oracle().getUnderlyingPrice(ezEthMarket));\n    // emit log_named_uint(\"value of stoneBorrowed\", vars.stoneBorrowed * pool.oracle().getUnderlyingPrice(stoneMarket));\n    // emit log_named_uint(\"value of wbtcBorrowed\", vars.wbtcBorrowed * pool.oracle().getUnderlyingPrice(wbtcMarket));\n\n    vm.startPrank(whale);\n    ERC20(vars.testUnderlying).transfer(wolfy, ERC20(vars.testUnderlying).balanceOf(whale));\n    vm.stopPrank();\n\n    uint256 hf = lens.getHealthFactor(wolfy, pool);\n    uint256 hypothetical = lens.getHealthFactorHypothetical(\n      pool,\n      wolfy,\n      address(vars.testCToken),\n      0,\n      0,\n      vars.amountBorrow\n    );\n\n    (uint256 err, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(wolfy);\n\n    emit log_named_uint(\"-------------------------------------------------\", 0);\n    emit log_named_uint(\"Collateral Value Before\", collateralValue);\n    emit log_named_uint(\"Liquidity Before\", liquidity);\n    emit log_named_uint(\"hf before\", hf);\n    emit log_named_uint(\"hypothetical hf\", hypothetical);\n\n    vm.startPrank(wolfy);\n    ERC20(vars.testUnderlying).approve(address(vars.testCToken), vars.amountBorrow);\n    vars.testCToken.repayBorrow(vars.amountBorrow);\n    vm.stopPrank();\n\n    uint256 hfAfter = lens.getHealthFactor(wolfy, pool);\n    (err, collateralValue, liquidity, shortfall) = pool.getAccountLiquidity(wolfy);\n\n    emit log_named_uint(\"-------------------------------------------------\", 0);\n    emit log_named_uint(\"Collateral Value After\", collateralValue);\n    emit log_named_uint(\"Liquidity After\", liquidity);\n    emit log_named_uint(\"hf after\", hfAfter);\n    emit log_named_uint(\"user balance after\", ERC20(vars.testUnderlying).balanceOf(wolfy));\n    emit log_named_uint(\"new borrow balance after repay\", vars.testCToken.borrowBalanceCurrent(wolfy));\n  }\n\n  function testModeUsdtBorrowCaps() public debuggingOnly fork(MODE_MAINNET) {\n    _testModeBorrowCaps(usdtMarket);\n  }\n\n  function testModeWethBorrowCaps() public debuggingOnly fork(MODE_MAINNET) {\n    _testModeBorrowCaps(wethMarket);\n    wethMarket.accrueInterest();\n    _testModeBorrowCaps(wethMarket);\n  }\n\n  function _testModeBorrowCaps(ICErc20 market) internal {\n    uint256 borrowCapUsdc = pool.borrowCaps(address(market));\n    uint256 totalBorrowsCurrent = market.totalBorrowsCurrent();\n\n    uint256 wethBorrowAmount = 154753148031252;\n    console.log(\"borrowCapUsdc %e\", borrowCapUsdc);\n    console.log(\"totalBorrowsCurrent %e\", totalBorrowsCurrent);\n    console.log(\"new totalBorrowsCurrent %e\", totalBorrowsCurrent + wethBorrowAmount);\n  }\n\n  function testMarketMember() public debuggingOnly fork(MODE_MAINNET) {\n    address rahul = 0x5A9e792143bf2708b4765C144451dCa54f559a19;\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    for (uint256 i = 0; i < markets.length; i++) {\n      if (pool.checkMembership(rahul, markets[i])) {\n        emit log(\"is a member\");\n      } else {\n        emit log(\"NOT a member\");\n      }\n    }\n  }\n\n  function testGetCashError() public debuggingOnly fork(MODE_MAINNET) {\n    ICErc20 market = ICErc20(0x49950319aBE7CE5c3A6C90698381b45989C99b46);\n    market.getCash();\n  }\n\n  function testWrsEthBalanceOfError() public debuggingOnly fork(MODE_MAINNET) {\n    address wrsEthMarketAddress = 0x49950319aBE7CE5c3A6C90698381b45989C99b46;\n    ERC20 wrsEth = ERC20(0xe7903B1F75C534Dd8159b313d92cDCfbC62cB3Cd);\n    wrsEth.balanceOf(0x1155b614971f16758C92c4890eD338C9e3ede6b7);\n  }\n\n  function testModeRepay() public debuggingOnly fork(MODE_MAINNET) {\n    address user = 0x1A3C4E9B49e4fc595fB7e5f723159bA73a9426e7;\n    ICErc20 market = usdcMarket;\n    ERC20 asset = ERC20(market.underlying());\n\n    uint256 borrowBalance = market.borrowBalanceCurrent(user);\n    emit log_named_uint(\"borrowBalance\", borrowBalance);\n\n    vm.startPrank(user);\n    asset.approve(address(market), borrowBalance);\n    uint256 err = market.repayBorrow(borrowBalance / 2);\n\n    emit log_named_uint(\"error\", err);\n  }\n\n  function testAssetsPrices() public debuggingOnly fork(MODE_MAINNET) {\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    emit log_named_uint(\"WETH price\", mpo.price(WETH));\n    emit log_named_uint(\"USDC price\", mpo.price(USDC));\n    emit log_named_uint(\"USDT price\", mpo.price(USDT));\n    emit log_named_uint(\"UNI price\", mpo.price(UNI));\n    emit log_named_uint(\"SNX price\", mpo.price(SNX));\n    emit log_named_uint(\"LINK price\", mpo.price(LINK));\n    emit log_named_uint(\"DAI price\", mpo.price(DAI));\n    emit log_named_uint(\"BAL price\", mpo.price(BAL));\n    emit log_named_uint(\"AAVE price\", mpo.price(AAVE));\n    emit log_named_uint(\"WBTC price\", mpo.price(WBTC));\n  }\n\n  function testDeployedMarkets() public debuggingOnly fork(MODE_MAINNET) {\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    for (uint8 i = 0; i < markets.length; i++) {\n      emit log_named_address(\"market\", address(markets[i]));\n      emit log(markets[i].symbol());\n      emit log(markets[i].name());\n    }\n  }\n\n  function testDisableCollateralUsdc() public debuggingOnly fork(MODE_MAINNET) {\n    address user = 0xF70CBE91fB1b1AfdeB3C45Fb8CDD2E1249b5b75E;\n    address usdcMarketAddr = 0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038;\n\n    vm.startPrank(user);\n\n    uint256 borrowed = ICErc20(usdcMarketAddr).borrowBalanceCurrent(user);\n\n    emit log_named_uint(\"borrowed\", borrowed);\n\n    pool.exitMarket(usdcMarketAddr);\n  }\n\n  function testBorrowRateAtRatio() public debuggingOnly fork(MODE_MAINNET) {\n    uint256 rate = levPosLens.getBorrowRateAtRatio(wethMarket, ezEthMarket, 9988992945501686, 2e18);\n    emit log_named_uint(\"borrow rate at ratio\", rate);\n  }\n\n  function testAssetAsCollateralCap() public debuggingOnly fork(MODE_MAINNET) {\n    address MODE_EZETH = 0x2416092f143378750bb29b79eD961ab195CcEea5;\n    address ezEthWhale = 0x2344F131B07E6AFd943b0901C55898573F0d1561;\n\n    vm.startPrank(multisig);\n    uint256 errCode = pool._deployMarket(\n      1, //delegateType\n      abi.encode(\n        MODE_EZETH,\n        address(pool),\n        ap.getAddress(\"FeeDistributor\"),\n        0x21a455cEd9C79BC523D4E340c2B97521F4217817, // irm - jump rate model on mode\n        \"Ionic Renzo Restaked ETH\",\n        \"ionezETH\",\n        0.10e18,\n        0.10e18\n      ),\n      \"\",\n      0.70e18\n    );\n    vm.stopPrank();\n    require(errCode == 0, \"error deploying market\");\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n    ICErc20 ezEthMarket = markets[markets.length - 1];\n\n    //    uint256 cap = pool.getAssetAsCollateralValueCap(ezEthMarket, usdcMarket, false, deployer);\n    uint256 cap = pool.supplyCaps(address(ezEthMarket));\n    require(cap == 0, \"non-zero cap\");\n\n    vm.startPrank(ezEthWhale);\n    ERC20(MODE_EZETH).approve(address(ezEthMarket), 1e36);\n    errCode = ezEthMarket.mint(1e18);\n    require(errCode == 0, \"should be unable to supply\");\n  }\n\n  function testNewStoneMarketCapped() public debuggingOnly fork(MODE_MAINNET) {\n    address MODE_STONE = 0x80137510979822322193FC997d400D5A6C747bf7;\n    address stoneWhale = 0x76486cbED5216C82d26Ee60113E48E06C189541A;\n\n    address redstoneOracleAddress = 0x63A1531a06F0Ac597a0DfA5A516a37073c3E1e0a;\n    RedstoneAdapterPriceOracle oracle = RedstoneAdapterPriceOracle(redstoneOracleAddress);\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = oracle;\n    vm.prank(mpo.admin());\n    mpo.add(asArray(MODE_STONE), oracles);\n\n    vm.startPrank(multisig);\n    uint256 errCode = pool._deployMarket(\n      1, //delegateType\n      abi.encode(\n        MODE_STONE,\n        address(pool),\n        ap.getAddress(\"FeeDistributor\"),\n        0x21a455cEd9C79BC523D4E340c2B97521F4217817, // irm - jump rate model on mode\n        \"Ionic StakeStone Ether\",\n        \"ionSTONE\",\n        0.10e18,\n        0.10e18\n      ),\n      \"\",\n      0.70e18\n    );\n    vm.stopPrank();\n    require(errCode == 0, \"error deploying market\");\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n    ICErc20 stoneMarket = markets[markets.length - 1];\n\n    //    uint256 cap = pool.getAssetAsCollateralValueCap(stoneMarket, usdcMarket, false, deployer);\n    uint256 cap = pool.supplyCaps(address(stoneMarket));\n    require(cap == 0, \"non-zero cap\");\n\n    vm.startPrank(stoneWhale);\n    ERC20(MODE_STONE).approve(address(stoneMarket), 1e36);\n    vm.expectRevert(\"not authorized\");\n    errCode = stoneMarket.mint(1e18);\n    //require(errCode != 0, \"should be unable to supply\");\n  }\n\n  function testRegisterSFS() public debuggingOnly fork(MODE_MAINNET) {\n    emit log_named_address(\"pool admin\", pool.admin());\n\n    vm.startPrank(multisig);\n    pool.registerInSFS();\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    for (uint8 i = 0; i < markets.length; i++) {\n      markets[i].registerInSFS();\n    }\n  }\n\n  function upgradePool() internal {\n    ComptrollerFirstExtension newComptrollerExtension = new ComptrollerFirstExtension();\n\n    Unitroller asUnitroller = Unitroller(payable(address(pool)));\n\n    // upgrade to the new comptroller extension\n    vm.startPrank(asUnitroller.admin());\n    asUnitroller._registerExtension(newComptrollerExtension, DiamondExtension(asUnitroller._listExtensions()[1]));\n\n    //asUnitroller._upgrade();\n    vm.stopPrank();\n  }\n\n  function testModeBorrowRate() public fork(MODE_MAINNET) {\n    //ICErc20[] memory markets = pool.getAllMarkets();\n\n    IonicComptroller pool = ezEthMarket.comptroller();\n    vm.prank(pool.admin());\n    ezEthMarket._setInterestRateModel(JumpRateModel(0x413aD59b80b1632988d478115a466bdF9B26743a));\n\n    JumpRateModel discRateModel = JumpRateModel(ezEthMarket.interestRateModel());\n\n    uint256 borrows = 200e18;\n    uint256 cash = 5000e18 - borrows;\n    uint256 reserves = 1e18;\n    uint256 rate = discRateModel.getBorrowRate(cash, borrows, reserves);\n\n    emit log_named_uint(\"rate per year %e\", rate * discRateModel.blocksPerYear());\n  }\n\n  function testModeFetchBorrowers() public fork(MODE_MAINNET) {\n    //    address[] memory borrowers = pool.getAllBorrowers();\n    //    emit log_named_uint(\"borrowers.len\", borrowers.length);\n\n    //upgradePool();\n\n    (uint256 totalPages, address[] memory borrowersPage) = pool.getPaginatedBorrowers(1, 0);\n\n    emit log_named_uint(\"total pages with 300 size (default)\", totalPages);\n\n    (totalPages, borrowersPage) = pool.getPaginatedBorrowers(totalPages - 1, 50);\n    emit log_named_array(\"last page of 300 borrowers\", borrowersPage);\n\n    (totalPages, borrowersPage) = pool.getPaginatedBorrowers(1, 50);\n    emit log_named_uint(\"total pages with 50 size\", totalPages);\n    emit log_named_array(\"page of 50 borrowers\", borrowersPage);\n\n    //    for (uint256 i = 0; i < borrowers.length; i++) {\n    //      (\n    //        uint256 error,\n    //        uint256 collateralValue,\n    //        uint256 liquidity,\n    //        uint256 shortfall\n    //      ) = pool.getAccountLiquidity(borrowers[i]);\n    //\n    //      emit log(\"\");\n    //      emit log_named_address(\"user\", borrowers[i]);\n    //      emit log_named_uint(\"collateralValue\", collateralValue);\n    //      if (liquidity > 0) emit log_named_uint(\"liquidity\", liquidity);\n    //      if (shortfall > 0) emit log_named_uint(\"SHORTFALL\", shortfall);\n    //    }\n  }\n\n  function testModeAccountLiquidity() public debuggingOnly fork(MODE_MAINNET) {\n    _testAccountLiquidity(0x0C387030a5D3AcDcde1A8DDaF26df31BbC1CE763);\n  }\n\n  function _testAccountLiquidity(address borrower) internal {\n    (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(borrower);\n\n    emit log(\"\");\n    emit log_named_address(\"user\", borrower);\n    emit log_named_uint(\"collateralValue\", collateralValue);\n    if (liquidity > 0) emit log_named_uint(\"liquidity\", liquidity);\n    if (shortfall > 0) emit log_named_uint(\"SHORTFALL\", shortfall);\n  }\n\n  function testModeDeployMarket() public debuggingOnly fork(MODE_MAINNET) {\n    address MODE_WEETH = 0x028227c4dd1e5419d11Bb6fa6e661920c519D4F5;\n    address weEthWhale = 0x6e55a90772B92f17f87Be04F9562f3faafd0cc38;\n\n    vm.startPrank(pool.admin());\n    uint256 errCode = pool._deployMarket(\n      1, //delegateType\n      abi.encode(\n        MODE_WEETH,\n        address(pool),\n        ap.getAddress(\"FeeDistributor\"),\n        0x21a455cEd9C79BC523D4E340c2B97521F4217817, // irm - jump rate model on mode\n        \"Ionic Wrapped eETH\",\n        \"ionweETH\",\n        0.10e18,\n        0.10e18\n      ),\n      \"\",\n      0.70e18\n    );\n    vm.stopPrank();\n    require(errCode == 0, \"error deploying market\");\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n    ICErc20 weEthMarket = markets[markets.length - 1];\n\n    //    uint256 cap = pool.getAssetAsCollateralValueCap(weEthMarket, usdcMarket, false, deployer);\n    uint256 cap = pool.supplyCaps(address(weEthMarket));\n    require(cap == 0, \"non-zero cap\");\n\n    vm.startPrank(weEthWhale);\n    ERC20(MODE_WEETH).approve(address(weEthMarket), 1e36);\n    errCode = weEthMarket.mint(0.01e18);\n    require(errCode == 0, \"should be unable to supply\");\n  }\n\n  function testModeWrsETH() public debuggingOnly forkAtBlock(MODE_MAINNET, 6635923) {\n    address wrsEth = 0x4186BFC76E2E237523CBC30FD220FE055156b41F;\n    RedstoneAdapterPriceOracleWrsETH oracle = new RedstoneAdapterPriceOracleWrsETH(\n      0x7C1DAAE7BB0688C9bfE3A918A4224041c7177256\n    );\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = oracle;\n    vm.prank(multisig);\n    mpo.add(asArray(wrsEth), oracles);\n\n    uint256 price = mpo.price(wrsEth);\n    emit log_named_uint(\"price of wrsEth\", price);\n  }\n\n  function testModeWeETH() public debuggingOnly forkAtBlock(MODE_MAINNET, 6861468) {\n    address weEth = 0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A;\n    RedstoneAdapterPriceOracleWeETH oracle = new RedstoneAdapterPriceOracleWeETH(\n      0x7C1DAAE7BB0688C9bfE3A918A4224041c7177256\n    );\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = oracle;\n    vm.prank(multisig);\n    mpo.add(asArray(weEth), oracles);\n\n    uint256 price = mpo.price(weEth);\n    emit log_named_uint(\"price of weEth\", price);\n    assertEq(price, 1036212437077011599);\n  }\n\n  function testPERLiquidation() public debuggingOnly forkAtBlock(MODE_MAINNET, 10255413) {\n    vm.prank(0x5Cc070844E98F4ceC5f2fBE1592fB1ed73aB7b48);\n    _functionCall(0xa12c1E460c06B1745EFcbfC9A1f666a8749B0e3A, hex\"20b72325000000000000000000000000f28570694a6c9cd0494955966ae75af61abf5a0700000000000000000000000000000000000000000000000001bc1214ed792fbb0000000000000000000000004341620757bee7eb4553912fafc963e59c949147000000000000000000000000c53edeafb6d502daec5a7015d67936cea0cd0f520000000000000000000000000000000000000000000000000000000000000000\", \"error in call\");\n  }\n\n  function testCtokenUpgrade() public debuggingOnly forkAtBlock(MODE_MAINNET, 10255413) {\n    CErc20PluginRewardsDelegate newImpl = new CErc20PluginRewardsDelegate();\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(wethMarket)));\n\n\n    (uint256[] memory poolIds, PoolDirectory.Pool[] memory pools) = PoolDirectory(0x39C353Cf9041CcF467A04d0e78B63d961E81458a).getActivePools();\n\n    emit log_named_uint(\"First Pool ID\", poolIds[0]);\n    emit log_named_uint(\"First Pool ID\", poolIds[1]);\n    emit log_named_string(\"First Pool Address\", pools[0].name);\n    emit log_named_string(\"First Pool Address\", pools[0].name);\n    emit log_named_address(\"First Pool Address\", pools[0].creator);\n    emit log_named_address(\"First Pool Address\", pools[1].creator);\n    emit log_named_address(\"First Pool Address\", pools[0].comptroller);\n    emit log_named_address(\"First Pool Address\", pools[1].comptroller);\n    //bytes32 bytesAtSlot = vm.load(address(proxy), 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\n    //address admin = address(uint160(uint256(bytesAtSlot)));\n    //vm.prank(admin);\n    //proxy.upgradeTo(address(newImpl));\n\n    //vm.prank(dpa.owner());\n    //proxy.upgradeTo(address(newImpl));\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function testRawCall() public debuggingOnly forkAtBlock(MODE_MAINNET, 7337902) {\n    address caller = 0x2b81E6C41636BaEa95a1Da5c688cCcd938f9Af33;\n    address target = 0x9B506A03bBFf2a842866b10BC6732da72640cd45;\n\n    ERC20(WETH).allowance(caller, target);\n\n    bytes\n      memory data = hex\"534da46000000000000000000000000059e710215d45f584f44c0fee83da6d43d762d8570000000000000000000000002be717340023c9e14c1bb12cb3ecbcfd3c3fb0380000000000000000000000002416092f143378750bb29b79ed961ab195cceea500000000000000000000000000000000000000000000000015faebcf6161ab5d00000000000000000000000000000000000000000000000029a2241af62c0000\";\n    vm.prank(caller);\n    _functionCall(target, data, \"raw call failed\");\n  }\n}\n"
    },
    "contracts/test/ExtensionsTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MarketsTest } from \"./config/MarketsTest.t.sol\";\n\nimport { DiamondExtension, DiamondBase } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../compound/CErc20PluginDelegate.sol\";\nimport { CErc20Delegator } from \"../compound/CErc20Delegator.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { CTokenFirstExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { ComptrollerV3Storage } from \"../compound/ComptrollerStorage.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract MockComptrollerExtension is DiamondExtension, ComptrollerV3Storage {\n  function getFirstMarketSymbol() public view returns (string memory) {\n    return allMarkets[0].symbol();\n  }\n\n  function _setTransferPaused(bool) public returns (bool) {\n    return false;\n  }\n\n  function _setSeizePaused(bool) public returns (bool) {\n    return false;\n  }\n\n  // a dummy fn to test if the replacement of extension fns works\n  function getSecondMarketSymbol() public view returns (string memory) {\n    return allMarkets[1].symbol();\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 4;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this._setTransferPaused.selector;\n    functionSelectors[--fnsCount] = this._setSeizePaused.selector;\n    functionSelectors[--fnsCount] = this.getFirstMarketSymbol.selector;\n    functionSelectors[--fnsCount] = this.getSecondMarketSymbol.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n}\n\ncontract MockSecondComptrollerExtension is DiamondExtension, ComptrollerV3Storage {\n  function getThirdMarketSymbol() public view returns (string memory) {\n    return allMarkets[2].symbol();\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 1;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.getThirdMarketSymbol.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n}\n\ncontract MockThirdComptrollerExtension is DiamondExtension, ComptrollerV3Storage {\n  function getFourthMarketSymbol() public view returns (string memory) {\n    return allMarkets[3].symbol();\n  }\n\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\n    uint8 fnsCount = 1;\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\n    functionSelectors[--fnsCount] = this.getFourthMarketSymbol.selector;\n    require(fnsCount == 0, \"use the correct array length\");\n    return functionSelectors;\n  }\n}\n\ncontract ExtensionsTest is MarketsTest {\n  MockComptrollerExtension internal mockExtension;\n  MockSecondComptrollerExtension internal second;\n  MockThirdComptrollerExtension internal third;\n\n  function afterForkSetUp() internal virtual override {\n    super.afterForkSetUp();\n    mockExtension = new MockComptrollerExtension();\n    second = new MockSecondComptrollerExtension();\n    third = new MockThirdComptrollerExtension();\n  }\n\n  function testExtensionReplace() public debuggingOnly fork(BSC_MAINNET) {\n    address payable jFiatPoolAddress = payable(0x31d76A64Bc8BbEffb601fac5884372DEF910F044);\n    _upgradeExistingPool(jFiatPoolAddress);\n\n    // replace the first extension with the mock\n    vm.prank(ffd.owner());\n    ffd._registerComptrollerExtension(jFiatPoolAddress, mockExtension, comptrollerExtension);\n\n    // assert that the replacement worked\n    MockComptrollerExtension asMockExtension = MockComptrollerExtension(jFiatPoolAddress);\n    emit log(asMockExtension.getSecondMarketSymbol());\n    assertEq(asMockExtension.getSecondMarketSymbol(), \"fETH-1\", \"market symbol does not match\");\n\n    // add a second mock extension\n    vm.prank(ffd.owner());\n    ffd._registerComptrollerExtension(jFiatPoolAddress, second, DiamondExtension(address(0)));\n\n    // add again the third, removing the second\n    vm.prank(ffd.owner());\n    ffd._registerComptrollerExtension(jFiatPoolAddress, third, second);\n\n    // assert that it worked\n    DiamondBase asBase = DiamondBase(jFiatPoolAddress);\n    address[] memory currentExtensions = asBase._listExtensions();\n    assertEq(currentExtensions.length, 2, \"extensions count does not match\");\n    assertEq(currentExtensions[0], address(mockExtension), \"!first\");\n    assertEq(currentExtensions[1], address(third), \"!second\");\n  }\n\n  function testNewPoolExtensions() public fork(BSC_MAINNET) {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    _prepareComptrollerUpgrade(address(0));\n\n    // deploy a pool that will have an extension registered automatically\n    {\n      (, address poolAddress) = fpd.deployPool(\n        \"just-a-test2\",\n        latestComptrollerImplementation,\n        abi.encode(payable(address(ffd))),\n        false,\n        0.1e18,\n        1.1e18,\n        ap.getAddress(\"MasterPriceOracle\")\n      );\n\n      address[] memory initExtensionsAfter = DiamondBase(payable(poolAddress))._listExtensions();\n      assertEq(initExtensionsAfter.length, 1, \"remove this if the ffd config is set up\");\n      assertEq(initExtensionsAfter[0], address(comptrollerExtension), \"first extension is not the CFE\");\n    }\n  }\n\n  function testMulticallMarket() public fork(BSC_MAINNET) {\n    uint8 random = uint8(block.timestamp % 256);\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    ComptrollerFirstExtension somePool = ComptrollerFirstExtension(pools[random % pools.length].comptroller);\n    ICErc20[] memory markets = somePool.getAllMarkets();\n\n    if (markets.length == 0) return;\n\n    ICErc20 someMarket = markets[random % markets.length];\n\n    emit log(\"pool\");\n    emit log_address(address(somePool));\n    emit log(\"market\");\n    emit log_address(address(someMarket));\n\n    vm.roll(block.number + 1);\n\n    bytes memory blockNumberBeforeCall = abi.encodeWithSelector(someMarket.accrualBlockNumber.selector);\n    bytes memory accrueInterestCall = abi.encodeWithSelector(someMarket.accrueInterest.selector);\n    bytes memory blockNumberAfterCall = abi.encodeWithSelector(someMarket.accrualBlockNumber.selector);\n    bytes[] memory results = someMarket.multicall(\n      asArray(blockNumberBeforeCall, accrueInterestCall, blockNumberAfterCall)\n    );\n    uint256 blockNumberBefore = abi.decode(results[0], (uint256));\n    uint256 blockNumberAfter = abi.decode(results[2], (uint256));\n\n    assertGt(blockNumberAfter, blockNumberBefore, \"did not accrue?\");\n  }\n\n  function testBscExistingCTokenExtensionUpgrade() public fork(BSC_MAINNET) {\n    _testAllPoolsAllMarketsCTokenExtensionUpgrade();\n  }\n\n  function testArbitrumExistingCTokenExtensionUpgrade() public fork(ARBITRUM_ONE) {\n    _testAllPoolsAllMarketsCTokenExtensionUpgrade();\n  }\n\n  function _testAllPoolsAllMarketsCTokenExtensionUpgrade() internal {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      _testPoolAllMarketsExtensionUpgrade(pools[i].comptroller);\n    }\n  }\n\n  function _testPoolAllMarketsExtensionUpgrade(address poolAddress) internal {\n    ComptrollerFirstExtension somePool = ComptrollerFirstExtension(poolAddress);\n\n    ICErc20[] memory markets = somePool.getAllMarkets();\n\n    if (markets.length == 0) return;\n\n    for (uint256 j = 0; j < markets.length; j++) {\n      ICErc20 someMarket = markets[j];\n      CErc20Delegator asDelegator = CErc20Delegator(address(someMarket));\n\n      emit log(\"pool\");\n      emit log_address(address(somePool));\n      emit log(\"market\");\n      emit log_address(address(someMarket));\n\n      try this._testExistingCTokenExtensionUpgrade(asDelegator) {} catch Error(string memory reason) {\n        address plugin = address(CErc20PluginDelegate(address(asDelegator)).plugin());\n        emit log(\"plugin\");\n        emit log_address(plugin);\n\n        address latestPlugin = ffd.latestPluginImplementation(plugin);\n        emit log(\"latest plugin impl\");\n        emit log_address(latestPlugin);\n\n        revert(reason);\n      }\n    }\n  }\n\n  function _testExistingCTokenExtensionUpgrade(CErc20Delegator asDelegator) public {\n    uint256 totalSupplyBefore = asDelegator.totalSupply();\n    if (totalSupplyBefore == 0) return; // total supply should be non-zero\n\n    // TODO\n    _upgradeMarket(ICErc20(address(asDelegator)));\n\n    // check if the extension was added\n    address[] memory extensions = asDelegator._listExtensions();\n    assertEq(extensions.length, 1, \"the first extension should be added\");\n    assertEq(extensions[0], address(newCTokenExtension), \"the first extension should be the only extension\");\n\n    // check if the storage is read from the same place\n    uint256 totalSupplyAfter = asDelegator.totalSupply();\n    assertGt(totalSupplyAfter, 0, \"total supply should be non-zero\");\n    assertEq(totalSupplyAfter, totalSupplyBefore, \"total supply should be the same\");\n  }\n\n  function testBscComptrollerExtensions() public debuggingOnly fork(BSC_MAINNET) {\n    _testComptrollersExtensions();\n  }\n\n  function testPolygonComptrollerExtensions() public debuggingOnly fork(POLYGON_MAINNET) {\n    _testComptrollersExtensions();\n  }\n\n  function testChapelComptrollerExtensions() public debuggingOnly fork(BSC_CHAPEL) {\n    _testComptrollersExtensions();\n  }\n\n  function testArbitrumComptrollerExtensions() public debuggingOnly fork(ARBITRUM_ONE) {\n    _testComptrollersExtensions();\n  }\n\n  function _testComptrollersExtensions() internal {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      address payable asPayable = payable(pools[i].comptroller);\n      DiamondBase asBase = DiamondBase(asPayable);\n      address[] memory extensions = asBase._listExtensions();\n      assertEq(extensions.length, 1, \"each pool should have the first extension\");\n    }\n  }\n\n  function testBulkAutoUpgrade() public debuggingOnly fork(POLYGON_MAINNET) {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      vm.prank(ffd.owner());\n      ffd.autoUpgradePool(IonicComptroller(pools[i].comptroller));\n    }\n  }\n\n  function testPolygonTotalUnderlyingSupplied() public debuggingOnly fork(POLYGON_MAINNET) {\n    _testTotalUnderlyingSupplied();\n  }\n\n  function testBscTotalUnderlyingSupplied() public debuggingOnly fork(BSC_MAINNET) {\n    _testTotalUnderlyingSupplied();\n  }\n\n  function _testTotalUnderlyingSupplied() internal {\n    PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      //      if (pools[i].comptroller == 0x5373C052Df65b317e48D6CAD8Bb8AC50995e9459) continue;\n      //      if (pools[i].comptroller == 0xD265ff7e5487E9DD556a4BB900ccA6D087Eb3AD2) continue;\n      ComptrollerFirstExtension poolExt = ComptrollerFirstExtension(pools[i].comptroller);\n\n      ICErc20[] memory markets = poolExt.getAllMarkets();\n      for (uint8 k = 0; k < markets.length; k++) {\n        CErc20Delegate market = CErc20Delegate(address(markets[k]));\n        //        emit log(market.contractType());\n        //        emit log_named_address(\"impl\", market.implementation());\n        CTokenFirstExtension marketAsExt = CTokenFirstExtension(address(markets[k]));\n        marketAsExt.getTotalUnderlyingSupplied();\n      }\n    }\n  }\n\n  function testDelegateType() public debuggingOnly fork(POLYGON_MAINNET) {\n    emit log(CErc20Delegate(0x587906620D627fe75C4d1288C6A584089780959c).contractType());\n  }\n}\n"
    },
    "contracts/test/FLRTest.t.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity >=0.8.0;\n\n// import \"forge-std/Vm.sol\";\n\n// import \"./config/BaseTest.t.sol\";\n\n// import { ERC20 } from \"solmate/tokens/ERC20.sol\";\n// import { Authority } from \"solmate/auth/Auth.sol\";\n// import { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\n// import { IERC20MetadataUpgradeable, IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n// import { IFlywheelBooster } from \"../ionic/strategies/flywheel/IFlywheelBooster.sol\";\n// import { FlywheelStaticRewards } from \"../ionic/strategies/flywheel/rewards/FlywheelStaticRewards.sol\";\n// import { FuseFlywheelCore } from \"fuse-flywheel/FuseFlywheelCore.sol\";\n\n// import { CErc20 } from \"../compound/CToken.sol\";\n// import { IonicFlywheelLensRouter, IonicComptroller, ICErc20, ERC20, IPriceOracle_IFLR } from \"../ionic/strategies/flywheel/IonicFlywheelLensRouter.sol\";\n// import { IonicFlywheel } from \"../ionic/strategies/flywheel/IonicFlywheel.sol\";\n// import { PoolDirectory } from \"../PoolDirectory.sol\";\n// import { IonicFlywheelCore } from \"../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\n\n// contract FLRTest is BaseTest {\n//   address rewardToken;\n\n//   IonicFlywheel flywheel;\n//   FlywheelStaticRewards rewards;\n//   IonicFlywheelLensRouter lensRouter;\n\n//   PoolDirectory internal fpd;\n\n//   function afterForkSetUp() internal override {\n//     fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n//     lensRouter = new IonicFlywheelLensRouter(fpd);\n//   }\n\n//   function setUpFlywheel(\n//     address _rewardToken,\n//     address mkt,\n//     IonicComptroller comptroller,\n//     address admin\n//   ) public {\n//     flywheel = new IonicFlywheel();\n//     flywheel.initialize(\n//       ERC20(_rewardToken),\n//       FlywheelStaticRewards(address(0)),\n//       IFlywheelBooster(address(0)),\n//       address(this)\n//     );\n\n//     rewards = new FlywheelStaticRewards(IonicFlywheelCore(address(flywheel)), address(this), Authority(address(0)));\n//     flywheel.setFlywheelRewards(rewards);\n\n//     flywheel.addStrategyForRewards(ERC20(mkt));\n\n//     // add flywheel as rewardsDistributor to call flywheelPreBorrowAction / flywheelPreSupplyAction\n//     vm.prank(admin);\n//     require(comptroller._addRewardsDistributor(address(flywheel)) == 0);\n\n//     // seed rewards to flywheel\n//     deal(_rewardToken, address(rewards), 1_000_000 * (10**ERC20(_rewardToken).decimals()));\n\n//     // Start reward distribution at 1 token per second\n//     rewards.setRewardsInfo(\n//       ERC20(mkt),\n//       FlywheelStaticRewards.RewardsInfo({\n//         rewardsPerSecond: uint224(789 * 10**ERC20(_rewardToken).decimals()),\n//         rewardsEndTimestamp: 0\n//       })\n//     );\n//   }\n\n//   function testFuseFlywheelLensRouterBsc() public debuggingOnly fork(BSC_MAINNET) {\n//     rewardToken = address(0x71be881e9C5d4465B3FfF61e89c6f3651E69B5bb); // BRZ\n//     emit log_named_address(\"rewardToken\", address(rewardToken));\n//     address mkt = 0x159A529c00CD4f91b65C54E77703EDb67B4942e4;\n//     setUpFlywheel(rewardToken, mkt, IonicComptroller(0x5EB884651F50abc72648447dCeabF2db091e4117), ap.owner());\n//     emit log_named_uint(\"mkt dec\", ERC20(mkt).decimals());\n\n//     (uint224 index, uint32 lastUpdatedTimestamp) = flywheel.strategyState(ERC20(mkt));\n\n//     emit log_named_uint(\"index\", index);\n//     emit log_named_uint(\"lastUpdatedTimestamp\", lastUpdatedTimestamp);\n//     emit log_named_uint(\"block.timestamp\", block.timestamp);\n//     emit log_named_uint(\n//       \"underlying price\",\n//       IPriceOracle_IFLR(address(IonicComptroller(0x5EB884651F50abc72648447dCeabF2db091e4117).oracle())).price(\n//         address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c)\n//       )\n//     );\n\n//     vm.warp(block.timestamp + 10);\n\n//     (uint224 rewardsPerSecond, uint32 rewardsEndTimestamp) = rewards.rewardsInfo(ERC20(mkt));\n\n//     vm.prank(address(flywheel));\n//     uint256 accrued = rewards.getAccruedRewards(ERC20(mkt), lastUpdatedTimestamp);\n\n//     emit log_named_uint(\"accrued\", accrued);\n//     emit log_named_uint(\"rewardsPerSecond\", rewardsPerSecond);\n//     emit log_named_uint(\"rewardsEndTimestamp\", rewardsEndTimestamp);\n//     emit log_named_uint(\"mkt ts\", ERC20(mkt).totalSupply());\n\n//     IonicFlywheelLensRouter.MarketRewardsInfo[] memory marketRewardsInfos = lensRouter.getPoolMarketRewardsInfo(\n//       IonicComptroller(0x5EB884651F50abc72648447dCeabF2db091e4117)\n//     );\n//     for (uint256 i = 0; i < marketRewardsInfos.length; i++) {\n//       if (address(marketRewardsInfos[i].market) != mkt) {\n//         emit log(\"NO REWARDS INFO\");\n//         continue;\n//       }\n\n//       emit log(\"\");\n//       emit log_named_address(\"RUNNING FOR MARKET\", address(marketRewardsInfos[i].market));\n//       for (uint256 j = 0; j < marketRewardsInfos[i].rewardsInfo.length; j++) {\n//         emit log_named_uint(\n//           \"rewardSpeedPerSecondPerToken\",\n//           marketRewardsInfos[i].rewardsInfo[j].rewardSpeedPerSecondPerToken\n//         );\n//         emit log_named_uint(\"rewardTokenPrice\", marketRewardsInfos[i].rewardsInfo[j].rewardTokenPrice);\n//         emit log_named_uint(\"formattedAPR\", marketRewardsInfos[i].rewardsInfo[j].formattedAPR);\n//         emit log_named_address(\"rewardToken\", address(marketRewardsInfos[i].rewardsInfo[j].rewardToken));\n//       }\n//     }\n//   }\n\n//   function testBscLensRouter() public fork(BSC_MAINNET) {\n//     IonicComptroller pool = IonicComptroller(0x1851e32F34565cb95754310b031C5a2Fc0a8a905);\n//     address user = 0x927d81b91c41D1961e3A7d24847b95484e60C626;\n//     IonicFlywheelLensRouter router = IonicFlywheelLensRouter(ap.getAddress(\"IonicFlywheelLensRouter\"));\n\n//     router.claimRewardsForPool(user, pool);\n//   }\n\n//   function testChapelRouter() public fork(BSC_CHAPEL) {\n//     IonicFlywheelLensRouter router = IonicFlywheelLensRouter(0x3391ed1C5203168337Fa827cB5Ac8BB8B60D93B7);\n//     router.getPoolMarketRewardsInfo(IonicComptroller(0x044c436b2f3EF29D30f89c121f9240cf0a08Ca4b));\n//   }\n\n//   function testNetAprPolygon() public fork(POLYGON_MAINNET) {\n//     address user = 0x8982aa50bb919E42e9204f12e5b59D053Eb2A602;\n//     int256 blocks = 26 * 24 * 365 * 60;\n//     int256 apr = lensRouter.getUserNetApr(user, blocks);\n//     emit log_named_int(\"apr\", apr);\n//   }\n\n//   function testNetAprMode() public fork(MODE_MAINNET) {\n//     address user = 0x8982aa50bb919E42e9204f12e5b59D053Eb2A602;\n//     int256 blocks = 30 * 24 * 365 * 60;\n//     int256 apr = lensRouter.getUserNetApr(user, blocks);\n//     emit log_named_int(\"apr\", apr);\n//   }\n\n//   function testNetAprChapel() public fork(BSC_CHAPEL) {\n//     address user = 0x8982aa50bb919E42e9204f12e5b59D053Eb2A602;\n//     int256 blocks = 26 * 24 * 365 * 60;\n//     int256 apr = lensRouter.getUserNetApr(user, blocks);\n//     emit log_named_int(\"apr\", apr);\n//   }\n// }\n"
    },
    "contracts/test/FlywheelUpgradesTest.t.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity >=0.8.0;\n\n// import { BaseTest } from \"./config/BaseTest.t.sol\";\n\n// import { PoolDirectory } from \"../PoolDirectory.sol\";\n// import { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n// import { IonicFlywheelCore } from \"../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\n// import { IonicReplacingFlywheel } from \"../ionic/strategies/flywheel/IonicReplacingFlywheel.sol\";\n// import { ReplacingFlywheelDynamicRewards } from \"../ionic/strategies/flywheel/rewards/ReplacingFlywheelDynamicRewards.sol\";\n// import { IonicFlywheelLensRouter } from \"../ionic/strategies/flywheel/IonicFlywheelLensRouter.sol\";\n// import { CErc20PluginRewardsDelegate } from \"../compound/CErc20PluginRewardsDelegate.sol\";\n// import { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\n// import { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n// import { Comptroller } from \"../compound/Comptroller.sol\";\n// import { FlywheelCore } from \"../ionic/strategies/flywheel/FlywheelCore.sol\";\n// import { IFlywheelRewards } from \"../ionic/strategies/flywheel/rewards/IFlywheelRewards.sol\";\n// import { FlywheelDynamicRewards } from \"../ionic/strategies/flywheel/rewards/FlywheelDynamicRewards.sol\";\n\n// import { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n// import { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\n// contract FlywheelUpgradesTest is BaseTest {\n//   PoolDirectory internal fpd;\n\n//   function afterForkSetUp() internal override {\n//     fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n//   }\n\n//   function testFlywheelUpgradeBsc() public fork(BSC_MAINNET) {\n//     _testFlywheelUpgrade();\n//   }\n\n//   function testFlywheelUpgradePolygon() public fork(POLYGON_MAINNET) {\n//     _testFlywheelUpgrade();\n//   }\n\n//   function _testFlywheelUpgrade() internal {\n//     IonicFlywheelCore newImpl = new IonicFlywheelCore();\n\n//     (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n//     for (uint8 i = 0; i < pools.length; i++) {\n//       IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n\n//       ICErc20[] memory markets = pool.getAllMarkets();\n\n//       address[] memory flywheels = pool.getRewardsDistributors();\n//       if (flywheels.length > 0) {\n//         emit log(\"\");\n//         emit log_named_address(\"pool\", address(pool));\n//       }\n//       for (uint8 j = 0; j < flywheels.length; j++) {\n//         IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\n\n//         // upgrade\n//         TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(flywheels[j]));\n//         bytes32 bytesAtSlot = vm.load(address(proxy), _ADMIN_SLOT);\n//         address admin = address(uint160(uint256(bytesAtSlot)));\n\n//         if (admin != address(0)) {\n//           //vm.prank(admin);\n//           //proxy.upgradeTo(address(newImpl));\n//           //emit log_named_address(\"upgradable flywheel\", address(flywheel));\n\n//           bool anyStrategyHasPositiveIndex = false;\n\n//           for (uint8 k = 0; k < markets.length; k++) {\n//             ERC20 strategy = ERC20(address(markets[k]));\n//             (uint224 index, uint32 ts) = flywheel.strategyState(strategy);\n//             if (index > 0) {\n//               anyStrategyHasPositiveIndex = true;\n//               break;\n//             }\n//           }\n\n//           if (!anyStrategyHasPositiveIndex) {\n//             emit log_named_address(\"all zero index strategies flywheel\", address(flywheel));\n//             //assertTrue(anyStrategyHasPositiveIndex, \"!flywheel has no strategies added or is broken\");\n//           }\n//         } else {\n//           emit log_named_address(\"not upgradable flywheel\", address(flywheel));\n//           assertTrue(false, \"flywheel proxy admin 0\");\n//         }\n//       }\n//     }\n//   }\n\n//   function testPolygonFlywheelAllowance() public fork(POLYGON_MAINNET) {\n//     _testAllPoolsMarketsAllowance();\n//   }\n\n//   function testBscFlywheelAllowance() public fork(BSC_MAINNET) {\n//     _testAllPoolsMarketsAllowance();\n//   }\n\n//   function _testAllPoolsMarketsAllowance() internal {\n//     (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n//     for (uint8 i = 0; i < pools.length; i++) {\n//       _testMarketsAllowance(pools[i].comptroller);\n//     }\n//   }\n\n//   function _testMarketsAllowance(address poolAddress) internal {\n//     ComptrollerFirstExtension poolExt = ComptrollerFirstExtension(poolAddress);\n//     address[] memory fws = poolExt.getRewardsDistributors();\n\n//     ICErc20[] memory markets = poolExt.getAllMarkets();\n\n//     for (uint8 j = 0; j < markets.length; j++) {\n//       string memory contractType = CErc20PluginRewardsDelegate(address(markets[j])).contractType();\n//       // check it only for dynamic rewards flywheels\n//       if (compareStrings(contractType, \"CErc20PluginRewardsDelegate\")) {\n//         for (uint8 i = 0; i < fws.length; i++) {\n//           ERC20 asStrategy = ERC20(address(markets[j]));\n//           IonicFlywheelCore flywheel = IonicFlywheelCore(fws[i]);\n//           (uint224 index, ) = flywheel.strategyState(asStrategy);\n//           ERC20 rewToken = flywheel.rewardToken();\n//           address rewardsContractAddress = address(flywheel.flywheelRewards());\n//           if (index > 0) {\n//             uint256 allowance = rewToken.allowance(address(asStrategy), rewardsContractAddress);\n//             if (allowance == 0) {\n//               assertGt(allowance, 0, \"!approved\");\n//               emit log_named_address(\"flywheel rewards\", rewardsContractAddress);\n//               emit log_named_address(\"strategy\", address(asStrategy));\n//               emit log_named_address(\"rwtoken\", address(rewToken));\n//               break;\n//             }\n//           }\n//         }\n//       }\n//     }\n//   }\n// }\n"
    },
    "contracts/test/GlobalPauser.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport \"./config/BaseTest.t.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { IComptroller } from \"../external/compound/IComptroller.sol\";\nimport { GlobalPauser } from \"../GlobalPauser.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\nimport \"forge-std/console.sol\";\n\ncontract GlobalPauserTest is BaseTest {\n  address public poolDirectory = 0x39C353Cf9041CcF467A04d0e78B63d961E81458a;\n  address public pauseGuardian = 0xD9677b0eeafdCe6BF322d9774Bb65B1f42cF0404;\n  address public multisig = 0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2;\n  GlobalPauser public pauser; // = GlobalPauser(0xe646D8Be18e545244C5E79F121202f75FA3880c8);\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    pauser = new GlobalPauser(poolDirectory);\n    pauser.setPauseGuardian(pauseGuardian, true);\n    (, PoolDirectory.Pool[] memory pools) = PoolDirectory(poolDirectory).getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      vm.prank(IonicComptroller(pools[i].comptroller).admin());\n      IonicComptroller(pools[i].comptroller)._setPauseGuardian(address(pauser));\n    }\n  }\n\n  function testPauseNotGuardian(address sender) public debuggingOnly forkAtBlock(MODE_MAINNET, 9269895) {\n    vm.assume(sender != pauseGuardian);\n    vm.expectRevert(bytes(\"!guardian\"));\n    pauser.pauseAll();\n  }\n\n  function testPauseAll() public debuggingOnly forkAtBlock(MODE_MAINNET, 9269895) {\n    (, PoolDirectory.Pool[] memory pools) = PoolDirectory(poolDirectory).getActivePools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      ICErc20[] memory markets = IonicComptroller(pools[i].comptroller).getAllMarkets();\n      for (uint256 j = 0; j < markets.length; j++) {\n        bool isPaused = IonicComptroller(pools[i].comptroller).borrowGuardianPaused(address(markets[j]));\n        assertEq(isPaused, false);\n        isPaused = IonicComptroller(pools[i].comptroller).mintGuardianPaused(address(markets[j]));\n        assertEq(isPaused, false);\n      }\n    }\n    vm.prank(pauseGuardian);\n    pauser.pauseAll();\n    for (uint256 i = 0; i < pools.length; i++) {\n      ICErc20[] memory markets = IonicComptroller(pools[i].comptroller).getAllMarkets();\n      for (uint256 j = 0; j < markets.length; j++) {\n        bool isPaused = IonicComptroller(pools[i].comptroller).borrowGuardianPaused(address(markets[j]));\n        assertEq(isPaused, true);\n        isPaused = IonicComptroller(pools[i].comptroller).mintGuardianPaused(address(markets[j]));\n        assertEq(isPaused, true);\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/helpers/BalancerReentrancyAttacker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IBalancerStablePool } from \"../../external/balancer/IBalancerStablePool.sol\";\nimport \"../../external/balancer/IBalancerVault.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\n\ncontract BalancerReentrancyAttacker {\n  IBalancerVault private immutable _vault;\n  MasterPriceOracle private _mpo;\n  address private _lpToken;\n\n  constructor(\n    IBalancerVault vault,\n    MasterPriceOracle mpo,\n    address lpToken\n  ) {\n    _vault = vault;\n    _mpo = mpo;\n    _lpToken = lpToken;\n  }\n\n  function startAttack() external payable {\n    UserBalanceOp[] memory ops = new UserBalanceOp[](1);\n    ops[0].kind = UserBalanceOpKind.DEPOSIT_INTERNAL;\n    // Asking to deposit 1 ETH\n    ops[0].amount = 1e18;\n    ops[0].sender = address(this);\n    ops[0].recipient = payable(address(this));\n\n    // but pass 2 eth, so there's an amount of exceding ETH and receive() callback is called\n    _vault.manageUserBalance{ value: 2e18 }(ops);\n  }\n\n  receive() external payable {\n    _reenterAttack();\n  }\n\n  function _reenterAttack() internal view {\n    _mpo.price(_lpToken);\n  }\n}\n"
    },
    "contracts/test/helpers/WithPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.4.23;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\n\nimport { JumpRateModel } from \"../../compound/JumpRateModel.sol\";\nimport { Unitroller } from \"../../compound/Unitroller.sol\";\nimport { Comptroller } from \"../../compound/Comptroller.sol\";\nimport { CErc20PluginDelegate } from \"../../compound/CErc20PluginDelegate.sol\";\nimport { CErc20PluginRewardsDelegate } from \"../../compound/CErc20PluginRewardsDelegate.sol\";\nimport { CErc20Delegate } from \"../../compound/CErc20Delegate.sol\";\nimport { CErc20Delegator } from \"../../compound/CErc20Delegator.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { InterestRateModel } from \"../../compound/InterestRateModel.sol\";\nimport { FeeDistributor } from \"../../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../../PoolDirectory.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { PoolLens } from \"../../PoolLens.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { CTokenFirstExtension, DiamondExtension } from \"../../compound/CTokenFirstExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../../compound/ComptrollerFirstExtension.sol\";\nimport { AuthoritiesRegistry } from \"../../ionic/AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../../ionic/PoolRolesAuthority.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract WithPool is BaseTest {\n  ERC20Upgradeable public underlyingToken;\n  CErc20Delegate cErc20Delegate;\n  CErc20PluginDelegate cErc20PluginDelegate;\n  CErc20PluginRewardsDelegate cErc20PluginRewardsDelegate;\n\n  IonicComptroller comptroller;\n  Comptroller newComptroller;\n  JumpRateModel interestModel;\n\n  FeeDistributor ionicAdmin;\n  PoolDirectory poolDirectory;\n  MasterPriceOracle priceOracle;\n  PoolLens poolLens;\n\n  address[] markets;\n  bool[] t;\n  bool[] f;\n  address[] newImplementation;\n  address[] hardcodedAddresses;\n  string[] hardcodedNames;\n\n  function setUpWithPool(MasterPriceOracle _masterPriceOracle, ERC20Upgradeable _underlyingToken) public {\n    priceOracle = _masterPriceOracle;\n    underlyingToken = _underlyingToken;\n\n    ionicAdmin = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    if (address(ionicAdmin) != address(0)) {\n      // upgrade\n      {\n        FeeDistributor newImpl = new FeeDistributor();\n        TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(address(ionicAdmin)));\n        bytes32 bytesAtSlot = vm.load(\n          address(proxy),\n          0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n        );\n        address admin = address(uint160(uint256(bytesAtSlot)));\n        vm.prank(admin);\n        proxy.upgradeTo(address(newImpl));\n      }\n    } else {\n      ionicAdmin = new FeeDistributor();\n      ionicAdmin.initialize(1e16);\n    }\n\n    {\n      vm.prank(ionicAdmin.owner());\n      ionicAdmin._setPendingOwner(address(this));\n      ionicAdmin._acceptOwner();\n    }\n    setUpBaseContracts();\n    setUpExtensions();\n  }\n\n  function setUpExtensions() internal {\n    cErc20Delegate = new CErc20Delegate();\n    cErc20PluginDelegate = new CErc20PluginDelegate();\n    cErc20PluginRewardsDelegate = new CErc20PluginRewardsDelegate();\n\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](2);\n    cErc20DelegateExtensions[0] = new CTokenFirstExtension();\n\n    ionicAdmin._setLatestCErc20Delegate(cErc20Delegate.delegateType(), address(cErc20Delegate), \"\");\n    ionicAdmin._setLatestCErc20Delegate(\n      cErc20PluginDelegate.delegateType(),\n      address(cErc20PluginDelegate),\n      abi.encode(address(0))\n    );\n    ionicAdmin._setLatestCErc20Delegate(\n      cErc20PluginRewardsDelegate.delegateType(),\n      address(cErc20PluginRewardsDelegate),\n      abi.encode(address(0))\n    );\n\n    cErc20DelegateExtensions[1] = cErc20Delegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20Delegate), cErc20DelegateExtensions);\n    cErc20DelegateExtensions[1] = cErc20PluginDelegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20PluginDelegate), cErc20DelegateExtensions);\n    cErc20DelegateExtensions[1] = cErc20PluginRewardsDelegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20PluginRewardsDelegate), cErc20DelegateExtensions);\n  }\n\n  function setUpBaseContracts() internal {\n    interestModel = new JumpRateModel(2343665, 1e18, 1e18, 4e18, 0.8e18);\n    poolDirectory = new PoolDirectory();\n    poolDirectory.initialize(false, new address[](0));\n\n    poolLens = new PoolLens();\n    poolLens.initialize(\n      poolDirectory,\n      \"Pool\",\n      \"lens\",\n      hardcodedAddresses,\n      hardcodedNames,\n      hardcodedNames,\n      hardcodedNames,\n      hardcodedNames,\n      hardcodedNames\n    );\n  }\n\n  function setUpPool(\n    string memory name,\n    bool enforceWhitelist,\n    uint256 closeFactor,\n    uint256 liquidationIncentive\n  ) public {\n    Comptroller newComptrollerImplementation = new Comptroller();\n    ionicAdmin._setLatestComptrollerImplementation(address(0), address(newComptrollerImplementation));\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = new ComptrollerFirstExtension();\n    extensions[1] = newComptrollerImplementation;\n    ionicAdmin._setComptrollerExtensions(address(newComptrollerImplementation), extensions);\n\n    (, address comptrollerAddress) = poolDirectory.deployPool(\n      name,\n      address(newComptrollerImplementation),\n      abi.encode(payable(address(ionicAdmin))),\n      enforceWhitelist,\n      closeFactor,\n      liquidationIncentive,\n      address(priceOracle)\n    );\n    Unitroller(payable(comptrollerAddress))._acceptAdmin();\n    comptroller = IonicComptroller(comptrollerAddress);\n\n    AuthoritiesRegistry impl = new AuthoritiesRegistry();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n    AuthoritiesRegistry newAr = AuthoritiesRegistry(address(proxy));\n    newAr.initialize(address(321));\n    ionicAdmin.reinitialize(newAr);\n    PoolRolesAuthority poolAuth = newAr.createPoolAuthority(comptrollerAddress);\n    newAr.setUserRole(comptrollerAddress, address(this), poolAuth.BORROWER_ROLE(), true);\n  }\n\n  function upgradePool(address pool) internal {\n    Comptroller newComptrollerImplementation = new Comptroller();\n\n    Unitroller asUnitroller = Unitroller(payable(pool));\n\n    // upgrade to the new comptroller\n    vm.startPrank(asUnitroller.admin());\n    asUnitroller._registerExtension(\n      newComptrollerImplementation,\n      DiamondExtension(asUnitroller.comptrollerImplementation())\n    );\n    asUnitroller._upgrade();\n    vm.stopPrank();\n  }\n\n  function deployCErc20Delegate(\n    address _underlyingToken,\n    bytes memory name,\n    bytes memory symbol,\n    uint256 _collateralFactorMantissa\n  ) public {\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        _underlyingToken,\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        name,\n        symbol,\n        uint256(1),\n        uint256(0)\n      ),\n      \"\",\n      _collateralFactorMantissa\n    );\n  }\n\n  function deployCErc20PluginDelegate(address _erc4626, uint256 _collateralFactorMantissa) public {\n    comptroller._deployMarket(\n      cErc20PluginDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(_erc4626),\n      _collateralFactorMantissa\n    );\n  }\n\n  function deployCErc20PluginRewardsDelegate(address _mockERC4626Dynamic, uint256 _collateralFactorMantissa) public {\n    comptroller._deployMarket(\n      cErc20PluginRewardsDelegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"cUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      abi.encode(_mockERC4626Dynamic),\n      _collateralFactorMantissa\n    );\n  }\n}\n"
    },
    "contracts/test/irm/AdjustableJumpRateModelTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { AdjustableJumpRateModel, InterestRateModelParams } from \"../../ionic/irms/AdjustableJumpRateModel.sol\";\n\ncontract InterestRateModelTest is BaseTest {\n  AdjustableJumpRateModel adjustableJumpRateModel;\n  InterestRateModelParams params;\n  InterestRateModelParams newParams;\n\n  function setUp() public {\n    params = InterestRateModelParams({\n      blocksPerYear: 10512000,\n      baseRatePerYear: 0.5e16,\n      multiplierPerYear: 0.18e18,\n      jumpMultiplierPerYear: 4e18,\n      kink: 0.8e18\n    });\n    adjustableJumpRateModel = new AdjustableJumpRateModel(params);\n  }\n\n  function testUpdateJrmParams() public {\n    assertEq(adjustableJumpRateModel.blocksPerYear(), params.blocksPerYear);\n    assertEq(adjustableJumpRateModel.baseRatePerBlock(), params.baseRatePerYear / params.blocksPerYear);\n\n    newParams = InterestRateModelParams({\n      blocksPerYear: 512000,\n      baseRatePerYear: 0.7e16,\n      multiplierPerYear: 0.18e18,\n      jumpMultiplierPerYear: 4e18,\n      kink: 0.8e18\n    });\n\n    adjustableJumpRateModel._setIrmParameters(newParams);\n    vm.roll(1);\n\n    assertEq(adjustableJumpRateModel.blocksPerYear(), newParams.blocksPerYear);\n    assertEq(adjustableJumpRateModel.baseRatePerBlock(), newParams.baseRatePerYear / newParams.blocksPerYear);\n  }\n}\n"
    },
    "contracts/test/irm/InterestRateModelTest.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity >=0.8.0;\n\n// import { BaseTest } from \"../config/BaseTest.t.sol\";\n\n// import { JumpRateModel } from \"../../compound/JumpRateModel.sol\";\n\n// contract InterestRateModelTest is BaseTest {\n//   AnkrFTMInterestRateModel ankrCertificateInterestRateModelFTM;\n//   AnkrBNBInterestRateModel ankrCertificateInterestRateModelBNB;\n\n//   JumpRateModel jumpRateModel;\n//   JumpRateModel mimoRateModel;\n\n//   address ANKR_BNB_RATE_PROVIDER = 0xCb0006B31e6b403fEeEC257A8ABeE0817bEd7eBa;\n//   address ANKR_BNB_BOND = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n//   address ANKR_FTM_RATE_PROVIDER = 0xB42bF10ab9Df82f9a47B86dd76EEE4bA848d0Fa2;\n\n//   uint8 day = 3;\n\n//   function afterForkSetUp() internal override {\n//     if (block.chainid == BSC_MAINNET) {\n//       ankrCertificateInterestRateModelBNB = new AnkrBNBInterestRateModel(\n//         10512000,\n//         0.5e16,\n//         3e18,\n//         0.85e18,\n//         day,\n//         ANKR_BNB_RATE_PROVIDER,\n//         ANKR_BNB_BOND\n//       );\n//       jumpRateModel = new JumpRateModel(10512000, 0.2e17, 0.18e18, 4e18, 0.8e18);\n//     } else if (block.chainid == POLYGON_MAINNET) {\n//       mimoRateModel = new JumpRateModel(13665600, 2e18, 0.4e17, 4e18, 0.8e18);\n//       jumpRateModel = new JumpRateModel(13665600, 0.2e17, 0.18e18, 2e18, 0.8e18);\n//     }\n//   }\n\n//   function testBscIrm() public fork(BSC_MAINNET) {\n//     testJumpRateBorrowRate();\n//     testJumpRateSupplyRate();\n//     testAnkrBNBBorrowModelRate();\n//     testAnkrBNBSupplyModelRate();\n//   }\n\n//   function testPolygonIrm() public fork(POLYGON_MAINNET) {\n//     testJumpRateBorrowRatePolygon();\n//   }\n\n//   function _convertToPerYearBsc(uint256 value) internal pure returns (uint256) {\n//     return value * 10512000;\n//   }\n\n//   function _convertToPerYearPolygon(uint256 value) internal pure returns (uint256) {\n//     return value * 13665600;\n//   }\n\n//   function _convertToPerYearFtm(uint256 value) internal pure returns (uint256) {\n//     return value * 21024000;\n//   }\n\n//   function testJumpRateBorrowRatePolygon() internal {\n//     uint256 borrowRate = mimoRateModel.getBorrowRate(0, 0, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(1e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(2e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(3e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(4e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(5e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//     borrowRate = mimoRateModel.getBorrowRate(6e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearPolygon(borrowRate), 0);\n//     assertLe(_convertToPerYearPolygon(borrowRate), 100e18);\n//   }\n\n//   function testJumpRateBorrowRate() internal {\n//     uint256 borrowRate = jumpRateModel.getBorrowRate(0, 0, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(1e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(2e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(3e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(4e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(5e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//     borrowRate = jumpRateModel.getBorrowRate(6e18, 10e18, 5e18);\n//     assertGe(_convertToPerYearBsc(borrowRate), 0);\n//     assertLe(_convertToPerYearBsc(borrowRate), 100e18);\n//   }\n\n//   function testJumpRateSupplyRate() internal {\n//     uint256 supplyRate = jumpRateModel.getSupplyRate(0, 10e18, 5e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(10e18, 10e18, 5e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(20e18, 10e18, 20e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(30e18, 10e18, 30e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(40e18, 10e18, 10e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(50e18, 10e18, 40e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//     jumpRateModel.getSupplyRate(60e18, 10e18, 60e18, 0.2e18);\n//     assertGe(_convertToPerYearBsc(supplyRate), 0);\n//     assertLe(_convertToPerYearBsc(supplyRate), 100e18);\n//   }\n\n//   function testAnkrFTMBorrowModelRate() internal {\n//     vm.mockCall(\n//       address(ANKR_FTM_RATE_PROVIDER),\n//       abi.encodeWithSelector(IAnkrFTMRateProvider.averagePercentageRate.selector),\n//       abi.encode(5e18)\n//     );\n//     // utilization 1 -> borrow rate: 0.084%\n//     uint256 borrowRate = ankrCertificateInterestRateModelFTM.getBorrowRate(800e18, 8e18, 8e18);\n//     uint256 util = ankrCertificateInterestRateModelFTM.utilizationRate(800e18, 8e18, 8e18);\n//     assertEq(util, 0.1e17);\n//     assertApproxEqRel(_convertToPerYearFtm(borrowRate) * 100, 0.084e18, 1e16, \"!borrow rate for utilization 1\");\n\n//     // utilization 10 -> borrow rate: 0.61%\n//     borrowRate = ankrCertificateInterestRateModelFTM.getBorrowRate(80e18, 8e18, 8e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(80e18, 8e18, 8e18);\n//     assertEq(util, 0.1e18);\n//     assertApproxEqRel(_convertToPerYearFtm(borrowRate) * 100, 0.61e18, 1e16, \"!borrow rate for utilization 10\");\n\n//     // utilization 20 -> borrow rate: 1.2%\n//     borrowRate = ankrCertificateInterestRateModelFTM.getBorrowRate(40e18, 8e18, 8e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(40e18, 8e18, 8e18);\n//     assertEq(util, 0.2e18);\n//     assertApproxEqRel(_convertToPerYearFtm(borrowRate) * 100, 1.2e18, 1e16, \"!borrow rate for utilization 20\");\n\n//     // utilization 80 -> borrow rate: 4.7%\n//     borrowRate = ankrCertificateInterestRateModelFTM.getBorrowRate(3e18, 8e18, 1e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(3e18, 8e18, 1e18);\n//     assertEq(util, 0.8e18);\n//     assertApproxEqRel(_convertToPerYearFtm(borrowRate) * 100, 4.7e18, 1e16, \"!borrow rate for utilization 80\");\n\n//     // utilization 90 -> borrow rate: 20.3%\n//     borrowRate = ankrCertificateInterestRateModelFTM.getBorrowRate(8e18, 7.2e18, 7.2e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(8e18, 7.2e18, 7.2e18);\n//     assertEq(util, 0.9e18);\n//     assertApproxEqRel(_convertToPerYearFtm(borrowRate) * 100, 20.3e18, 1e16, \"!borrow rate for utilization 90\");\n//   }\n\n//   function testAnkrBNBBorrowModelRate() internal {\n//     vm.mockCall(\n//       address(ANKR_BNB_RATE_PROVIDER),\n//       abi.encodeWithSelector(IAnkrBNBRateProvider.averagePercentageRate.selector),\n//       abi.encode(2.5e18)\n//     );\n\n//     // utilization 1 -> borrow rate: 0.04%\n//     uint256 borrowRate = ankrCertificateInterestRateModelBNB.getBorrowRate(800e18, 8e18, 8e18);\n//     uint256 util = ankrCertificateInterestRateModelBNB.utilizationRate(800e18, 8e18, 8e18);\n//     assertEq(util, 0.1e17);\n//     assertApproxEqRel(_convertToPerYearBsc(borrowRate) * 100, 0.04e18, 1e17, \"!borrow rate for utilization 1\");\n\n//     // utilization 10 -> borrow rate: 0.3%\n//     borrowRate = ankrCertificateInterestRateModelBNB.getBorrowRate(80e18, 8e18, 8e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(80e18, 8e18, 8e18);\n//     assertEq(util, 0.1e18);\n//     assertApproxEqRel(_convertToPerYearBsc(borrowRate) * 100, 0.3e18, 1e17, \"!borrow rate for utilization 10\");\n\n//     // utilization 20 -> borrow rate: 0.6%\n//     borrowRate = ankrCertificateInterestRateModelBNB.getBorrowRate(40e18, 8e18, 8e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(40e18, 8e18, 8e18);\n//     assertEq(util, 0.2e18);\n//     assertApproxEqRel(_convertToPerYearBsc(borrowRate) * 100, 0.6e18, 1e17, \"!borrow rate for utilization 20\");\n\n//     // utilization 80 -> borrow rate: 2.36%\n//     borrowRate = ankrCertificateInterestRateModelBNB.getBorrowRate(3e18, 8e18, 1e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(3e18, 8e18, 1e18);\n//     assertEq(util, 0.8e18);\n//     assertApproxEqRel(_convertToPerYearBsc(borrowRate) * 100, 2.36e18, 1e17, \"!borrow rate for utilization 80\");\n\n//     // utilization 90 -> borrow rate: 17%\n//     borrowRate = ankrCertificateInterestRateModelBNB.getBorrowRate(8e18, 7.2e18, 7.2e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(8e18, 7.2e18, 7.2e18);\n//     assertEq(util, 0.9e18);\n//     assertApproxEqRel(_convertToPerYearBsc(borrowRate) * 100, 17e18, 1e17, \"!borrow rate for utilization 90\");\n//   }\n\n//   function testAnkrFTMSupplyModelRate() internal {\n//     vm.mockCall(\n//       address(ANKR_FTM_RATE_PROVIDER),\n//       abi.encodeWithSelector(IAnkrFTMRateProvider.averagePercentageRate.selector),\n//       abi.encode(5e18)\n//     );\n\n//     // utilization 1 -> supply rate: 0.00075%\n//     uint256 supplyRate = ankrCertificateInterestRateModelFTM.getSupplyRate(800e18, 8e18, 8e18, 0.1e18);\n//     uint256 util = ankrCertificateInterestRateModelFTM.utilizationRate(800e18, 8e18, 8e18);\n//     assertEq(util, 0.1e17);\n//     assertApproxEqRel(_convertToPerYearFtm(supplyRate) * 100, 0.00075e18, 1e16, \"!supply rate for utilization 1\");\n\n//     // utilization 10 -> supply rate: 0.0055%\n//     supplyRate = ankrCertificateInterestRateModelFTM.getSupplyRate(80e18, 8e18, 8e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(80e18, 8e18, 8e18);\n//     assertEq(util, 0.1e18);\n//     assertApproxEqRel(_convertToPerYearFtm(supplyRate) * 100, 0.055e18, 1e16, \"!supply rate for utilization 10\");\n\n//     // utilization 20 -> supply rate: 0.022%\n//     supplyRate = ankrCertificateInterestRateModelFTM.getSupplyRate(40e18, 8e18, 8e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(40e18, 8e18, 8e18);\n//     assertEq(util, 0.2e18);\n//     assertApproxEqRel(_convertToPerYearFtm(supplyRate) * 100, 0.216e18, 1e16, \"!supply rate for utilization 20\");\n\n//     // utilization 80 -> supply rate: 3.4%\n//     supplyRate = ankrCertificateInterestRateModelFTM.getSupplyRate(3e18, 8e18, 1e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(3e18, 8e18, 1e18);\n//     assertEq(util, 0.8e18);\n//     assertApproxEqRel(_convertToPerYearFtm(supplyRate) * 100, 3.4e18, 1e16, \"!supply rate for utilization 80\");\n\n//     // utilization 90 -> supply rate: 16.5%\n//     supplyRate = ankrCertificateInterestRateModelFTM.getSupplyRate(8e18, 7.2e18, 7.2e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelFTM.utilizationRate(8e18, 7.2e18, 7.2e18);\n//     assertEq(util, 0.9e18);\n//     assertApproxEqRel(_convertToPerYearFtm(supplyRate) * 100, 16.5e18, 1e16, \"!supply rate for utilization 90\");\n//   }\n\n//   function testAnkrBNBSupplyModelRate() internal {\n//     vm.mockCall(\n//       address(ANKR_BNB_RATE_PROVIDER),\n//       abi.encodeWithSelector(IAnkrBNBRateProvider.averagePercentageRate.selector),\n//       abi.encode(2.5e18)\n//     );\n\n//     // utilization 1 -> supply rate: 0.00037%\n//     uint256 supplyRate = ankrCertificateInterestRateModelBNB.getSupplyRate(800e18, 8e18, 8e18, 0.1e18);\n//     uint256 util = ankrCertificateInterestRateModelBNB.utilizationRate(800e18, 8e18, 8e18);\n//     assertEq(util, 0.1e17);\n//     assertApproxEqRel(_convertToPerYearBsc(supplyRate) * 100, 0.00037e18, 1e17, \"!supply rate for utilization 1\");\n\n//     // utilization 10 -> supply rate: 0.027%\n//     supplyRate = ankrCertificateInterestRateModelBNB.getSupplyRate(80e18, 8e18, 8e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(80e18, 8e18, 8e18);\n//     assertEq(util, 0.1e18);\n//     assertApproxEqRel(_convertToPerYearBsc(supplyRate) * 100, 0.027e18, 1e17, \"!supply rate for utilization 10\");\n\n//     // utilization 20 -> supply rate: 0.1%\n//     supplyRate = ankrCertificateInterestRateModelBNB.getSupplyRate(40e18, 8e18, 8e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(40e18, 8e18, 8e18);\n//     assertEq(util, 0.2e18);\n//     assertApproxEqRel(_convertToPerYearBsc(supplyRate) * 100, 0.1e18, 1e17, \"!supply rate for utilization 20\");\n\n//     // utilization 80 -> supply rate: 1.7%\n//     supplyRate = ankrCertificateInterestRateModelBNB.getSupplyRate(3e18, 8e18, 1e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(3e18, 8e18, 1e18);\n//     assertEq(util, 0.8e18);\n//     assertApproxEqRel(_convertToPerYearBsc(supplyRate) * 100, 1.7e18, 1e17, \"!supply rate for utilization 80\");\n\n//     // utilization 90 -> supply rate: 14.3%\n//     supplyRate = ankrCertificateInterestRateModelBNB.getSupplyRate(8e18, 7.2e18, 7.2e18, 0.1e18);\n//     util = ankrCertificateInterestRateModelBNB.utilizationRate(8e18, 7.2e18, 7.2e18);\n//     assertEq(util, 0.9e18);\n//     assertApproxEqRel(_convertToPerYearBsc(supplyRate) * 100, 14.3e18, 1e17, \"!supply rate for utilization 90\");\n//   }\n// }\n"
    },
    "contracts/test/irm/PrudentiaIrmTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IRateComputer } from \"adrastia-periphery/rates/IRateComputer.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { PrudentiaInterestRateModel } from \"../../ionic/irms/PrudentiaInterestRateModel.sol\";\n\ncontract MockRateComputer is IRateComputer {\n  mapping(address => uint64) public rates;\n\n  function computeRate(address token) external view override returns (uint64) {\n    return rates[token];\n  }\n\n  function setRate(address token, uint64 rate) public {\n    rates[token] = rate;\n  }\n}\n\ncontract PrudentiaIrmTest is BaseTest {\n  using Math for uint64;\n\n  MockRateComputer rateComputer;\n  address token;\n  PrudentiaInterestRateModel irm;\n  uint256 blocksPerYear;\n\n  function setUp() public {\n    rateComputer = new MockRateComputer();\n    token = address(0x1);\n    blocksPerYear = 10512000;\n    irm = new PrudentiaInterestRateModel(blocksPerYear, token, rateComputer);\n  }\n\n  function test_utilizationRate_zeroTotal() public {\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.utilizationRate(cash, borrows, reserves), 0);\n  }\n\n  function test_utilizationRate_zero() public {\n    uint256 cash = 100;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.utilizationRate(cash, borrows, reserves), 0);\n  }\n\n  function test_utilizationRate_50() public {\n    uint256 cash = 100;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n\n    assertEq(irm.utilizationRate(cash, borrows, reserves), 5e17);\n  }\n\n  function test_utilizationRate_100() public {\n    uint256 cash = 0;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n\n    assertEq(irm.utilizationRate(cash, borrows, reserves), 1e18);\n  }\n\n  function test_getBorrowRate_100_a() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 0;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getBorrowRate_100_b() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 100;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getBorrowRate_50() public {\n    uint64 rate = 5e17;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getBorrowRate_1() public {\n    uint64 rate = 1e16;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getBorrowRate_0() public {\n    uint64 rate = 0;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getBorrowRate_1mantissa() public {\n    uint64 rate = 1;\n    rateComputer.setRate(token, rate);\n\n    // These should have no effect\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n\n    assertEq(irm.getBorrowRate(cash, borrows, reserves), 1); // Rounds up to 1. We don't want to return 0.\n  }\n\n  function test_getSupplyRate_100_100util() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 0;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), rate.ceilDiv(blocksPerYear));\n  }\n\n  function test_getSupplyRate_100_50util() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 100;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), rate.ceilDiv(blocksPerYear) / 2);\n  }\n\n  function test_getSupplyRate_100_1util() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 99;\n    uint256 borrows = 1;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), rate.ceilDiv(blocksPerYear) / 100);\n  }\n\n  function test_getSupplyRate_100_0util() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 100;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), 0);\n  }\n\n  function test_getSupplyRate_0_0util() public {\n    uint64 rate = 0;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 0;\n    uint256 borrows = 0;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), 0);\n  }\n\n  function test_getSupplyRate_0_100util() public {\n    uint64 rate = 0;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 0;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), 0);\n  }\n\n  function test_getSupplyRate_0_50util() public {\n    uint64 rate = 0;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 50;\n    uint256 borrows = 50;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), 0);\n  }\n\n  function test_getSupplyRate_0_1util() public {\n    uint64 rate = 0;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 99;\n    uint256 borrows = 1;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 0;\n\n    assertEq(irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa), 0);\n  }\n\n  function test_getSupplyRate_100_50util_10rf() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 100;\n    uint256 borrows = 100;\n    uint256 reserves = 0;\n    uint256 reserveFactorMantissa = 1e17;\n\n    assertEq(\n      irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa),\n      (uint256(rate.ceilDiv(blocksPerYear) / 2) * (1e18 - reserveFactorMantissa)) / 1e18\n    );\n  }\n\n  function test_getSupplyRate_100_50util_10rf_10reserves() public {\n    uint64 rate = 1e18;\n    rateComputer.setRate(token, rate);\n\n    uint256 cash = 100;\n    uint256 borrows = 100;\n    uint256 reserves = 10;\n    cash += reserves;\n    uint256 reserveFactorMantissa = 1e17;\n\n    assertEq(\n      irm.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa),\n      (uint256(rate.ceilDiv(blocksPerYear) / 2) * (1e18 - reserveFactorMantissa)) / 1e18\n    );\n  }\n}\n"
    },
    "contracts/test/LatestImplementationWhitelisted.t.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport { CErc20 } from \"../compound/CToken.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../compound/CErc20PluginDelegate.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { IERC4626 } from \"../compound/IERC4626.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\ncontract LatestImplementationWhitelisted is BaseTest {\n  FeeDistributor ionicAdmin;\n  PoolDirectory poolDirectory;\n\n  address[] poolsImplementationsSet;\n  address[] marketsImplementationsSet;\n  address[] pluginsSet;\n\n  function testBscImplementations() public fork(BSC_MAINNET) {\n    testPoolImplementations();\n    testMarketImplementations();\n    testPluginImplementations();\n  }\n\n  function testPolygonImplementations() public fork(POLYGON_MAINNET) {\n    testPoolImplementations();\n    testMarketImplementations();\n    testPluginImplementations();\n  }\n\n  function afterForkSetUp() internal override {\n    poolDirectory = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    ionicAdmin = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n  }\n\n  function testPoolImplementations() internal {\n    (, PoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(payable(pools[i].comptroller));\n      address implementation = comptroller.comptrollerImplementation();\n\n      bool added = false;\n      for (uint8 k = 0; k < poolsImplementationsSet.length; k++) {\n        if (poolsImplementationsSet[k] == implementation) {\n          added = true;\n        }\n      }\n\n      if (!added) poolsImplementationsSet.push(implementation);\n    }\n\n    emit log(\"listing the set\");\n    for (uint8 k = 0; k < poolsImplementationsSet.length; k++) {\n      emit log_address(poolsImplementationsSet[k]);\n\n      address latestImpl = ionicAdmin.latestComptrollerImplementation(poolsImplementationsSet[k]);\n      assertTrue(poolsImplementationsSet[k] == latestImpl, \"some pool is not upgraded the latest impl\");\n    }\n  }\n\n  function testMarketImplementations() internal {\n    (, PoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(payable(pools[i].comptroller));\n      ICErc20[] memory markets = comptroller.getAllMarkets();\n      for (uint8 j = 0; j < markets.length; j++) {\n        ICErc20 market = markets[j];\n        address implementation = market.implementation();\n\n        bool added = false;\n        for (uint8 k = 0; k < marketsImplementationsSet.length; k++) {\n          if (marketsImplementationsSet[k] == implementation) {\n            added = true;\n          }\n        }\n\n        if (!added) marketsImplementationsSet.push(implementation);\n      }\n    }\n\n    emit log(\"listing the set\");\n    for (uint8 k = 0; k < marketsImplementationsSet.length; k++) {\n      emit log_address(marketsImplementationsSet[k]);\n      (address latestCErc20Delegate, bytes memory becomeImplementationData) = ionicAdmin.latestCErc20Delegate(\n        CErc20Delegate(marketsImplementationsSet[k]).delegateType()\n      );\n\n      assertTrue(marketsImplementationsSet[k] == latestCErc20Delegate, \"some markets need to be upgraded\");\n    }\n  }\n\n  function testPluginImplementations() internal {\n    (, PoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\n\n    for (uint8 i = 0; i < pools.length; i++) {\n      IonicComptroller comptroller = IonicComptroller(payable(pools[i].comptroller));\n      ICErc20[] memory markets = comptroller.getAllMarkets();\n      for (uint8 j = 0; j < markets.length; j++) {\n        CErc20PluginDelegate delegate = CErc20PluginDelegate(address(markets[j]));\n\n        address plugin;\n        try delegate.plugin() returns (IERC4626 _plugin) {\n          plugin = address(_plugin);\n        } catch {\n          continue;\n        }\n\n        bool added = false;\n        for (uint8 k = 0; k < pluginsSet.length; k++) {\n          if (pluginsSet[k] == plugin) {\n            added = true;\n          }\n        }\n\n        if (!added) pluginsSet.push(plugin);\n      }\n    }\n\n    emit log(\"listing the set\");\n    for (uint8 k = 0; k < pluginsSet.length; k++) {\n      address latestPluginImpl = ionicAdmin.latestPluginImplementation(pluginsSet[k]);\n\n      emit log_address(pluginsSet[k]);\n\n      assertTrue(pluginsSet[k] == latestPluginImpl, \"some plugin is not upgraded to the latest impl\");\n    }\n  }\n}\n"
    },
    "contracts/test/LeveredPositionTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MarketsTest, BaseTest } from \"./config/MarketsTest.t.sol\";\nimport { DiamondBase, DiamondExtension } from \"../ionic/DiamondExtension.sol\";\n\nimport { LeveredPosition } from \"../ionic/levered/LeveredPosition.sol\";\nimport { LeveredPositionFactory, IFeeDistributor } from \"../ionic/levered/LeveredPositionFactory.sol\";\nimport { JarvisLiquidatorFunder } from \"../liquidators/JarvisLiquidatorFunder.sol\";\nimport { BalancerSwapLiquidator } from \"../liquidators/BalancerSwapLiquidator.sol\";\nimport { AlgebraSwapLiquidator } from \"../liquidators/AlgebraSwapLiquidator.sol\";\nimport { SolidlyLpTokenLiquidator, SolidlyLpTokenWrapper } from \"../liquidators/SolidlyLpTokenLiquidator.sol\";\nimport { SolidlySwapLiquidator } from \"../liquidators/SolidlySwapLiquidator.sol\";\nimport { UniswapV3LiquidatorFunder } from \"../liquidators/UniswapV3LiquidatorFunder.sol\";\n\nimport { CurveLpTokenLiquidatorNoRegistry } from \"../liquidators/CurveLpTokenLiquidatorNoRegistry.sol\";\nimport { LeveredPositionFactoryFirstExtension } from \"../ionic/levered/LeveredPositionFactoryFirstExtension.sol\";\nimport { LeveredPositionFactorySecondExtension } from \"../ionic/levered/LeveredPositionFactorySecondExtension.sol\";\nimport { ILeveredPositionFactory } from \"../ionic/levered/ILeveredPositionFactory.sol\";\nimport { LeveredPositionsLens } from \"../ionic/levered/LeveredPositionsLens.sol\";\nimport { LiquidatorsRegistry } from \"../liquidators/registry/LiquidatorsRegistry.sol\";\nimport { LiquidatorsRegistryExtension } from \"../liquidators/registry/LiquidatorsRegistryExtension.sol\";\nimport { LiquidatorsRegistrySecondExtension } from \"../liquidators/registry/LiquidatorsRegistrySecondExtension.sol\";\nimport { ILiquidatorsRegistry } from \"../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { IRedemptionStrategy } from \"../liquidators/IRedemptionStrategy.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { SafeOwnable } from \"../ionic/SafeOwnable.sol\";\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\ncontract LeveredPositionLensTest is BaseTest {\n  LeveredPositionsLens lens;\n  ILeveredPositionFactory factory;\n\n  function afterForkSetUp() internal override {\n    factory = ILeveredPositionFactory(ap.getAddress(\"LeveredPositionFactory\"));\n    lens = LeveredPositionsLens(ap.getAddress(\"LeveredPositionsLens\"));\n    //    lens = new LeveredPositionsLens();\n    //    lens.initialize(factory);\n  }\n\n  function testLPLens() public debuggingOnly fork(BSC_CHAPEL) {\n    _testLPLens();\n  }\n\n  function _testLPLens() internal {\n    address[] memory positions;\n    bool[] memory closed;\n    (positions, closed) = factory.getPositionsByAccount(0xb6c11605e971ab46B9BE4fDC48C9650A257075db);\n\n    //    address[] memory accounts = factory.getAccountsWithOpenPositions();\n    //    for (uint256 i = 0; i < accounts.length; i++) {\n    //      (positions, closed) = factory.getPositionsByAccount(accounts[i]);\n    //      if (positions.length > 0) break;\n    //    }\n\n    uint256[] memory apys = new uint256[](positions.length);\n    LeveredPosition[] memory pos = new LeveredPosition[](positions.length);\n    for (uint256 j = 0; j < positions.length; j++) {\n      apys[j] = 1e17;\n\n      if (address(0) == positions[j]) revert(\"zero pos address\");\n      pos[j] = LeveredPosition(positions[j]);\n    }\n\n    LeveredPositionsLens.PositionInfo[] memory infos = lens.getPositionsInfo(pos, apys);\n\n    for (uint256 k = 0; k < infos.length; k++) {\n      emit log_named_address(\"address\", address(pos[k]));\n      emit log_named_uint(\"positionSupplyAmount\", infos[k].positionSupplyAmount);\n      emit log_named_uint(\"positionValue\", infos[k].positionValue);\n      emit log_named_uint(\"debtAmount\", infos[k].debtAmount);\n      emit log_named_uint(\"debtValue\", infos[k].debtValue);\n      emit log_named_uint(\"equityValue\", infos[k].equityValue);\n      emit log_named_uint(\"equityAmount\", infos[k].equityAmount);\n      emit log_named_int(\"currentApy\", infos[k].currentApy);\n      emit log_named_uint(\"debtRatio\", infos[k].debtRatio);\n      emit log_named_uint(\"liquidationThreshold\", infos[k].liquidationThreshold);\n      emit log_named_uint(\"safetyBuffer\", infos[k].safetyBuffer);\n\n      emit log(\"\");\n    }\n  }\n\n  function testPrintLeveredPositions() public debuggingOnly fork(POLYGON_MAINNET) {\n    address[] memory accounts = factory.getAccountsWithOpenPositions();\n\n    emit log_named_array(\"accounts\", accounts);\n\n    for (uint256 j = 0; j < accounts.length; j++) {\n      address[] memory positions;\n      bool[] memory closed;\n      (positions, closed) = factory.getPositionsByAccount(accounts[j]);\n      emit log_named_array(\"positions\", positions);\n      //emit log_named_array(\"closed\", closed);\n    }\n  }\n\n  function testScenarioLeverageFailed() public debuggingOnly forkAtBlock(MODE_MAINNET, 10672173) {\n    address USER = 0x95Ce459B20586cf44ee6d295C4f28e1a134CF529;\n    // IERC20Upgradeable(0x4200000000000000000000000000000000000006).approve(\n    //   address(factory),\n    //   100000 ether\n    // );\n    vm.prank(ap.owner());\n    ap.setAddress(\"IUniswapV2Router02\", 0x3a63171DD9BebF4D07BC782FECC7eb0b890C2A45);\n    vm.startPrank(USER);\n    LeveredPosition position = factory.createAndFundPositionAtRatio(\n      ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2),\n      ICErc20(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038),\n      IERC20Upgradeable(0x4200000000000000000000000000000000000006),\n      16754252276537996590,\n      3000000000000000000\n    );\n    emit log_named_address(\"position\", address(position));\n\n    // vm.stopPrank();\n    // ILiquidatorsRegistry registry = factory.liquidatorsRegistry();\n    // vm.startPrank(registry.owner());\n    // registry._setRedemptionStrategy(\n    //   new UniswapV3LiquidatorFunder(),\n    //   IERC20Upgradeable(0xd988097fb8612cc24eeC14542bC03424c656005f),\n    //   IERC20Upgradeable(0x4200000000000000000000000000000000000006)\n    // );\n    // vm.stopPrank();\n    // vm.startPrank(USER);\n\n    vm.roll(10673509);\n    position.adjustLeverageRatio(3000000000000000000);\n\n    // vm.roll(10852409);\n    // position.adjustLeverageRatio(3000000000000000000);\n\n    // vm.roll(11268772);\n    // position.adjustLeverageRatio(3000000000000000000);\n    vm.stopPrank();\n  }\n}\n\ncontract LeveredPositionFactoryTest is BaseTest {\n  ILeveredPositionFactory factory;\n  LeveredPositionsLens lens;\n\n  function afterForkSetUp() internal override {\n    factory = ILeveredPositionFactory(ap.getAddress(\"LeveredPositionFactory\"));\n    lens = LeveredPositionsLens(ap.getAddress(\"LeveredPositionsLens\"));\n  }\n\n  function testChapelNetApy() public debuggingOnly fork(BSC_CHAPEL) {\n    ICErc20 _stableMarket = ICErc20(address(1)); // DAI\n\n    uint256 borrowRate = 5.2e16; // 5.2%\n    vm.mockCall(\n      address(_stableMarket),\n      abi.encodeWithSelector(_stableMarket.borrowRatePerBlock.selector),\n      abi.encode(borrowRate / factory.blocksPerYear())\n    );\n\n    uint256 _borrowRate = _stableMarket.borrowRatePerBlock() * factory.blocksPerYear();\n    emit log_named_uint(\"_borrowRate\", _borrowRate);\n\n    int256 netApy = lens.getNetAPY(\n      2.7e16, // 2.7%\n      1e18, // supply amount\n      ICErc20(address(0)), // BOMB\n      _stableMarket,\n      2e18 // ratio\n    );\n\n    emit log_named_int(\"net apy\", netApy);\n\n    // boosted APY = 2x 2.7% = 5.4 % of the equity\n    // borrow APR = 5.2%\n    // diff = 5.4 - 5.2 = 0.2%\n    assertApproxEqRel(netApy, 0.2e16, 1e12, \"!net apy\");\n  }\n}\n\nabstract contract LeveredPositionTest is MarketsTest {\n  ICErc20 collateralMarket;\n  ICErc20 stableMarket;\n  ILeveredPositionFactory factory;\n  ILiquidatorsRegistry registry;\n  LeveredPosition position;\n  LeveredPositionsLens lens;\n\n  uint256 minLevRatio;\n  uint256 maxLevRatio;\n\n  function afterForkSetUp() internal virtual override {\n    super.afterForkSetUp();\n\n    factory = ILeveredPositionFactory(ap.getAddress(\"LeveredPositionFactory\"));\n    registry = factory.liquidatorsRegistry();\n    //    {\n    //      // upgrade the factory\n    //      LeveredPositionFactoryFirstExtension newExt1 = new LeveredPositionFactoryFirstExtension();\n    //      LeveredPositionFactorySecondExtension newExt2 = new LeveredPositionFactorySecondExtension();\n    //\n    //      vm.startPrank(factory.owner());\n    //      DiamondBase asBase = DiamondBase(address(factory));\n    //      address[] memory oldExts = asBase._listExtensions();\n    //\n    //      if (oldExts.length == 1) {\n    //        asBase._registerExtension(newExt1, DiamondExtension(oldExts[0]));\n    //        asBase._registerExtension(newExt2, DiamondExtension(address(0)));\n    //      } else if (oldExts.length == 2) {\n    //        asBase._registerExtension(newExt1, DiamondExtension(oldExts[0]));\n    //        asBase._registerExtension(newExt2, DiamondExtension(oldExts[1]));\n    //      }\n    //      vm.stopPrank();\n    //    }\n\n    lens = LeveredPositionsLens(ap.getAddress(\"LeveredPositionsLens\"));\n  }\n\n  function upgradeRegistry() internal {\n    DiamondBase asBase = DiamondBase(address(registry));\n    address[] memory exts = asBase._listExtensions();\n    LiquidatorsRegistryExtension newExt1 = new LiquidatorsRegistryExtension();\n    LiquidatorsRegistrySecondExtension newExt2 = new LiquidatorsRegistrySecondExtension();\n    vm.prank(SafeOwnable(address(registry)).owner());\n    asBase._registerExtension(newExt1, DiamondExtension(exts[0]));\n    vm.prank(SafeOwnable(address(registry)).owner());\n    asBase._registerExtension(newExt2, DiamondExtension(exts[1]));\n  }\n\n  function upgradePoolAndMarkets() internal {\n    _upgradeExistingPool(address(collateralMarket.comptroller()));\n    _upgradeMarket(collateralMarket);\n    _upgradeMarket(stableMarket);\n  }\n\n  function _unpauseMarkets(address collat, address stable) internal {\n    ComptrollerFirstExtension asExtension = ComptrollerFirstExtension(address(ICErc20(stable).comptroller()));\n    vm.startPrank(asExtension.admin());\n    asExtension._setMintPaused(ICErc20(collat), false);\n    asExtension._setMintPaused(ICErc20(stable), false);\n    asExtension._setBorrowPaused(ICErc20(stable), false);\n    vm.stopPrank();\n  }\n\n  function _configurePairAndLiquidator(address _collat, address _stable, IRedemptionStrategy _liquidator) internal {\n    _configurePair(_collat, _stable);\n    _configureTwoWayLiquidator(_collat, _stable, _liquidator);\n  }\n\n  function _configurePair(address _collat, address _stable) internal {\n    collateralMarket = ICErc20(_collat);\n    stableMarket = ICErc20(_stable);\n\n    //upgradePoolAndMarkets();\n    //_unpauseMarkets(_collat, _stable);\n    vm.prank(factory.owner());\n    factory._setPairWhitelisted(collateralMarket, stableMarket, true);\n  }\n\n  function _whitelistTestUser(address user) internal {\n    address pool = address(collateralMarket.comptroller());\n    PoolRolesAuthority pra = ffd.authoritiesRegistry().poolsAuthorities(pool);\n\n    vm.startPrank(pra.owner());\n    pra.setUserRole(user, pra.BORROWER_ROLE(), true);\n    vm.stopPrank();\n  }\n\n  function _configureTwoWayLiquidator(\n    address inputMarket,\n    address outputMarket,\n    IRedemptionStrategy strategy\n  ) internal {\n    IERC20Upgradeable inputToken = underlying(inputMarket);\n    IERC20Upgradeable outputToken = underlying(outputMarket);\n    vm.startPrank(registry.owner());\n    registry._setRedemptionStrategy(strategy, inputToken, outputToken);\n    registry._setRedemptionStrategy(strategy, outputToken, inputToken);\n    vm.stopPrank();\n  }\n\n  function underlying(address market) internal view returns (IERC20Upgradeable) {\n    return IERC20Upgradeable(ICErc20(market).underlying());\n  }\n\n  struct Liquidator {\n    IERC20Upgradeable inputToken;\n    IERC20Upgradeable outputToken;\n    IRedemptionStrategy strategy;\n  }\n\n  function _configureMultipleLiquidators(Liquidator[] memory liquidators) internal {\n    IRedemptionStrategy[] memory strategies = new IRedemptionStrategy[](liquidators.length);\n    IERC20Upgradeable[] memory inputTokens = new IERC20Upgradeable[](liquidators.length);\n    IERC20Upgradeable[] memory outputTokens = new IERC20Upgradeable[](liquidators.length);\n    for (uint256 i = 0; i < liquidators.length; i++) {\n      strategies[i] = liquidators[i].strategy;\n      inputTokens[i] = liquidators[i].inputToken;\n      outputTokens[i] = liquidators[i].outputToken;\n    }\n    vm.startPrank(registry.owner());\n    registry._setRedemptionStrategies(strategies, inputTokens, outputTokens);\n    vm.stopPrank();\n  }\n\n  function _fundMarketAndSelf(ICErc20 market, address whale) internal {\n    IERC20Upgradeable token = IERC20Upgradeable(market.underlying());\n\n    if (whale == address(0)) {\n      whale = address(911);\n      //vm.deal(address(token), whale, 100e18);\n    }\n\n    uint256 allTokens = token.balanceOf(whale);\n    vm.prank(whale);\n    token.transfer(address(this), allTokens / 20);\n\n    if (market.getCash() < allTokens / 2) {\n      _whitelistTestUser(whale);\n      vm.startPrank(whale);\n      token.approve(address(market), allTokens / 2);\n      market.mint(allTokens / 2);\n      vm.stopPrank();\n    }\n  }\n\n  function _openLeveredPosition(\n    address _positionOwner,\n    uint256 _depositAmount\n  ) internal returns (LeveredPosition _position, uint256 _maxRatio, uint256 _minRatio) {\n    IERC20Upgradeable collateralToken = IERC20Upgradeable(collateralMarket.underlying());\n    collateralToken.transfer(_positionOwner, _depositAmount);\n\n    vm.startPrank(_positionOwner);\n    collateralToken.approve(address(factory), _depositAmount);\n    _position = factory.createAndFundPosition(collateralMarket, stableMarket, collateralToken, _depositAmount);\n    vm.stopPrank();\n\n    _maxRatio = _position.getMaxLeverageRatio();\n    emit log_named_uint(\"max ratio\", _maxRatio);\n    _minRatio = _position.getMinLeverageRatio();\n    emit log_named_uint(\"min ratio\", _minRatio);\n\n    assertGt(_maxRatio, _minRatio, \"max ratio <= min ratio\");\n  }\n\n  function testOpenLeveredPosition() public virtual whenForking {\n    assertApproxEqRel(position.getCurrentLeverageRatio(), 1e18, 4e16, \"initial leverage ratio should be 1.0 (1e18)\");\n  }\n\n  function testAnyLeverageRatio(uint64 ratioDiff) public debuggingOnly whenForking {\n    // ratioDiff is between 0 and 2^64 ~= 18.446e18\n    uint256 targetLeverageRatio = 1e18 + uint256(ratioDiff);\n    emit log_named_uint(\"fuzz max ratio\", maxLevRatio);\n    emit log_named_uint(\"fuzz min ratio\", minLevRatio);\n    emit log_named_uint(\"target ratio\", targetLeverageRatio);\n    vm.assume(targetLeverageRatio < maxLevRatio);\n    vm.assume(minLevRatio < targetLeverageRatio);\n\n    uint256 borrowedAssetPrice = stableMarket.comptroller().oracle().getUnderlyingPrice(stableMarket);\n    (uint256 sd, uint256 bd) = position.getSupplyAmountDelta(targetLeverageRatio);\n    emit log_named_uint(\"borrows delta val\", (bd * borrowedAssetPrice) / 1e18);\n    emit log_named_uint(\"min borrow value\", ffd.getMinBorrowEth(stableMarket));\n\n    uint256 equityAmount = position.getEquityAmount();\n    emit log_named_uint(\"equity amount\", equityAmount);\n\n    uint256 currentLeverageRatio = position.getCurrentLeverageRatio();\n    emit log_named_uint(\"current ratio\", currentLeverageRatio);\n\n    uint256 leverageRatioRealized = position.adjustLeverageRatio(targetLeverageRatio);\n    emit log_named_uint(\"equity amount\", position.getEquityAmount());\n    assertApproxEqRel(leverageRatioRealized, targetLeverageRatio, 4e16, \"target ratio not matching\");\n  }\n\n  function testMinMaxLeverageRatio() public whenForking {\n    assertGt(maxLevRatio, minLevRatio, \"max ratio <= min ratio\");\n\n    // attempting to adjust to minLevRatio - 0.01 should fail\n    vm.expectRevert(abi.encodeWithSelector(LeveredPosition.BorrowStableFailed.selector, 0x3fa));\n    position.adjustLeverageRatio((minLevRatio + 1e18) / 2);\n    // just testing\n    position.adjustLeverageRatio(maxLevRatio);\n    // but adjusting to the minLevRatio + 0.01 should succeed\n    position.adjustLeverageRatio(minLevRatio + 0.01e18);\n  }\n\n  function testMaxLeverageRatio() public whenForking {\n    uint256 _equityAmount = position.getEquityAmount();\n    uint256 rate = lens.getBorrowRateAtRatio(collateralMarket, stableMarket, _equityAmount, maxLevRatio);\n    emit log_named_uint(\"borrow rate at max ratio\", rate);\n\n    position.adjustLeverageRatio(maxLevRatio);\n    assertApproxEqRel(position.getCurrentLeverageRatio(), maxLevRatio, 4e16, \"target max ratio not matching\");\n  }\n\n  function testRewardsAccruedClaimed() public whenForking {\n    address[] memory flywheels = position.pool().getRewardsDistributors();\n    if (flywheels.length > 0) {\n      vm.warp(block.timestamp + 60 * 60 * 24);\n      vm.roll(block.number + 10000);\n\n      (ERC20[] memory rewardTokens, uint256[] memory amounts) = position.getAccruedRewards();\n\n      ERC20 rewardToken;\n      bool atLeastOneAccrued = false;\n      for (uint256 i = 0; i < amounts.length; i++) {\n        atLeastOneAccrued = amounts[i] > 0;\n        if (atLeastOneAccrued) {\n          rewardToken = rewardTokens[i];\n          emit log_named_address(\"accrued from reward token\", address(rewardTokens[i]));\n          break;\n        }\n      }\n\n      assertEq(atLeastOneAccrued, true, \"!should have accrued at least one reward token\");\n\n      if (atLeastOneAccrued) {\n        uint256 rewardsBalanceBefore = rewardToken.balanceOf(address(this));\n        position.claimRewards();\n        uint256 rewardsBalanceAfter = rewardToken.balanceOf(address(this));\n        assertGt(rewardsBalanceAfter - rewardsBalanceBefore, 0, \"should have claimed some rewards\");\n      }\n    } else {\n      emit log(\"no flywheels/rewards for the pair pool\");\n    }\n  }\n\n  function testLeverMaxDown() public whenForking {\n    IERC20Upgradeable stableAsset = IERC20Upgradeable(stableMarket.underlying());\n    IERC20Upgradeable collateralAsset = IERC20Upgradeable(collateralMarket.underlying());\n    uint256 startingEquity = position.getEquityAmount();\n\n    uint256 leverageRatioRealized = position.adjustLeverageRatio(maxLevRatio);\n    assertApproxEqRel(leverageRatioRealized, maxLevRatio, 4e16, \"target ratio not matching\");\n\n    // decrease the ratio in 10 equal steps\n    uint256 ratioDiffStep = (maxLevRatio - 1e18) / 9;\n    while (leverageRatioRealized > 1e18) {\n      uint256 targetLeverDownRatio = leverageRatioRealized - ratioDiffStep;\n      if (targetLeverDownRatio < minLevRatio) targetLeverDownRatio = 1e18;\n      leverageRatioRealized = position.adjustLeverageRatio(targetLeverDownRatio);\n      assertApproxEqRel(leverageRatioRealized, targetLeverDownRatio, 3e16, \"target lever down ratio not matching\");\n    }\n\n    uint256 withdrawAmount = position.closePosition();\n    emit log_named_uint(\"withdraw amount\", withdrawAmount);\n    assertApproxEqRel(startingEquity, withdrawAmount, 5e16, \"!withdraw amount\");\n\n    assertEq(position.getEquityAmount(), 0, \"!nonzero equity amount\");\n    assertEq(position.getCurrentLeverageRatio(), 0, \"!nonzero leverage ratio\");\n  }\n}\n\ncontract WmaticMaticXLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    upgradeRegistry();\n\n    uint256 depositAmount = 500e18;\n\n    address wmaticMarket = 0xCb8D7c2690536d3444Da3d207f62A939483c8A93;\n    address maticxMarket = 0x6ebdbEe1a509247B4A3ac3b73a43bd434C52C7c2;\n    address wmaticWhale = 0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97;\n    address maticxWhale = 0x72f0275444F2aF8dBf13F78D54A8D3aD7b6E68db;\n\n    _configurePair(wmaticMarket, maticxMarket);\n    _fundMarketAndSelf(ICErc20(wmaticMarket), wmaticWhale);\n    _fundMarketAndSelf(ICErc20(maticxMarket), maticxWhale);\n\n    // call amountOutAndSlippageOfSwap to cache the slippage\n    {\n      IERC20Upgradeable collateralToken = IERC20Upgradeable(collateralMarket.underlying());\n      IERC20Upgradeable stableToken = IERC20Upgradeable(stableMarket.underlying());\n\n      vm.startPrank(wmaticWhale);\n      collateralToken.approve(address(registry), 1e36);\n      registry.amountOutAndSlippageOfSwap(collateralToken, 100e18, stableToken);\n      vm.stopPrank();\n      vm.startPrank(maticxWhale);\n      stableToken.approve(address(registry), 1e36);\n      registry.amountOutAndSlippageOfSwap(stableToken, 100e18, collateralToken);\n      vm.stopPrank();\n\n      emit log_named_uint(\"slippage coll->stable\", registry.getSlippage(collateralToken, stableToken));\n      emit log_named_uint(\"slippage stable->coll\", registry.getSlippage(stableToken, collateralToken));\n    }\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract StkBnbWBnbLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(BSC_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 2e18;\n\n    address stkBnbMarket = 0xAcfbf93d8fD1A9869bAb2328669dDba33296a421;\n    address wbnbMarket = 0x3Af258d24EBdC03127ED6cEb8e58cA90835fbca5;\n    address stkBnbWhale = 0x84b78452A97C5afDa1400943333F691448069A29; // algebra pool\n    address wbnbWhale = 0x84b78452A97C5afDa1400943333F691448069A29; // algebra pool\n\n    AlgebraSwapLiquidator liquidator = new AlgebraSwapLiquidator();\n    _configurePairAndLiquidator(stkBnbMarket, wbnbMarket, liquidator);\n    _fundMarketAndSelf(ICErc20(stkBnbMarket), stkBnbWhale);\n    _fundMarketAndSelf(ICErc20(wbnbMarket), wbnbWhale);\n\n    IERC20Upgradeable collateralToken = IERC20Upgradeable(collateralMarket.underlying());\n    collateralToken.transfer(address(this), depositAmount);\n    collateralToken.approve(address(factory), depositAmount);\n    position = factory.createAndFundPosition(collateralMarket, stableMarket, collateralToken, depositAmount);\n  }\n}\n\ninterface TwoBrl {\n  function minter() external view returns (address);\n\n  function mint(address payable _to, uint256 _value) external returns (bool);\n}\n\ncontract Jbrl2BrlLeveredPositionTest is LeveredPositionTest {\n  IonicComptroller pool;\n  ComptrollerFirstExtension asExtension;\n\n  function setUp() public fork(BSC_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1000e18;\n\n    address twoBrlMarket = 0xf0a2852958aD041a9Fb35c312605482Ca3Ec17ba; // 2brl as collateral\n    address jBrlMarket = 0x82A3103bc306293227B756f7554AfAeE82F8ab7a; // jbrl as borrowable\n    address payable twoBrlWhale = payable(address(177)); // empty account\n    address jBrlWhale = 0xA0695f78AF837F570bcc50f53e58Cda300798B65; // solidly pair BRZ-JBRL\n\n    TwoBrl twoBrl = TwoBrl(ICErc20(twoBrlMarket).underlying());\n    vm.prank(twoBrl.minter());\n    twoBrl.mint(twoBrlWhale, depositAmount * 100);\n\n    _configurePair(twoBrlMarket, jBrlMarket);\n    _fundMarketAndSelf(ICErc20(twoBrlMarket), twoBrlWhale);\n    _fundMarketAndSelf(ICErc20(jBrlMarket), jBrlWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract BombWbnbLeveredPositionTest is LeveredPositionTest {\n  uint256 depositAmount = 100e18;\n  address whale = 0xe7B7dF67C1fe053f1C6B965826d3bFF19603c482;\n  address wbnbWhale = 0x57E30beb8054B248CE301FeabfD0c74677Fa40f0;\n  uint256 ratioOnCreation = 1.0e18;\n  uint256 minBorrowNative = 1e17;\n\n  function setUp() public fork(BSC_CHAPEL) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    upgradeRegistry();\n\n    vm.mockCall(\n      address(ffd),\n      abi.encodeWithSelector(IFeeDistributor.minBorrowEth.selector),\n      abi.encode(minBorrowNative)\n    );\n\n    address xMarket = 0x9B6E1039103812E0dcC1100a158e4a68014b2571; // BOMB\n    address yMarket = 0x9dD00920f5B74A31177cbaB834AB0904703c31B1; // WBNB\n\n    collateralMarket = ICErc20(xMarket);\n    stableMarket = ICErc20(yMarket);\n\n    //upgradePoolAndMarkets();\n\n    IERC20Upgradeable collateralToken = IERC20Upgradeable(collateralMarket.underlying());\n    IERC20Upgradeable stableToken = IERC20Upgradeable(stableMarket.underlying());\n    // call amountOutAndSlippageOfSwap to cache the slippage\n    {\n      vm.startPrank(whale);\n      collateralToken.approve(address(registry), 1e36);\n      registry.amountOutAndSlippageOfSwap(collateralToken, 1e18, stableToken);\n      collateralToken.transfer(address(this), depositAmount);\n      vm.stopPrank();\n\n      vm.startPrank(wbnbWhale);\n      stableToken.approve(address(registry), 1e36);\n      registry.amountOutAndSlippageOfSwap(stableToken, 1e18, collateralToken);\n      vm.stopPrank();\n    }\n\n    vm.prank(whale);\n    collateralToken.transfer(address(this), depositAmount);\n\n    collateralToken.approve(address(factory), depositAmount);\n    position = factory.createAndFundPositionAtRatio(\n      collateralMarket,\n      stableMarket,\n      collateralToken,\n      depositAmount,\n      ratioOnCreation\n    );\n\n    maxLevRatio = position.getMaxLeverageRatio();\n    minLevRatio = position.getMinLeverageRatio();\n\n    vm.label(address(position), \"Levered Position\");\n  }\n}\n\ncontract PearlWUsdrWUsdrUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 0.000002e18;\n\n    address lpTokenMarket = 0x06F61E22ef144f1cC4550D40ffbF681CB1C3aCAF;\n    address wusdrMarket = 0x26EA46e975778662f98dAa0E7a12858dA9139262;\n    address lpTokenWhale = 0x03Fa7A2628D63985bDFe07B95d4026663ED96065;\n    address wUsdrWhale = 0x8711a1a52c34EDe8E61eF40496ab2618a8F6EA4B;\n\n    _configurePair(lpTokenMarket, wusdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(wusdrMarket), wUsdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrWUsdrUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 0.000002e18;\n\n    address lpTokenMarket = 0x06F61E22ef144f1cC4550D40ffbF681CB1C3aCAF;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0x03Fa7A2628D63985bDFe07B95d4026663ED96065;\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdcUsdrLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 800e9;\n\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address usdcMarket = 0x71A7037a42D0fB9F905a76B7D16846b2EACC59Aa;\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    IRedemptionStrategy liquidator = new SolidlySwapLiquidator();\n    _configurePairAndLiquidator(usdrMarket, usdcMarket, liquidator);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdcUsdcUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 10e9;\n\n    // LP token underlying 0xD17cb0f162f133e339C0BbFc18c36c357E681D6b\n    address lpTokenMarket = 0x83DF24fE1B1eBF38048B91ffc4a8De0bAa88b891;\n    address usdcMarket = 0x71A7037a42D0fB9F905a76B7D16846b2EACC59Aa;\n    address lpTokenWhale = 0x97Bd59A8202F8263C2eC39cf6cF6B438D0B45876; // Thena Gauge\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    _configurePair(lpTokenMarket, usdcMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrUsdcUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 10e9;\n\n    // LP token underlying 0xD17cb0f162f133e339C0BbFc18c36c357E681D6b\n    address lpTokenMarket = 0x83DF24fE1B1eBF38048B91ffc4a8De0bAa88b891;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0x97Bd59A8202F8263C2eC39cf6cF6B438D0B45876; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrDaiUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 2e18;\n\n    // LP token underlying 0xBD02973b441Aa83c8EecEA158b98B5984bb1036E\n    address lpTokenMarket = 0xBcE30B4D78cEb9a75A1Aa62156529c3592b3F08b;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0x85Fa2331040933A02b154579fAbE6A6a5A765279; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrTngblUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 0.02e18;\n\n    // LP token underlying 0x0Edc235693C20943780b76D79DD763236E94C751\n    address lpTokenMarket = 0x2E870Aeee3D9d1eA29Ec93d2c0A99A4e0D5EB697;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0xdaeF32cA8D699015fcFB2884F6902fFCebE51c5b; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrWbtcUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 0.000000071325342755e18;\n\n    // LP token underlying 0xb95E1C22dd965FafE926b2A793e9D6757b6613F4\n    address lpTokenMarket = 0xffc8c8d747E52fAfbf973c64Bab10d38A6902c46;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0x39976f6328ebA2a3C860b7DE5cF2c1bB41581FB8; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrWethUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 0.004081e18;\n\n    // LP token underlying 0x343D9a8D2Bc6A62390aEc764bb5b900C4B039127\n    address lpTokenMarket = 0x343D9a8D2Bc6A62390aEc764bb5b900C4B039127;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0x7D02A8b758791A03319102f81bF61E220F73e43D; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract PearlUsdrMaticUsdrLpLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 0.05e18;\n\n    // LP token underlying vAMM-WMATIC/USDR\n    address lpTokenMarket = 0xfacEdA4f9731797102f040380aD5e234c92d1942;\n    address usdrMarket = 0x1F11940B239D129dE0e5D30A3E59089af5Ecd6ed;\n    address lpTokenWhale = 0xdA0AfBeEEBef6dA2F060237D35cab759b99B13B6; // Thena Gauge\n    address usdrWhale = 0x00e8c0E92eB3Ad88189E7125Ec8825eDc03Ab265; // wUSDR contract\n\n    _configurePair(lpTokenMarket, usdrMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdrMarket), usdrWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroCashAUsdcCashLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n    upgradeRegistry();\n\n    uint256 depositAmount = 300e18;\n\n    // LP token underlying xCASH-USDC\n    address lpTokenMarket = 0x1D2A7078a404ab970f951d5A6dbECD9e24838FB6;\n    address cashMarket = 0xf69207CFDe6228A1e15A34F2b0c4fDe0845D9eBa;\n    address lpTokenWhale = 0x35a499c15b4dDCf7e98628D415346B9795CCa80d;\n    address cashWhale = 0x88C522E526E5Eea8d636fd6805cA7fEB488780D0;\n\n    _configurePair(lpTokenMarket, cashMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(cashMarket), cashWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroUsdcAUsdcCashLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 700e18;\n\n    // LP token underlying xCASH-USDC\n    address lpTokenMarket = 0x1D2A7078a404ab970f951d5A6dbECD9e24838FB6;\n    address usdcMarket = 0x38EbA94210bCEf3F9231E1764EE230abC14D1cbc;\n    address lpTokenWhale = 0x35a499c15b4dDCf7e98628D415346B9795CCa80d;\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    _configurePair(lpTokenMarket, usdcMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroUsdcAUsdcWethLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e18;\n\n    // LP token underlying xUSDC-WETH05\n    address lpTokenMarket = 0xC7cA03A0bE1dBAc350E5BfE5050fC5af6406490E;\n    address usdcMarket = 0x38EbA94210bCEf3F9231E1764EE230abC14D1cbc;\n    address lpTokenWhale = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    _configurePair(lpTokenMarket, usdcMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroCashUsdcLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 300e18;\n\n    address cashMarket = 0xf69207CFDe6228A1e15A34F2b0c4fDe0845D9eBa;\n    address usdcMarket = 0x38EbA94210bCEf3F9231E1764EE230abC14D1cbc;\n    address cashWhale = 0x88C522E526E5Eea8d636fd6805cA7fEB488780D0;\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    _configurePair(cashMarket, usdcMarket);\n    _fundMarketAndSelf(ICErc20(cashMarket), cashWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroCashAUsdcWethLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e18;\n\n    // LP token underlying xUSDC-WETH05\n    address lpTokenMarket = 0xC7cA03A0bE1dBAc350E5BfE5050fC5af6406490E;\n    address cashMarket = 0xf69207CFDe6228A1e15A34F2b0c4fDe0845D9eBa;\n    address lpTokenWhale = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n    address cashWhale = 0x88C522E526E5Eea8d636fd6805cA7fEB488780D0;\n\n    _configurePair(lpTokenMarket, cashMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(cashMarket), cashWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract RetroWethAWbtcWethLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e18;\n\n    // LP token underlying xWBTC-WETH05\n    address lpTokenMarket = 0xCB1a06eff3459078c26516ae3a1dB44A61D2DbCA;\n    address wethMarket = 0x2469B23354cb7cA50b798663Ec5812Bf28d15e9e;\n    address lpTokenWhale = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n    address wethWhale = 0x1eED63EfBA5f81D95bfe37d82C8E736b974F477b;\n\n    _configurePair(lpTokenMarket, wethMarket);\n    _fundMarketAndSelf(ICErc20(lpTokenMarket), lpTokenWhale);\n    _fundMarketAndSelf(ICErc20(wethMarket), wethWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract DavosUsdcDusdLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(POLYGON_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 500e18;\n\n    address dusdMarket = 0xE70d09dA78900A0429ee70b35200F70A30d7d2B9;\n    address usdcMarket = 0x14787e50578d8c606C3d57bDbA53dD65Fd665449;\n    address dusdWhale = 0xE69a1876bdACfa7A7a4F6D531BE2FDE843D2165C;\n    address usdcWhale = 0x5a52E96BAcdaBb82fd05763E25335261B270Efcb;\n\n    _configurePair(dusdMarket, usdcMarket);\n    _fundMarketAndSelf(ICErc20(dusdMarket), dusdWhale);\n    _fundMarketAndSelf(ICErc20(usdcMarket), usdcWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract ModeWethUSDCLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(MODE_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e17;\n\n    address wethMarket = 0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2;\n    address USDCMarket = 0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038;\n    address wethWhale = 0x7380511493DD4c2f1dD75E9CCe5bD52C787D4B51;\n    address USDCWhale = 0x34b83A3759ba4c9F99c339604181bf6bBdED4C79;\n\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = ICErc20(USDCMarket);\n\n    uint256[] memory newBorrowCaps = new uint256[](1);\n    newBorrowCaps[0] = 1e36;\n\n    IonicComptroller comptroller = IonicComptroller(ICErc20(wethMarket).comptroller());\n\n    vm.prank(comptroller.admin());\n    comptroller._setMarketBorrowCaps(cTokens, newBorrowCaps);\n    vm.stopPrank();\n\n    _configurePair(wethMarket, USDCMarket);\n    _fundMarketAndSelf(ICErc20(wethMarket), wethWhale);\n    _fundMarketAndSelf(ICErc20(USDCMarket), USDCWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract ModeWethUSDTLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(MODE_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e18;\n\n    address wethMarket = 0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2;\n    address USDTMarket = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n    address wethWhale = 0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2;\n    address USDTWhale = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = ICErc20(USDTMarket);\n\n    uint256[] memory newBorrowCaps = new uint256[](1);\n    newBorrowCaps[0] = 1e36;\n\n    IonicComptroller comptroller = IonicComptroller(ICErc20(wethMarket).comptroller());\n\n    vm.prank(comptroller.admin());\n    comptroller._setMarketBorrowCaps(cTokens, newBorrowCaps);\n\n    _configurePair(wethMarket, USDTMarket);\n    _fundMarketAndSelf(ICErc20(wethMarket), wethWhale);\n    _fundMarketAndSelf(ICErc20(USDTMarket), USDTWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract ModeWbtcUSDCLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(MODE_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e6;\n\n    address wbtcMarket = 0xd70254C3baD29504789714A7c69d60Ec1127375C;\n    address USDCMarket = 0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038;\n    address wbtcWhale = 0x3f3429D28438Cc14133966820b8A9Ea61Cf1D4F0;\n    address USDCWhale = 0x34b83A3759ba4c9F99c339604181bf6bBdED4C79;\n\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = ICErc20(USDCMarket);\n\n    uint256[] memory newBorrowCaps = new uint256[](1);\n    newBorrowCaps[0] = 1e36;\n\n    IonicComptroller comptroller = IonicComptroller(ICErc20(wbtcMarket).comptroller());\n\n    vm.prank(comptroller.admin());\n    comptroller._setMarketBorrowCaps(cTokens, newBorrowCaps);\n    vm.stopPrank();\n\n    IERC20Upgradeable token = IERC20Upgradeable(ICErc20(wbtcMarket).underlying());\n\n    _configurePair(wbtcMarket, USDCMarket);\n\n    uint256 allTokens = token.balanceOf(wbtcWhale);\n\n    vm.prank(wbtcWhale);\n    token.transfer(address(this), allTokens);\n    vm.stopPrank();\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\ncontract ModeWbtcUSDTLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(MODE_MAINNET) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e6;\n\n    address wbtcMarket = 0xd70254C3baD29504789714A7c69d60Ec1127375C;\n    address USDTMarket = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n    address wbtcWhale = 0xd70254C3baD29504789714A7c69d60Ec1127375C;\n    address USDTWhale = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n\n    ICErc20[] memory cTokens = new ICErc20[](1);\n    cTokens[0] = ICErc20(USDTMarket);\n\n    uint256[] memory newBorrowCaps = new uint256[](1);\n    newBorrowCaps[0] = 1e36;\n\n    IonicComptroller comptroller = IonicComptroller(ICErc20(wbtcMarket).comptroller());\n\n    vm.prank(comptroller.admin());\n    comptroller._setMarketBorrowCaps(cTokens, newBorrowCaps);\n    vm.stopPrank();\n\n    _configurePair(wbtcMarket, USDTMarket);\n    _fundMarketAndSelf(ICErc20(wbtcMarket), wbtcWhale);\n    _fundMarketAndSelf(ICErc20(USDTMarket), USDTWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n\n/*\ncontract XYLeveredPositionTest is LeveredPositionTest {\n  function setUp() public fork(X_CHAIN_ID) {}\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    uint256 depositAmount = 1e18;\n\n    address xMarket = 0x...1;\n    address yMarket = 0x...2;\n    address xWhale = 0x...3;\n    address yWhale = 0x...4;\n\n    IRedemptionStrategy liquidator = new IRedemptionStrategy();\n    _configurePairAndLiquidator(xMarket, yMarket, liquidator);\n    _fundMarketAndSelf(ICErc20(xMarket), xWhale);\n    _fundMarketAndSelf(ICErc20(yMarket), yWhale);\n\n    (position, maxLevRatio, minLevRatio) = _openLeveredPosition(address(this), depositAmount);\n  }\n}\n*/\n"
    },
    "contracts/test/liquidators/AaveTokenLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport \"../../liquidators/AaveTokenLiquidator.sol\";\n\ncontract AaveTokenLiquidatorTest is BaseTest {\n  AaveTokenLiquidator public liquidator;\n  address stable;\n  address amUsdc = 0x1a13F4Ca1d028320A707D99520AbFefca3998b7F;\n  uint256 inputAmount;\n\n  function afterForkSetUp() internal override {\n    liquidator = new AaveTokenLiquidator();\n    stable = ap.getAddress(\"stableToken\");\n  }\n\n  function testAmUsdcPolygon() public fork(POLYGON_MAINNET) {\n    address amUsdcWhale = 0xe8599F3cc5D38a9aD6F3684cd5CEa72f10Dbc383; // curve pool\n    inputAmount = 1000e6;\n\n    IERC20Upgradeable amUsdcToken = IERC20Upgradeable(amUsdc);\n    vm.prank(amUsdcWhale);\n    amUsdcToken.transfer(address(liquidator), inputAmount);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      amUsdcToken,\n      inputAmount,\n      abi.encode(stable)\n    );\n\n    assertEq(address(outputToken), stable, \"!usdc output\");\n    assertApproxEqRel(outputAmount, inputAmount, 8e16, \"!output does not match input\");\n  }\n}\n"
    },
    "contracts/test/liquidators/AlgebraSwapLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport \"../../liquidators/AlgebraSwapLiquidator.sol\";\n\ncontract AlgebraSwapLiquidatorTest is BaseTest {\n  AlgebraSwapLiquidator public liquidator;\n  address algebraSwapRouter = 0x327Dd3208f0bCF590A66110aCB6e5e6941A4EfA0;\n  address ankrBnbAddress = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n  address wbnbAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n  uint256 inputAmount = 1e18;\n\n  function afterForkSetUp() internal override {\n    liquidator = new AlgebraSwapLiquidator();\n  }\n\n  function testAlgebraAnkrBnbWbnb() public fork(BSC_MAINNET) {\n    address ankrBnbWhale = 0x366B523317Cc95B1a4D30b33f8637882825C5E23;\n\n    IERC20Upgradeable ankr = IERC20Upgradeable(ankrBnbAddress);\n    vm.prank(ankrBnbWhale);\n    ankr.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      ankr,\n      inputAmount,\n      abi.encode(wbnbAddress, algebraSwapRouter)\n    );\n\n    assertEq(address(outputToken), wbnbAddress, \"!wbnb output\");\n    assertApproxEqRel(outputAmount, inputAmount, 8e16, \"!wbnb amount\");\n  }\n\n  function testAlgebraWbnbAnkrBnb() public fork(BSC_MAINNET) {\n    address wbnbWhale = 0x36696169C63e42cd08ce11f5deeBbCeBae652050;\n\n    IERC20Upgradeable wbnb = IERC20Upgradeable(wbnbAddress);\n    vm.prank(wbnbWhale);\n    wbnb.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      wbnb,\n      inputAmount,\n      abi.encode(ankrBnbAddress, algebraSwapRouter)\n    );\n\n    assertEq(address(outputToken), ankrBnbAddress, \"!ankrbnb output\");\n    assertApproxEqRel(outputAmount, inputAmount, 8e16, \"!ankrbnb amount\");\n  }\n\n  function testModeKimV4RedemptionStrategy() public fork(MODE_MAINNET) {\n    address MODE_EZETH = 0x2416092f143378750bb29b79eD961ab195CcEea5;\n    address ezEthWhale = 0x2344F131B07E6AFd943b0901C55898573F0d1561;\n    address kimV4Router = 0xAc48FcF1049668B285f3dC72483DF5Ae2162f7e8;\n    address modeWETH = ap.getAddress(\"wtoken\");\n\n    IERC20Upgradeable ezETH = IERC20Upgradeable(MODE_EZETH);\n    vm.prank(ezEthWhale);\n    ezETH.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      ezETH,\n      inputAmount,\n      abi.encode(modeWETH, kimV4Router)\n    );\n\n    assertEq(address(outputToken), modeWETH, \"!WETH output token\");\n    assertApproxEqRel(outputAmount, inputAmount, 8e16, \"!weth amount\");\n  }\n}\n"
    },
    "contracts/test/liquidators/BalancerLpTokenLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { BalancerLpTokenLiquidator } from \"../../liquidators/BalancerLpTokenLiquidator.sol\";\nimport { BalancerSwapLiquidator } from \"../../liquidators/BalancerSwapLiquidator.sol\";\n\nimport { ICErc20Compound as ICErc20 } from \"../../external/compound/ICErc20.sol\";\nimport \"../../external/balancer/IBalancerPool.sol\";\nimport \"../../external/balancer/IBalancerVault.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract BalancerLpTokenLiquidatorTest is BaseTest {\n  BalancerLpTokenLiquidator private lpTokenLiquidator;\n  BalancerSwapLiquidator private swapLiquidator;\n  address stable;\n  address wtoken;\n\n  function afterForkSetUp() internal override {\n    lpTokenLiquidator = new BalancerLpTokenLiquidator();\n    swapLiquidator = new BalancerSwapLiquidator();\n    stable = ap.getAddress(\"stableToken\");\n    wtoken = ap.getAddress(\"wtoken\");\n  }\n\n  function testRedeemLpToken(\n    address whaleAddress,\n    address inputTokenAddress,\n    address outputTokenAddress\n  ) internal {\n    return testBalancerLpTokenLiquidator(lpTokenLiquidator, 1e18, whaleAddress, inputTokenAddress, outputTokenAddress);\n  }\n\n  function testBalancerLpTokenLiquidator(\n    IRedemptionStrategy liquidator,\n    uint256 amount,\n    address whaleAddress,\n    address inputTokenAddress,\n    address outputTokenAddress\n  ) internal {\n    IERC20Upgradeable inputToken = IERC20Upgradeable(inputTokenAddress);\n    IERC20Upgradeable outputToken = IERC20Upgradeable(outputTokenAddress);\n\n    vm.prank(whaleAddress);\n    inputToken.transfer(address(liquidator), amount);\n\n    uint256 balanceBefore = outputToken.balanceOf(address(liquidator));\n\n    bytes memory data = abi.encode(address(outputToken));\n    liquidator.redeem(inputToken, amount, data);\n\n    uint256 balanceAfter = outputToken.balanceOf(address(liquidator));\n\n    assertGt(balanceAfter - balanceBefore, 0, \"!redeem input token\");\n  }\n\n  function testBalancerSwapLiquidator(\n    uint256 amount,\n    address whaleAddress,\n    address inputTokenAddress,\n    address outputTokenAddress,\n    address pool\n  ) internal {\n    IERC20Upgradeable inputToken = IERC20Upgradeable(inputTokenAddress);\n    IERC20Upgradeable outputToken = IERC20Upgradeable(outputTokenAddress);\n\n    vm.prank(whaleAddress);\n    inputToken.transfer(address(swapLiquidator), amount);\n\n    uint256 balanceBefore = outputToken.balanceOf(address(swapLiquidator));\n\n    bytes memory data = abi.encode(outputTokenAddress, pool);\n    swapLiquidator.redeem(inputToken, amount, data);\n\n    uint256 balanceAfter = outputToken.balanceOf(address(swapLiquidator));\n\n    assertGt(balanceAfter - balanceBefore, 0, \"!swap input token\");\n  }\n\n  function testMimoParBalancerLpLiquidatorRedeem() public fork(POLYGON_MAINNET) {\n    address lpToken = 0x82d7f08026e21c7713CfAd1071df7C8271B17Eae; //MIMO-PAR 8020\n    address lpTokenWhale = 0xbB60ADbe38B4e6ab7fb0f9546C2C1b665B86af11;\n    address outputTokenAddress = 0xE2Aa7db6dA1dAE97C5f5C6914d285fBfCC32A128; // PAR\n\n    testRedeemLpToken(lpTokenWhale, lpToken, outputTokenAddress);\n  }\n\n  function testWmaticStmaticLPLiquidatorRedeem() public fork(POLYGON_MAINNET) {\n    address lpToken = 0x8159462d255C1D24915CB51ec361F700174cD994; // stMATIC-WMATIC stable\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer V2\n    address outputTokenAddress = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270; // WMATIC\n\n    testRedeemLpToken(lpTokenWhale, lpToken, outputTokenAddress);\n  }\n\n  function testWmaticMaticXLPLiquidatorRedeem() public fork(POLYGON_MAINNET) {\n    address lpToken = 0xC17636e36398602dd37Bb5d1B3a9008c7629005f; // WMATIC-MaticX stable\n    address lpTokenWhale = 0x48534d027f8962692122dB440714fFE88Ab1fA85;\n    address outputTokenAddress = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270; // WMATIC\n\n    testRedeemLpToken(lpTokenWhale, lpToken, outputTokenAddress);\n  }\n\n  function testJbrlBrzLiquidatorRedeem() public fork(POLYGON_MAINNET) {\n    address lpToken = 0xE22483774bd8611bE2Ad2F4194078DaC9159F4bA; // jBRL-BRZ stable\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer V2\n    address outputTokenAddress = 0xf2f77FE7b8e66571E0fca7104c4d670BF1C8d722; // jBRL\n\n    testRedeemLpToken(lpTokenWhale, lpToken, outputTokenAddress);\n  }\n\n  function testBoostedAaveRedeem() public fork(POLYGON_MAINNET) {\n    address inputToken = 0x48e6B98ef6329f8f0A30eBB8c7C960330d648085; // bb-am-USD\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer V2\n    address outputTokenAddress = 0xF93579002DBE8046c43FEfE86ec78b1112247BB8; // linear aaver usdc\n    testRedeemLpToken(lpTokenWhale, inputToken, outputTokenAddress);\n  }\n\n  function testWmaticStmaticLiquidatorRedeem() public fork(POLYGON_MAINNET) {\n    address inputToken = 0x8159462d255C1D24915CB51ec361F700174cD994; // Balancer stMATIC Stable Pool\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer Gauge\n    address outputTokenAddress = wtoken;\n    testRedeemLpToken(lpTokenWhale, inputToken, outputTokenAddress);\n  }\n\n  function testBoostedAaaveWmaticMaticXRedeem() public fork(POLYGON_MAINNET) {\n    address inputToken = 0xE78b25c06dB117fdF8F98583CDaaa6c92B79E917; // Balancer MaticX Boosted Aave WMATIC StablePool\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer Gauge\n    address outputTokenAddress = 0xE4885Ed2818Cc9E840A25f94F9b2A28169D1AEA7; // aave-linear-wmatic\n    testRedeemLpToken(lpTokenWhale, inputToken, outputTokenAddress);\n  }\n\n  function testLinearAaaveWmaticRedeem() public fork(POLYGON_MAINNET) {\n    uint256 amount = 1e18;\n    address inputToken = 0xE4885Ed2818Cc9E840A25f94F9b2A28169D1AEA7; // aave-linear-wmatic\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer Gauge\n    address outputTokenAddress = wtoken;\n    address pool = inputToken; // use own for swap\n    testBalancerSwapLiquidator(amount, lpTokenWhale, inputToken, outputTokenAddress, pool);\n  }\n\n  function testLinearAaveUsdcRedeem() public fork(POLYGON_MAINNET) {\n    uint256 amount = 1e18;\n    address inputToken = 0xF93579002DBE8046c43FEfE86ec78b1112247BB8; // bb-am-USD\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer Gauge\n    address outputTokenAddress = stable; // usdc\n    address pool = inputToken; // use own for swap\n    testBalancerSwapLiquidator(amount, lpTokenWhale, inputToken, outputTokenAddress, pool);\n  }\n\n  function testSwapWmaticStMatic() public fork(POLYGON_MAINNET) {\n    uint256 amount = 1000e18;\n    address pool = 0x8159462d255C1D24915CB51ec361F700174cD994; // wmatic-stmatic\n    address inputToken = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270; // wmatic\n    address inputTokenWhale = 0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97; // aave wmatic\n    address outputToken = 0x3A58a54C066FdC0f2D55FC9C89F0415C92eBf3C4; // stmatic\n\n    testBalancerSwapLiquidator(amount, inputTokenWhale, inputToken, outputToken, pool);\n  }\n}\n"
    },
    "contracts/test/liquidators/CurveLpTokenLiquidatorNoRegistryTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { CurveLpTokenLiquidatorNoRegistry, CurveLpTokenWrapper } from \"../../liquidators/CurveLpTokenLiquidatorNoRegistry.sol\";\nimport { CurveLpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\nimport { CurveV2LpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract CurveLpTokenLiquidatorNoRegistryTest is BaseTest {\n  CurveLpTokenLiquidatorNoRegistry private liquidator;\n\n  IERC20Upgradeable twobrl = IERC20Upgradeable(0x1B6E11c5DB9B15DE87714eA9934a6c52371CfEA9);\n  IERC20Upgradeable lpToken3Eps = IERC20Upgradeable(0xaF4dE8E872131AE328Ce21D909C74705d3Aaf452);\n\n  address pool3Eps = 0x160CAed03795365F3A589f10C379FfA7d75d4E76;\n  address pool2Brl = 0xad51e40D8f255dba1Ad08501D6B1a6ACb7C188f3;\n\n  CurveLpTokenPriceOracleNoRegistry curveV1Oracle;\n  CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle;\n\n  IERC20Upgradeable bUSD;\n  address wtoken;\n\n  function afterForkSetUp() internal override {\n    wtoken = ap.getAddress(\"wtoken\");\n    liquidator = new CurveLpTokenLiquidatorNoRegistry();\n    bUSD = IERC20Upgradeable(ap.getAddress(\"bUSD\"));\n    curveV1Oracle = CurveLpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\"));\n    curveV2Oracle = CurveV2LpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveV2LpTokenPriceOracleNoRegistry\"));\n  }\n\n  function testRedeemToken() public fork(BSC_MAINNET) {\n    address lpTokenWhale = 0x8D7408C2b3154F9f97fc6dd24cd36143908d1E52;\n    vm.prank(lpTokenWhale);\n    lpToken3Eps.transfer(address(liquidator), 1234);\n\n    bytes memory data = abi.encode(bUSD, wtoken, curveV1Oracle);\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(lpToken3Eps, 1234, data);\n\n    assertEq(address(outputToken), address(bUSD), \"!outputToken\");\n    assertGt(outputAmount, 0, \"!outputAmount>0\");\n    assertEq(outputToken.balanceOf(address(liquidator)), outputAmount, \"!outputAmount\");\n  }\n\n  function testRedeem2Brl() public fork(BSC_MAINNET) {\n    address jbrl = 0x316622977073BBC3dF32E7d2A9B3c77596a0a603;\n    address whale2brl = 0x6219b46d6a5B5BfB4Ec433a9F96DB3BF4076AEE1;\n    vm.prank(whale2brl);\n    twobrl.transfer(address(liquidator), 123456);\n\n    address poolOf2Brl = curveV1Oracle.poolOf(address(twobrl)); // 0xad51e40D8f255dba1Ad08501D6B1a6ACb7C188f3\n\n    require(poolOf2Brl != address(0), \"could not find the pool for 2brl\");\n\n    bytes memory data = abi.encode(jbrl, wtoken, curveV1Oracle);\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(twobrl, 123456, data);\n    assertEq(address(outputToken), jbrl);\n    assertGt(outputAmount, 0);\n    assertEq(outputToken.balanceOf(address(liquidator)), outputAmount);\n  }\n\n  address maiAddress = 0xa3Fa99A148fA48D14Ed51d610c367C61876997F1;\n  address whaleMai = 0xC63c477465a792537D291ADb32Ed15c0095E106B;\n  address whaleMai3Crv = 0x96c62EC93c552b60d2a7F0801313A29E4B8feecE;\n  address mai3Crv = 0x447646e84498552e62eCF097Cc305eaBFFF09308;\n  IERC20Upgradeable mai3CrvToken = IERC20Upgradeable(mai3Crv);\n\n  // Not set up / deployed\n  // function testRedeemMai3Crv() public fork(POLYGON_MAINNET) {\n  //   vm.prank(whaleMai3Crv);\n  //   mai3Crv.transfer(address(liquidator), 1.23456e18);\n\n  //   bytes memory data = abi.encode(maiAddress, wtoken, curveV1Oracle);\n  //   (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(mai3Crv, 1.23456e18, data);\n  //   assertEq(address(outputToken), maiAddress);\n  //   assertGt(outputAmount, 0);\n  //   assertEq(outputToken.balanceOf(address(liquidator)), outputAmount);\n  // }\n\n  function testCurveLpTokenWrapper() public fork(POLYGON_MAINNET) {\n    IERC20Upgradeable mai = IERC20Upgradeable(maiAddress);\n    CurveLpTokenWrapper wrapper = new CurveLpTokenWrapper();\n    vm.prank(whaleMai);\n    mai.transfer(address(wrapper), 1e18);\n\n    wrapper.redeem(mai, 1e18, abi.encode(mai3Crv, mai3Crv));\n\n    assertGt(mai3CrvToken.balanceOf(address(wrapper)), 0, \"!wrapped\");\n    assertEq(mai.balanceOf(address(wrapper)), 0, \"!unused mai\");\n  }\n\n  function test3CrvWrapMai3Crv() public fork(POLYGON_MAINNET) {\n    address threeCrvWhale = 0x7117de93b352AE048925323F3fCb1Cd4b4d52eC4;\n    address threeCrvAddress = 0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171;\n\n    IERC20Upgradeable threeCrv = IERC20Upgradeable(threeCrvAddress);\n\n    CurveLpTokenWrapper wrapper = new CurveLpTokenWrapper();\n    vm.prank(threeCrvWhale);\n    threeCrv.transfer(address(wrapper), 1e18);\n\n    wrapper.redeem(threeCrv, 1e18, abi.encode(mai3Crv, mai3Crv)); // pool = token\n\n    assertGt(mai3CrvToken.balanceOf(address(wrapper)), 0, \"!wrapped\");\n    assertEq(threeCrv.balanceOf(address(wrapper)), 0, \"!unused 3Crv\");\n  }\n}\n"
    },
    "contracts/test/liquidators/CurveSwapLiquidatorTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ICurvePool } from \"../../external/curve/ICurvePool.sol\";\nimport { CurveSwapLiquidatorFunder } from \"../../liquidators/CurveSwapLiquidatorFunder.sol\";\n\nimport { CurveLpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\nimport { CurveV2LpTokenPriceOracleNoRegistry } from \"../../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract CurveSwapLiquidatorTest is BaseTest {\n  CurveSwapLiquidatorFunder private csl;\n  address private maiAddress = 0x3F56e0c36d275367b8C502090EDF38289b3dEa0d;\n  address private val3EPSAddress = 0x5b5bD8913D766D005859CE002533D4838B0Ebbb5;\n\n  address private lpTokenMai3EPS = 0x80D00D2c8d920a9253c3D65BA901250a55011b37;\n  address private poolAddress = 0x68354c6E8Bbd020F9dE81EAf57ea5424ba9ef322;\n\n  CurveLpTokenPriceOracleNoRegistry curveV1Oracle;\n  CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle;\n\n  function afterForkSetUp() internal override {\n    csl = new CurveSwapLiquidatorFunder();\n    curveV1Oracle = CurveLpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveLpTokenPriceOracleNoRegistry\"));\n    curveV2Oracle = CurveV2LpTokenPriceOracleNoRegistry(ap.getAddress(\"CurveV2LpTokenPriceOracleNoRegistry\"));\n\n    if (address(curveV1Oracle) == address(0)) {\n      address[][] memory _poolUnderlyings = new address[][](1);\n      _poolUnderlyings[0] = asArray(maiAddress, val3EPSAddress);\n      curveV1Oracle = new CurveLpTokenPriceOracleNoRegistry();\n      curveV1Oracle.initialize(asArray(lpTokenMai3EPS), asArray(poolAddress), _poolUnderlyings);\n    }\n  }\n\n  // Curve pools need to be configured in the CurveV1 or CurveV2 oracles\n  // We have not deployed CurveV2 oracle yet\n  function testSwapCurveV1UsdtUsdc() public debuggingOnly fork(ARBITRUM_ONE) {\n    address usdtAddress = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n    address usdcAddress = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n    address usdtWhale = 0xB38e8c17e38363aF6EbdCb3dAE12e0243582891D; // binance\n\n    IERC20Upgradeable inputToken = IERC20Upgradeable(usdtAddress);\n    uint256 inputAmount = 150e6;\n\n    bytes memory data = abi.encode(curveV1Oracle, curveV2Oracle, usdtAddress, usdcAddress, ap.getAddress(\"wtoken\"));\n\n    vm.prank(usdtWhale);\n    inputToken.transfer(address(csl), inputAmount);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = csl.redeem(inputToken, inputAmount, data);\n\n    assertEq(address(outputToken), usdcAddress, \"output token does not match\");\n    assertApproxEqAbs(outputAmount, inputAmount, 1e5, \"output amount does not match\");\n  }\n\n  function testSwapCurveV2EspBnbxBnb() public fork(BSC_MAINNET) {\n    address bnbxAddress = 0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275;\n    address wbnb = ap.getAddress(\"wtoken\");\n    address bnbxWhale = 0x4eE98B27eeF58844E460922eC9Da7C05D32F284A;\n\n    IERC20Upgradeable inputToken = IERC20Upgradeable(bnbxAddress);\n    uint256 inputAmount = 3e18;\n\n    bytes memory data = abi.encode(curveV1Oracle, curveV2Oracle, bnbxAddress, wbnb, wbnb);\n\n    vm.prank(bnbxWhale);\n    inputToken.transfer(address(csl), inputAmount);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = csl.redeem(inputToken, inputAmount, data);\n\n    assertEq(address(outputToken), wbnb, \"output token does not match\");\n    assertApproxEqRel(outputAmount, inputAmount, 8e16, \"output amount does not match\");\n  }\n\n  function testRedeemMAI() public fork(BSC_MAINNET) {\n    ICurvePool curvePool = ICurvePool(poolAddress);\n\n    assertEq(maiAddress, curvePool.coins(0), \"coin 0 must be MAI\");\n    assertEq(val3EPSAddress, curvePool.coins(1), \"coin 1 must be val3EPS\");\n\n    uint256 inputAmount = 1e10;\n\n    uint256 maiForVal3EPS = curvePool.get_dy(0, 1, inputAmount);\n    emit log_uint(maiForVal3EPS);\n\n    dealMai(address(csl), inputAmount);\n\n    bytes memory data = abi.encode(curveV1Oracle, address(0), maiAddress, val3EPSAddress, ap.getAddress(\"wtoken\"));\n    (IERC20Upgradeable shouldBeVal3EPS, uint256 outputAmount) = csl.redeem(\n      IERC20Upgradeable(maiAddress),\n      inputAmount,\n      data\n    );\n    assertEq(address(shouldBeVal3EPS), val3EPSAddress, \"output token does not match\");\n\n    assertEq(maiForVal3EPS, outputAmount, \"output amount does not match\");\n  }\n\n  function testEstimateInputAmount() public fork(BSC_MAINNET) {\n    ICurvePool curvePool = ICurvePool(poolAddress);\n\n    assertEq(maiAddress, curvePool.coins(0), \"coin 0 must be MAI\");\n    assertEq(val3EPSAddress, curvePool.coins(1), \"coin 1 must be val3EPS\");\n\n    bytes memory data = abi.encode(curveV1Oracle, address(0), maiAddress, val3EPSAddress, ap.getAddress(\"wtoken\"));\n\n    (IERC20Upgradeable inputToken, uint256 inputAmount) = csl.estimateInputAmount(2e10, data);\n\n    emit log(\"input\");\n    emit log_uint(inputAmount);\n    emit log_address(address(inputToken));\n    uint256 shouldBeAround2e10 = curvePool.get_dy(1, 0, inputAmount);\n    emit log(\"should be around 2e10\");\n    emit log_uint(shouldBeAround2e10);\n    assertTrue(shouldBeAround2e10 >= 20e9 && shouldBeAround2e10 <= 23e9, \"rough estimate didn't work\");\n  }\n\n  function dealMai(address to, uint256 amount) internal {\n    address whale = 0xc412eCccaa35621cFCbAdA4ce203e3Ef78c4114a; // anyswap\n    vm.prank(whale);\n    IERC20Upgradeable(maiAddress).transfer(to, amount);\n  }\n}\n"
    },
    "contracts/test/liquidators/GammaLpTokenLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport { GammaAlgebraLpTokenLiquidator, GammaAlgebraLpTokenWrapper } from \"../../liquidators/gamma/GammaAlgebraLpTokenLiquidator.sol\";\nimport { GammaUniswapV3LpTokenLiquidator, GammaUniswapV3LpTokenWrapper } from \"../../liquidators/gamma/GammaUniswapV3LpTokenLiquidator.sol\";\nimport { IHypervisor } from \"../../external/gamma/IHypervisor.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract GammaLpTokenLiquidatorTest is BaseTest {\n  GammaAlgebraLpTokenLiquidator public aLiquidator;\n  GammaUniswapV3LpTokenLiquidator public uLiquidator;\n  GammaAlgebraLpTokenWrapper aWrapper;\n  GammaUniswapV3LpTokenWrapper uWrapper;\n\n  address uniV3SwapRouter;\n  address algebraSwapRouter;\n  address uniProxyAlgebra;\n  address uniProxyUni;\n  address wtoken;\n\n  function afterForkSetUp() internal override {\n    aLiquidator = new GammaAlgebraLpTokenLiquidator();\n    uLiquidator = new GammaUniswapV3LpTokenLiquidator();\n    aWrapper = new GammaAlgebraLpTokenWrapper();\n    uWrapper = new GammaUniswapV3LpTokenWrapper();\n    wtoken = ap.getAddress(\"wtoken\");\n    if (block.chainid == POLYGON_MAINNET) {\n      uniProxyAlgebra = 0xA42d55074869491D60Ac05490376B74cF19B00e6;\n      uniProxyUni = 0xDC8eE75f52FABF057ae43Bb4B85C55315b57186c;\n      uniV3SwapRouter = 0x1891783cb3497Fdad1F25C933225243c2c7c4102; // Retro\n      algebraSwapRouter = 0xf5b509bB0909a69B1c207E495f687a596C168E12; // QS\n    }\n  }\n\n  function testGammaUniswapV3LpTokenLiquidator() public fork(POLYGON_MAINNET) {\n    uint256 withdrawAmount = 1e18;\n\n    address WMATIC_WETH_RETRO_GAMMA_VAULT = 0xe7806B5ba13d4B2Ab3EaB3061cB31d4a4F3390Aa;\n    address WMATIC_WETH_RETRO_WHALE = 0xcb7c356b9287DeC7d36923238F53e6C955bfE778;\n\n    IHypervisor vault = IHypervisor(WMATIC_WETH_RETRO_GAMMA_VAULT);\n    vm.prank(WMATIC_WETH_RETRO_WHALE);\n    vault.transfer(address(uLiquidator), withdrawAmount);\n\n    address outputTokenAddress = ap.getAddress(\"wtoken\"); // WMATIC\n    bytes memory strategyData = abi.encode(outputTokenAddress, uniV3SwapRouter);\n    (, uint256 outputAmount) = uLiquidator.redeem(vault, withdrawAmount, strategyData);\n\n    emit log_named_uint(\"wmatic redeemed\", outputAmount);\n    assertGt(outputAmount, 0, \"!failed to withdraw and swap\");\n  }\n\n  function testGammaAlgebraLpTokenLiquidator() public fork(POLYGON_MAINNET) {\n    uint256 withdrawAmount = 1e18;\n    address DAI_GNS_QS_GAMMA_VAULT = 0x7aE7FB44c92B4d41abB6E28494f46a2EB3c2a690;\n    address DAI_GNS_QS_WHALE = 0x20ec0d06F447d550fC6edee42121bc8C1817b97D;\n\n    IHypervisor vault = IHypervisor(DAI_GNS_QS_GAMMA_VAULT);\n    vm.prank(DAI_GNS_QS_WHALE);\n    vault.transfer(address(aLiquidator), withdrawAmount);\n\n    address outputTokenAddress = ap.getAddress(\"wtoken\"); // WMATIC\n    bytes memory strategyData = abi.encode(outputTokenAddress, algebraSwapRouter);\n    (, uint256 outputAmount) = aLiquidator.redeem(vault, withdrawAmount, strategyData);\n\n    emit log_named_uint(\"wbnb redeemed\", outputAmount);\n    assertGt(outputAmount, 0, \"!failed to withdraw and swap\");\n  }\n\n  function testGammaLpTokenWrapperWmatic() public fork(POLYGON_MAINNET) {\n    address WMATIC_WETH_QS_GAMMA_VAULT = 0x02203f2351E7aC6aB5051205172D3f772db7D814;\n    IHypervisor vault = IHypervisor(WMATIC_WETH_QS_GAMMA_VAULT);\n    address wtokenWhale = 0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97;\n    address wethAddress = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;\n\n    vm.prank(wtokenWhale);\n    IERC20Upgradeable(wtoken).transfer(address(aWrapper), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = aWrapper.redeem(\n      IERC20Upgradeable(wtoken),\n      1e18,\n      abi.encode(algebraSwapRouter, uniProxyAlgebra, vault)\n    );\n\n    emit log_named_uint(\"lp tokens minted\", outputAmount);\n\n    assertGt(outputToken.balanceOf(address(aWrapper)), 0, \"!wrapped\");\n    assertEq(IERC20Upgradeable(wtoken).balanceOf(address(aWrapper)), 0, \"!unused wtoken\");\n    assertEq(IERC20Upgradeable(wethAddress).balanceOf(address(aWrapper)), 0, \"!unused usdt\");\n  }\n\n  function testGammaLpTokenWrapperUsdt() public fork(POLYGON_MAINNET) {\n    address ETH_USDT_QS_GAMMA_VAULT = 0x5928f9f61902b139e1c40cBa59077516734ff09f; // Wide\n    IHypervisor vault = IHypervisor(ETH_USDT_QS_GAMMA_VAULT);\n    address usdtAddress = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\n    address usdtWhale = 0x0639556F03714A74a5fEEaF5736a4A64fF70D206;\n    IERC20Upgradeable usdt = IERC20Upgradeable(usdtAddress);\n\n    vm.prank(usdtWhale);\n    usdt.transfer(address(aWrapper), 1e6);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = aWrapper.redeem(\n      usdt,\n      1e6,\n      abi.encode(algebraSwapRouter, uniProxyAlgebra, vault)\n    );\n\n    emit log_named_uint(\"lp tokens minted\", outputAmount);\n\n    assertGt(outputToken.balanceOf(address(aWrapper)), 0, \"!wrapped\");\n    assertEq(IERC20Upgradeable(wtoken).balanceOf(address(aWrapper)), 0, \"!unused wtoken\");\n    assertEq(usdt.balanceOf(address(aWrapper)), 0, \"!unused usdt\");\n  }\n\n  function testGammaUniV3LpTokenWrapper() public fork(POLYGON_MAINNET) {\n    address USDC_CASH_GAMMA_VAULT = 0x64e14623CA543b540d0bA80477977f7c2c00a7Ea;\n    IHypervisor vault = IHypervisor(USDC_CASH_GAMMA_VAULT);\n    address usdcAddress = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n    address usdcWhale = 0xe7804c37c13166fF0b37F5aE0BB07A3aEbb6e245;\n    IERC20Upgradeable usdc = IERC20Upgradeable(usdcAddress);\n\n    vm.prank(usdcWhale);\n    usdc.transfer(address(uWrapper), 1e6);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = uWrapper.redeem(\n      usdc,\n      1e6,\n      abi.encode(uniV3SwapRouter, uniProxyUni, vault)\n    );\n\n    emit log_named_uint(\"lp tokens minted\", outputAmount);\n\n    assertGt(outputToken.balanceOf(address(uWrapper)), 0, \"!wrapped\");\n    assertEq(IERC20Upgradeable(wtoken).balanceOf(address(uWrapper)), 0, \"!unused wtoken\");\n    assertEq(usdc.balanceOf(address(uWrapper)), 0, \"!unused usdc\");\n  }\n\n  function testUsdcWethGammaUniV3LpTokenWrapper() public debuggingOnly fork(POLYGON_MAINNET) {\n    address USDC_WETH_RETRO_GAMMA_VAULT = 0xe058e1FfFF9B13d3FCd4803FDb55d1Cc2fe07DDC;\n    address usdcAddress = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n    address usdcWhale = 0xe7804c37c13166fF0b37F5aE0BB07A3aEbb6e245;\n    IERC20Upgradeable usdc = IERC20Upgradeable(usdcAddress);\n\n    vm.prank(usdcWhale);\n    usdc.transfer(address(uWrapper), 9601.830212e6);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = uWrapper.redeem(\n      usdc,\n      9601.830212e6,\n      abi.encode(uniV3SwapRouter, uniProxyUni, USDC_WETH_RETRO_GAMMA_VAULT)\n    );\n\n    emit log_named_uint(\"lp tokens minted\", outputAmount);\n\n    assertGt(outputToken.balanceOf(address(uWrapper)), 0, \"!wrapped\");\n    assertEq(IERC20Upgradeable(wtoken).balanceOf(address(uWrapper)), 0, \"!unused wtoken\");\n    assertEq(usdc.balanceOf(address(uWrapper)), 0, \"!unused usdc\");\n  }\n}\n"
    },
    "contracts/test/liquidators/IonicLiquidatorTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\n\nimport { IonicLiquidator, ILiquidator } from \"../../IonicLiquidator.sol\";\nimport { IonicUniV3Liquidator } from \"../../IonicUniV3Liquidator.sol\";\nimport { ICurvePool } from \"../../external/curve/ICurvePool.sol\";\nimport { CurveSwapLiquidatorFunder } from \"../../liquidators/CurveSwapLiquidatorFunder.sol\";\nimport { UniswapV3LiquidatorFunder } from \"../../liquidators/UniswapV3LiquidatorFunder.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport \"../../external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol\";\nimport { AuthoritiesRegistry } from \"../../ionic/AuthoritiesRegistry.sol\";\nimport { LiquidatorsRegistrySecondExtension } from \"../../liquidators/registry/LiquidatorsRegistrySecondExtension.sol\";\nimport \"../../liquidators/registry/LiquidatorsRegistryExtension.sol\";\nimport { Unitroller } from \"../../compound/Unitroller.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport { UpgradesBaseTest } from \"../UpgradesBaseTest.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { ProxyAdmin } from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport { PoolLens } from \"../../PoolLens.sol\";\n\ncontract MockRedemptionStrategy is IRedemptionStrategy {\n  function redeem(\n    IERC20Upgradeable,\n    uint256,\n    bytes memory\n  ) external returns (IERC20Upgradeable, uint256) {\n    return (IERC20Upgradeable(address(0)), 1);\n  }\n\n  function name() public pure returns (string memory) {\n    return \"MockRedemptionStrategy\";\n  }\n}\n\ncontract IonicLiquidatorTest is UpgradesBaseTest {\n  ILiquidator liquidator;\n  address uniswapRouter;\n  address swapRouter;\n  IUniswapV3Quoter quoter;\n  address usdcWhale;\n  address wethWhale;\n  address poolAddress;\n  address uniV3PooForFlash;\n  uint256 usdcMarketIndex;\n  uint256 wethMarketIndex;\n\n  AuthoritiesRegistry authRegistry;\n  ILiquidatorsRegistry liquidatorsRegistry;\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    if (block.chainid == BSC_MAINNET) {\n      uniswapRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    } else if (block.chainid == POLYGON_MAINNET) {\n      uniswapRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\n      swapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n      quoter = IUniswapV3Quoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n      usdcWhale = 0x625E7708f30cA75bfd92586e17077590C60eb4cD; // aave reserve\n      wethWhale = 0x1eED63EfBA5f81D95bfe37d82C8E736b974F477b;\n      poolAddress = 0x22A705DEC988410A959B8b17C8c23E33c121580b; // Retro stables pool\n      uniV3PooForFlash = 0xA374094527e1673A86dE625aa59517c5dE346d32; // usdc-wmatic\n      usdcMarketIndex = 3;\n      wethMarketIndex = 5;\n    } else if (block.chainid == MODE_MAINNET) {\n      uniswapRouter = 0x5D61c537393cf21893BE619E36fC94cd73C77DD3; // kim router\n      //      uniswapRouter = 0xC9Adff795f46105E53be9bbf14221b1C9919EE25; // sup router\n      //      swapRouter = 0xC9Adff795f46105E53be9bbf14221b1C9919EE25; // sup router\n      swapRouter = 0x5D61c537393cf21893BE619E36fC94cd73C77DD3; // kim router\n      //quoter = IUniswapV3Quoter(0x7Fd569b2021850fbA53887dd07736010aCBFc787); // other sup quoter?\n      quoter = IUniswapV3Quoter(0x5E6AEbab1AD525f5336Bd12E6847b851531F72ba); // sup quoter\n      usdcWhale = 0x34b83A3759ba4c9F99c339604181bf6bBdED4C79; // vault\n      wethWhale = 0xF4C85269240C1D447309fA602A90ac23F1CB0Dc0;\n      poolAddress = 0xFB3323E24743Caf4ADD0fDCCFB268565c0685556;\n      //uniV3PooForFlash = 0x293f2B2c17f8cEa4db346D87Ef5712C9dd0491EF; // kim weth-usdc pool\n      uniV3PooForFlash = 0x047CF4b081ee80d2928cb2ce3F3C4964e26eB0B9; // kim usdt-usdc pool\n      //      uniV3PooForFlash = 0xf2e9C024F1C0B7a2a4ea11243C2D86A7b38DD72f; // sup univ2 0x34a1E3Db82f669f8cF88135422AfD80e4f70701A\n      usdcMarketIndex = 1;\n      wethMarketIndex = 0;\n      // weth 0x4200000000000000000000000000000000000006\n      // usdc 0xd988097fb8612cc24eeC14542bC03424c656005f\n    }\n\n    //    vm.prank(ap.owner());\n    //    ap.setAddress(\"IUniswapV2Router02\", uniswapRouter);\n    vm.prank(ap.owner());\n    ap.setAddress(\"UNISWAP_V3_ROUTER\", uniswapRouter);\n\n    authRegistry = AuthoritiesRegistry(ap.getAddress(\"AuthoritiesRegistry\"));\n    liquidatorsRegistry = ILiquidatorsRegistry(ap.getAddress(\"LiquidatorsRegistry\"));\n    liquidator = IonicLiquidator(payable(ap.getAddress(\"IonicLiquidator\")));\n  }\n\n  function upgradeRegistry() internal {\n    DiamondBase asBase = DiamondBase(address(liquidatorsRegistry));\n    address[] memory exts = asBase._listExtensions();\n    LiquidatorsRegistryExtension newExt1 = new LiquidatorsRegistryExtension();\n    LiquidatorsRegistrySecondExtension newExt2 = new LiquidatorsRegistrySecondExtension();\n    vm.prank(SafeOwnable(address(liquidatorsRegistry)).owner());\n    asBase._registerExtension(newExt1, DiamondExtension(exts[0]));\n    vm.prank(SafeOwnable(address(liquidatorsRegistry)).owner());\n    asBase._registerExtension(newExt2, DiamondExtension(exts[1]));\n  }\n\n  function testBsc() public fork(BSC_MAINNET) {\n    testUpgrade();\n  }\n\n  function testPolygon() public fork(POLYGON_MAINNET) {\n    testUpgrade();\n  }\n\n  function testUpgrade() internal {\n    // in case these slots start to get used, please redeploy the FSL\n    // with a larger storage gap to protect the owner variable of OwnableUpgradeable\n    // from being overwritten by the IonicLiquidator storage\n    for (uint256 i = 40; i < 51; i++) {\n      address atSloti = address(uint160(uint256(vm.load(address(liquidator), bytes32(i)))));\n      assertEq(\n        atSloti,\n        address(0),\n        \"replace the FSL proxy/storage contract with a new one before the owner variable is overwritten\"\n      );\n    }\n  }\n\n  function testSpecificLiquidation() public debuggingOnly fork(MODE_MAINNET) {\n    address borrower = 0x5834a3AAFA83A53822B313994Bb554d8E8c215dF;\n    address debtMarketAddr = 0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2;\n    address collateralMarketAddr = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n\n    liquidator = ILiquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n\n    ILiquidator.LiquidateToTokensWithFlashSwapVars memory vars;\n    vars.borrower = borrower;\n    vars.cErc20 = ICErc20(debtMarketAddr);\n    vars.cTokenCollateral = ICErc20(collateralMarketAddr);\n    vars.repayAmount = 0x408c7a4d7c4092;\n    vars.flashSwapContract = 0x468cC91dF6F669CaE6cdCE766995Bd7874052FBc;\n    vars.minProfitAmount = 0;\n    vars.redemptionStrategies = new IRedemptionStrategy[](1);\n    vars.strategyData = new bytes[](1);\n    vars.debtFundingStrategies = new IFundsConversionStrategy[](0);\n    vars.debtFundingStrategiesData = new bytes[](0);\n\n    vars.redemptionStrategies[0] = IFundsConversionStrategy(0x5cA3fd2c285C4138185Ef1BdA7573D415020F3C8);\n    vars.strategyData[\n        0\n      ] = hex\"0000000000000000000000004200000000000000000000000000000000000006000000000000000000000000ac48fcf1049668b285f3dc72483df5ae2162f7e8\";\n\n    liquidator.safeLiquidateToTokensWithFlashLoan(vars);\n  }\n\n  function testWithdrawalLiquidator() public debuggingOnly fork(MODE_MAINNET) {\n    TransparentUpgradeableProxy proxyV3 = TransparentUpgradeableProxy(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    IonicUniV3Liquidator implV3 = new IonicUniV3Liquidator();\n    IonicUniV3Liquidator liquidatorV3 = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    ProxyAdmin proxyAdmin = ProxyAdmin(ap.getAddress(\"DefaultProxyAdmin\"));\n\n    vm.startPrank(proxyAdmin.owner());\n    proxyAdmin.upgrade(proxyV3, address(implV3));\n    vm.stopPrank();\n\n    vm.prank(0x4200000000000000000000000000000000000016);\n    (bool success, ) = address(liquidatorV3).call{ value: 1 ether }(\"\");\n    require(success, \"transfer of funds failed\");\n\n    uint256 beforeBalance = liquidatorV3.owner().balance;\n\n    vm.prank(liquidatorV3.owner());\n    liquidatorV3.withdrawAll();\n\n    emit log_named_uint(\"balance of liquidator\", liquidatorV3.owner().balance);\n\n    assertEq(liquidatorV3.owner().balance, beforeBalance + 1 ether);\n    assertEq(address(liquidatorV3).balance, 0);\n  }\n\n  function testLiquidateAfterUpgradeLiquidator() public debuggingOnly forkAtBlock(MODE_MAINNET, 9382006) {\n    // upgrade IonicLiquidator\n    TransparentUpgradeableProxy proxyV3 = TransparentUpgradeableProxy(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    IonicUniV3Liquidator implV3 = new IonicUniV3Liquidator();\n    IonicUniV3Liquidator liquidatorV3 = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    PoolLens lens = PoolLens(0x70BB19a56BfAEc65aE861E6275A90163AbDF36a6);\n\n    ProxyAdmin proxyAdmin = ProxyAdmin(ap.getAddress(\"DefaultProxyAdmin\"));\n\n    vm.startPrank(proxyAdmin.owner());\n    proxyAdmin.upgrade(proxyV3, address(implV3));\n    vm.stopPrank();\n\n    vm.startPrank(0x1155b614971f16758C92c4890eD338C9e3ede6b7);\n    liquidatorV3.setPoolLens(address(lens));\n    liquidatorV3.setHealthFactorThreshold(1e18);\n    vm.stopPrank();\n\n    IonicComptroller pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n    (, , uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d);\n    emit log_named_uint(\"liquidity\", liquidity);\n    emit log_named_uint(\"shortfall\", shortfall);\n\n    uint256 healthFactor = lens.getHealthFactor(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d, pool);\n    emit log_named_uint(\"hf before\", healthFactor);\n\n    ILiquidator.LiquidateToTokensWithFlashSwapVars memory vars = ILiquidator.LiquidateToTokensWithFlashSwapVars({\n      borrower: 0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d,\n      repayAmount: 1134537086250983,\n      cErc20: ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2),\n      cTokenCollateral: ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2),\n      flashSwapContract: 0x468cC91dF6F669CaE6cdCE766995Bd7874052FBc,\n      minProfitAmount: 0,\n      redemptionStrategies: new IRedemptionStrategy[](0),\n      strategyData: new bytes[](0),\n      debtFundingStrategies: new IFundsConversionStrategy[](0),\n      debtFundingStrategiesData: new bytes[](0)\n    });\n    liquidatorV3.safeLiquidateToTokensWithFlashLoan(vars);\n\n    uint256 healthFactorAfter = lens.getHealthFactor(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d, pool);\n    emit log_named_uint(\"hf after\", healthFactorAfter);\n  }\n\n  function testLiquidateAfterUpgradeLiquidatorExpressRelay() public debuggingOnly forkAtBlock(MODE_MAINNET, 9382006) {\n    // upgrade IonicLiquidator\n    TransparentUpgradeableProxy proxyV3 = TransparentUpgradeableProxy(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    IonicUniV3Liquidator implV3 = new IonicUniV3Liquidator();\n    IonicUniV3Liquidator liquidatorV3 = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n    PoolLens lens = PoolLens(0x70BB19a56BfAEc65aE861E6275A90163AbDF36a6);\n    address expressRelay = makeAddr(\"expressRelay\");\n\n    ProxyAdmin proxyAdmin = ProxyAdmin(ap.getAddress(\"DefaultProxyAdmin\"));\n\n    vm.startPrank(proxyAdmin.owner());\n    proxyAdmin.upgrade(proxyV3, address(implV3));\n    vm.stopPrank();\n\n    vm.startPrank(0x1155b614971f16758C92c4890eD338C9e3ede6b7);\n    liquidatorV3.setPoolLens(address(lens));\n    liquidatorV3.setHealthFactorThreshold(95e16);\n    liquidatorV3.setExpressRelay(expressRelay);\n    vm.stopPrank();\n\n    IonicComptroller pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n    (, , uint256 liquidity, uint256 shortfall) = pool.getAccountLiquidity(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d);\n    emit log_named_uint(\"liquidity\", liquidity);\n    emit log_named_uint(\"shortfall\", shortfall);\n\n    uint256 healthFactor = lens.getHealthFactor(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d, pool);\n    emit log_named_uint(\"hf before\", healthFactor);\n\n    address borrower = address(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d);\n\n    ILiquidator.LiquidateToTokensWithFlashSwapVars memory vars = ILiquidator.LiquidateToTokensWithFlashSwapVars({\n      borrower: borrower,\n      repayAmount: 1134537086250983,\n      cErc20: ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2),\n      cTokenCollateral: ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2),\n      flashSwapContract: 0x468cC91dF6F669CaE6cdCE766995Bd7874052FBc,\n      minProfitAmount: 0,\n      redemptionStrategies: new IRedemptionStrategy[](0),\n      strategyData: new bytes[](0),\n      debtFundingStrategies: new IFundsConversionStrategy[](0),\n      debtFundingStrategiesData: new bytes[](0)\n    });\n\n    vm.mockCall(\n      expressRelay, \n      abi.encodeWithSelector(bytes4(keccak256(\"isPermissioned(address,bytes)\")), address(liquidatorV3), abi.encode(borrower)),\n      abi.encode(false)  \n    );\n    vm.expectRevert(\"invalid liquidation\");\n    liquidatorV3.safeLiquidateToTokensWithFlashLoan(vars);\n\n    vm.mockCall(\n      expressRelay, \n      abi.encodeWithSelector(bytes4(keccak256(\"isPermissioned(address,bytes)\")), address(liquidatorV3), abi.encode(borrower)),\n      abi.encode(true)  \n    );\n    liquidatorV3.safeLiquidateToTokensWithFlashLoan(vars);\n\n    uint256 healthFactorAfter = lens.getHealthFactor(0x92eA6902C5023CC632e3Fd84dE7CcA6b98FE853d, pool);\n    emit log_named_uint(\"hf after\", healthFactorAfter);\n  }\n\n  // TODO test with marginal shortfall for liquidation penalty errors\n  function _testLiquidatorLiquidate(address contractForFlashSwap) internal {\n    IonicComptroller pool = IonicComptroller(poolAddress);\n    //    _upgradePoolWithExtension(Unitroller(payable(poolAddress)));\n    //upgradeRegistry();\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    ICErc20 usdcMarket = markets[usdcMarketIndex];\n    IERC20Upgradeable usdc = IERC20Upgradeable(usdcMarket.underlying());\n    ICErc20 wethMarket = markets[wethMarketIndex];\n    IERC20Upgradeable weth = IERC20Upgradeable(wethMarket.underlying());\n    {\n      emit log_named_address(\"usdc market\", address(usdcMarket));\n      emit log_named_address(\"weth market\", address(wethMarket));\n      emit log_named_address(\"usdc underlying\", usdcMarket.underlying());\n      emit log_named_address(\"weth underlying\", wethMarket.underlying());\n      vm.prank(pool.admin());\n      pool._setBorrowCapForCollateral(address(usdcMarket), address(wethMarket), 1e36);\n    }\n\n    {\n      vm.prank(pool.admin());\n      pool._borrowCapWhitelist(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038, address(this), true);\n    }\n\n    {\n      vm.prank(wethWhale);\n      weth.transfer(address(this), 0.1e18);\n\n      weth.approve(address(wethMarket), 1e36);\n      require(wethMarket.mint(0.1e18) == 0, \"mint weth failed\");\n      pool.enterMarkets(asArray(address(usdcMarket), address(wethMarket)));\n    }\n\n    {\n      vm.startPrank(usdcWhale);\n      usdc.approve(address(usdcMarket), 2e36);\n      require(usdcMarket.mint(70e6) == 0, \"mint usdc failed\");\n      vm.stopPrank();\n    }\n\n    {\n      require(usdcMarket.borrow(50e6) == 0, \"borrow usdc failed\");\n\n      // the collateral prices change\n      BasePriceOracle mpo = pool.oracle();\n      uint256 priceCollateral = mpo.getUnderlyingPrice(wethMarket);\n      vm.mockCall(\n        address(mpo),\n        abi.encodeWithSelector(mpo.getUnderlyingPrice.selector, wethMarket),\n        abi.encode(priceCollateral / 10)\n      );\n    }\n\n    (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData) = liquidatorsRegistry\n      .getRedemptionStrategies(weth, usdc);\n\n    uint256 seizedAmount = liquidator.safeLiquidateToTokensWithFlashLoan(\n      ILiquidator.LiquidateToTokensWithFlashSwapVars({\n        borrower: address(this),\n        repayAmount: 10e6,\n        cErc20: usdcMarket,\n        cTokenCollateral: wethMarket,\n        flashSwapContract: contractForFlashSwap,\n        minProfitAmount: 6,\n        redemptionStrategies: strategies,\n        strategyData: strategiesData,\n        debtFundingStrategies: new IFundsConversionStrategy[](0),\n        debtFundingStrategiesData: new bytes[](0)\n      })\n    );\n\n    emit log_named_uint(\"seized amount\", seizedAmount);\n    require(seizedAmount > 0, \"didn't seize any assets\");\n  }\n}\n"
    },
    "contracts/test/liquidators/JarvisLiquidatorFunderTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { JarvisLiquidatorFunder } from \"../../liquidators/JarvisLiquidatorFunder.sol\";\nimport { IonicLiquidator, ILiquidator } from \"../../IonicLiquidator.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport { IUniswapV2Factory } from \"../../external/uniswap/IUniswapV2Factory.sol\";\nimport { IComptroller } from \"../../external/compound/IComptroller.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ISynthereumLiquidityPool } from \"../../external/jarvis/ISynthereumLiquidityPool.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\nimport { IUniswapV2Router02 } from \"../../external/uniswap/IUniswapV2Router02.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ninterface IMockERC20 is IERC20Upgradeable {\n  function mint(address _address, uint256 amount) external;\n}\n\ncontract JarvisLiquidatorFunderTest is BaseTest {\n  JarvisLiquidatorFunder private jarvisLiquidator;\n\n  ISynthereumLiquidityPool synthereumLiquidityPool =\n    ISynthereumLiquidityPool(0x0fD8170Dc284CD558325029f6AEc1538c7d99f49);\n\n  address minter = 0x0fD8170Dc284CD558325029f6AEc1538c7d99f49;\n  IMockERC20 jBRLToken = IMockERC20(0x316622977073BBC3dF32E7d2A9B3c77596a0a603);\n\n  IERC20Upgradeable bUSD;\n\n  function afterForkSetUp() internal override {\n    uint64 expirationPeriod = 60 * 40; // 40 mins\n    bUSD = IERC20Upgradeable(ap.getAddress(\"bUSD\")); // TODO check if bUSD == stableToken at AP\n\n    ISynthereumLiquidityPool[] memory pools = new ISynthereumLiquidityPool[](1);\n    pools[0] = synthereumLiquidityPool;\n    uint256[] memory times = new uint256[](1);\n    times[0] = expirationPeriod;\n\n    jarvisLiquidator = new JarvisLiquidatorFunder();\n  }\n\n  function testRedeemToken() public fork(BSC_MAINNET) {\n    vm.prank(minter);\n    jBRLToken.mint(address(jarvisLiquidator), 10e18);\n\n    bytes memory data = abi.encode(address(jBRLToken), address(synthereumLiquidityPool), 60 * 40);\n    (uint256 redeemableAmount, ) = synthereumLiquidityPool.getRedeemTradeInfo(10e18);\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = jarvisLiquidator.redeem(jBRLToken, 10e18, data);\n\n    // should be BUSD\n    assertEq(address(outputToken), address(bUSD));\n    assertEq(outputAmount, redeemableAmount);\n  }\n\n  function testEmergencyRedeemToken() public fork(BSC_MAINNET) {\n    ISynthereumLiquidityPool pool = synthereumLiquidityPool;\n    address manager = pool.synthereumFinder().getImplementationAddress(\"Manager\");\n    vm.prank(manager);\n    pool.emergencyShutdown();\n\n    vm.prank(minter);\n    jBRLToken.mint(address(jarvisLiquidator), 10e18);\n\n    bytes memory data = abi.encode(address(jBRLToken), address(synthereumLiquidityPool), 60 * 40);\n    (uint256 redeemableAmount, uint256 fee) = synthereumLiquidityPool.getRedeemTradeInfo(10e18);\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = jarvisLiquidator.redeem(jBRLToken, 10e18, data);\n\n    // should be BUSD\n    assertEq(address(outputToken), address(bUSD));\n    assertEq(outputAmount, redeemableAmount + fee);\n  }\n\n  struct LiquidationData {\n    address[] cTokens;\n    IRedemptionStrategy[] strategies;\n    bytes[] abis;\n    IonicLiquidator liquidator;\n    IFundsConversionStrategy[] fundingStrategies;\n    bytes[] data;\n  }\n\n  // TODO test with the latest block and contracts and/or without the FSL\n  function testJbrlLiquidation() public debuggingOnly forkAtBlock(BSC_MAINNET, 21700285) {\n    LiquidationData memory vars;\n    IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n    // setting up a new liquidator\n    //    vars.liquidator = IonicLiquidator(payable(0xc9C3D317E89f4390A564D56180bBB1842CF3c99C));\n    vars.liquidator = new IonicLiquidator();\n    vars.liquidator.initialize(ap.getAddress(\"wtoken\"), address(uniswapRouter), 25);\n\n    IComptroller comptroller = IComptroller(0x31d76A64Bc8BbEffb601fac5884372DEF910F044);\n\n    ICErc20 cTokenJBRL = ICErc20(0x82A3103bc306293227B756f7554AfAeE82F8ab7a);\n    ICErc20 cTokenBUSD = ICErc20(0xa7213deB44f570646Ea955771Cc7f39B58841363);\n\n    uint256 borrowAmount = 1e21;\n    address accountOne = address(10001);\n    address accountTwo = address(20002);\n\n    // Account One supply JBRL\n    dealJBRL(accountOne, 10e12);\n    // Account One supply BUSD\n    dealBUSD(accountOne, 10e21);\n\n    // Account One deposit BUSD\n    vm.startPrank(accountOne);\n    {\n      vars.cTokens = new address[](2);\n      vars.cTokens[0] = address(cTokenJBRL);\n      vars.cTokens[1] = address(cTokenBUSD);\n      comptroller.enterMarkets(vars.cTokens);\n    }\n    bUSD.approve(address(cTokenBUSD), 1e36);\n    require(cTokenBUSD.mint(5e21) == 0, \"mint failed\");\n    vm.stopPrank();\n\n    // Account One borrow jBRL\n    vm.prank(accountOne);\n    require(cTokenJBRL.borrow(borrowAmount) == 0, \"borrow failed\");\n\n    // some time passes, interest accrues and prices change\n    {\n      vm.roll(block.number + 100);\n      cTokenBUSD.accrueInterest();\n      cTokenJBRL.accrueInterest();\n\n      MasterPriceOracle mpo = MasterPriceOracle(address(comptroller.oracle()));\n      uint256 priceBUSD = mpo.getUnderlyingPrice(cTokenBUSD);\n      vm.mockCall(\n        address(mpo),\n        abi.encodeWithSelector(mpo.getUnderlyingPrice.selector, cTokenBUSD),\n        abi.encode(priceBUSD / 100)\n      );\n    }\n\n    // prepare the liquidation\n    vars.strategies = new IRedemptionStrategy[](0);\n    vars.abis = new bytes[](0);\n\n    vars.fundingStrategies = new IFundsConversionStrategy[](1);\n    vars.data = new bytes[](1);\n    vars.data[0] = abi.encode(ap.getAddress(\"bUSD\"), address(synthereumLiquidityPool), 60 * 40);\n    vars.fundingStrategies[0] = jarvisLiquidator;\n\n    // all strategies need to be whitelisted\n    vm.prank(vars.liquidator.owner());\n    vars.liquidator._whitelistRedemptionStrategy(vars.fundingStrategies[0], true);\n\n    address pairAddress = IUniswapV2Factory(uniswapRouter.factory()).getPair(address(bUSD), ap.getAddress(\"wtoken\"));\n    IUniswapV2Pair flashSwapPair = IUniswapV2Pair(pairAddress);\n\n    uint256 repayAmount = borrowAmount / 10;\n    // liquidate\n    vm.prank(accountTwo);\n    vars.liquidator.safeLiquidateToTokensWithFlashLoan(\n      ILiquidator.LiquidateToTokensWithFlashSwapVars(\n        accountOne,\n        repayAmount,\n        ICErc20(address(cTokenJBRL)),\n        ICErc20(address(cTokenBUSD)),\n        address(flashSwapPair),\n        0,\n        vars.strategies,\n        vars.abis,\n        vars.fundingStrategies,\n        vars.data\n      )\n    );\n  }\n\n  function dealBUSD(address to, uint256 amount) internal {\n    vm.prank(0x0000000000000000000000000000000000001004); // whale\n    bUSD.transfer(to, amount);\n  }\n\n  function dealJBRL(address to, uint256 amount) internal {\n    vm.prank(0xad51e40D8f255dba1Ad08501D6B1a6ACb7C188f3); // whale\n    jBRLToken.transfer(to, amount);\n  }\n}\n"
    },
    "contracts/test/liquidators/SaddleLpTokenLiquidatorTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { SaddleLpTokenLiquidator } from \"../../liquidators/SaddleLpTokenLiquidator.sol\";\nimport { SaddleLpPriceOracle } from \"../../oracles/default/SaddleLpPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { ISwap } from \"../../external/saddle/ISwap.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract SaddleLpTokenLiquidatorTest is BaseTest {\n  MasterPriceOracle mpo;\n  address stable;\n  SaddleLpTokenLiquidator private liquidator;\n  SaddleLpPriceOracle oracle;\n  address fraxUsdc_lp = 0x896935B02D3cBEb152192774e4F1991bb1D2ED3f;\n  address frax = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F;\n\n  function afterForkSetUp() internal override {\n    liquidator = new SaddleLpTokenLiquidator();\n    oracle = new SaddleLpPriceOracle();\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    stable = ap.getAddress(\"stableToken\");\n\n    address[] memory uls = new address[](2);\n    uls[0] = stable;\n    uls[1] = frax;\n\n    address[][] memory underlyings = new address[][](1);\n    underlyings[0] = uls;\n\n    vm.prank(mpo.admin());\n    oracle.initialize(asArray(fraxUsdc_lp), asArray(0x401AFbc31ad2A3Bc0eD8960d63eFcDEA749b4849), underlyings);\n  }\n\n  function testSaddleLpTokenLiquidator() public fork(ARBITRUM_ONE) {\n    IERC20Upgradeable lpToken = IERC20Upgradeable(fraxUsdc_lp);\n    address lpTokenWhale = 0xa5bD85ed9fA27ba23BfB702989e7218E44fd4706; // metaswap\n    uint8 outputTokenIndex = 0;\n    address poolAddr = oracle.poolOf(address(lpToken));\n    ISwap pool = ISwap(poolAddr);\n    address outputTokenAddr = pool.getToken(0);\n    bytes memory data = abi.encode(outputTokenAddr, address(oracle), ap.getAddress(\"wtoken\"));\n    uint256 amount = 1e18;\n\n    IERC20Upgradeable outputToken = IERC20Upgradeable(outputTokenAddr);\n\n    vm.prank(lpTokenWhale);\n    lpToken.transfer(address(liquidator), 1e18);\n\n    vm.prank(address(liquidator));\n    lpToken.approve(poolAddr, 1e18);\n    vm.expectRevert(bytes(\"Pausable: paused\"));\n    liquidator.redeem(lpToken, amount, data);\n    // assertGt(outputToken.balanceOf(address(liquidator)), 0, \"!redeem output\");\n  }\n}\n"
    },
    "contracts/test/liquidators/SolidlyLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport \"../../liquidators/SolidlySwapLiquidator.sol\";\n\ncontract SolidlyLiquidatorTest is BaseTest {\n  SolidlySwapLiquidator public liquidator;\n  MasterPriceOracle public mpo;\n  address stableToken;\n  address solidlySwapRouter;\n  address hayAddress = 0x0782b6d8c4551B9760e74c0545a9bCD90bdc41E5;\n  address ankrAddress = 0xf307910A4c7bbc79691fD374889b36d8531B08e3;\n  address ankrBnbAddress = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n  uint256 inputAmount = 1e18;\n\n  function afterForkSetUp() internal override {\n    liquidator = new SolidlySwapLiquidator();\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    stableToken = ap.getAddress(\"stableToken\");\n\n    if (block.chainid == BSC_MAINNET) {\n      solidlySwapRouter = 0xd4ae6eCA985340Dd434D38F470aCCce4DC78D109;\n    } else if (block.chainid == POLYGON_MAINNET) {\n      solidlySwapRouter = 0x06374F57991CDc836E5A318569A910FE6456D230;\n    }\n  }\n\n  function testSolidlyHayBusd() public fork(BSC_MAINNET) {\n    address hayWhale = 0x1fa71DF4b344ffa5755726Ea7a9a56fbbEe0D38b;\n\n    IERC20Upgradeable hay = IERC20Upgradeable(hayAddress);\n    vm.prank(hayWhale);\n    hay.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      hay,\n      inputAmount,\n      abi.encode(solidlySwapRouter, stableToken, true)\n    );\n\n    assertEq(address(outputToken), stableToken, \"!busd output\");\n    assertApproxEqRel(inputAmount, outputAmount, 8e16, \"!busd amount\");\n  }\n\n  function testSolidlyAnkrHay() public fork(BSC_MAINNET) {\n    address ankrWhale = 0x146eE71e057e6B10eFB93AEdf631Fde6CbAED5E2;\n\n    IERC20Upgradeable ankr = IERC20Upgradeable(ankrAddress);\n    vm.prank(ankrWhale);\n    ankr.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      ankr,\n      inputAmount,\n      abi.encode(solidlySwapRouter, hayAddress, false)\n    );\n\n    uint256 outputValue = mpo.price(hayAddress) * outputAmount;\n    uint256 inputValue = mpo.price(ankrAddress) * inputAmount;\n\n    assertEq(address(outputToken), hayAddress, \"!hay output\");\n    assertApproxEqRel(outputValue, inputValue, 9e16, \"!hay amount\");\n  }\n\n  function testSolidlyAnkrAnkrBNB() public fork(BSC_MAINNET) {\n    address ankrWhale = 0x146eE71e057e6B10eFB93AEdf631Fde6CbAED5E2;\n\n    IERC20Upgradeable ankr = IERC20Upgradeable(ankrAddress);\n    vm.prank(ankrWhale);\n    ankr.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      ankr,\n      inputAmount,\n      abi.encode(solidlySwapRouter, ankrBnbAddress, false)\n    );\n\n    uint256 outputValue = mpo.price(ankrBnbAddress) * outputAmount;\n    uint256 inputValue = mpo.price(ankrAddress) * inputAmount;\n\n    assertEq(address(outputToken), ankrBnbAddress, \"!ankrBNB output\");\n    assertApproxEqRel(outputValue, inputValue, 8e16, \"!ankrBNB amount\");\n  }\n\n  function testSolidlyHayAnkrBNB() public fork(BSC_MAINNET) {\n    address hayWhale = 0x1fa71DF4b344ffa5755726Ea7a9a56fbbEe0D38b;\n\n    IERC20Upgradeable hay = IERC20Upgradeable(hayAddress);\n    vm.prank(hayWhale);\n    hay.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      hay,\n      inputAmount,\n      abi.encode(solidlySwapRouter, ankrBnbAddress, false)\n    );\n\n    uint256 outputValue = mpo.price(ankrBnbAddress) * outputAmount;\n    uint256 inputValue = mpo.price(hayAddress) * inputAmount;\n\n    assertEq(address(outputToken), ankrBnbAddress, \"!ankrBNB output\");\n    assertApproxEqRel(outputValue, inputValue, 8e16, \"!ankrBNB amount\");\n  }\n\n  function testSolidlyDaiUsdrLp() public fork(POLYGON_MAINNET) {\n    address daiUsdrLpAddress = 0x6ab291A9BB3C20F0017f2E93A6d1196842D09bF4;\n    address daiUsdrLpWhale = 0x5E21386E8E0e6C77Abd1E08e21e9D41e760D3747;\n    address usdrAddress = 0xb5DFABd7fF7F83BAB83995E72A52B97ABb7bcf63;\n\n    IERC20Upgradeable daiUsdrLp = IERC20Upgradeable(daiUsdrLpAddress);\n    vm.prank(daiUsdrLpWhale);\n    daiUsdrLp.transfer(address(liquidator), 1e18);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      daiUsdrLp,\n      inputAmount,\n      abi.encode(solidlySwapRouter, usdrAddress, false)\n    );\n\n    uint256 outputValue = mpo.price(usdrAddress) * outputAmount;\n    uint256 inputValue = mpo.price(daiUsdrLpAddress) * inputAmount;\n\n    assertEq(address(outputToken), usdrAddress, \"!usdr output\");\n    assertApproxEqRel(outputValue, inputValue, 8e16, \"!in value != out value\");\n  }\n}\n"
    },
    "contracts/test/liquidators/UniswapLikeLpTokenLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { UniswapLpTokenPriceOracle } from \"../../oracles/default/UniswapLpTokenPriceOracle.sol\";\nimport { SolidlyLpTokenPriceOracle } from \"../../oracles/default/SolidlyLpTokenPriceOracle.sol\";\nimport { UniswapLikeLpTokenPriceOracle } from \"../../oracles/default/UniswapLikeLpTokenPriceOracle.sol\";\nimport { UniswapLpTokenLiquidator } from \"../../liquidators/UniswapLpTokenLiquidator.sol\";\nimport { SolidlyLpTokenLiquidator, SolidlyLpTokenWrapper } from \"../../liquidators/SolidlyLpTokenLiquidator.sol\";\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\nimport { IUniswapV2Router02 } from \"../../external/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport { IPair } from \"../../external/solidly/IPair.sol\";\nimport { IRouter } from \"../../external/solidly/IRouter.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract UniswapLikeLpTokenLiquidatorTest is BaseTest {\n  UniswapLpTokenLiquidator private uniLiquidator;\n  SolidlyLpTokenLiquidator private solidlyLpTokenLiquidator;\n  SolidlyLpTokenWrapper solidlyLpTokenWrapper;\n  SolidlyLpTokenPriceOracle private oracleSolidly;\n  UniswapLpTokenPriceOracle private oracleUniswap;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address stableToken;\n  address uniswapV2Router;\n  address solidlyRouter;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    uniswapV2Router = ap.getAddress(\"IUniswapV2Router02\");\n    wtoken = ap.getAddress(\"wtoken\");\n    stableToken = ap.getAddress(\"stableToken\");\n    solidlyRouter = ap.getAddress(\"SOLIDLY_SWAP_ROUTER\");\n    emit log_named_address(\"solidlyRouter\", solidlyRouter);\n    uniLiquidator = new UniswapLpTokenLiquidator();\n    solidlyLpTokenLiquidator = new SolidlyLpTokenLiquidator();\n    solidlyLpTokenWrapper = new SolidlyLpTokenWrapper();\n    oracleSolidly = new SolidlyLpTokenPriceOracle(wtoken);\n    oracleUniswap = new UniswapLpTokenPriceOracle(wtoken);\n  }\n\n  function setUpOracles(address lpToken, UniswapLikeLpTokenPriceOracle oracle) internal {\n    if (address(mpo.oracles(lpToken)) == address(0)) {\n      address[] memory underlyings = new address[](1);\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n\n      underlyings[0] = lpToken;\n      oracles[0] = BasePriceOracle(oracle);\n\n      vm.prank(mpo.admin());\n      mpo.add(underlyings, oracles);\n      emit log(\"added the oracle\");\n    } else {\n      emit log(\"found the oracle\");\n    }\n  }\n\n  function testUniswapLpTokenRedeem(\n    address whale,\n    address lpToken,\n    UniswapLikeLpTokenPriceOracle oracle\n  ) internal {\n    setUpOracles(lpToken, oracle);\n    IERC20Upgradeable lpTokenContract = IERC20Upgradeable(lpToken);\n    IUniswapV2Pair pool = IUniswapV2Pair(lpToken);\n\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    address[] memory swapToken0Path;\n    address[] memory swapToken1Path;\n\n    IERC20Upgradeable outputToken = IERC20Upgradeable(wtoken);\n\n    if (token0 != wtoken) {\n      swapToken0Path = asArray(token0, wtoken);\n      swapToken1Path = new address[](0);\n    } else {\n      swapToken0Path = new address[](0);\n      swapToken1Path = asArray(token1, wtoken);\n    }\n\n    uint256 outputBalanceBefore = outputToken.balanceOf(address(uniLiquidator));\n\n    uint256 redeemAmount = 1e18;\n    // redeem\n    {\n      bytes memory data = abi.encode(uniswapV2Router, swapToken0Path, swapToken1Path);\n\n      vm.prank(whale);\n      lpTokenContract.transfer(address(uniLiquidator), redeemAmount);\n\n      vm.prank(address(uniLiquidator));\n      lpTokenContract.approve(lpToken, redeemAmount);\n      uniLiquidator.redeem(lpTokenContract, redeemAmount, data);\n    }\n\n    uint256 outputBalanceAfter = outputToken.balanceOf(address(uniLiquidator));\n    uint256 outputBalanceDiff = outputBalanceAfter - outputBalanceBefore;\n    assertGt(outputBalanceDiff, 0, \"!redeem output\");\n\n    // compare the value of the input LP tokens and the value of the output tokens\n    checkInputOutputValue(redeemAmount, lpToken, outputBalanceDiff, address(outputToken));\n  }\n\n  function testSolidlyLpTokenRedeem(\n    address whale,\n    address lpToken,\n    address outputTokenAddress,\n    UniswapLikeLpTokenPriceOracle oracle\n  ) internal {\n    setUpOracles(lpToken, oracle);\n    IERC20Upgradeable lpTokenContract = IERC20Upgradeable(lpToken);\n\n    IERC20Upgradeable outputToken = IERC20Upgradeable(outputTokenAddress);\n\n    uint256 outputBalanceBefore = outputToken.balanceOf(address(solidlyLpTokenLiquidator));\n\n    uint256 redeemAmount = 1e18;\n    // redeem\n    {\n      bytes memory data = abi.encode(solidlyRouter, outputTokenAddress);\n\n      vm.prank(whale);\n      lpTokenContract.transfer(address(solidlyLpTokenLiquidator), redeemAmount);\n\n      solidlyLpTokenLiquidator.redeem(lpTokenContract, redeemAmount, data);\n    }\n\n    uint256 outputBalanceAfter = outputToken.balanceOf(address(solidlyLpTokenLiquidator));\n    uint256 outputBalanceDiff = outputBalanceAfter - outputBalanceBefore;\n    assertGt(outputBalanceDiff, 0, \"!redeem output\");\n\n    // compare the value of the input LP tokens and the value of the output tokens\n    checkInputOutputValue(redeemAmount, lpToken, outputBalanceDiff, address(outputToken));\n  }\n\n  function checkInputOutputValue(\n    uint256 inputAmount,\n    address inputToken,\n    uint256 outputAmount,\n    address outputToken\n  ) internal {\n    uint256 outputTokenPrice = mpo.price(address(outputToken));\n    uint256 outputValue = (outputTokenPrice * outputAmount) / 1e18;\n    uint256 inputTokenPrice = mpo.price(inputToken);\n    uint256 inputValue = (inputAmount * inputTokenPrice) / 1e18;\n\n    assertApproxEqAbs(inputValue, outputValue, 1e15, \"value of output does not match the value of the output\");\n  }\n\n  function testUniswapLpRedeem() public fork(BSC_MAINNET) {\n    address lpTokenWhale = 0xa5f8C5Dbd5F286960b9d90548680aE5ebFf07652; // pcs main staking contract\n    address WBNB_BUSD_Uniswap = 0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16;\n    testUniswapLpTokenRedeem(lpTokenWhale, WBNB_BUSD_Uniswap, oracleUniswap);\n  }\n\n  function testSolidlyLpRedeem() public fork(BSC_MAINNET) {\n    address ankrBNB = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n\n    address WBNB_BUSD = 0x483653bcF3a10d9a1c334CE16a19471a614F4385;\n    address HAY_BUSD = 0x93B32a8dfE10e9196403dd111974E325219aec24;\n    address ANKR_ankrBNB = 0x7ef540f672Cd643B79D2488344944499F7518b1f;\n\n    address WBNB_BUSD_whale = 0x7144851e51523a88EA6BeC9710cC07f3a9B3baa7;\n    address HAY_BUSD_whale = 0x5f8a3d4ad41352A8145DDe8dC0aA3159C7B7649D;\n    address ANKR_ankrBNB_whale = 0x5FFEAe4E352Bf3789C9152Ef7eAfD9c1B3bfcE26;\n\n    testSolidlyLpTokenRedeem(WBNB_BUSD_whale, WBNB_BUSD, wtoken, oracleSolidly);\n    testSolidlyLpTokenRedeem(HAY_BUSD_whale, HAY_BUSD, stableToken, oracleSolidly);\n    testSolidlyLpTokenRedeem(ANKR_ankrBNB_whale, ANKR_ankrBNB, ankrBNB, oracleSolidly);\n  }\n\n  function _testSolidlyLpTokenWrapper(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    address whale,\n    IPair lpToken\n  ) internal {\n    // TODO get the data from the liquidators registry\n    IRouter.Route[] memory swapPath0 = new IRouter.Route[](1);\n    IRouter.Route[] memory swapPath1 = new IRouter.Route[](1);\n    IERC20Upgradeable otherUnderlying;\n    {\n      address token0 = lpToken.token0();\n      address token1 = lpToken.token1();\n      bool isInputToken0 = token0 == address(inputToken);\n      bool isInputToken1 = token1 == address(inputToken);\n      require(isInputToken0 || isInputToken1, \"!input token not underlying\");\n\n      if (isInputToken0) otherUnderlying = IERC20Upgradeable(token1);\n      else otherUnderlying = IERC20Upgradeable(token0);\n\n      swapPath0[0].stable = lpToken.stable();\n      swapPath0[0].from = token0;\n      swapPath0[0].to = token1;\n\n      swapPath1[0].stable = lpToken.stable();\n      swapPath1[0].from = token1;\n      swapPath1[0].to = token0;\n    }\n\n    bytes memory data = abi.encode(solidlyRouter, lpToken, swapPath0, swapPath1);\n\n    vm.prank(whale);\n    inputToken.transfer(address(solidlyLpTokenWrapper), inputAmount);\n\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = solidlyLpTokenWrapper.redeem(inputToken, inputAmount, data);\n\n    BasePriceOracle[] memory solOracles = new BasePriceOracle[](1);\n    solOracles[0] = oracleSolidly;\n    if (mpo.oracles(address(outputToken)) == BasePriceOracle(address(0))) {\n      vm.prank(mpo.admin());\n      mpo.add(asArray(address(outputToken)), solOracles);\n    }\n\n    uint256 lpTokensBalance = lpToken.balanceOf(address(solidlyLpTokenWrapper));\n    assertGt(lpTokensBalance, 0, \"!no lp tokens wrapped\");\n    uint256 inputTokensAfter = inputToken.balanceOf(address(solidlyLpTokenWrapper));\n    assertEq(inputTokensAfter, 0, \"!input tokens left after\");\n    //    uint256 otherTokensAfter = otherUnderlying.balanceOf(address(solidlyLpTokenWrapper));\n    //    assertEq(otherTokensAfter, 0, \"!other underlying tokens left after\");\n    //    emit log_named_uint(\"bps other leftover\", (valueOf(otherUnderlying, otherTokensAfter) * 10000) / valueOf(inputToken, inputAmount));\n    assertApproxEqRel(valueOf(inputToken, inputAmount), valueOf(outputToken, outputAmount), 5e16, \"!slippage too high\");\n  }\n\n  function valueOf(IERC20Upgradeable token, uint256 amount) internal view returns (uint256) {\n    uint256 price = mpo.price(address(token));\n    uint256 decimalsScale = 10**ERC20Upgradeable(address(token)).decimals();\n    return (amount * price) / decimalsScale;\n  }\n\n  function testWrapSolidlyLpTokensWbnbBusd() public fork(BSC_MAINNET) {\n    IERC20Upgradeable wbnb = IERC20Upgradeable(ap.getAddress(\"wtoken\"));\n    address WBNB_BUSD = 0x483653bcF3a10d9a1c334CE16a19471a614F4385;\n    address wbnbWhale = 0xF977814e90dA44bFA03b6295A0616a897441aceC;\n\n    _testSolidlyLpTokenWrapper(wbnb, 1e18, wbnbWhale, IPair(WBNB_BUSD));\n  }\n\n  function testWrapSolidlyLpTokensHayBusd() public fork(BSC_MAINNET) {\n    IERC20Upgradeable busd = IERC20Upgradeable(ap.getAddress(\"stableToken\"));\n    address HAY_BUSD = 0x93B32a8dfE10e9196403dd111974E325219aec24;\n    address busdWhale = 0xF977814e90dA44bFA03b6295A0616a897441aceC;\n\n    _testSolidlyLpTokenWrapper(busd, 1000e18, busdWhale, IPair(HAY_BUSD));\n  }\n\n  function testWrapSolidlyLpTokensjBrlBrz() public fork(BSC_MAINNET) {\n    IERC20Upgradeable jBRL = IERC20Upgradeable(0x316622977073BBC3dF32E7d2A9B3c77596a0a603);\n    address jBRL_BRZ = 0xA0695f78AF837F570bcc50f53e58Cda300798B65;\n    address jBRLWhale = 0xad51e40D8f255dba1Ad08501D6B1a6ACb7C188f3;\n\n    _testSolidlyLpTokenWrapper(jBRL, 1000e18, jBRLWhale, IPair(jBRL_BRZ));\n  }\n\n  function testWrapSolidlyLpTokensBrzJBrl() public fork(BSC_MAINNET) {\n    IERC20Upgradeable brz = IERC20Upgradeable(0x71be881e9C5d4465B3FfF61e89c6f3651E69B5bb);\n    address jBRL_BRZ = 0xA0695f78AF837F570bcc50f53e58Cda300798B65;\n    address brzWhale = 0xad51e40D8f255dba1Ad08501D6B1a6ACb7C188f3;\n\n    _testSolidlyLpTokenWrapper(brz, 1000e4, brzWhale, IPair(jBRL_BRZ));\n  }\n\n  function testWrapSolidlyLpTokensUsdrUsdc() public fork(POLYGON_MAINNET) {\n    IERC20Upgradeable usdc = IERC20Upgradeable(ap.getAddress(\"stableToken\"));\n    address USDC_USDR = 0xD17cb0f162f133e339C0BbFc18c36c357E681D6b;\n    address USDCWhale = 0xe7804c37c13166fF0b37F5aE0BB07A3aEbb6e245; // binance hot wallet\n\n    _testSolidlyLpTokenWrapper(usdc, 1000e6, USDCWhale, IPair(USDC_USDR));\n  }\n\n  function testWrapSolidlyLpTokensUsdrUsdr() public fork(POLYGON_MAINNET) {\n    IERC20Upgradeable usdr = IERC20Upgradeable(0x40379a439D4F6795B6fc9aa5687dB461677A2dBa);\n    address WUSDR_USDR = 0x8711a1a52c34EDe8E61eF40496ab2618a8F6EA4B;\n    address USDRWhale = 0xBD02973b441Aa83c8EecEA158b98B5984bb1036E; // curve lp token\n\n    _testSolidlyLpTokenWrapper(usdr, 1000e9, USDRWhale, IPair(WUSDR_USDR));\n  }\n\n  function testWrapSolidlyLpTokensMaticUsdr() public fork(POLYGON_MAINNET) {\n    IERC20Upgradeable usdr = IERC20Upgradeable(0x40379a439D4F6795B6fc9aa5687dB461677A2dBa);\n    address MATIC_USDR = 0xB4d852b92148eAA16467295975167e640E1FE57A;\n    address USDRWhale = 0xBD02973b441Aa83c8EecEA158b98B5984bb1036E; // curve lp token\n\n    _testSolidlyLpTokenWrapper(usdr, 1000e9, USDRWhale, IPair(MATIC_USDR));\n  }\n}\n"
    },
    "contracts/test/liquidators/UniswapV2LiquidatorFunderTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport { UniswapV2LiquidatorFunder } from \"../../liquidators/UniswapV2LiquidatorFunder.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract UniswapV2LiquidatorFunderTest is BaseTest {\n  address maiAddress;\n  address usdcAddress;\n  UniswapV2LiquidatorFunder uv2lf;\n  address uniswapV2Router;\n\n  function afterForkSetUp() internal override {\n    uv2lf = new UniswapV2LiquidatorFunder();\n    uniswapV2Router = ap.getAddress(\"IUniswapV2Router02\");\n    usdcAddress = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\n    maiAddress = 0x3F56e0c36d275367b8C502090EDF38289b3dEa0d;\n  }\n\n  function testConvertUsdcMai() public fork(BSC_MAINNET) {\n    address[] memory swapPath = new address[](2);\n    swapPath[0] = maiAddress;\n    swapPath[1] = usdcAddress;\n    bytes memory strategyData = abi.encode(uniswapV2Router, swapPath);\n\n    uint256 outputUsdcExpected = 1e10;\n    (IERC20Upgradeable inputToken, uint256 inputMaiRequired) = uv2lf.estimateInputAmount(\n      outputUsdcExpected,\n      strategyData\n    );\n\n    assertApproxEqAbs(inputMaiRequired, outputUsdcExpected, 1e9);\n    assertEq(address(inputToken), maiAddress, \"!mai address\");\n  }\n}\n"
    },
    "contracts/test/liquidators/UniswapV3LiquidatorFunderTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { UniswapV3LiquidatorFunder } from \"../../liquidators/UniswapV3LiquidatorFunder.sol\";\nimport { IonicLiquidator } from \"../../IonicLiquidator.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport { IUniswapV2Factory } from \"../../external/uniswap/IUniswapV2Factory.sol\";\nimport { IUniswapV3Factory } from \"../../external/uniswap/IUniswapV3Factory.sol\";\nimport { Quoter } from \"../../external/uniswap/quoter/Quoter.sol\";\nimport { IUniswapV3Pool } from \"../../external/uniswap/IUniswapV3Pool.sol\";\nimport { ISwapRouter } from \"../../external/uniswap/ISwapRouter.sol\";\nimport { IComptroller } from \"../../external/compound/IComptroller.sol\";\nimport { IUniswapV2Router02 } from \"../../external/uniswap/IUniswapV2Router02.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract UniswapV3LiquidatorFunderTest is BaseTest {\n  UniswapV3LiquidatorFunder private uniswapv3Liquidator;\n\n  IERC20Upgradeable parToken;\n  IERC20Upgradeable usdcToken;\n  address univ3SwapRouter;\n  uint256 poolFee;\n  Quoter quoter;\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    if (block.chainid == POLYGON_MAINNET) {\n      quoter = new Quoter(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n      univ3SwapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n      parToken = IERC20Upgradeable(0xE2Aa7db6dA1dAE97C5f5C6914d285fBfCC32A128); // PAR, 18 decimals\n      usdcToken = IERC20Upgradeable(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174); // USDC, 6 decimals\n      poolFee = 500;\n    }\n    uniswapv3Liquidator = new UniswapV3LiquidatorFunder();\n  }\n\n  function testUniV3ParUsdcRedeem() public fork(POLYGON_MAINNET) {\n    uint256 parInputAmount = 10000e18;\n    address parTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // Balancer V2\n\n    vm.prank(parTokenWhale);\n    parToken.transfer(address(uniswapv3Liquidator), parInputAmount);\n\n    bytes memory data = abi.encode(parToken, usdcToken, poolFee, ISwapRouter(univ3SwapRouter), quoter);\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = uniswapv3Liquidator.redeem(parToken, parInputAmount, data);\n\n    uint256 inputValue = (parInputAmount * mpo.price(address(parToken))) / 1e18;\n    uint256 outputValue = (outputAmount * mpo.price(address(usdcToken))) / 1e6;\n\n    assertEq(address(outputToken), address(usdcToken), \"!out tok\");\n    assertApproxEqRel(inputValue, outputValue, 1e16, \"!out amount\");\n  }\n}\n"
    },
    "contracts/test/liquidators/UniswapV3LiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { IonicUniV3Liquidator, IUniswapV3Pool, ILiquidator } from \"../../IonicUniV3Liquidator.sol\";\nimport \"../../external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol\";\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { IUniswapV2Router02 } from \"../../external/uniswap/IUniswapV2Router02.sol\";\nimport { IUniswapV3Factory } from \"../../external/uniswap/IUniswapV3Factory.sol\";\nimport { UniswapV2LiquidatorFunder } from \"../../liquidators/UniswapV2LiquidatorFunder.sol\";\nimport { UniswapV3LiquidatorFunder } from \"../../liquidators/UniswapV3LiquidatorFunder.sol\";\nimport { KimUniV2Liquidator } from \"../../liquidators/KimUniV2Liquidator.sol\";\n\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\nimport { AuthoritiesRegistry } from \"../../ionic/AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../../ionic/PoolRolesAuthority.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\nimport \"./IonicLiquidatorTest.sol\";\n\ncontract UniswapV3LiquidatorTest is IonicLiquidatorTest {\n  function testPolygonUniV3LiquidatorLiquidate() public fork(POLYGON_MAINNET) {\n    IonicUniV3Liquidator _liquidator = new IonicUniV3Liquidator();\n    _liquidator.initialize(ap.getAddress(\"wtoken\"), address(quoter));\n    liquidator = _liquidator;\n    _testLiquidatorLiquidate(uniV3PooForFlash);\n  }\n\n  function testModeUniV3LiquidatorLiquidate() public debuggingOnly fork(MODE_MAINNET) {\n    IonicUniV3Liquidator _liquidator = new IonicUniV3Liquidator();\n    _liquidator.initialize(ap.getAddress(\"wtoken\"), address(quoter));\n    liquidator = _liquidator;\n\n    IonicComptroller pool = IonicComptroller(poolAddress);\n    {\n      ICErc20[] memory markets = pool.getAllMarkets();\n\n      ICErc20 usdcMarket = markets[usdcMarketIndex];\n      IERC20Upgradeable usdc = IERC20Upgradeable(usdcMarket.underlying());\n      ICErc20 wethMarket = markets[wethMarketIndex];\n      IERC20Upgradeable weth = IERC20Upgradeable(wethMarket.underlying());\n      {\n        emit log_named_address(\"usdc market\", address(usdcMarket));\n        emit log_named_address(\"weth market\", address(wethMarket));\n        emit log_named_address(\"usdc underlying\", usdcMarket.underlying());\n        emit log_named_address(\"weth underlying\", wethMarket.underlying());\n        vm.startPrank(liquidatorsRegistry.owner());\n        IRedemptionStrategy strategy = new UniswapV3LiquidatorFunder();\n        liquidatorsRegistry._setRedemptionStrategy(strategy, weth, usdc);\n        vm.stopPrank();\n        vm.prank(OwnableUpgradeable(address(liquidator)).owner());\n        liquidator._whitelistRedemptionStrategy(strategy, true);\n      }\n    }\n\n    _testLiquidatorLiquidate(uniV3PooForFlash);\n  }\n\n  function testModeKimUniV2Liquidator() public fork(MODE_MAINNET) {\n    IonicLiquidator _liquidator = new IonicLiquidator();\n    _liquidator.initialize(ap.getAddress(\"wtoken\"), ap.getAddress(\"IUniswapV2Router02\"), 30);\n    liquidator = _liquidator;\n    liquidator.setPoolLens(0x70BB19a56BfAEc65aE861E6275A90163AbDF36a6);\n    liquidator.setHealthFactorThreshold(1e18);\n\n    IonicComptroller pool = IonicComptroller(poolAddress);\n    {\n      ICErc20[] memory markets = pool.getAllMarkets();\n\n      ICErc20 usdcMarket = markets[usdcMarketIndex];\n      IERC20Upgradeable usdc = IERC20Upgradeable(usdcMarket.underlying());\n      ICErc20 wethMarket = markets[wethMarketIndex];\n      IERC20Upgradeable weth = IERC20Upgradeable(wethMarket.underlying());\n      {\n        emit log_named_address(\"usdc market\", address(usdcMarket));\n        emit log_named_address(\"weth market\", address(wethMarket));\n        emit log_named_address(\"usdc underlying\", usdcMarket.underlying());\n        emit log_named_address(\"weth underlying\", wethMarket.underlying());\n        vm.startPrank(liquidatorsRegistry.owner());\n        IRedemptionStrategy strategy = KimUniV2Liquidator(0x6aC17D406a820fa464fFdc0940FCa7E60b3b36B7);\n        liquidatorsRegistry._setRedemptionStrategy(strategy, weth, usdc);\n        vm.stopPrank();\n        liquidator._whitelistRedemptionStrategy(strategy, true);\n      }\n    }\n\n    _testLiquidatorLiquidate(uniV3PooForFlash);\n  }\n\n  function testUniV3PoolForFee() public debuggingOnly fork(MODE_MAINNET) {\n    address wethAddr = 0x4200000000000000000000000000000000000006;\n    address usdcAddr = 0xd988097fb8612cc24eeC14542bC03424c656005f;\n    IERC20Upgradeable usdc = IERC20Upgradeable(usdcAddr);\n    IERC20Upgradeable weth = IERC20Upgradeable(wethAddr);\n\n    IUniswapV2Router02 kimRouter = IUniswapV2Router02(0x5D61c537393cf21893BE619E36fC94cd73C77DD3);\n    address factoryAddress;\n    //factory = kimRouter.factory();\n    factoryAddress = 0xC33Ce0058004d44E7e1F366E5797A578fDF38584;\n    IUniswapV3Factory factory = IUniswapV3Factory(factoryAddress);\n    address pool;\n\n    uint256 feeConfig = liquidatorsRegistry.uniswapV3Fees(usdc, weth);\n    emit log_named_uint(\"feeConfig\", feeConfig);\n\n    if (feeConfig == 0) {\n      pool = factory.getPool(wethAddr, usdcAddr, uint24(feeConfig));\n      emit log_named_address(\"Pool at fee 0\", pool);\n    }\n\n    pool = factory.getPool(wethAddr, usdcAddr, 500);\n    emit log_named_address(\"Pool at fee 500\", pool);\n  }\n}\n"
    },
    "contracts/test/liquidators/WombatLpTokenLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\nimport { WombatLpTokenLiquidator } from \"../../liquidators/WombatLpTokenLiquidator.sol\";\nimport { IWombatLpAsset } from \"../../oracles/default/WombatLpTokenPriceOracle.sol\";\nimport { WombatLpTokenPriceOracle } from \"../../oracles/default/WombatLpTokenPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\n\ncontract WombatLpTokenLiquidatorTest is BaseTest {\n  WombatLpTokenLiquidator private wtl;\n  WombatLpTokenPriceOracle private oracle;\n  MasterPriceOracle private mp;\n\n  function afterForkSetUp() internal override {\n    wtl = new WombatLpTokenLiquidator();\n    oracle = new WombatLpTokenPriceOracle();\n    mp = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  function testRedeemWBNB() public fork(BSC_MAINNET) {\n    address wombatBUSD = 0xF319947eCe3823b790dd87b0A509396fE325745a;\n    uint256 assetAmount = 100e18;\n\n    deal(wombatBUSD, address(wtl), assetAmount);\n\n    vm.prank(address(mp));\n    uint256 assetPrice = oracle.price(wombatBUSD); // wombatBUSD price\n    uint256 underlyingPrice = mp.price(IWombatLpAsset(wombatBUSD).underlyingToken()); // wbnb price\n\n    // amount convertion = assetAmount * underlyingPrice / assetPrice\n    uint256 expectedAmount = (assetAmount * underlyingPrice) / assetPrice;\n\n    bytes memory strategyData = abi.encode(\n      IWombatLpAsset(wombatBUSD).pool(),\n      IWombatLpAsset(wombatBUSD).underlyingToken()\n    );\n    (, uint256 redeemAmount) = wtl.redeem(IERC20Upgradeable(wombatBUSD), assetAmount, strategyData);\n\n    assertApproxEqAbs(\n      expectedAmount,\n      redeemAmount,\n      uint256(5e17),\n      string(abi.encodePacked(\"!redeemAmount == expectedAmount \"))\n    );\n  }\n}\n"
    },
    "contracts/test/liquidators/XBombLiquidatorTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/bomb/IXBomb.sol\";\nimport \"../../liquidators/XBombLiquidatorFunder.sol\";\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract XBombLiquidatorTest is BaseTest {\n  // the Pancake BOMB/xBOMB pair\n  address holder = 0x6aE0Fb5D98911cF5AF6A8CE0AeCE426227d41103;\n  IXBomb xbombToken = IXBomb(0xAf16cB45B8149DA403AF41C63AbFEBFbcd16264b);\n  address bombTokenAddress = 0x522348779DCb2911539e76A1042aA922F9C47Ee3; // BOMB\n  XBombLiquidatorFunder liquidator;\n\n  function afterForkSetUp() internal override {\n    liquidator = new XBombLiquidatorFunder();\n  }\n\n  function testRedeem() public debuggingOnly fork(BSC_MAINNET) {\n    // make sure we're testing with at least some tokens\n    uint256 balance = xbombToken.balanceOf(holder);\n    assertTrue(balance > 0);\n\n    // impersonate the holder\n    vm.prank(holder);\n\n    // fund the liquidator so it can redeem the tokens\n    xbombToken.transfer(address(liquidator), balance);\n\n    bytes memory data = abi.encode(address(xbombToken), address(xbombToken), bombTokenAddress);\n    // redeem the underlying reward token\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      IERC20Upgradeable(address(xbombToken)),\n      balance,\n      data\n    );\n\n    assertEq(address(outputToken), bombTokenAddress);\n    assertEq(outputAmount, xbombToken.toREWARD(balance));\n  }\n}\n"
    },
    "contracts/test/LiquidatorsRegistryTest.t.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.10;\n\nimport { LiquidatorsRegistry } from \"../liquidators/registry/LiquidatorsRegistry.sol\";\nimport { LiquidatorsRegistryExtension } from \"../liquidators/registry/LiquidatorsRegistryExtension.sol\";\nimport { LiquidatorsRegistrySecondExtension } from \"../liquidators/registry/LiquidatorsRegistrySecondExtension.sol\";\nimport { ILiquidatorsRegistry } from \"../liquidators/registry/ILiquidatorsRegistry.sol\";\nimport { IRedemptionStrategy } from \"../liquidators/IRedemptionStrategy.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport \"../ionic/DiamondExtension.sol\";\nimport { SafeOwnable } from \"../ionic/SafeOwnable.sol\";\n\ncontract LiquidatorsRegistryTest is BaseTest {\n  ILiquidatorsRegistry registry;\n\n  // all-chains\n  IERC20Upgradeable stable;\n  IERC20Upgradeable wtoken;\n  MasterPriceOracle mpo;\n\n  // chapel\n  IERC20Upgradeable chapelBomb = IERC20Upgradeable(0xe45589fBad3A1FB90F5b2A8A3E8958a8BAB5f768);\n  IERC20Upgradeable chapelTUsd = IERC20Upgradeable(0x4f1885D25eF219D3D4Fa064809D6D4985FAb9A0b);\n  IERC20Upgradeable chapelTDai = IERC20Upgradeable(0x8870f7102F1DcB1c35b01af10f1baF1B00aD6805);\n\n  // bsc\n  IERC20Upgradeable wbnbBusdLpToken = IERC20Upgradeable(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);\n  IERC20Upgradeable usdcBusdCakeLpToken = IERC20Upgradeable(0x2354ef4DF11afacb85a5C7f98B624072ECcddbB1);\n  IERC20Upgradeable ankrAnkrBnbGammaLpToken = IERC20Upgradeable(0x3f8f3caefF393B1994a9968E835Fd38eCba6C1be);\n\n  // polygon\n  IERC20Upgradeable usdr3CrvCurveLpToken = IERC20Upgradeable(0xa138341185a9D0429B0021A11FB717B225e13e1F);\n  IERC20Upgradeable maticxBbaBalancerStableLpToken = IERC20Upgradeable(0xb20fC01D21A50d2C734C4a1262B4404d41fA7BF0);\n  IERC20Upgradeable stMaticBbaBalancerStableLpToken = IERC20Upgradeable(0x216690738Aac4aa0C4770253CA26a28f0115c595);\n  IERC20Upgradeable mimoParBalancerWeightedLpToken = IERC20Upgradeable(0x82d7f08026e21c7713CfAd1071df7C8271B17Eae);\n\n  function afterForkSetUp() internal override {\n    registry = ILiquidatorsRegistry(ap.getAddress(\"LiquidatorsRegistry\"));\n    stable = IERC20Upgradeable(ap.getAddress(\"stableToken\"));\n    wtoken = IERC20Upgradeable(ap.getAddress(\"wtoken\"));\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  function upgradeRegistry() internal {\n    DiamondBase asBase = DiamondBase(address(registry));\n    address[] memory exts = asBase._listExtensions();\n    LiquidatorsRegistryExtension newExt1 = new LiquidatorsRegistryExtension();\n    LiquidatorsRegistrySecondExtension newExt2 = new LiquidatorsRegistrySecondExtension();\n    vm.prank(SafeOwnable(address(registry)).owner());\n    asBase._registerExtension(newExt1, DiamondExtension(exts[0]));\n    vm.prank(SafeOwnable(address(registry)).owner());\n    asBase._registerExtension(newExt2, DiamondExtension(exts[1]));\n  }\n\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n\n  function testResetStrategies() public debuggingOnly fork(BSC_CHAPEL) {\n    upgradeRegistry();\n\n    IRedemptionStrategy[] memory strategiesConfig = new IRedemptionStrategy[](3);\n    IERC20Upgradeable[] memory inputTokensConfig = new IERC20Upgradeable[](3);\n    IERC20Upgradeable[] memory outputTokensConfig = new IERC20Upgradeable[](3);\n    {\n      strategiesConfig[0] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      strategiesConfig[1] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      strategiesConfig[2] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      inputTokensConfig[0] = IERC20Upgradeable(chapelBomb);\n      inputTokensConfig[1] = IERC20Upgradeable(chapelTUsd);\n      inputTokensConfig[2] = IERC20Upgradeable(chapelTDai);\n      outputTokensConfig[0] = IERC20Upgradeable(chapelTUsd);\n      outputTokensConfig[1] = IERC20Upgradeable(chapelBomb);\n      outputTokensConfig[2] = IERC20Upgradeable(chapelBomb);\n    }\n\n    bool matchingBefore = registry.pairsStrategiesMatch(strategiesConfig, inputTokensConfig, outputTokensConfig);\n    assertEq(matchingBefore, false, \"should not match prior\");\n\n    vm.prank(ap.getAddress(\"deployer\"));\n    registry._resetRedemptionStrategies(strategiesConfig, inputTokensConfig, outputTokensConfig);\n\n    bool matchingAfter = registry.pairsStrategiesMatch(strategiesConfig, inputTokensConfig, outputTokensConfig);\n    assertEq(matchingAfter, true, \"should match after\");\n  }\n\n  function testResetDuplicatingStrategies() public debuggingOnly fork(BSC_CHAPEL) {\n    upgradeRegistry();\n\n    IRedemptionStrategy[] memory strategiesConfig = new IRedemptionStrategy[](4);\n    IERC20Upgradeable[] memory inputTokensConfig = new IERC20Upgradeable[](4);\n    IERC20Upgradeable[] memory outputTokensConfig = new IERC20Upgradeable[](4);\n    {\n      strategiesConfig[0] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      strategiesConfig[1] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      strategiesConfig[2] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      strategiesConfig[3] = IRedemptionStrategy(0xC875a8D8E8a593953115131697a788faEAa37109);\n      inputTokensConfig[0] = IERC20Upgradeable(chapelBomb);\n      inputTokensConfig[1] = IERC20Upgradeable(chapelTUsd);\n      inputTokensConfig[2] = IERC20Upgradeable(chapelTDai);\n      inputTokensConfig[3] = IERC20Upgradeable(chapelTDai);\n      outputTokensConfig[0] = IERC20Upgradeable(chapelTUsd);\n      outputTokensConfig[1] = IERC20Upgradeable(chapelBomb);\n      outputTokensConfig[2] = IERC20Upgradeable(chapelBomb);\n      outputTokensConfig[3] = IERC20Upgradeable(chapelBomb);\n    }\n\n    bool matchingBefore = registry.pairsStrategiesMatch(strategiesConfig, inputTokensConfig, outputTokensConfig);\n    assertEq(matchingBefore, false, \"should not match prior\");\n\n    vm.prank(ap.getAddress(\"deployer\"));\n    registry._resetRedemptionStrategies(strategiesConfig, inputTokensConfig, outputTokensConfig);\n\n    bool matchingAfter = registry.pairsStrategiesMatch(strategiesConfig, inputTokensConfig, outputTokensConfig);\n    assertEq(matchingAfter, true, \"should match after\");\n  }\n\n  function testRedemptionPathChapel() public debuggingOnly fork(BSC_CHAPEL) {\n    emit log(\"bomb tusd\");\n    emit log(registry.redemptionStrategiesByTokens(chapelBomb, chapelTDai).name());\n    emit log(\"tusd bomb\");\n    emit log(registry.redemptionStrategiesByTokens(chapelTDai, chapelBomb).name());\n\n    (IRedemptionStrategy strategy, bytes memory strategyData) = registry.getRedemptionStrategy(chapelBomb, chapelTDai);\n  }\n\n  function testInputTokensChapel() public debuggingOnly fork(BSC_CHAPEL) {\n    address[] memory inputTokens = registry.getInputTokensByOutputToken(chapelBomb);\n\n    emit log_named_array(\"inputs\", inputTokens);\n  }\n\n  function testInputTokensBsc() public debuggingOnly fork(BSC_MAINNET) {\n    address[] memory inputTokens = registry.getInputTokensByOutputToken(stable);\n\n    emit log_named_array(\"inputs\", inputTokens);\n  }\n\n  function _swap(\n    address whale,\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    IERC20Upgradeable outputToken,\n    uint256 tolerance\n  ) internal {\n    vm.startPrank(whale);\n    inputToken.approve(address(registry), inputAmount);\n    (uint256 swappedAmountOut, uint256 slippage) = registry.amountOutAndSlippageOfSwap(\n      inputToken,\n      inputAmount,\n      outputToken\n    );\n    vm.stopPrank();\n\n    emit log_named_uint(\"received\", swappedAmountOut);\n    assertLt(slippage, tolerance, \"slippage too high\");\n  }\n\n  function testSwappingUniLpBsc() public fork(BSC_MAINNET) {\n    address lpTokenWhale = 0x14B2e8329b8e06BCD524eb114E23fAbD21910109;\n\n    IERC20Upgradeable inputToken = usdcBusdCakeLpToken;\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = stable;\n\n    _swap(lpTokenWhale, inputToken, inputAmount, outputToken, 1e16);\n  }\n\n  function testSwappingGammaLpBsc() public fork(BSC_MAINNET) {\n    address lpTokenWhale = 0xd44ad81474d075c3Bf0307830977A5804BfC0bc7; // thena gauge\n\n    IERC20Upgradeable inputToken = ankrAnkrBnbGammaLpToken;\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = wtoken;\n\n    _swap(lpTokenWhale, inputToken, inputAmount, outputToken, 1e16);\n  }\n\n  function testSwappingBalancerStableLpPolygon() public fork(POLYGON_MAINNET) {\n    // TODO: run deployment to fix the liquidation path and set the balancer liquidator data\n    address lpTokenWhale = 0xBA12222222228d8Ba445958a75a0704d566BF2C8; // balancer gauge\n\n    // maticx-wmatic aave boosted\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = wtoken;\n\n    _swap(lpTokenWhale, maticxBbaBalancerStableLpToken, inputAmount, outputToken, 1e16);\n\n    // stmatic-wmatic aave boosted\n    _swap(lpTokenWhale, stMaticBbaBalancerStableLpToken, inputAmount, outputToken, 1e16);\n  }\n\n  function testSwappingBalancerWeightedLpPolygon() public fork(POLYGON_MAINNET) {\n    address lpTokenWhale = 0xbB60ADbe38B4e6ab7fb0f9546C2C1b665B86af11; // mimo staker\n\n    IERC20Upgradeable inputToken = mimoParBalancerWeightedLpToken;\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = IERC20Upgradeable(0xE2Aa7db6dA1dAE97C5f5C6914d285fBfCC32A128); // PAR\n\n    _swap(lpTokenWhale, inputToken, inputAmount, outputToken, 5e16);\n  }\n\n  address tusdWhale = 0x161FbE0943Af4A39a50262026A81a243B635982d; // old XBombSwap\n  address tdaiWhale = 0xd816eb4660615BBF080ddf425F28ea4AF30d04D5; // old XBombSwap\n  address bombWhale = 0xd816eb4660615BBF080ddf425F28ea4AF30d04D5; // old XBombSwap\n\n  function testSwappingBombTDaiChapel() public debuggingOnly fork(BSC_CHAPEL) {\n    IERC20Upgradeable inputToken = chapelBomb;\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = chapelTDai;\n\n    _swap(bombWhale, inputToken, inputAmount, outputToken, 5e16);\n  }\n\n  function testSwappingTUsdBombChapel() public debuggingOnly fork(BSC_CHAPEL) {\n    IERC20Upgradeable inputToken = chapelTUsd;\n    uint256 inputAmount = 1e18;\n    IERC20Upgradeable outputToken = chapelBomb;\n\n    _swap(tusdWhale, inputToken, inputAmount, outputToken, 5e16);\n  }\n\n  function testUpdateLiquidator() public debuggingOnly fork(MODE_MAINNET) {\n    LiquidatorsRegistry registry = LiquidatorsRegistry(0xc71B968C6C23e2723Bae32957D815C9bE3ca1b34);\n    address multisig = 0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2;\n    vm.prank(multisig);\n    registry._registerExtension(\n      DiamondExtension(0x3FA4BC2FCAc5515d5b758D4D580bbD626c93D621),\n      DiamondExtension(0xac409691b385Fdbb66752Ff2D97e50BC23fF2295)\n    );\n  }\n}\n"
    },
    "contracts/test/LiquidityMining.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"forge-std/Vm.sol\";\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { FlywheelStaticRewards } from \"../ionic/strategies/flywheel/rewards/FlywheelStaticRewards.sol\";\nimport { IFlywheelBooster } from \"../ionic/strategies/flywheel/IFlywheelBooster.sol\";\nimport { IFlywheelRewards } from \"../ionic/strategies/flywheel/rewards/IFlywheelRewards.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { CErc20 } from \"../compound/CToken.sol\";\nimport { JumpRateModel } from \"../compound/JumpRateModel.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20Delegator } from \"../compound/CErc20Delegator.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { InterestRateModel } from \"../compound/InterestRateModel.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { AuthoritiesRegistry } from \"../ionic/AuthoritiesRegistry.sol\";\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\n\nimport { MockPriceOracle } from \"../oracles/1337/MockPriceOracle.sol\";\nimport { CTokenFirstExtension, DiamondExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { IonicFlywheelLensRouter } from \"../ionic/strategies/flywheel/IonicFlywheelLensRouter.sol\";\nimport { IonicFlywheel } from \"../ionic/strategies/flywheel/IonicFlywheel.sol\";\nimport { IonicFlywheelCore } from \"../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\ncontract LiquidityMiningTest is BaseTest {\n  MockERC20 underlyingToken;\n  MockERC20 rewardToken;\n\n  JumpRateModel interestModel;\n  IonicComptroller comptroller;\n  CErc20Delegate cErc20Delegate;\n  ICErc20 cErc20;\n  FeeDistributor ionicAdmin;\n  PoolDirectory poolDirectory;\n\n  IonicFlywheel flywheel;\n  FlywheelStaticRewards rewards;\n  IonicFlywheelLensRouter flywheelClaimer;\n\n  address user = address(1337);\n\n  uint8 baseDecimal;\n  uint8 rewardDecimal;\n\n  address[] markets;\n  IonicFlywheelCore[] flywheelsToClaim;\n\n  function setUpBaseContracts(uint8 _baseDecimal, uint8 _rewardDecimal) public {\n    baseDecimal = _baseDecimal;\n    rewardDecimal = _rewardDecimal;\n    underlyingToken = new MockERC20(\"UnderlyingToken\", \"UT\", baseDecimal);\n    rewardToken = new MockERC20(\"RewardToken\", \"RT\", rewardDecimal);\n    interestModel = new JumpRateModel(2343665, 1 * 10**baseDecimal, 1 * 10**baseDecimal, 4 * 10**baseDecimal, 0.8e18);\n    ionicAdmin = new FeeDistributor();\n    ionicAdmin.initialize(1 * 10**(baseDecimal - 2));\n    poolDirectory = new PoolDirectory();\n    poolDirectory.initialize(false, new address[](0));\n    cErc20Delegate = new CErc20Delegate();\n    // set the new delegate as the latest\n    ionicAdmin._setLatestCErc20Delegate(cErc20Delegate.delegateType(), address(cErc20Delegate), abi.encode(address(0)));\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](2);\n    cErc20DelegateExtensions[0] = new CTokenFirstExtension();\n    cErc20DelegateExtensions[1] = cErc20Delegate;\n    ionicAdmin._setCErc20DelegateExtensions(address(cErc20Delegate), cErc20DelegateExtensions);\n  }\n\n  function setUpPoolAndMarket() public {\n    MockPriceOracle priceOracle = new MockPriceOracle(10);\n    Comptroller tempComptroller = new Comptroller();\n    ionicAdmin._setLatestComptrollerImplementation(address(0), address(tempComptroller));\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = new ComptrollerFirstExtension();\n    extensions[1] = tempComptroller;\n    ionicAdmin._setComptrollerExtensions(address(tempComptroller), extensions);\n    (, address comptrollerAddress) = poolDirectory.deployPool(\n      \"TestPool\",\n      address(tempComptroller),\n      abi.encode(payable(address(ionicAdmin))),\n      false,\n      0.1e18,\n      1.1e18,\n      address(priceOracle)\n    );\n\n    Unitroller(payable(comptrollerAddress))._acceptAdmin();\n    comptroller = IonicComptroller(comptrollerAddress);\n\n    AuthoritiesRegistry impl = new AuthoritiesRegistry();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(1), \"\");\n    AuthoritiesRegistry newAr = AuthoritiesRegistry(address(proxy));\n    newAr.initialize(address(321));\n    ionicAdmin.reinitialize(newAr);\n    PoolRolesAuthority poolAuth = newAr.createPoolAuthority(comptrollerAddress);\n    newAr.setUserRole(comptrollerAddress, user, poolAuth.BORROWER_ROLE(), true);\n\n    vm.roll(1);\n    comptroller._deployMarket(\n      cErc20Delegate.delegateType(),\n      abi.encode(\n        address(underlyingToken),\n        comptroller,\n        payable(address(ionicAdmin)),\n        InterestRateModel(address(interestModel)),\n        \"CUnderlyingToken\",\n        \"CUT\",\n        uint256(1),\n        uint256(0)\n      ),\n      \"\",\n      0.9e18\n    );\n\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\n    cErc20 = allMarkets[allMarkets.length - 1];\n  }\n\n  function setUpFlywheel() public {\n    IonicFlywheel impl = new IonicFlywheel();\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(impl), address(dpa), \"\");\n    flywheel = IonicFlywheel(address(proxy));\n    flywheel.initialize(rewardToken, FlywheelStaticRewards(address(0)), IFlywheelBooster(address(0)), address(this));\n    rewards = new FlywheelStaticRewards(IonicFlywheelCore(address(flywheel)), address(this), Authority(address(0)));\n    flywheel.setFlywheelRewards(rewards);\n\n    flywheelClaimer = new IonicFlywheelLensRouter(poolDirectory);\n\n    flywheel.addStrategyForRewards(ERC20(address(cErc20)));\n\n    // add flywheel as rewardsDistributor to call flywheelPreBorrowAction / flywheelPreSupplyAction\n    require(comptroller._addRewardsDistributor(address(flywheel)) == 0);\n\n    // seed rewards to flywheel\n    rewardToken.mint(address(rewards), 100 * 10**rewardDecimal);\n\n    // Start reward distribution at 1 token per second\n    rewards.setRewardsInfo(\n      ERC20(address(cErc20)),\n      FlywheelStaticRewards.RewardsInfo({ rewardsPerSecond: uint224(1 * 10**rewardDecimal), rewardsEndTimestamp: 0 })\n    );\n\n    // preparation for a later call\n    flywheelsToClaim.push(IonicFlywheelCore(address(flywheel)));\n  }\n\n  function _initialize(uint8 _baseDecimal, uint8 _rewardDecimal) internal {\n    setUpBaseContracts(_baseDecimal, _rewardDecimal);\n    setUpPoolAndMarket();\n    setUpFlywheel();\n    deposit(1 * 10**_baseDecimal);\n    vm.warp(block.timestamp + 1);\n  }\n\n  function deposit(uint256 _amount) public {\n    underlyingToken.mint(user, _amount);\n    vm.startPrank(user);\n    underlyingToken.approve(address(cErc20), _amount);\n    comptroller.enterMarkets(markets);\n    cErc20.mint(_amount);\n    vm.stopPrank();\n  }\n\n  function _testIntegration() internal {\n    uint256 percentFee = flywheel.performanceFee();\n    uint224 percent100 = 100e16; //flywheel.ONE();\n\n    // store expected rewards per token (1 token per second over total supply)\n    uint256 rewardsPerTokenPlusFee = (1 * 10**rewardDecimal * 1 * 10**baseDecimal) / cErc20.totalSupply();\n    uint256 rewardsPerTokenForFee = (rewardsPerTokenPlusFee * percentFee) / percent100;\n    uint256 rewardsPerToken = rewardsPerTokenPlusFee - rewardsPerTokenForFee;\n\n    // store expected user rewards (user balance times reward per second over 1 token)\n    uint256 userRewards = (rewardsPerToken * cErc20.balanceOf(user)) / (1 * 10**baseDecimal);\n\n    ERC20 asErc20 = ERC20(address(cErc20));\n    // accrue rewards and check against expected\n    assertEq(flywheel.accrue(asErc20, user), userRewards, \"!accrue amount\");\n\n    // check market index\n    (uint224 index, ) = flywheel.strategyState(asErc20);\n    assertEq(index, 10**rewardDecimal + rewardsPerToken, \"!index\");\n\n    // claim and check user balance\n    flywheelClaimer.claimRewardsForMarket(user, asErc20, flywheelsToClaim, asArray(true));\n    assertEq(rewardToken.balanceOf(user), userRewards, \"!user rewards\");\n\n    // mint more tokens by user and rerun test\n    deposit(1 * 10**baseDecimal);\n\n    // for next test, advance 10 seconds instead of 1 (multiply expectations by 10)\n    vm.warp(block.timestamp + 10);\n\n    uint256 rewardsPerToken2PlusFee = (1 * 10**rewardDecimal * 1 * 10**baseDecimal) / cErc20.totalSupply();\n    uint256 rewardsPerToken2ForFee = (rewardsPerToken2PlusFee * percentFee) / percent100;\n    uint256 rewardsPerToken2 = rewardsPerToken2PlusFee - rewardsPerToken2ForFee;\n\n    uint256 userRewards2 = (10 * (rewardsPerToken2 * cErc20.balanceOf(user))) / (1 * 10**baseDecimal);\n\n    // accrue all unclaimed rewards and claim them\n    flywheelClaimer.claimRewardsForMarket(user, asErc20, flywheelsToClaim, asArray(true));\n\n    emit log_named_uint(\"userRewards\", userRewards);\n    emit log_named_uint(\"userRewards2\", userRewards2);\n    // user balance should accumulate from both rewards\n    assertEq(rewardToken.balanceOf(user), userRewards + userRewards2, \"balance mismatch\");\n  }\n\n  function testIntegrationRewardStandard(uint8 i, uint8 j) public {\n    vm.assume(i > 1);\n    vm.assume(j > 1);\n    vm.assume(i < 19);\n    vm.assume(j < 19);\n\n    _initialize(i, j);\n    _testIntegration();\n  }\n}\n"
    },
    "contracts/test/MaxBorrowTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./helpers/WithPool.sol\";\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\nimport { PoolLensSecondary } from \"../PoolLensSecondary.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\ncontract MockAsset is MockERC20 {\n  constructor() MockERC20(\"test\", \"test\", 8) {}\n\n  function deposit() external payable {}\n}\n\ncontract MaxBorrowTest is WithPool {\n  address usdcWhale = 0x625E7708f30cA75bfd92586e17077590C60eb4cD;\n  address daiWhale = 0x06959153B974D0D5fDfd87D561db6d8d4FA0bb0B;\n\n  struct LiquidationData {\n    address[] cTokens;\n    ICErc20[] allMarkets;\n    MockAsset usdc;\n    MockAsset dai;\n  }\n\n  function afterForkSetUp() internal override {\n    super.setUpWithPool(\n      MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\")),\n      ERC20Upgradeable(ap.getAddress(\"wtoken\"))\n    );\n\n    if (block.chainid == POLYGON_MAINNET) {\n      vm.prank(0x369582d2010B6eD950B571F4101e3bB9b554876F); // SAND/WMATIC\n      MockERC20(address(underlyingToken)).transfer(address(this), 100e18);\n      setUpPool(\"polygon-test\", false, 0.1e18, 1.1e18);\n    } else if (block.chainid == BSC_MAINNET) {\n      deal(address(underlyingToken), address(this), 100e18);\n      setUpPool(\"bsc-test\", false, 0.1e18, 1.1e18);\n    }\n  }\n\n  // TODO redeploy to polygon to fix\n  function testMaxBorrow() public fork(POLYGON_MAINNET) {\n    PoolLensSecondary poolLensSecondary = new PoolLensSecondary();\n    poolLensSecondary.initialize(poolDirectory);\n\n    LiquidationData memory vars;\n    vm.roll(1);\n    vars.usdc = MockAsset(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    vars.dai = MockAsset(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063);\n\n    deployCErc20Delegate(address(vars.usdc), \"USDC\", \"usdc\", 0.9e18);\n    deployCErc20Delegate(address(vars.dai), \"DAI\", \"dai\", 0.9e18);\n\n    vars.allMarkets = comptroller.getAllMarkets();\n\n    CErc20Delegate cToken = CErc20Delegate(address(vars.allMarkets[0]));\n\n    CErc20Delegate cDaiToken = CErc20Delegate(address(vars.allMarkets[1]));\n\n    vars.cTokens = new address[](1);\n\n    address accountOne = address(1);\n    PoolRolesAuthority pra = ionicAdmin.authoritiesRegistry().poolsAuthorities(address(comptroller));\n\n    vm.startPrank(pra.owner());\n    pra.setUserRole(accountOne, pra.BORROWER_ROLE(), true);\n    vm.stopPrank();\n\n    vm.prank(usdcWhale);\n    MockERC20(address(vars.usdc)).transfer(accountOne, 10000e6);\n\n    vm.prank(daiWhale);\n    MockERC20(address(vars.dai)).transfer(accountOne, 10000e18);\n\n    // Account One Supply\n    {\n      emit log(\"Account One Supply\");\n      vm.startPrank(accountOne);\n      vars.usdc.approve(address(cToken), 1e36);\n      cToken.mint(1e6);\n      vars.cTokens[0] = address(cToken);\n      comptroller.enterMarkets(vars.cTokens);\n\n      vars.dai.approve(address(cDaiToken), 1e36);\n      cDaiToken.mint(1e18);\n      vars.cTokens[0] = address(cDaiToken);\n      comptroller.enterMarkets(vars.cTokens);\n\n      vm.stopPrank();\n      assertEq(cToken.totalSupply(), 1e6 * 5);\n      assertEq(cDaiToken.totalSupply(), 1e18 * 5);\n\n      uint256 maxBorrow = poolLensSecondary.getMaxBorrow(accountOne, ICErc20(address(cToken)));\n      uint256 maxDaiBorrow = poolLensSecondary.getMaxBorrow(accountOne, ICErc20(address(cDaiToken)));\n      assertApproxEqAbs((maxBorrow * 1e18) / 10**cToken.decimals(), maxDaiBorrow, uint256(1e16), \"!max borrow\");\n    }\n\n    // borrow cap for collateral test\n    {\n      vm.prank(comptroller.admin());\n      comptroller._setBorrowCapForCollateral(address(cToken), address(cDaiToken), 0.5e6);\n    }\n\n    uint256 maxBorrowAfterBorrowCap = poolLensSecondary.getMaxBorrow(accountOne, ICErc20(address(cToken)));\n    assertApproxEqAbs(maxBorrowAfterBorrowCap, 0.5e6, uint256(1e5), \"!max borrow\");\n\n    // blacklist\n    {\n      vm.prank(comptroller.admin());\n      comptroller._blacklistBorrowingAgainstCollateral(address(cToken), address(cDaiToken), true);\n    }\n\n    uint256 maxBorrowAfterBlacklist = poolLensSecondary.getMaxBorrow(accountOne, ICErc20(address(cToken)));\n    assertEq(maxBorrowAfterBlacklist, 0, \"!blacklist\");\n  }\n\n  // TODO test with the latest block and contracts and/or without the FSL\n  function testBorrowCapPerCollateral() public debuggingOnly forkAtBlock(BSC_MAINNET, 23761190) {\n    address payable jFiatPoolAddress = payable(0x31d76A64Bc8BbEffb601fac5884372DEF910F044);\n\n    address poolAddress = jFiatPoolAddress;\n    Comptroller pool = Comptroller(poolAddress);\n\n    ComptrollerFirstExtension asExtension = ComptrollerFirstExtension(poolAddress);\n    address[] memory borrowers = asExtension.getAllBorrowers();\n    address someBorrower = borrowers[1];\n\n    ICErc20[] memory markets = asExtension.getAllMarkets();\n    for (uint256 i = 0; i < markets.length; i++) {\n      ICErc20 market = markets[i];\n      uint256 borrowed = market.borrowBalanceCurrent(someBorrower);\n      if (borrowed > 0) {\n        emit log(\"borrower has borrowed\");\n        emit log_uint(borrowed);\n        emit log(\"from market\");\n        emit log_address(address(market));\n        emit log_uint(i);\n        emit log(\"\");\n      }\n\n      uint256 collateral = market.balanceOf(someBorrower);\n      if (collateral > 0) {\n        emit log(\"has collateral\");\n        emit log_uint(collateral);\n        emit log(\"in market\");\n        emit log_address(address(market));\n        emit log_uint(i);\n        emit log(\"\");\n      }\n    }\n\n    ICErc20 marketToBorrow = markets[0];\n    ICErc20 cappedCollateralMarket = markets[6];\n    uint256 borrowAmount = marketToBorrow.borrowBalanceCurrent(someBorrower);\n\n    {\n      (uint256 errBefore, , uint256 liquidityBefore, uint256 shortfallBefore) = pool.getHypotheticalAccountLiquidity(\n        someBorrower,\n        address(marketToBorrow),\n        0,\n        borrowAmount,\n        0\n      );\n      emit log(\"errBefore\");\n      emit log_uint(errBefore);\n      emit log(\"liquidityBefore\");\n      emit log_uint(liquidityBefore);\n      emit log(\"shortfallBefore\");\n      emit log_uint(shortfallBefore);\n\n      assertGt(liquidityBefore, 0, \"expected positive liquidity\");\n    }\n\n    vm.prank(pool.admin());\n    asExtension._setBorrowCapForCollateral(address(marketToBorrow), address(cappedCollateralMarket), 1);\n    emit log(\"\");\n\n    (uint256 errAfter, , uint256 liquidityAfter, uint256 shortfallAfter) = pool.getHypotheticalAccountLiquidity(\n      someBorrower,\n      address(marketToBorrow),\n      0,\n      borrowAmount,\n      0\n    );\n    emit log(\"errAfter\");\n    emit log_uint(errAfter);\n    emit log(\"liquidityAfter\");\n    emit log_uint(liquidityAfter);\n    emit log(\"shortfallAfter\");\n    emit log_uint(shortfallAfter);\n\n    assertGt(shortfallAfter, 0, \"expected some shortfall\");\n  }\n}\n"
    },
    "contracts/test/MaxWithdrawTest.t.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity >=0.8.0;\n\n// import \"./helpers/WithPool.sol\";\n// import { BaseTest } from \"./config/BaseTest.t.sol\";\n// import \"forge-std/Test.sol\";\n\n// import { ERC20 } from \"solmate/tokens/ERC20.sol\";\n// import { FuseFlywheelDynamicRewards } from \"fuse-flywheel/rewards/FuseFlywheelDynamicRewards.sol\";\n// import { MockERC20 } from \"solmate/test/utils/mocks/MockERC20.sol\";\n// import { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\n// import { IRedemptionStrategy } from \"../liquidators/IRedemptionStrategy.sol\";\n// import { IFundsConversionStrategy } from \"../liquidators/IFundsConversionStrategy.sol\";\n// import { IUniswapV2Router02 } from \"../external/uniswap/IUniswapV2Router02.sol\";\n// import { PoolLensSecondary } from \"../PoolLensSecondary.sol\";\n// import { UniswapLpTokenLiquidator } from \"../liquidators/UniswapLpTokenLiquidator.sol\";\n// import { IUniswapV2Pair } from \"../external/uniswap/IUniswapV2Pair.sol\";\n// import { IUniswapV2Factory } from \"../external/uniswap/IUniswapV2Factory.sol\";\n// import { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\n// contract MockAsset is MockERC20 {\n//   constructor() MockERC20(\"test\", \"test\", 8) {}\n\n//   function deposit() external payable {}\n// }\n\n// contract MaxWithdrawTest is WithPool {\n//   struct LiquidationData {\n//     address[] cTokens;\n//     ICErc20[] allMarkets;\n//     MockAsset bnb;\n//     MockAsset mimo;\n//     MockAsset usdc;\n//   }\n\n//   function afterForkSetUp() internal override {\n//     super.setUpWithPool(\n//       MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\")),\n//       ERC20Upgradeable(ap.getAddress(\"wtoken\"))\n//     );\n\n//     deal(address(underlyingToken), address(this), 100e18);\n//     setUpPool(\"bsc-test\", false, 0.1e18, 1.1e18);\n//   }\n\n//   function testMaxWithdrawBsc() public fork(BSC_MAINNET) {\n//     PoolLensSecondary poolLensSecondary = new PoolLensSecondary();\n//     poolLensSecondary.initialize(poolDirectory);\n\n//     LiquidationData memory vars;\n//     vm.roll(1);\n//     vars.bnb = MockAsset(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n//     vars.usdc = MockAsset(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n\n//     deployCErc20Delegate(address(vars.bnb), \"BNB\", \"bnb\", 0.9e18);\n//     deployCErc20Delegate(address(vars.usdc), \"USDC\", \"usdc\", 0.9e18);\n\n//     // TODO no need to upgrade after the next deploy\n//     upgradePool(address(comptroller));\n\n//     vars.allMarkets = comptroller.getAllMarkets();\n//     CErc20Delegate cBnbToken = CErc20Delegate(address(vars.allMarkets[0]));\n\n//     CErc20Delegate cUSDC = CErc20Delegate(address(vars.allMarkets[1]));\n\n//     vars.cTokens = new address[](1);\n//     vars.cTokens[0] = address(cBnbToken);\n\n//     address accountOne = address(1);\n//     address accountTwo = address(2);\n//     address accountThree = address(3);\n\n//     {\n//       address comptrollerAddress = address(comptroller);\n//       AuthoritiesRegistry ar = ionicAdmin.authoritiesRegistry();\n//       PoolRolesAuthority poolAuth = ar.poolsAuthorities(comptrollerAddress);\n//       ar.setUserRole(comptrollerAddress, accountOne, poolAuth.BORROWER_ROLE(), true);\n//       ar.setUserRole(comptrollerAddress, accountTwo, poolAuth.BORROWER_ROLE(), true);\n//       ar.setUserRole(comptrollerAddress, accountThree, poolAuth.BORROWER_ROLE(), true);\n//     }\n\n//     // Account One Supply\n//     deal(address(vars.bnb), accountOne, 5000000000e18);\n//     deal(address(vars.bnb), accountThree, 5000000000e18);\n//     deal(address(vars.usdc), accountTwo, 10000e18);\n\n//     // Account One Supply\n//     {\n//       emit log(\"Account One Supply\");\n//       vm.startPrank(accountOne);\n//       vars.bnb.approve(address(cBnbToken), 1e36);\n//       assertEq(cBnbToken.mint(1e18), 0, \"!cbnb mint acc 1\");\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//     }\n\n//     // Account Three Supply\n//     {\n//       emit log(\"Account Three Supply\");\n//       vm.startPrank(accountThree);\n//       vars.bnb.approve(address(cBnbToken), 1e36);\n//       assertEq(cBnbToken.mint(1e18), 0, \"!cbnb mint acc 3\");\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//     }\n\n//     // Account Two Supply\n//     {\n//       emit log(\"Account Two Supply\");\n//       vm.startPrank(accountTwo);\n//       vars.usdc.approve(address(cUSDC), 1e36);\n//       assertEq(cUSDC.mint(1000e18), 0, \"!cusdc mint acc 2\");\n//       vars.cTokens[0] = address(cUSDC);\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//       assertEq(cUSDC.totalSupply(), 1000e18 * 5, \"!cUSDC total supply\");\n//       assertEq(cBnbToken.totalSupply(), 1e18 * 5 * 2, \"!cBNB total supply\");\n//     }\n\n//     // Account Two Borrow\n//     {\n//       emit log(\"Account Two Borrow\");\n//       vm.startPrank(accountTwo);\n//       assertEq(cBnbToken.borrow(0.5e18), 0, \"!cbnb borrow acc 2\");\n//       vm.stopPrank();\n//     }\n\n//     // Account One Borrow\n//     {\n//       emit log(\"Account One Borrow\");\n//       vm.startPrank(accountOne);\n//       assertEq(cUSDC.borrow(110e18), 0, \"!cusdc borrow acc 1\");\n//       assertEq(cUSDC.totalBorrows(), 110e18, \"!total borrows\");\n\n//       uint256 maxWithdraw = poolLensSecondary.getMaxRedeem(accountOne, ICErc20(address(cBnbToken)));\n\n//       uint256 beforeBnbBalance = vars.bnb.balanceOf(accountOne);\n//       cBnbToken.redeemUnderlying(type(uint256).max);\n//       uint256 afterBnbBalance = vars.bnb.balanceOf(accountOne);\n\n//       assertEq(afterBnbBalance - beforeBnbBalance, maxWithdraw, \"!bnb diff\");\n//       vm.stopPrank();\n//     }\n//   }\n\n//   function testMIIMOMaxWithdraw() public fork(POLYGON_MAINNET) {\n//     PoolLensSecondary poolLensSecondary = new PoolLensSecondary();\n//     poolLensSecondary.initialize(poolDirectory);\n\n//     LiquidationData memory vars;\n//     vm.roll(1);\n//     vars.mimo = MockAsset(0xADAC33f543267c4D59a8c299cF804c303BC3e4aC);\n//     vars.usdc = MockAsset(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n\n//     deployCErc20Delegate(address(vars.mimo), \"MIMO\", \"mimo\", 0.9e18);\n//     deployCErc20Delegate(address(vars.usdc), \"USDC\", \"usdc\", 0.9e18);\n\n//     vars.allMarkets = comptroller.getAllMarkets();\n//     CErc20Delegate cMimoToken = CErc20Delegate(address(vars.allMarkets[0]));\n\n//     CErc20Delegate cUSDC = CErc20Delegate(address(vars.allMarkets[1]));\n\n//     vars.cTokens = new address[](1);\n\n//     address accountOne = address(1);\n//     address accountTwo = address(2);\n//     address accountThree = address(3);\n\n//     {\n//       address comptrollerAddress = address(comptroller);\n//       AuthoritiesRegistry ar = ionicAdmin.authoritiesRegistry();\n//       PoolRolesAuthority poolAuth = ar.poolsAuthorities(comptrollerAddress);\n//       ar.setUserRole(comptrollerAddress, accountOne, poolAuth.BORROWER_ROLE(), true);\n//       ar.setUserRole(comptrollerAddress, accountTwo, poolAuth.BORROWER_ROLE(), true);\n//       ar.setUserRole(comptrollerAddress, accountThree, poolAuth.BORROWER_ROLE(), true);\n//     }\n\n//     deal(address(vars.mimo), accountOne, 5e27);\n//     deal(address(vars.mimo), accountThree, 5e27);\n//     deal(address(vars.usdc), accountTwo, 10000e6);\n\n//     // Account One Supply\n//     {\n//       emit log(\"Account One Supply\");\n//       vm.startPrank(accountOne);\n//       vars.mimo.approve(address(cMimoToken), 1e36);\n//       assertEq(cMimoToken.mint(10e24), 0, \"!cmimo mint acc 1\");\n//       vars.cTokens[0] = address(cMimoToken);\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//     }\n\n//     // Account Three Supply\n//     {\n//       emit log(\"Account Three Supply\");\n//       vm.startPrank(accountThree);\n//       vars.mimo.approve(address(cMimoToken), 1e36);\n//       assertEq(cMimoToken.mint(10e24), 0, \"!cmimo mint acc 3\");\n//       vars.cTokens[0] = address(cMimoToken);\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//     }\n\n//     // Account Two Supply\n//     {\n//       emit log(\"Account Two Supply\");\n//       vm.startPrank(accountTwo);\n//       vars.usdc.approve(address(cUSDC), 1e36);\n//       assertEq(cUSDC.mint(1000e6), 0, \"!cusdc mint acc 2\");\n//       vars.cTokens[0] = address(cUSDC);\n//       comptroller.enterMarkets(vars.cTokens);\n//       vm.stopPrank();\n//       assertEq(cUSDC.totalSupply(), 1000e6 * 5, \"!cUSDC total supply\");\n//       assertEq(cMimoToken.totalSupply(), 10000000e18 * 5 * 2, \"!cMimo total supply\");\n//     }\n\n//     // Account Two Borrow\n//     {\n//       emit log(\"Account Two Borrow\");\n//       vm.startPrank(accountTwo);\n//       uint256 maxBorrow = poolLensSecondary.getMaxBorrow(accountTwo, ICErc20(address(cMimoToken)));\n//       emit log_uint(maxBorrow);\n//       assertEq(cMimoToken.borrow(maxBorrow), 0, \"!cmimo borrow acc 2\");\n//       assertEq(cMimoToken.totalBorrows(), maxBorrow, \"!cMimo total borrows\");\n\n//       vm.stopPrank();\n//     }\n\n//     // Account One Borrow\n//     {\n//       emit log(\"Account One Borrow\");\n//       vm.startPrank(accountOne);\n//       vars.usdc.approve(address(cUSDC), 1e36);\n//       assertEq(cUSDC.borrow(150e6), 0, \"!cusdc borrow acc 1\");\n//       assertEq(cUSDC.totalBorrows(), 150e6, \"!cUSDC total borrows\");\n\n//       uint256 maxWithdraw = poolLensSecondary.getMaxRedeem(accountOne, ICErc20(address(cMimoToken)));\n\n//       uint256 beforeMimoBalance = vars.mimo.balanceOf(accountOne);\n//       cMimoToken.redeemUnderlying(type(uint256).max);\n//       uint256 afterMimoBalance = vars.mimo.balanceOf(accountOne);\n\n//       assertEq(afterMimoBalance - beforeMimoBalance, maxWithdraw, \"!mimo diff\");\n//       vm.stopPrank();\n//     }\n//   }\n// }\n"
    },
    "contracts/test/MinBorrowTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract MinBorrowTest is BaseTest {\n  FeeDistributor ffd;\n\n  function afterForkSetUp() internal override {\n    ffd = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n  }\n\n  function testMinBorrow() public fork(BSC_MAINNET) {\n    IERC20Upgradeable usdc = IERC20Upgradeable(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n    IERC20Upgradeable busd = IERC20Upgradeable(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n    ICErc20 usdcMarket = ICErc20(0x16B8da195CdC7F380B333bf6cF2f0f33c1061755);\n    ICErc20 busdMarket = ICErc20(0x3BCb7dbBe729B24bE6c660B3e8ADD1Cb352e371D);\n    IonicComptroller comptroller = usdcMarket.comptroller();\n    deal(address(usdc), address(this), 10000e18);\n    deal(address(busd), address(1), 10000e18);\n\n    usdc.approve(address(usdcMarket), 1e36);\n    usdcMarket.mint(1000e18);\n\n    vm.startPrank(address(1));\n    busd.approve(address(busdMarket), 1e36);\n    busdMarket.mint(1000e18);\n    vm.stopPrank();\n\n    // the 0 liquidity base min borrow amount\n    uint256 baseMinBorrowEth = ffd.minBorrowEth();\n\n    address[] memory cTokens = new address[](2);\n    cTokens[0] = address(usdcMarket);\n    cTokens[1] = address(busdMarket);\n    comptroller.enterMarkets(cTokens);\n\n    uint256 minBorrowEth = ffd.getMinBorrowEth(busdMarket);\n    assertEq(minBorrowEth, baseMinBorrowEth, \"!minBorrowEth for default min borrow eth\");\n\n    busdMarket.borrow(300e18);\n\n    minBorrowEth = ffd.getMinBorrowEth(busdMarket);\n    assertEq(minBorrowEth, 0, \"!minBorrowEth after borrowing less amount than min amount\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/AlgebraPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { AlgebraPriceOracle } from \"../../../oracles/default/AlgebraPriceOracle.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"../../../oracles/default/ConcentratedLiquidityBasePriceOracle.sol\";\nimport { IAlgebraPool } from \"../../../external/algebra/IAlgebraPool.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract AlgebraPriceOracleTest is BaseTest {\n  AlgebraPriceOracle oracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address wbtc;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    stable = ap.getAddress(\"stableToken\");\n    wtoken = ap.getAddress(\"wtoken\"); // WETH\n    wbtc = ap.getAddress(\"wBTCToken\"); // WBTC\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new AlgebraPriceOracle();\n\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n  }\n\n  function testBscAssets() public forkAtBlock(BSC_MAINNET, 27513712) {\n    address thena = 0xF4C8E32EaDEC4BFe97E0F595AdD0f4450a863a11; // THE (18 decimals)\n    address usdt = 0x55d398326f99059fF775485246999027B3197955; // USDT (18 decimals)\n\n    address[] memory underlyings = new address[](2);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](2);\n\n    underlyings[0] = thena;\n    underlyings[1] = usdt;\n\n    // THE-WBNB\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x51Bd5e6d3da9064D59BcaA5A76776560aB42cEb8,\n      10 minutes,\n      wtoken\n    );\n    // USDT-USDC\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x1b9a1120a17617D8eC4dC80B921A9A1C50Caef7d,\n      10 minutes,\n      stable\n    );\n\n    uint256[] memory expPrices = new uint256[](2);\n    expPrices[0] = 1279780177402873; // == 0,001279 BNB -> $0,418 / $326 = 0,0012822   (20/04/2023)\n    expPrices[1] = mpo.price(usdt);\n\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n\n    assertEq(prices[0], expPrices[0], \"!Price Error\");\n    assertApproxEqRel(prices[1], expPrices[1], 1e17, \"!Price Error\");\n  }\n\n  function testPolygonAssets() public forkAtBlock(POLYGON_MAINNET, 46013460) {\n    address maticX = 0xfa68FB4628DFF1028CFEc22b4162FCcd0d45efb6;\n    address dai = 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063;\n    address[] memory underlyings = new address[](3);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](3);\n\n    // 18 / 18\n    underlyings[0] = maticX; // MaticX (18 decimals)\n    // 8 / 6\n    underlyings[1] = wbtc; // WBTC (8 decimals)\n    // 18 / 6\n    underlyings[2] = dai; // DAI (18 decimals)\n\n    // MaticX-Wmatic\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x05BFE97Bf794a4DB69d3059091F064eA0a5E538E,\n      10 minutes,\n      wtoken\n    );\n    // WBTC-USDC\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xA5CD8351Cbf30B531C7b11B0D9d3Ff38eA2E280f,\n      10 minutes,\n      stable\n    );\n    // DAI-USDC\n    configs[2] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xe7E0eB9F6bCcCfe847fDf62a3628319a092F11a2,\n      10 minutes,\n      stable\n    );\n\n    uint256[] memory expPrices = new uint256[](3);\n    expPrices[0] = 1072289959017680334; //  0,72$ / 0,67$ =  1,07 MATIC   (07/07/2023)\n    expPrices[1] = mpo.price(wbtc);\n    expPrices[2] = mpo.price(dai);\n\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n\n    assertEq(prices[0], expPrices[0], \"!Price Error\");\n    assertApproxEqRel(prices[1], expPrices[1], 1e17, \"!Price Error\");\n    assertApproxEqRel(prices[2], expPrices[2], 1e17, \"!Price Error\");\n  }\n\n  function testZkEvmAssets() public forkAtBlock(ZKEVM_MAINNET, 4167547) {\n    address usdt = 0x1E4a5963aBFD975d8c9021ce480b42188849D41d; // 6 decimals\n    address wmatic = 0xa2036f0538221a77A3937F1379699f44945018d0;\n\n    address[] memory underlyings = new address[](3);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](3);\n\n    underlyings[0] = wmatic; // WMATIC (18 decimals)\n    underlyings[1] = wbtc; // WBTC (8 decimals)\n    underlyings[2] = usdt; // WBTC (6 decimals)\n\n    // WMATIC-WETH\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xB73AbFb5a2C89f4038baA476Ff3A7942A021c196,\n      10 minutes,\n      wtoken\n    );\n    // WBTC-WETH\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xFC4A3A7dc6b62bd2EA595b106392f5E006083b83,\n      10 minutes,\n      wtoken\n    );\n    // USDT-USDC\n    configs[2] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x9591b8A30c3a52256ea93E98dA49EE43Afa136A8,\n      10 minutes,\n      stable\n    );\n\n    uint256[] memory expPrices = new uint256[](3);\n    expPrices[0] = 366000000000000; //  $0.670691 / 1833$ =  0,000366   (07/07x/2023)\n    expPrices[1] = 15849057118531331165; // $29,016.86 / 1833$ = 15,85  (07/07/2023)\n    expPrices[2] = 545553737043099; // $1 / 1833$ = 0,000545$           (07/07/2023)\n\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n\n    assertApproxEqRel(prices[0], expPrices[0], 1e17, \"!Price Error\");\n    assertApproxEqRel(prices[1], expPrices[1], 1e17, \"!Price Error\");\n    assertApproxEqRel(prices[2], expPrices[2], 1e17, \"!Price Error\");\n  }\n\n  function getPriceFeed(address[] memory underlyings, ConcentratedLiquidityBasePriceOracle.AssetConfig[] memory configs)\n    internal\n    returns (uint256[] memory price)\n  {\n    vm.prank(oracle.owner());\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.roll(1);\n\n    price = new uint256[](underlyings.length);\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      vm.prank(address(mpo));\n      price[i] = oracle.price(underlyings[i]);\n    }\n    return price;\n  }\n\n  function testSetUnsupportedBaseToken() public fork(POLYGON_MAINNET) {\n    address usdt = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\n    address ixt = 0xE06Bd4F5aAc8D0aA337D13eC88dB6defC6eAEefE;\n\n    address[] memory underlyings = new address[](1);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](1);\n\n    underlyings[0] = ixt;\n\n    // USDT/IXT\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xD6e486c197606559946384AE2624367d750A160f,\n      10 minutes,\n      usdt\n    );\n    // revert if underlying is not supported\n    vm.startPrank(oracle.owner());\n    vm.expectRevert(bytes(\"Base token must be supported\"));\n    oracle.setPoolFeeds(underlyings, configs);\n\n    // add it successfully when suported\n    oracle._setSupportedBaseTokens(asArray(usdt, stable));\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.stopPrank();\n\n    // check prices\n    vm.prank(address(mpo));\n    uint256 price = oracle.price(ixt);\n    assertTrue(price > 0, \"!Price Error\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/AnkrCertificateTokenPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { AnkrCertificateTokenPriceOracle } from \"../../../oracles/default/AnkrCertificateTokenPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\n\ncontract AnkrCertificateTokenPriceOracleTest is BaseTest {\n  AnkrCertificateTokenPriceOracle private oracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address aFTMc = 0xCfC785741Dc0e98ad4c9F6394Bb9d43Cd1eF5179;\n  address ankrBNB = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n  address aMATICc = 0x0E9b89007eEE9c958c0EDA24eF70723C2C93dD58;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    wtoken = ap.getAddress(\"wtoken\");\n    oracle = new AnkrCertificateTokenPriceOracle();\n    if (block.chainid == BSC_MAINNET) {\n      oracle.initialize(ankrBNB);\n    } else if (block.chainid == POLYGON_MAINNET) {\n      oracle.initialize(aMATICc);\n    }\n  }\n\n  function testAnkrBSCOracle() public forkAtBlock(BSC_MAINNET, 24150586) {\n    uint256 priceAnkrBNB = oracle.price(ankrBNB);\n    assertGt(priceAnkrBNB, 1e18);\n    assertEq(priceAnkrBNB, 1040035572321529337);\n  }\n\n  function testAnkrPolygonOracle() public fork(POLYGON_MAINNET) {\n    uint256 priceAnkrMATICc = oracle.price(aMATICc);\n    uint256 pricWmatic = mpo.price(wtoken);\n    assertGt(priceAnkrMATICc, 1e18);\n    assertGt(priceAnkrMATICc, pricWmatic);\n  }\n}\n"
    },
    "contracts/test/oracles/default/API3PriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { API3PriceOracle } from \"../../../oracles/default/API3PriceOracle.sol\";\nimport { IProxy } from \"../../../external/api3/IProxy.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\ncontract API3PriceOracleTest is BaseTest {\n  API3PriceOracle private oracle;\n  MasterPriceOracle mpo;\n  address stableToken;\n  address otherToken;\n  address anotherToken;\n  address wbtc;\n  address wtoken;\n  address NATIVE_TOKEN_USD_PRICE_FEED;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    stableToken = ap.getAddress(\"stableToken\");\n    wbtc = ap.getAddress(\"wBTCToken\");\n    wtoken = ap.getAddress(\"wtoken\");\n    oracle = new API3PriceOracle();\n    if (block.chainid == ZKEVM_MAINNET) {\n      // ETH-USD\n      NATIVE_TOKEN_USD_PRICE_FEED = 0x26690F9f17FdC26D419371315bc17950a0FC90eD;\n    } else {\n      revert(\"Unsupported chain\");\n    }\n  }\n\n  function setUpZkEvm() public {\n    vm.prank(mpo.admin());\n    oracle.initialize(stableToken, NATIVE_TOKEN_USD_PRICE_FEED);\n\n    address[] memory underlyings = new address[](4);\n    address[] memory proxies = new address[](4);\n\n    // USDT\n    otherToken = 0x1E4a5963aBFD975d8c9021ce480b42188849D41d;\n    // WMATIC\n    anotherToken = 0xa2036f0538221a77A3937F1379699f44945018d0;\n\n    underlyings[0] = stableToken;\n    underlyings[1] = otherToken;\n    underlyings[2] = anotherToken;\n    underlyings[3] = wbtc;\n\n    proxies[0] = 0x8DF7d919Fe9e866259BB4D135922c5Bd96AF6A27;\n    proxies[1] = 0xF63Fa6EA00678F435Ae3e845541EBb2Db0a1e8fF;\n    proxies[2] = 0xF63Fa6EA00678F435Ae3e845541EBb2Db0a1e8fF;\n    proxies[3] = 0xe5Cf15fED24942E656dBF75165aF1851C89F21B5;\n\n    vm.prank(oracle.owner());\n    oracle.setPriceFeeds(underlyings, proxies);\n\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](4);\n    oracles[0] = oracle;\n    oracles[1] = oracle;\n    oracles[2] = oracle;\n    oracles[3] = oracle;\n\n    vm.prank(mpo.admin());\n    mpo.add(underlyings, oracles);\n  }\n\n  function testAPI3PriceOracleZkEvm() public fork(ZKEVM_MAINNET) {\n    setUpZkEvm();\n    vm.startPrank(address(mpo));\n    uint256 api3UsdcPrice = oracle.price(stableToken);\n    uint256 api3UsdtPrice = oracle.price(otherToken);\n    uint256 api3WmaticPrice = oracle.price(anotherToken);\n    uint256 api3WbtcPrice = oracle.price(wbtc);\n    uint256 mpoWethPrice = mpo.price(wtoken);\n    vm.stopPrank();\n\n    assertApproxEqRel(api3UsdcPrice, api3UsdtPrice, 1e16);\n\n    assertGt(api3UsdcPrice, api3WmaticPrice);\n    assertGt(api3WbtcPrice, mpoWethPrice);\n    assertGt(mpoWethPrice, api3UsdcPrice);\n  }\n}\n"
    },
    "contracts/test/oracles/default/BalancerLpPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { BalancerLpTokenPriceOracle } from \"../../../oracles/default/BalancerLpTokenPriceOracle.sol\";\nimport { BalancerLpTokenPriceOracleNTokens } from \"../../../oracles/default/BalancerLpTokenPriceOracleNTokens.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\nimport \"../../../external/balancer/IBalancerPool.sol\";\nimport \"../../../external/balancer/IBalancerVault.sol\";\nimport \"../../../external/balancer/BNum.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract BalancerLpTokenPriceOracleTest is BaseTest, BNum {\n  BalancerLpTokenPriceOracle oracle;\n  BalancerLpTokenPriceOracleNTokens oracleNTokens;\n\n  MasterPriceOracle mpo;\n\n  address wbtc = 0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6;\n  address weth = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;\n\n  address balWeth2080 = 0x3d468AB2329F296e1b9d8476Bb54Dd77D8c2320f;\n  address wbtcWeth5050 = 0xCF354603A9AEbD2Ff9f33E1B04246d8Ea204ae95;\n  address wmaticUsdcWethBal25252525 = 0x0297e37f1873D2DAb4487Aa67cD56B58E2F27875;\n  address threeBrl333333 = 0x5A5E4Fa45Be4c9cb214cD4EC2f2eB7053F9b4F6D;\n\n  address mimoPar8020 = 0x82d7f08026e21c7713CfAd1071df7C8271B17Eae;\n  address mimoPar8020_c = 0xcb67Bd2aE0597eDb2426802CdF34bb4085d9483A;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new BalancerLpTokenPriceOracle();\n    oracleNTokens = new BalancerLpTokenPriceOracleNTokens();\n    oracle.initialize(mpo);\n    oracleNTokens.initialize(mpo);\n  }\n\n  // TODO: add test for mimo / par pair, when we deploy the MIMO DIA price oracle\n  // See: https://github.com/Midas-Protocol/monorepo/issues/476\n  function testPriceBalancer() public forkAtBlock(POLYGON_MAINNET, 46024675) {\n    // 2-token pools\n    uint256 priceWbtcEth = oracle.price(wbtcWeth5050);\n    uint256 priceNTokensWbtEth = oracleNTokens.price(wbtcWeth5050);\n\n    uint256 priceMimoPar = oracle.price(mimoPar8020);\n    uint256 priceNTokensMimoPar = oracleNTokens.price(mimoPar8020);\n    uint256 underlyingPriceMimoPar = mpo.getUnderlyingPrice(ICErc20(mimoPar8020_c));\n\n    // Based on this tx: https://polygonscan.com/tx/0x206f359e35b49265c7b3cb28691e1ca547ae79475af8e479331dc936fcbf0dd0\n    // 1220 USD$ worth of liquidity was removed for 0,197227836914 wbtcWeth5050 tokens\n\n    // (1220 / 0,19722783691) = 6.185,7 USD / wbtcWeth5050\n    // 6.185,7 / 1.00 =  6.185,7 wbtcWeth5050 / MATIC   [1 MATIC ~= 1 USD$]\n    // 6.185,7 * 1e18 ~ 6.185e21\n    // Updated: 07/07/2023\n    assertEq(priceWbtcEth, 11262839540893715595453);\n    // Max deviation of 1e17, or 0.1%\n    assertApproxEqRel(priceWbtcEth, priceNTokensWbtEth, 1e17);\n\n    // Based on this tx: https://polygonscan.com/tx/0x38eda84addb9392a1bd15b1fe518de6d9e4a6dc3df7a611aba5d4ddf5cc83b47\n    // 0,03 USD$ worth of liquidity was removed for 0,92153 mimoPar8020 tokens\n\n    // (0,03 / 0,92153) = 0,03255 USD / mimoPar8020\n    // 0,03255 / 1.00 = 0,03255 mimoPar8020 / MATIC   [1 MATIC ~= 1 USD$]\n    // 0,03255 * 1e18 ~ 3,255e16\n\n    assertEq(priceMimoPar, 55237961865401672);\n    assertEq(priceMimoPar, underlyingPriceMimoPar);\n    // Max deviation of 1e17, or 0.1%\n    assertApproxEqRel(priceMimoPar, priceNTokensMimoPar, 1e17);\n\n    // 4-token pools\n    uint256 priceNTokenswmaticUsdcWethBal = oracleNTokens.price(wmaticUsdcWethBal25252525);\n\n    // Based on this tx: https://polygonscan.com/tx/0x206f359e35b49265c7b3cb28691e1ca547ae79475af8e479331dc936fcbf0dd0\n    // 5390 USD$ worth of liquidity was removed for 440,3219429 wmaticUsdcWethBal25252525 tokens\n\n    // (5390 / 440,321) = 12,2410 USD / wmaticUsdcWethBal25252525\n    // 12,2410 / 1.00 = 12,2410 wmaticUsdcWethBal25252525 / MATIC   [1 MATIC ~= 1 USD$]\n    // 12,2410 * 1e18 ~ 1,2241e19\n    // Updated: 07/07/2023\n    assertEq(priceNTokenswmaticUsdcWethBal, 15468228316697206187);\n  }\n}\n"
    },
    "contracts/test/oracles/default/BalancerLpStablePoolPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BalancerLpStablePoolPriceOracle } from \"../../../oracles/default/BalancerLpStablePoolPriceOracle.sol\";\nimport { BalancerLpLinearPoolPriceOracle } from \"../../../oracles/default/BalancerLpLinearPoolPriceOracle.sol\";\nimport { BalancerRateProviderOracle } from \"../../../oracles/default/BalancerRateProviderOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { IBalancerLinearPool } from \"../../../external/balancer/IBalancerLinearPool.sol\";\nimport { IBalancerStablePool } from \"../../../external/balancer/IBalancerStablePool.sol\";\nimport { IBalancerVault, UserBalanceOp } from \"../../../external/balancer/IBalancerVault.sol\";\nimport { BalancerReentrancyAttacker } from \"../../helpers/BalancerReentrancyAttacker.sol\";\n\ncontract BalancerLpStablePoolPriceOracleTest is BaseTest {\n  BalancerLpStablePoolPriceOracle stableLpOracle;\n  BalancerLpLinearPoolPriceOracle linearLpOracle;\n  BalancerRateProviderOracle rateProviderOracle;\n  MasterPriceOracle mpo;\n\n  address MATICx_AaveMATIC_pool = 0xE78b25c06dB117fdF8F98583CDaaa6c92B79E917;\n  address stMATIC_AaveMATIC_pool = 0x216690738Aac4aa0C4770253CA26a28f0115c595;\n  address stMATIC_WMATIC_pool = 0x8159462d255C1D24915CB51ec361F700174cD994;\n  address jBRL_BRZ_pool = 0xE22483774bd8611bE2Ad2F4194078DaC9159F4bA;\n  address jEUR_agEUR_pool = 0xa48D164F6eB0EDC68bd03B56fa59E12F24499aD1;\n  address MATICx_WMATIC_pool = 0xb20fC01D21A50d2C734C4a1262B4404d41fA7BF0;\n  address csMATIC_WMATIC_pool = 0x02d2e2D7a89D6c5CB3681cfCb6F7dAC02A55eDA4;\n\n  address boostedAavePool = 0x48e6B98ef6329f8f0A30eBB8c7C960330d648085;\n  address linearAaveUsdtPool = 0xFf4ce5AAAb5a627bf82f4A571AB1cE94Aa365eA6;\n  address linearAaveUsdcPool = 0xF93579002DBE8046c43FEfE86ec78b1112247BB8;\n  address linearAaveDaiPool = 0x178E029173417b1F9C8bC16DCeC6f697bC323746;\n  address linearAaveWmaticPool = 0xE4885Ed2818Cc9E840A25f94F9b2A28169D1AEA7;\n\n  address boostedTetuPool = 0xb3d658d5b95BF04E2932370DD1FF976fe18dd66A;\n  address linearTetuUsdtPool = 0x7c82A23B4C48D796dee36A9cA215b641C6a8709d;\n  address linearTetuUsdcPool = 0xae646817e458C0bE890b81e8d880206710E3c44e;\n  address linearTetuDaiPool = 0xDa1CD1711743e57Dd57102E9e61b75f3587703da;\n\n  address wtoken;\n  address stMATIC = 0x3A58a54C066FdC0f2D55FC9C89F0415C92eBf3C4;\n  address MATICx = 0xfa68FB4628DFF1028CFEc22b4162FCcd0d45efb6;\n  address csMATIC = 0xFcBB00dF1d663eeE58123946A30AB2138bF9eb2A;\n  address agEUR = 0xE0B52e49357Fd4DAf2c15e02058DCE6BC0057db4;\n  address jEUR = 0x4e3Decbb3645551B8A19f0eA1678079FCB33fB4c;\n  address jBRL = 0xf2f77FE7b8e66571E0fca7104c4d670BF1C8d722;\n  address BRZ = 0x491a4eB4f1FC3BfF8E1d2FC856a6A46663aD556f;\n  address usdt = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\n  address usdc = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n  address dai = 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063;\n  address mai = 0xa3Fa99A148fA48D14Ed51d610c367C61876997F1;\n\n  address csMATICRateProvider = 0x87393BE8ac323F2E63520A6184e5A8A9CC9fC051;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    wtoken = ap.getAddress(\"wtoken\");\n\n    address[] memory linearAaveLps = asArray(linearAaveUsdtPool, linearAaveUsdcPool, linearAaveDaiPool);\n    address[] memory linearTetuLps = asArray(linearTetuUsdtPool, linearTetuUsdcPool, linearTetuDaiPool);\n\n    stableLpOracle = new BalancerLpStablePoolPriceOracle();\n    stableLpOracle.initialize();\n\n    linearLpOracle = new BalancerLpLinearPoolPriceOracle();\n    linearLpOracle.initialize(linearAaveLps);\n    linearLpOracle.registerToken(linearAaveWmaticPool);\n\n    vm.startPrank(linearLpOracle.owner());\n    for (uint256 i = 0; i < linearTetuLps.length; i++) {\n      linearLpOracle.registerToken(linearTetuLps[i]);\n    }\n    vm.stopPrank();\n\n    rateProviderOracle = new BalancerRateProviderOracle();\n    rateProviderOracle.initialize(asArray(csMATICRateProvider), asArray(wtoken), asArray(csMATIC));\n\n    // Add the oracles to the MPO\n    BasePriceOracle[] memory aaveLinerlpOracles = new BasePriceOracle[](linearAaveLps.length);\n    for (uint256 i = 0; i < linearAaveLps.length; i++) {\n      aaveLinerlpOracles[i] = linearLpOracle;\n    }\n    BasePriceOracle[] memory tetuLinearlpOracles = new BasePriceOracle[](linearTetuLps.length);\n    for (uint256 i = 0; i < linearTetuLps.length; i++) {\n      tetuLinearlpOracles[i] = linearLpOracle;\n    }\n\n    BasePriceOracle[] memory linearAaveWmaticOracle = new BasePriceOracle[](1);\n    linearAaveWmaticOracle[0] = linearLpOracle;\n\n    BasePriceOracle[] memory csMATICOracle = new BasePriceOracle[](1);\n    csMATICOracle[0] = rateProviderOracle;\n\n    vm.startPrank(mpo.admin());\n    mpo.add(linearAaveLps, aaveLinerlpOracles);\n    mpo.add(linearTetuLps, tetuLinearlpOracles);\n    mpo.add(asArray(csMATIC), csMATICOracle);\n    mpo.add(asArray(linearAaveWmaticPool), linearAaveWmaticOracle);\n    vm.stopPrank();\n  }\n\n  function testReentrancyWmaticStmaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    address vault = address(IBalancerStablePool(stMATIC_WMATIC_pool).getVault());\n    BalancerReentrancyAttacker reentrancyAttacker = new BalancerReentrancyAttacker(\n      IBalancerVault(vault),\n      mpo,\n      stMATIC_WMATIC_pool\n    );\n\n    // add the oracle to the mpo for that LP token\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = BasePriceOracle(stableLpOracle);\n    vm.prank(mpo.admin());\n    mpo.add(asArray(stMATIC_WMATIC_pool), oracles);\n\n    // gives ETH to attacker\n    vm.deal(address(reentrancyAttacker), 5 ether);\n\n    // makes sure the address calling the attack is from attacker\n    vm.prank(address(reentrancyAttacker));\n\n    // should revert with the specific message\n    vm.expectRevert(bytes(\"BAL#420\"));\n    reentrancyAttacker.startAttack();\n  }\n\n  function testReentrancyErrorMessageWmaticStmaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    // add the oracle to the mpo for that LP token\n    {\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n      oracles[0] = BasePriceOracle(stableLpOracle);\n      vm.prank(mpo.admin());\n      mpo.add(asArray(stMATIC_WMATIC_pool), oracles);\n    }\n\n    address vault = address(IBalancerStablePool(stMATIC_WMATIC_pool).getVault());\n    // raise the reentrancy flag for that vault\n    vm.store(vault, bytes32(uint256(0)), bytes32(uint256(2)));\n    // should revert with the specific message\n    vm.expectRevert(bytes(\"Balancer vault view reentrancy\"));\n    mpo.price(stMATIC_WMATIC_pool);\n  }\n\n  // Tests for ComposableStablePools\n  function testJeurAgEurLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(jEUR_agEUR_pool, stableLpOracle);\n\n    uint256[] memory baseTokenPrices = new uint256[](2);\n    baseTokenPrices[0] = mpo.price(jEUR);\n    baseTokenPrices[1] = mpo.price(agEUR);\n    uint256 minTokenPrice = _getMinValue(baseTokenPrices);\n    uint256 poolRate = IBalancerStablePool(jEUR_agEUR_pool).getRate();\n    uint256 expectedRate = (minTokenPrice * poolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertEq(price, expectedRate);\n  }\n\n  function testJbrlBrzLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(jBRL_BRZ_pool, stableLpOracle);\n\n    uint256[] memory baseTokenPrices = new uint256[](2);\n    baseTokenPrices[0] = mpo.price(jBRL);\n    baseTokenPrices[1] = mpo.price(BRZ);\n    uint256 minTokenPrice = _getMinValue(baseTokenPrices);\n    uint256 poolRate = IBalancerStablePool(jBRL_BRZ_pool).getRate();\n    uint256 expectedRate = (minTokenPrice * poolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertEq(price, expectedRate);\n  }\n\n  function testWmaticStmaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(stMATIC_WMATIC_pool, stableLpOracle);\n\n    uint256[] memory baseTokenPrices = new uint256[](2);\n    baseTokenPrices[0] = mpo.price(stMATIC);\n    baseTokenPrices[1] = mpo.price(wtoken);\n    uint256 minTokenPrice = _getMinValue(baseTokenPrices);\n    uint256 poolRate = IBalancerStablePool(stMATIC_WMATIC_pool).getRate();\n    uint256 expectedRate = (minTokenPrice * poolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertApproxEqRel(price, expectedRate, 1e15);\n  }\n\n  function testCsMaticWmaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(csMATIC_WMATIC_pool, stableLpOracle);\n\n    uint256[] memory baseTokenPrices = new uint256[](2);\n    baseTokenPrices[0] = mpo.price(csMATIC);\n    baseTokenPrices[1] = mpo.price(wtoken);\n\n    uint256 minTokenPrice = _getMinValue(baseTokenPrices);\n    uint256 poolRate = IBalancerStablePool(csMATIC_WMATIC_pool).getRate();\n    uint256 expectedRate = (minTokenPrice * poolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertEq(price, expectedRate);\n  }\n\n  function testBoostedAaveLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    IBalancerStablePool stablePool = IBalancerStablePool(boostedAavePool);\n\n    // Updates cache of getTokenRate\n    stablePool.updateTokenRateCache(linearAaveUsdtPool);\n    stablePool.updateTokenRateCache(linearAaveUsdcPool);\n    stablePool.updateTokenRateCache(linearAaveDaiPool);\n\n    uint256 price = _getLpTokenPrice(boostedAavePool, stableLpOracle);\n\n    // Find min price among the three underlying linear pools\n    uint256[] memory linearPoolTokenPrices = new uint256[](3);\n    linearPoolTokenPrices[0] =\n      (mpo.price(linearAaveUsdtPool) * 1e18) /\n      IBalancerLinearPool(linearAaveUsdtPool).getRate();\n    linearPoolTokenPrices[1] =\n      (mpo.price(linearAaveUsdcPool) * 1e18) /\n      IBalancerLinearPool(linearAaveUsdcPool).getRate();\n    linearPoolTokenPrices[2] = (mpo.price(linearAaveDaiPool) * 1e18) / IBalancerLinearPool(linearAaveDaiPool).getRate();\n    uint256 mainTokenPrice = _getMinValue(linearPoolTokenPrices);\n\n    uint256 stablePoolRate = IBalancerStablePool(boostedAavePool).getRate();\n    uint256 expectedRate = (mainTokenPrice * stablePoolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertEq(price, expectedRate);\n  }\n\n  function testMaticXAaveMaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    IBalancerStablePool stablePool = IBalancerStablePool(MATICx_AaveMATIC_pool);\n\n    // Updates cache of getTokenRate\n    stablePool.updateTokenRateCache(linearAaveWmaticPool);\n\n    uint256 price = _getLpTokenPrice(MATICx_AaveMATIC_pool, stableLpOracle);\n\n    // Find min price among the three underlying linear pools\n    uint256[] memory poolTokenPrices = new uint256[](2);\n    poolTokenPrices[0] = (mpo.price(linearAaveWmaticPool) * 1e18) / IBalancerLinearPool(linearAaveWmaticPool).getRate();\n    poolTokenPrices[1] = mpo.price(MATICx);\n\n    uint256 mainTokenPrice = _getMinValue(poolTokenPrices);\n    uint256 stablePoolRate = IBalancerStablePool(MATICx_AaveMATIC_pool).getRate();\n    uint256 expectedRate = (mainTokenPrice * stablePoolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertApproxEqRel(price, expectedRate, 1e16, \"!price\");\n  }\n\n  function testStMaticAaveMaticLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    IBalancerStablePool stablePool = IBalancerStablePool(stMATIC_AaveMATIC_pool);\n\n    // Updates cache of getTokenRate\n    stablePool.updateTokenRateCache(linearAaveWmaticPool);\n\n    uint256 price = _getLpTokenPrice(stMATIC_AaveMATIC_pool, stableLpOracle);\n\n    // Find min price among the three underlying linear pools\n    uint256[] memory poolTokenPrices = new uint256[](2);\n    poolTokenPrices[0] = (mpo.price(linearAaveWmaticPool) * 1e18) / IBalancerLinearPool(linearAaveWmaticPool).getRate();\n    poolTokenPrices[1] = mpo.price(MATICx);\n\n    uint256 mainTokenPrice = _getMinValue(poolTokenPrices);\n    uint256 stablePoolRate = IBalancerStablePool(stMATIC_AaveMATIC_pool).getRate();\n    uint256 expectedRate = (mainTokenPrice * stablePoolRate) / 1e18;\n\n    assertTrue(price > 0);\n    assertApproxEqRel(price, expectedRate, 1e16, \"!price\");\n  }\n\n  // Tests for LinearPools\n  function testLinearAaveUsdtLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(linearAaveUsdtPool, linearLpOracle);\n\n    assertTrue(price > 0);\n    uint256 poolRate = IBalancerLinearPool(linearAaveUsdtPool).getRate();\n    uint256 expectedRate = (mpo.price(usdt) * poolRate) / 1e18;\n    assertEq(price, expectedRate);\n  }\n\n  function testLinearTetuUsdtLpTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 price = _getLpTokenPrice(linearTetuUsdtPool, linearLpOracle);\n\n    assertTrue(price > 0);\n    uint256 poolRate = IBalancerLinearPool(linearTetuUsdtPool).getRate();\n    uint256 expectedRate = (mpo.price(usdt) * poolRate) / 1e18;\n    assertEq(price, expectedRate);\n  }\n\n  function _getLpTokenPrice(address lpToken, BasePriceOracle oracle) internal returns (uint256) {\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = oracle;\n\n    vm.prank(mpo.admin());\n    mpo.add(asArray(lpToken), oracles);\n    emit log(\"added the oracle\");\n    return mpo.price(lpToken);\n  }\n\n  function _getMinValue(uint256[] memory prices) internal pure returns (uint256 minPrice) {\n    minPrice = type(uint256).max;\n    for (uint256 i = 0; i < prices.length; i++) {\n      if (prices[i] < minPrice) {\n        minPrice = prices[i];\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/oracles/default/BalancerRateProviderOracle.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { BalancerRateProviderOracle } from \"../../../oracles/default/BalancerRateProviderOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { IBalancerStablePool } from \"../../../external/balancer/IBalancerStablePool.sol\";\nimport { IBalancerVault, UserBalanceOp } from \"../../../external/balancer/IBalancerVault.sol\";\n\ncontract BalancerRateProviderOracleTest is BaseTest {\n  BalancerRateProviderOracle oracle;\n  MasterPriceOracle mpo;\n  uint256 wtokenPrice;\n\n  // base tokens\n  address wtoken;\n  address weth = 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619;\n\n  // Underlyings\n  address stMATIC = 0x3A58a54C066FdC0f2D55FC9C89F0415C92eBf3C4;\n  address MATICx = 0xfa68FB4628DFF1028CFEc22b4162FCcd0d45efb6;\n  address csMATIC = 0xFcBB00dF1d663eeE58123946A30AB2138bF9eb2A;\n  address wstETH = 0x03b54A6e9a984069379fae1a4fC4dBAE93B3bCCD;\n\n  // Rate Providers\n  address csMATICRateProvider = 0x87393BE8ac323F2E63520A6184e5A8A9CC9fC051;\n  address stMATICRateProvider = 0xdEd6C522d803E35f65318a9a4d7333a22d582199;\n  address MATICxRateProvider = 0xeE652bbF72689AA59F0B8F981c9c90e2A8Af8d8f;\n  address wstETHRateProvider = 0x8c1944E305c590FaDAf0aDe4f737f5f95a4971B6;\n\n  // zkEVM\n  address wstETHzkevmRateProvider = 0x00346D2Fd4B2Dc3468fA38B857409BC99f832ef8;\n  address rETHzkevmRateProvider = 0x60b39BEC6AF8206d1E6E8DFC63ceA214A506D6c3;\n\n  address rETHzkevm = 0xb23C20EFcE6e24Acca0Cef9B7B7aA196b84EC942;\n  address wstETHzkevm = 0x5D8cfF95D7A57c0BF50B30b43c7CC0D52825D4a9;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    wtoken = ap.getAddress(\"wtoken\");\n\n    address[] memory baseTokens;\n    address[] memory underlyings;\n    address[] memory rateProviders;\n\n    if (block.chainid == POLYGON_MAINNET) {\n      wtokenPrice = mpo.price(wtoken);\n      underlyings = asArray(stMATIC, MATICx, csMATIC);\n      baseTokens = asArray(wtoken, wtoken, wtoken);\n      rateProviders = asArray(stMATICRateProvider, MATICxRateProvider, csMATICRateProvider);\n    } else if (block.chainid == ZKEVM_MAINNET) {\n      underlyings = asArray(rETHzkevm, wstETHzkevm);\n      baseTokens = asArray(wtoken, wtoken);\n      rateProviders = asArray(rETHzkevmRateProvider, wstETHzkevmRateProvider);\n    } else {\n      revert(\"not supported\");\n    }\n    oracle = new BalancerRateProviderOracle();\n    oracle.initialize(rateProviders, baseTokens, underlyings);\n  }\n\n  function getTokenPrice(address token) internal returns (uint256) {\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = BasePriceOracle(oracle);\n\n    vm.prank(mpo.admin());\n    mpo.add(asArray(token), oracles);\n    emit log(\"added the oracle\");\n    return mpo.price(token);\n  }\n\n  function testStmaticTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 priceFromMpo = mpo.price(stMATIC);\n    uint256 priceFromRateProviderOracle = getTokenPrice(stMATIC);\n    assertApproxEqRel(priceFromMpo, priceFromRateProviderOracle, 1e16, \"!diff > 1%\");\n\n    // Must be close but higher than to the price for WTOKEN\n    assertTrue(priceFromRateProviderOracle > wtokenPrice);\n    assertApproxEqRel(mpo.price(wtoken), priceFromRateProviderOracle, 2e17, \"!diff > 20%\");\n  }\n\n  function testMaticXTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    uint256 priceFromMpo = mpo.price(MATICx);\n    uint256 priceFromRateProviderOracle = getTokenPrice(MATICx);\n    assertApproxEqRel(priceFromMpo, priceFromRateProviderOracle, 1e16, \"!diff > 1%\");\n    // Must be close but higher than to the price for WTOKEN\n    assertTrue(priceFromRateProviderOracle > wtokenPrice);\n    assertApproxEqRel(mpo.price(wtoken), priceFromRateProviderOracle, 2e17, \"!diff > 20%\");\n  }\n\n  function testCsMaticTokenOraclePrice() public fork(POLYGON_MAINNET) {\n    // We don't have yet a price feed for csMATIC currently live\n    // uint256 priceFromMpo = mpo.price(csMATIC);\n    uint256 priceFromRateProviderOracle = getTokenPrice(csMATIC);\n    // assertApproxEqRel(priceFromMpo, priceFromRateProviderOracle, 1e16, \"!diff > 1%\");\n    // Must be close but higher than to the price for WTOKEN\n    assertTrue(priceFromRateProviderOracle > wtokenPrice);\n    assertApproxEqRel(mpo.price(wtoken), priceFromRateProviderOracle, 2e17, \"!diff > 20%\");\n  }\n\n  // function tesZkEvmPriceOracle() public fork(ZKEVM_MAINNET) {\n  function testGetZkEvmRP() public fork(ZKEVM_MAINNET) {\n    // We don't have yet a price feed for csMATIC currently live\n    // uint256 priceFromMpo = mpo.price(csMATIC);\n    uint256 rEthPriceFromRateProviderOracle = getTokenPrice(rETHzkevm);\n    uint256 wstEthPriceFromRateProviderOracle = getTokenPrice(wstETHzkevm);\n    // assertApproxEqRel(priceFromMpo, priceFromRateProviderOracle, 1e16, \"!diff > 1%\");\n    // Must be close but higher than to the price for WTOKEN\n    assertTrue(rEthPriceFromRateProviderOracle > wtokenPrice);\n    assertTrue(wstEthPriceFromRateProviderOracle > wtokenPrice);\n    assertApproxEqRel(mpo.price(wtoken), rEthPriceFromRateProviderOracle, 2e17, \"!diff > 20%\");\n    assertApproxEqRel(mpo.price(wtoken), wstEthPriceFromRateProviderOracle, 2e17, \"!diff > 20%\");\n  }\n\n  function testRegisterNewToken() public fork(POLYGON_MAINNET) {\n    vm.prank(oracle.owner());\n\n    uint256 lenghtBefore = oracle.getAllUnderlyings().length;\n    oracle.registerToken(wstETHRateProvider, weth, wstETH);\n    assertTrue(oracle.getAllUnderlyings().length == lenghtBefore + 1);\n\n    uint256 price = getTokenPrice(wstETH);\n    // Must be close but higher than to the price for WETH\n    assertTrue(price > mpo.price(weth));\n    assertApproxEqRel(mpo.price(weth), price, 2e17, \"!diff > 20%\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/BNBxPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { BNBxPriceOracle } from \"../../../oracles/default/BNBxPriceOracle.sol\";\n\ncontract BNBxPriceOracleTest is BaseTest {\n  BNBxPriceOracle private oracle;\n  address BNBx = 0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275;\n\n  function afterForkSetUp() internal override {\n    oracle = new BNBxPriceOracle();\n    oracle.initialize();\n  }\n\n  function testBnbXOraclePrice() public forkAtBlock(BSC_MAINNET, 22332594) {\n    uint256 priceBnbX = oracle.price(BNBx);\n    assertGt(priceBnbX, 1e18);\n    assertEq(priceBnbX, 1041708576933034575);\n  }\n}\n"
    },
    "contracts/test/oracles/default/ChainlinkOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ChainlinkPriceOracleV2 } from \"../../../oracles/default/ChainlinkPriceOracleV2.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract ChainlinkOraclesTest is BaseTest {\n  ChainlinkPriceOracleV2 oracle;\n\n  address usdcPolygon = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n  address usdtPolygon = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\n  address usdcFeedPolygon = 0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7;\n  address usdtFeedPolygon = 0x0A6513e40db6EB1b165753AD52E80663aeA50545;\n\n  address jBRLBsc = 0x316622977073BBC3dF32E7d2A9B3c77596a0a603;\n  address jBRLFeedBsc = 0x5cb1Cb3eA5FB46de1CE1D0F3BaDB3212e8d8eF48;\n  address usdcBsc = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\n  address usdtBsc = 0x55d398326f99059fF775485246999027B3197955;\n  address usdtFeedBsc = 0xB97Ad0E74fa7d920791E90258A6E2085088b4320;\n  address usdcFeedBsc = 0x51597f405303C4377E36123cBc172b13269EA163;\n  ICErc20 usdcMarketBsc = ICErc20(0x8D5bE2768c335e88b71E4e913189AEE7104f01B4);\n  ICErc20 usdtMarketBsc = ICErc20(0x1F73754c135d5B9fDE674806f43AeDfA2c7eaDb5);\n\n  function afterForkSetUp() internal override {\n    oracle = ChainlinkPriceOracleV2(ap.getAddress(\"ChainlinkPriceOracleV2\"));\n  }\n\n  function setUpOracleFeed(address testedTokenAddress, address aggregatorAddress) internal {\n    address[] memory underlyings = new address[](1);\n    underlyings[0] = testedTokenAddress;\n    address[] memory aggregators = new address[](1);\n    aggregators[0] = aggregatorAddress;\n\n    vm.prank(oracle.owner());\n    oracle.setPriceFeeds(underlyings, aggregators, ChainlinkPriceOracleV2.FeedBaseCurrency.USD);\n  }\n\n  function testJBRLPrice() public fork(BSC_MAINNET) {\n    setUpOracleFeed(jBRLBsc, jBRLFeedBsc);\n    assert(oracle.price(jBRLBsc) > 0);\n  }\n\n  function testBSCChainlinkUSDCPrice() public fork(BSC_MAINNET) {\n    setUpOracleFeed(usdcBsc, usdcFeedBsc);\n    uint256 price = oracle.price(usdcBsc);\n    uint256 underlyingPrice = oracle.getUnderlyingPrice(usdcMarketBsc);\n    assertEq(price, underlyingPrice);\n  }\n\n  function testBSCChainlinkUSDTPrice() public fork(BSC_MAINNET) {\n    setUpOracleFeed(usdtBsc, usdtFeedBsc);\n    uint256 price = oracle.price(usdtBsc);\n    uint256 underlyingPrice = oracle.getUnderlyingPrice(usdtMarketBsc);\n    assertEq(price, underlyingPrice);\n  }\n\n  function testUsdcUsdtDeviationBsc() public fork(BSC_MAINNET) {\n    setUpOracleFeed(usdtBsc, usdtFeedBsc);\n    setUpOracleFeed(usdcBsc, usdcFeedBsc);\n\n    uint256 usdtPrice = oracle.getUnderlyingPrice(usdtMarketBsc);\n    uint256 usdcPrice = oracle.getUnderlyingPrice(usdcMarketBsc);\n\n    assertApproxEqAbs(usdtPrice, usdcPrice, 1e16, \"usd prices differ too much\");\n  }\n\n  function testUsdcUsdtDeviationPolygon() public fork(POLYGON_MAINNET) {\n    setUpOracleFeed(usdtPolygon, usdtFeedPolygon);\n    setUpOracleFeed(usdcPolygon, usdcFeedPolygon);\n\n    uint256 usdtPrice = oracle.price(usdtPolygon);\n    uint256 usdcPrice = oracle.price(usdcPolygon);\n\n    assertApproxEqAbs(usdtPrice, usdcPrice, 1e16, \"usd prices differ too much\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/CurveV2LpTokenPriceOracleNoRegistryTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICurveV2Pool } from \"../../../external/curve/ICurveV2Pool.sol\";\nimport { CurveV2LpTokenPriceOracleNoRegistry } from \"../../../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract CurveLpTokenPriceOracleNoRegistryTest is BaseTest {\n  CurveV2LpTokenPriceOracleNoRegistry oracle;\n  address busd;\n  address epsJCHFBUSD_lp = 0x5887cEa5e2bb7dD36F0C06Da47A8Df918c289A29;\n  address epsJCHFBUSD_pool = 0xBcA6E25937B0F7E0FD8130076b6B218F595E32e2;\n  ICErc20 epsJCHFBUSD_c = ICErc20(0x1F0452D6a8bb9EAbC53Fa6809Fa0a060Dd531267);\n\n  address epsBnbxBnb_lp = 0xFD4afeAc39DA03a05f61844095A75c4fB7D766DA;\n  address epsBnbxBnb_pool = 0xFD4afeAc39DA03a05f61844095A75c4fB7D766DA;\n  ICErc20 epsBnbxBnb_c = ICErc20(0xD96643Ba2Bf96e73509C4bb73c0cb259dAf34de1);\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    busd = ap.getAddress(\"bUSD\");\n\n    address[] memory lpTokens = new address[](2);\n    lpTokens[0] = epsJCHFBUSD_lp;\n    lpTokens[1] = epsBnbxBnb_lp;\n\n    address[] memory pools = new address[](2);\n    pools[0] = epsJCHFBUSD_pool;\n    pools[1] = epsBnbxBnb_pool;\n\n    address[] memory baseTokens = new address[](2);\n    baseTokens[0] = busd;\n    baseTokens[1] = address(0);\n\n    oracle = new CurveV2LpTokenPriceOracleNoRegistry();\n    oracle.initialize(lpTokens, pools);\n  }\n\n  function testCurveV2LpTokenPriceOracleCHFBUSD() public forkAtBlock(BSC_MAINNET, 21675481) {\n    ICurveV2Pool pool = ICurveV2Pool(epsJCHFBUSD_pool);\n    vm.prank(address(mpo));\n    uint256 lp_price = (pool.lp_price() * mpo.price(busd)) / 10**18;\n    vm.startPrank(address(mpo));\n    uint256 price = oracle.price(epsJCHFBUSD_lp);\n    uint256 ulPrice = oracle.getUnderlyingPrice(epsJCHFBUSD_c);\n    assertEq(price, ulPrice);\n    assertEq(price, lp_price);\n    assertEq(price, 7319017681980243);\n    vm.stopPrank();\n  }\n\n  function testCurveV2LpTokenPriceOracleBNBXBNB() public forkAtBlock(BSC_MAINNET, 24036448) {\n    ICurveV2Pool pool = ICurveV2Pool(epsBnbxBnb_pool);\n    vm.startPrank(address(mpo));\n    // coins(0) is BNBx\n    uint256 lp_price = (pool.lp_price() * mpo.price(0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275)) / 10**18;\n    uint256 price = oracle.price(epsBnbxBnb_lp);\n\n    // TODO: add these when the oracle is added\n    // uint256 ulPrice = oracle.getUnderlyingPrice(epsBnbxBnb_c);\n    // assertEq(price, ulPrice);\n    assertEq(price, lp_price);\n    assertEq(price, 2058628564849750905);\n    vm.stopPrank();\n  }\n}\n"
    },
    "contracts/test/oracles/default/CurveV2PriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ICurveV2Pool } from \"../../../external/curve/ICurveV2Pool.sol\";\nimport { CurveV2PriceOracle } from \"../../../oracles/default/CurveV2PriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract CurveV2PriceOracleTest is BaseTest {\n  CurveV2PriceOracle oracle;\n  address busd;\n  address wbtc;\n\n  address Bnbx = 0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275;\n  address epsBnbxBnb_pool = 0xFD4afeAc39DA03a05f61844095A75c4fB7D766DA;\n  address epsBusdBtc_pool = 0xeF8A7e653F18CFD4b92a0f5b644393A4C635f19f;\n\n  address eusd = 0x97de57eC338AB5d51557DA3434828C5DbFaDA371; // 18 decimals\n  address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // 6 decimals\n  uint256 usdcPriceEth = 0.00057716e18;\n  address usdcEusdPool = 0x880F2fB3704f1875361DE6ee59629c6c6497a5E3;\n\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    address[] memory tokens;\n    address[] memory pools;\n\n    if (block.chainid == ETHEREUM_MAINNET) {\n      tokens = new address[](1);\n      tokens[0] = eusd;\n\n      pools = new address[](1);\n      pools[0] = usdcEusdPool;\n    } else {\n      mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n      busd = ap.getAddress(\"bUSD\");\n      wbtc = ap.getAddress(\"wBTCToken\");\n\n      tokens = new address[](3);\n      tokens[0] = Bnbx;\n      tokens[1] = wbtc;\n      tokens[2] = busd;\n\n      pools = new address[](3);\n      pools[0] = epsBnbxBnb_pool;\n      pools[1] = epsBusdBtc_pool;\n      pools[2] = epsBusdBtc_pool;\n    }\n\n    oracle = new CurveV2PriceOracle();\n    oracle.initialize(tokens, pools);\n  }\n\n  function testCurveV2PriceOracleBNBxBNB() public fork(BSC_MAINNET) {\n    vm.prank(address(mpo));\n    uint256 bnbx_mpo_price = mpo.price(Bnbx);\n    vm.startPrank(address(mpo));\n    uint256 priceBnbx = oracle.price(Bnbx);\n    assertApproxEqRel(bnbx_mpo_price, priceBnbx, 1e16); // 1%\n    vm.stopPrank();\n  }\n\n  function testCurveV2PriceOracleWbtcBNB() public fork(BSC_MAINNET) {\n    vm.prank(address(mpo));\n    uint256 wbtc_mpo_price = mpo.price(wbtc);\n    uint256 busd_mpo_price = mpo.price(busd);\n    vm.startPrank(address(mpo));\n    uint256 priceWbtc = oracle.price(wbtc);\n    uint256 priceBusd = oracle.price(busd);\n    assertApproxEqRel(wbtc_mpo_price, priceWbtc, 1e16); // 1%\n    assertApproxEqRel(busd_mpo_price, priceBusd, 1e16); // 1%\n    vm.stopPrank();\n  }\n\n  function testCurveV2PriceOracleEUsdUsdc() public fork(ETHEREUM_MAINNET) {\n    // TODO use the MPO when deployed\n    // testing the decimals scaling, eusd has 18, usdc has 6 decimals\n    uint256 priceEusd = oracle.price(eusd);\n    assertApproxEqRel(usdcPriceEth, priceEusd, 1e17); // 10%\n  }\n\n  function price(address asset) public view returns (uint256) {\n    if (asset == usdc) return usdcPriceEth;\n    else return 0;\n  }\n}\n"
    },
    "contracts/test/oracles/default/DiaPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { DiaPriceOracle, DIAOracleV2 } from \"../../../oracles/default/DiaPriceOracle.sol\";\nimport { SimplePriceOracle } from \"../../../oracles/default/SimplePriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\ncontract MockDiaPriceFeed is DIAOracleV2 {\n  struct DiaOracle {\n    DIAOracleV2 feed;\n    string key;\n  }\n\n  uint128 public staticPrice;\n\n  constructor(uint128 _staticPrice) {\n    staticPrice = _staticPrice;\n  }\n\n  function getValue(string memory key) external view returns (uint128, uint128) {\n    return (staticPrice, uint128(block.timestamp));\n  }\n}\n\ncontract DiaPriceOracleTest is BaseTest {\n  DiaPriceOracle private oracle;\n  MasterPriceOracle masterPriceOracle;\n\n  function testDiaPriceOracleWithMasterPriceOracleBsc() public forkAtBlock(BSC_MAINNET, 20238373) {\n    oracle = DiaPriceOracle(0x944e833dC2Af9fc58D5cfA99B9D8666c843Ad58C);\n\n    // miMATIC (MAI)\n    uint256 price = oracle.price(0x3F56e0c36d275367b8C502090EDF38289b3dEa0d);\n    assertApproxEqAbs(price, 3086017057904017, 1e14);\n    masterPriceOracle = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    // compare to BUSD, ensure price does not deviate too much\n    uint256 priceBusd = masterPriceOracle.price(ap.getAddress(\"bUSD\"));\n    assertApproxEqAbs(price, priceBusd, 1e14);\n  }\n\n  function setUpWithMasterPriceOracle() internal {\n    SimplePriceOracle spo = new SimplePriceOracle();\n    spo.initialize();\n    spo.setDirectPrice(address(2), 200000000000000000); // 1e36 / 200000000000000000 = 5e18\n    MasterPriceOracle mpo = new MasterPriceOracle();\n    address[] memory underlyings = new address[](1);\n    underlyings[0] = address(2);\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    oracles[0] = spo;\n    mpo.initialize(underlyings, oracles, spo, address(this), true, address(0));\n    oracle = new DiaPriceOracle(address(this), true, address(0), MockDiaPriceFeed(address(0)), \"\", mpo, address(2));\n  }\n}\n"
    },
    "contracts/test/oracles/default/ERC4626OracleAndLiquidatorTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { ERC4626Oracle } from \"../../../oracles/default/ERC4626Oracle.sol\";\nimport { SimplePriceOracle } from \"../../../oracles/default/SimplePriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { IERC4626 } from \"../../../compound/IERC4626.sol\";\nimport { ChainlinkPriceOracleV2 } from \"../../../oracles/default/ChainlinkPriceOracleV2.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\nimport { IUniswapV3Factory } from \"../../../external/uniswap/IUniswapV3Factory.sol\";\nimport { Quoter } from \"../../../external/uniswap/quoter/Quoter.sol\";\nimport { IUniswapV3Pool } from \"../../../external/uniswap/IUniswapV3Pool.sol\";\nimport { ISwapRouter } from \"../../../external/uniswap/ISwapRouter.sol\";\nimport { ERC4626Liquidator } from \"../../../liquidators/ERC4626Liquidator.sol\";\n\ncontract ERC4626OracleAndLiquidatorTest is BaseTest {\n  // TODO: refactor this into oracle and liquidator tests once oracles are deployed\n  // TODO: refactor oracle set up using the address provider\n\n  MasterPriceOracle mpo;\n  ChainlinkPriceOracleV2 chainlinkOracle;\n  ERC4626Oracle erc4626Oracle;\n\n  IERC20Upgradeable wethToken;\n  IERC20Upgradeable wbtcToken;\n  IERC20Upgradeable daiToken;\n  IERC20Upgradeable usdcToken;\n  IERC20Upgradeable usdtToken;\n\n  address nativeUsdPriceFeed;\n  address usdcEthPriceFeed;\n  address wbtcEthPriceFeed;\n\n  IERC4626 erc4626Vault;\n  address[] underlyingTokens;\n  ERC4626Liquidator liquidator;\n\n  address usdcMarketAddress;\n  address univ3SwapRouter;\n\n  uint256 poolFee;\n\n  Quoter quoter;\n\n  address holder;\n\n  function setUpErc4626Oracle() public {\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n    erc4626Oracle = new ERC4626Oracle();\n    vm.prank(erc4626Oracle.owner());\n    erc4626Oracle.initialize();\n    oracles[0] = erc4626Oracle;\n    vm.prank(mpo.admin());\n    mpo.add(asArray(address(erc4626Vault)), oracles);\n  }\n\n  function setUpBaseOracles() public {\n    setUpMpoAndAddresses();\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](2);\n    chainlinkOracle = new ChainlinkPriceOracleV2();\n    chainlinkOracle.initialize(address(usdcToken), nativeUsdPriceFeed);\n    vm.prank(chainlinkOracle.owner());\n    chainlinkOracle.setPriceFeeds(\n      asArray(address(usdcToken), address(wbtcToken)),\n      asArray(usdcEthPriceFeed, wbtcEthPriceFeed),\n      ChainlinkPriceOracleV2.FeedBaseCurrency.ETH\n    );\n    oracles[0] = BasePriceOracle(address(chainlinkOracle));\n    oracles[1] = BasePriceOracle(address(chainlinkOracle));\n\n    vm.prank(mpo.admin());\n    mpo.add(asArray(address(usdcToken), address(wbtcToken)), oracles);\n  }\n\n  function setUpMpoAndAddresses() public {\n    if (block.chainid == ETHEREUM_MAINNET) {\n      usdcToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n      daiToken = IERC20Upgradeable(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n      usdtToken = IERC20Upgradeable(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n      wbtcToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n      wethToken = IERC20Upgradeable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n      nativeUsdPriceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n      usdcEthPriceFeed = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4;\n      wbtcEthPriceFeed = 0xdeb288F737066589598e9214E782fa5A8eD689e8;\n\n      address[] memory assets = new address[](0);\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](0);\n      mpo = new MasterPriceOracle();\n      mpo.initialize(assets, oracles, BasePriceOracle(address(0)), address(this), true, address(wethToken));\n    }\n  }\n\n  function setupRealYieldStrategyUsdAddresses() public {\n    if (block.chainid == ETHEREUM_MAINNET) {\n      underlyingTokens = asArray(address(usdcToken), address(daiToken), address(usdtToken)); // USDC, 6 decimals\n      poolFee = 10;\n      erc4626Vault = IERC4626(0x97e6E0a40a3D02F12d1cEC30ebfbAE04e37C119E); // USDC-DAI-USDT Real Yield\n      quoter = new Quoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n      univ3SwapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n      holder = 0x3541Fda19b09769A938EB2A5f5154b01aE5b0869;\n    }\n    liquidator = new ERC4626Liquidator();\n  }\n\n  function setupEthBtcStrategyAddresses() public {\n    if (block.chainid == ETHEREUM_MAINNET) {\n      underlyingTokens = asArray(address(usdcToken), address(wbtcToken), address(wethToken));\n      poolFee = 500;\n      erc4626Vault = IERC4626(0x6b7f87279982d919Bbf85182DDeAB179B366D8f2); // ETH-BTC trend\n      quoter = new Quoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n      univ3SwapRouter = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n      holder = 0xF955C57f9EA9Dc8781965FEaE0b6A2acE2BAD6f3;\n    }\n    liquidator = new ERC4626Liquidator();\n  }\n\n  function testRealYieldErc4626PriceOracle() public fork(ETHEREUM_MAINNET) {\n    setUpBaseOracles();\n    setupRealYieldStrategyUsdAddresses();\n    setUpErc4626Oracle();\n\n    uint256 priceRealYieldUsdc = mpo.price(address(erc4626Vault));\n    uint256 priceUsdc = mpo.price(address(usdcToken));\n\n    // Approximate only -- these should not match.\n    assertApproxEqRel(priceRealYieldUsdc, priceUsdc, 3e16, \"!diff > 3%\");\n  }\n\n  function testRealYieldUsdErc4626RedemptionStrategy() public fork(ETHEREUM_MAINNET) {\n    setUpBaseOracles();\n    setupRealYieldStrategyUsdAddresses();\n    setUpErc4626Oracle();\n    executeTestRedemptionStrategy(usdcToken);\n  }\n\n  function testEthBtcMomementumErc4626RedemptionStrategy() public fork(ETHEREUM_MAINNET) {\n    setUpBaseOracles();\n    setupEthBtcStrategyAddresses();\n    setUpErc4626Oracle();\n    executeTestRedemptionStrategy(wethToken);\n  }\n\n  function executeTestRedemptionStrategy(IERC20Upgradeable _outputToken) internal {\n    uint256 balance = erc4626Vault.balanceOf(holder);\n    assertTrue(balance > 0);\n\n    // impersonate the holder\n    vm.prank(holder);\n\n    // fund the liquidator so it can redeem the tokens\n    erc4626Vault.transfer(address(liquidator), balance);\n\n    bytes memory data = abi.encode(address(_outputToken), poolFee, univ3SwapRouter, underlyingTokens, quoter);\n\n    // redeem the underlying reward token\n    (IERC20Upgradeable outputToken, uint256 outputAmount) = liquidator.redeem(\n      IERC20Upgradeable(address(erc4626Vault)),\n      balance,\n      data\n    );\n\n    // ensure the output token is the expected token\n    assertEq(address(outputToken), address(_outputToken));\n\n    uint256 liquidatorBalance = _outputToken.balanceOf(address(liquidator));\n    // get the redeemed value of the erc4626 token\n    uint256 redeemValue = (mpo.price(address(erc4626Vault)) * balance) / 1e18;\n    // get the redeemed value of the output token\n    uint256 redeemOutputTokenValue = (mpo.price(address(_outputToken)) * liquidatorBalance) /\n      10**ERC20Upgradeable(address(_outputToken)).decimals();\n    // ensure they are approximately equal\n    assertApproxEqRel(redeemValue, redeemOutputTokenValue, 3e16, \"!diff > 3%\");\n\n    uint256 maxVal = redeemValue > redeemOutputTokenValue ? redeemValue : redeemOutputTokenValue;\n    uint256 minVal = redeemValue < redeemOutputTokenValue ? redeemValue : redeemOutputTokenValue;\n\n    uint256 absoluteDifference = maxVal - minVal;\n    uint256 percentageDifference = (absoluteDifference * 10000) / maxVal; // Multiplied by 10000 for 2 decimal places of precision\n\n    // log the differences\n    emit log_named_uint(\"redeemOutputTokenValue\", redeemOutputTokenValue);\n    emit log_named_uint(\"redeemValue\", redeemValue);\n    emit log_named_uint(\"base 1000 diff\", percentageDifference);\n  }\n}\n"
    },
    "contracts/test/oracles/default/GammaPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { GammaPoolAlgebraPriceOracle } from \"../../../oracles/default/GammaPoolPriceOracle.sol\";\nimport { GammaPoolUniswapV3PriceOracle } from \"../../../oracles/default/GammaPoolPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { LiquidityAmounts } from \"../../../external/uniswap/LiquidityAmounts.sol\";\nimport { IUniswapV3Pool } from \"../../../external/uniswap/IUniswapV3Pool.sol\";\n\nimport { IHypervisor } from \"../../../external/gamma/IHypervisor.sol\";\n\ncontract GammaPoolPriceOracleTest is BaseTest {\n  GammaPoolAlgebraPriceOracle private aOracle;\n  GammaPoolUniswapV3PriceOracle private uOracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    stable = ap.getAddress(\"stableToken\");\n    wtoken = ap.getAddress(\"wtoken\");\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    aOracle = new GammaPoolAlgebraPriceOracle();\n    uOracle = new GammaPoolUniswapV3PriceOracle();\n    vm.prank(mpo.admin());\n    aOracle.initialize(wtoken);\n    uOracle.initialize(wtoken);\n  }\n\n  function testPriceGammaAlgebraNow() public fork(POLYGON_MAINNET) {\n    {\n      uint256 withdrawAmount = 1e18;\n      address DAI_GNS_QS_GAMMA_VAULT = 0x7aE7FB44c92B4d41abB6E28494f46a2EB3c2a690; // QS aDAI-GNS (Narrow)\n      address DAI_GNS_QS_GAMMA_WHALE = 0x20ec0d06F447d550fC6edee42121bc8C1817b97D; // QS Masterchef\n\n      vm.prank(address(mpo));\n      uint256 price_DAI_GNS = aOracle.price(DAI_GNS_QS_GAMMA_VAULT);\n\n      uint256 expectedPrice = priceAtWithdraw(DAI_GNS_QS_GAMMA_WHALE, DAI_GNS_QS_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_DAI_GNS, expectedPrice, 1e16, \"!aDAI-GNS price\");\n    }\n\n    {\n      uint256 withdrawAmount = 1e6;\n      address DAI_USDT_QS_GAMMA_VAULT = 0x45A3A657b834699f5cC902e796c547F826703b79;\n      address DAI_USDT_QS_WHALE = 0x20ec0d06F447d550fC6edee42121bc8C1817b97D; // QS Masterchef\n\n      vm.prank(address(mpo));\n      uint256 price_DAI_USDT = aOracle.price(DAI_USDT_QS_GAMMA_VAULT) / (1e18 / withdrawAmount);\n\n      uint256 expectedPrice = priceAtWithdraw(DAI_USDT_QS_WHALE, DAI_USDT_QS_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_DAI_USDT, expectedPrice, 1e16, \"!aDAI-USDT price\");\n    }\n\n    {\n      uint256 withdrawAmount = 1e6;\n      address WETH_USDT_QS_GAMMA_VAULT = 0x5928f9f61902b139e1c40cBa59077516734ff09f; // QS aWETH-USDT (Narrow)\n      address WETH_USDT_QS_WHALE = 0x20ec0d06F447d550fC6edee42121bc8C1817b97D; // QS Masterchef\n\n      vm.prank(address(mpo));\n      uint256 price_WETH_USDT = aOracle.price(WETH_USDT_QS_GAMMA_VAULT) / (1e18 / withdrawAmount);\n\n      uint256 expectedPrice = priceAtWithdraw(WETH_USDT_QS_WHALE, WETH_USDT_QS_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_WETH_USDT, expectedPrice, 10e16, \"!aWETH-USDT price\");\n    }\n  }\n\n  function testPriceGammaUniV3Now() public fork(POLYGON_MAINNET) {\n    uint256 withdrawAmount = 1e18;\n    {\n      address USDC_CASH_RETRO_GAMMA_VAULT = 0x64e14623CA543b540d0bA80477977f7c2c00a7Ea;\n      address USDC_CASH_RETRO_WHALE = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n\n      vm.prank(address(mpo));\n      uint256 price_USDC_CASH = uOracle.price(USDC_CASH_RETRO_GAMMA_VAULT);\n\n      uint256 expectedPrice = priceAtWithdraw(USDC_CASH_RETRO_WHALE, USDC_CASH_RETRO_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_USDC_CASH, expectedPrice, 1e16, \"!aUSDC-CASH price\");\n    }\n\n    {\n      address USDC_WETH_RETRO_GAMMA_VAULT = 0xe058e1FfFF9B13d3FCd4803FDb55d1Cc2fe07DDC;\n      address USDC_WETH_RETRO_WHALE = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n\n      vm.prank(address(mpo));\n      uint256 price_USDC_WETH = uOracle.price(USDC_WETH_RETRO_GAMMA_VAULT);\n\n      uint256 expectedPrice = priceAtWithdraw(USDC_WETH_RETRO_WHALE, USDC_WETH_RETRO_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_USDC_WETH, expectedPrice, 5e16, \"!aUSDC_WETH price\");\n    }\n\n    {\n      address WMATIC_MATICX_RETRO_GAMMA_VAULT = 0x2589469b7A72802CE02484f053CB6df869eB2689;\n      address WMATIC_MATICX_RETRO_WHALE = 0xcFB07d195DB81da622E94BDB3171392756775914;\n\n      vm.prank(address(mpo));\n      uint256 price_WMATIC_MATICX = uOracle.price(WMATIC_MATICX_RETRO_GAMMA_VAULT);\n\n      uint256 expectedPrice = priceAtWithdraw(\n        WMATIC_MATICX_RETRO_WHALE,\n        WMATIC_MATICX_RETRO_GAMMA_VAULT,\n        withdrawAmount\n      );\n\n      assertApproxEqRel(price_WMATIC_MATICX, expectedPrice, 1e16, \"!aWMATIC_MATICX price\");\n    }\n\n    {\n      address WBTC_WETH_RETRO_GAMMA_VAULT = 0x336536F5bB478D8624dDcE0942fdeF5C92bC4662;\n      address WBTC_WETH_RETRO_GAMMA_WHALE = 0x38e481367E0c50f4166AD2A1C9fde0E3c662CFBa;\n\n      vm.prank(address(mpo));\n      uint256 price_WBTC_WETH = uOracle.price(WBTC_WETH_RETRO_GAMMA_VAULT);\n\n      uint256 expectedPrice = priceAtWithdraw(WBTC_WETH_RETRO_GAMMA_WHALE, WBTC_WETH_RETRO_GAMMA_VAULT, withdrawAmount);\n      assertApproxEqRel(price_WBTC_WETH, expectedPrice, 5e16, \"!aWBTC_WETH price\");\n    }\n  }\n\n  function priceAtWithdraw(\n    address whale,\n    address vaultAddress,\n    uint256 withdrawAmount\n  ) internal returns (uint256) {\n    address emptyAddress = address(900202020);\n    IHypervisor vault = IHypervisor(vaultAddress);\n    ERC20Upgradeable token0 = ERC20Upgradeable(vault.token0());\n    ERC20Upgradeable token1 = ERC20Upgradeable(vault.token1());\n\n    uint256 balance0Before = token0.balanceOf(emptyAddress);\n    uint256 balance1Before = token1.balanceOf(emptyAddress);\n\n    uint256[4] memory minAmounts;\n    vm.prank(whale);\n    vault.withdraw(withdrawAmount, emptyAddress, whale, minAmounts);\n\n    uint256 balance0After = token0.balanceOf(emptyAddress);\n    uint256 balance1After = token1.balanceOf(emptyAddress);\n\n    uint256 price0 = mpo.price(address(token0));\n    uint256 price1 = mpo.price(address(token1));\n\n    uint256 balance0Diff = (balance0After - balance0Before) * 10**(18 - uint256(token0.decimals()));\n    uint256 balance1Diff = (balance1After - balance1Before) * 10**(18 - uint256(token1.decimals()));\n\n    return (balance0Diff * price0 + balance1Diff * price1) / 1e18;\n  }\n}\n"
    },
    "contracts/test/oracles/default/GelatoGUniPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { GelatoGUniPriceOracle } from \"../../../oracles/default/GelatoGUniPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\n\ncontract GelatoGUniPriceOracleTest is BaseTest {\n  GelatoGUniPriceOracle private oracle;\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new GelatoGUniPriceOracle(ap.getAddress(\"wtoken\"));\n  }\n\n  function testPriceGelatoGUni() public fork(POLYGON_MAINNET) {\n    address PAR_USDC_ARRAKIS_VAULT = 0xC1DF4E2fd282e39346422e40C403139CD633Aacd;\n    address WBTC_WETH_ARRAKIS_VAULT = 0x590217ef04BcB96FF6Da991AB070958b8F9E77f0;\n\n    vm.prank(address(mpo));\n    uint256 price_PAR_USDC = oracle.price(PAR_USDC_ARRAKIS_VAULT);\n\n    vm.prank(address(mpo));\n    uint256 price_WBTC_WETH = oracle.price(WBTC_WETH_ARRAKIS_VAULT);\n\n    assertTrue(price_PAR_USDC > 0, \"!Price Error\");\n    assertTrue(price_WBTC_WETH > 0, \"!Price Error\");\n    assertGt(price_WBTC_WETH, price_PAR_USDC);\n  }\n}\n"
    },
    "contracts/test/oracles/default/KyberSwapPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { KyberSwapPriceOracle } from \"../../../oracles/default/KyberSwapPriceOracle.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"../../../oracles/default/ConcentratedLiquidityBasePriceOracle.sol\";\nimport { IPool } from \"../../../external/kyber/IPool.sol\";\nimport { IPoolOracle } from \"../../../external/kyber/IPoolOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"../../../oracles/default/ConcentratedLiquidityBasePriceOracle.sol\";\n\nimport \"../../../external/uniswap/TickMath.sol\";\nimport \"../../../external/uniswap/FullMath.sol\";\n\ncontract KyberSwapPriceOracleTest is BaseTest {\n  KyberSwapPriceOracle oracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address wbtc;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    stable = 0x176211869cA2b568f2A7D4EE941E073a821EE1ff; // ap.getAddress(\"stableToken\");\n\n    wtoken = ap.getAddress(\"wtoken\"); // WETH\n    wbtc = ap.getAddress(\"wBTCToken\"); // WBTC\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new KyberSwapPriceOracle();\n\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n  }\n\n  function getPriceX96FromSqrtPriceX96(\n    address token0,\n    address priceToken,\n    uint160 sqrtPriceX96\n  ) public pure returns (uint256 price_) {\n    price_ = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2**(96 * 2)) / 1e18);\n    if (token0 != priceToken) price_ = 1e36 / price_;\n  }\n\n  function testLineaAssets() public debuggingOnly forkAtBlock(LINEA_MAINNET, 173370) {\n    address axlUsdc = 0xEB466342C4d449BC9f53A865D5Cb90586f405215;\n    address dai = 0x4AF15ec2A0BD43Db75dd04E62FAA3B8EF36b00d5;\n\n    address[] memory underlyings = new address[](3);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](3);\n\n    underlyings[0] = stable; // (6 decimals)\n    underlyings[1] = axlUsdc; // (6 decimals)\n    underlyings[2] = dai; // (6 decimals)\n\n    // 6 / 18\n    IPool usdcWethPool = IPool(0x4b21d64Cf83e56860F1739452817E4c0fa1D399D);\n    // 6 / 6\n    IPool axlUsdcUsdcPool = IPool(0xFbEdC4eBEB2951fF96A636c934FCE35117847c9d);\n    // 18 / 6\n    IPool daiUsdcPool = IPool(0xB6E91bA27bB6C3b2ADC31884459D3653F9293e33);\n\n    // WETH-USDC\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(address(usdcWethPool), 1200, wtoken);\n    // USDC-axlUSDC\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(address(axlUsdcUsdcPool), 1200, stable);\n    // DAI-USDC\n    configs[2] = ConcentratedLiquidityBasePriceOracle.AssetConfig(address(daiUsdcPool), 1200, stable);\n\n    uint256 priceUsdc = mpo.price(stable);\n    uint256[] memory expPrices = new uint256[](3);\n\n    expPrices[0] = priceUsdc;\n    expPrices[1] = priceUsdc;\n    expPrices[2] = priceUsdc;\n\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n\n    assertApproxEqRel(prices[0], expPrices[0], 1e17, \"!Price Error\");\n    assertApproxEqRel(prices[1], expPrices[1], 1e17, \"!Price Error\");\n    assertApproxEqRel(prices[2], expPrices[2], 1e17, \"!Price Error\");\n  }\n\n  function getPriceFeed(address[] memory underlyings, ConcentratedLiquidityBasePriceOracle.AssetConfig[] memory configs)\n    internal\n    returns (uint256[] memory price)\n  {\n    vm.prank(oracle.owner());\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.roll(1);\n\n    price = new uint256[](underlyings.length);\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      vm.prank(address(mpo));\n      price[i] = oracle.price(underlyings[i]);\n    }\n    return price;\n  }\n}\n"
    },
    "contracts/test/oracles/default/MasterPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\nimport { SimplePriceOracle } from \"../../../oracles/default/SimplePriceOracle.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { MockRevertPriceOracle } from \"../../../oracles/1337/MockRevertPriceOracle.sol\";\n\ncontract MasterPriceOracleTest is BaseTest {\n  MasterPriceOracle mpo;\n  SimplePriceOracle mainOracle;\n  SimplePriceOracle fallbackOracle;\n  MockRevertPriceOracle revertingOracle;\n  ICErc20 mockCToken;\n  address someAdminAccount = address(94949);\n  address ezETH = 0x2416092f143378750bb29b79eD961ab195CcEea5;\n  address ionezETH = 0x59e710215d45F584f44c0FEe83DA6d43D762D857;\n\n  function afterForkSetUp() internal override {\n    MasterPriceOracle newMpo = new MasterPriceOracle();\n    SimplePriceOracle defaultOracle = new SimplePriceOracle();\n\n    address[] memory underlyings = new address[](0);\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](0);\n\n    vm.prank(someAdminAccount);\n    newMpo.initialize(underlyings, oracles, defaultOracle, someAdminAccount, true, address(0));\n\n    mpo = newMpo;\n\n    SimplePriceOracle impl = new SimplePriceOracle();\n    vm.prank(address(someAdminAccount));\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(\n      address(impl),\n      address(dpa),\n      abi.encodePacked(impl.initialize.selector)\n    );\n    mainOracle = SimplePriceOracle(address(proxy));\n\n    SimplePriceOracle fallbackImpl = new SimplePriceOracle();\n    vm.prank(address(someAdminAccount));\n    TransparentUpgradeableProxy fallbackProxy = new TransparentUpgradeableProxy(\n      address(fallbackImpl),\n      address(dpa),\n      abi.encodePacked(impl.initialize.selector)\n    );\n    fallbackOracle = SimplePriceOracle(address(fallbackProxy));\n\n    vm.startPrank(someAdminAccount);\n    mainOracle.setDirectPrice(ezETH, 2000);\n    fallbackOracle.setDirectPrice(ezETH, 2000);\n    vm.stopPrank();\n\n    address[] memory tokens = new address[](1);\n    tokens[0] = ezETH;\n\n    BasePriceOracle[] memory oraclesToAdd = new BasePriceOracle[](1);\n    oraclesToAdd[0] = BasePriceOracle(mainOracle);\n    BasePriceOracle[] memory fallbackOraclesToAdd = new BasePriceOracle[](1);\n    fallbackOraclesToAdd[0] = BasePriceOracle(fallbackOracle);\n\n    vm.startPrank(someAdminAccount);\n    mpo.add(tokens, oraclesToAdd);\n    mpo.addFallbacks(tokens, fallbackOraclesToAdd);\n    vm.stopPrank();\n\n    revertingOracle = new MockRevertPriceOracle();\n  }\n\n  function testGetUnderlyingPrice() public fork(MODE_MAINNET) {\n    vm.prank(someAdminAccount);\n    uint256 price = mpo.getUnderlyingPrice(ICErc20(ionezETH));\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testGetUnderlyingPriceWhenZero() public fork(MODE_MAINNET) {\n    vm.prank(someAdminAccount);\n    mainOracle.setDirectPrice(ezETH, 0);\n    uint256 price = mpo.getUnderlyingPrice(ICErc20(ionezETH));\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testGetUnderlyingPriceWhenZeroAddressOracle() public fork(MODE_MAINNET) {\n    address[] memory tokens = new address[](1);\n    tokens[0] = ezETH;\n\n    BasePriceOracle[] memory oraclesToAdd = new BasePriceOracle[](1);\n    oraclesToAdd[0] = BasePriceOracle(0x0000000000000000000000000000000000000000);\n\n    vm.prank(someAdminAccount);\n    mpo.add(tokens, oraclesToAdd);\n\n    uint256 price = mpo.getUnderlyingPrice(ICErc20(ionezETH));\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testGetUnderlyingPriceWhenOracleReverts() public fork(MODE_MAINNET) {\n    address[] memory tokens = new address[](1);\n    tokens[0] = ezETH;\n\n    BasePriceOracle[] memory oraclesToAdd = new BasePriceOracle[](1);\n    oraclesToAdd[0] = BasePriceOracle(revertingOracle);\n\n    vm.prank(someAdminAccount);\n    mpo.add(tokens, oraclesToAdd);\n\n    uint256 price = mpo.getUnderlyingPrice(ICErc20(ionezETH));\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testPrice() public fork(MODE_MAINNET) {\n    vm.prank(someAdminAccount);\n    uint256 price = mpo.price(ezETH);\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testPriceWhenZero() public fork(MODE_MAINNET) {\n    vm.prank(someAdminAccount);\n    mainOracle.setDirectPrice(ezETH, 0);\n    uint256 price = mpo.price(ezETH);\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testPriceWhenZeroAddressOracle() public fork(MODE_MAINNET) {\n    address[] memory tokens = new address[](1);\n    tokens[0] = ezETH;\n\n    BasePriceOracle[] memory oraclesToAdd = new BasePriceOracle[](1);\n    oraclesToAdd[0] = BasePriceOracle(0x0000000000000000000000000000000000000000);\n\n    vm.prank(someAdminAccount);\n    mpo.add(tokens, oraclesToAdd);\n\n    uint256 price = mpo.price(ezETH);\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n\n  function testPriceWhenOracleReverts() public fork(MODE_MAINNET) {\n    address[] memory tokens = new address[](1);\n    tokens[0] = ezETH;\n\n    BasePriceOracle[] memory oraclesToAdd = new BasePriceOracle[](1);\n    oraclesToAdd[0] = BasePriceOracle(revertingOracle);\n\n    vm.prank(someAdminAccount);\n    mpo.add(tokens, oraclesToAdd);\n\n    uint256 price = mpo.price(ezETH);\n    assertEq(price, 2000, \"Price should match the mock price\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/PythPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { PythPriceOracle } from \"../../../oracles/default/PythPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/MockPyth.sol\";\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\ncontract PythPriceOracleTest is BaseTest {\n  PythPriceOracle oracle;\n  IPyth pythOracle;\n  MasterPriceOracle mpo;\n\n  address stable;\n  address wtoken;\n  address wbtc;\n\n  address neonPyth = 0x7f2dB085eFC3560AFF33865dD727225d91B4f9A5;\n  address lineaPyth = 0xA2aa501b19aff244D90cc15a4Cf739D2725B5729;\n  address polygonPyth = 0xff1a0f4744e8582DF1aE09D5611b887B6a12925C;\n  address zkevmPyth = 0xC5E56d6b40F3e3B5fbfa266bCd35C37426537c65;\n\n  bytes32 ethUsdTokenPriceFeed = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;\n  bytes32 btcUsdTokenPriceFeed = 0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43;\n  bytes32 neonUsdTokenPriceFeed = 0xd82183dd487bef3208a227bb25d748930db58862c5121198e723ed0976eb92b7;\n  bytes32 maticUsdTokenPriceFeed = 0x5de33a9112c2b700b8d30b8a3402c103578ccfa2765696471cc672bd5cf6ac52;\n  bytes32 usdcUsdTokenPriceFeed = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a;\n\n  function afterForkSetUp() internal override {\n    stable = ap.getAddress(\"stableToken\");\n    wtoken = ap.getAddress(\"wtoken\");\n    wbtc = ap.getAddress(\"wBTCToken\");\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new PythPriceOracle();\n\n    // create an array of bytes to pass to the oracle\n    bytes32[] memory feedIds = new bytes32[](2);\n    feedIds[0] = usdcUsdTokenPriceFeed;\n    feedIds[1] = btcUsdTokenPriceFeed;\n    vm.startPrank(mpo.admin());\n\n    if (block.chainid == NEON_MAINNET) {\n      oracle.initialize(neonPyth, neonUsdTokenPriceFeed, stable);\n    } else if (block.chainid == LINEA_MAINNET) {\n      oracle.initialize(lineaPyth, ethUsdTokenPriceFeed, stable);\n    } else if (block.chainid == POLYGON_MAINNET) {\n      oracle.initialize(polygonPyth, maticUsdTokenPriceFeed, stable);\n    } else if (block.chainid == ZKEVM_MAINNET) {\n      oracle.initialize(zkevmPyth, ethUsdTokenPriceFeed, stable);\n    } else {\n      revert(\"Unsupported chain\");\n    }\n    oracle.setPriceFeeds(asArray(stable, wbtc), feedIds);\n    vm.stopPrank();\n  }\n\n  function testPolygonTokenPrice() public debuggingOnly fork(POLYGON_MAINNET) {\n    PythStructs.Price memory pythPrice = IPyth(polygonPyth).getPriceUnsafe(maticUsdTokenPriceFeed);\n    emit log_named_uint(\"price\", uint256(uint64(pythPrice.price)));\n    emit log_named_uint(\"updated\", pythPrice.publishTime);\n    emit log_named_uint(\"ts\", block.timestamp);\n\n    uint256 price = oracle.price(wbtc);\n    uint256 priceMpo = mpo.price(wbtc);\n    assertApproxEqRel(price, priceMpo, 1e16);\n  }\n\n  function testLineaTokenPrice() public debuggingOnly fork(LINEA_MAINNET) {\n    PythStructs.Price memory pythPrice = IPyth(lineaPyth).getPriceUnsafe(btcUsdTokenPriceFeed);\n    emit log_named_uint(\"price\", uint256(uint64(pythPrice.price)));\n    emit log_named_uint(\"updated\", pythPrice.publishTime);\n    emit log_named_uint(\"ts\", block.timestamp);\n\n    uint256 price = oracle.price(wbtc);\n    uint256 priceMpo = mpo.price(wbtc);\n    assertApproxEqRel(price, priceMpo, 1e17);\n  }\n\n  function testNeonTokenPrice() public debuggingOnly fork(NEON_MAINNET) {\n    PythStructs.Price memory pythPriceNeon = IPyth(neonPyth).getPriceUnsafe(neonUsdTokenPriceFeed);\n    emit log_named_uint(\"price\", uint256(uint64(pythPriceNeon.price)));\n    emit log_named_uint(\"updated\", pythPriceNeon.publishTime);\n    emit log_named_uint(\"ts\", block.timestamp);\n    PythStructs.Price memory pythPrice = IPyth(neonPyth).getPriceUnsafe(btcUsdTokenPriceFeed);\n    emit log_named_uint(\"price\", uint256(uint64(pythPrice.price)));\n    emit log_named_uint(\"updated\", pythPrice.publishTime);\n    emit log_named_uint(\"ts\", block.timestamp);\n\n    uint256 price = oracle.price(wbtc);\n    uint256 priceMpo = mpo.price(wbtc);\n    assertApproxEqRel(price, priceMpo, 1e16);\n  }\n\n  function testZkEvmTokenPrice() public fork(ZKEVM_MAINNET) {\n    PythStructs.Price memory pythPrice = IPyth(zkevmPyth).getPriceUnsafe(btcUsdTokenPriceFeed);\n    emit log_named_uint(\"price\", uint256(uint64(pythPrice.price)));\n    emit log_named_uint(\"updated\", pythPrice.publishTime);\n    emit log_named_uint(\"ts\", block.timestamp);\n\n    uint256 price = oracle.price(wbtc);\n    uint256 priceMpo = mpo.price(wbtc);\n    assertApproxEqRel(price, priceMpo, 1e16);\n  }\n}\n"
    },
    "contracts/test/oracles/default/SaddleLpPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { ISwap } from \"../../../external/saddle/ISwap.sol\";\nimport { SaddleLpPriceOracle } from \"../../../oracles/default/SaddleLpPriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract SaddleLpPriceOracleTest is BaseTest {\n  SaddleLpPriceOracle oracle;\n  address usdc = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n  address frax = 0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F;\n  address fraxUsdc_lp = 0x896935B02D3cBEb152192774e4F1991bb1D2ED3f;\n  address fraxUsdc_pool = 0x401AFbc31ad2A3Bc0eD8960d63eFcDEA749b4849;\n  // TODO: add test once this is deployed\n  // ICErc20 fraxUsdc_c = ICErc20(0x);\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n\n    address[] memory lpTokens = new address[](1);\n    lpTokens[0] = fraxUsdc_lp;\n    address[] memory pools = new address[](1);\n    pools[0] = fraxUsdc_pool;\n    address[][] memory underlyings = new address[][](1);\n    underlyings[0] = new address[](2);\n    underlyings[0][0] = usdc;\n    underlyings[0][1] = frax;\n\n    vm.startPrank(mpo.admin());\n    oracle = new SaddleLpPriceOracle();\n    oracle.initialize(lpTokens, pools, underlyings);\n    vm.stopPrank();\n  }\n\n  function testSaddleLpTokenPriceOracle() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 44898730) {\n    vm.prank(address(mpo));\n    uint256 price = oracle.price(fraxUsdc_lp);\n    assertEq(price, 785240575939374);\n  }\n}\n"
    },
    "contracts/test/oracles/default/SimplePriceOracleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { SimplePriceOracle } from \"../../../oracles/default/SimplePriceOracle.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract SimplePriceOracleTest is BaseTest {\n  SimplePriceOracle oracle;\n  MasterPriceOracle mpo;\n  address someAdminAccount = address(94949);\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    SimplePriceOracle impl = new SimplePriceOracle();\n\n    vm.prank(someAdminAccount);\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(\n      address(impl),\n      address(dpa),\n      abi.encodePacked(impl.initialize.selector)\n    );\n    oracle = SimplePriceOracle(address(proxy));\n  }\n\n  function testSimplePO() public fork(BSC_MAINNET) {\n    vm.expectRevert(\"Ownable: caller is not the owner\");\n    oracle.setDirectPrice(address(1), 1);\n\n    vm.prank(someAdminAccount);\n    oracle.setDirectPrice(address(1), 1);\n  }\n}\n"
    },
    "contracts/test/oracles/default/SolidlyPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { SolidlyPriceOracle } from \"../../../oracles/default/SolidlyPriceOracle.sol\";\nimport { SolidlyLpTokenPriceOracle } from \"../../../oracles/default/SolidlyLpTokenPriceOracle.sol\";\nimport { IPair } from \"../../../external/solidly/IPair.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nstruct PriceExpected {\n  uint256 price;\n  uint256 percentErrorAllowed;\n}\n\ncontract SolidlyPriceOracleTest is BaseTest {\n  SolidlyPriceOracle oracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    // Not using the address provider yet -- config just added\n    // TODO: use ap when deployment is done\n\n    stable = ap.getAddress(\"stableToken\"); // USDC\n    wtoken = ap.getAddress(\"wtoken\"); // WETH\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new SolidlyPriceOracle();\n\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n  }\n\n  // Ankr Price: $0.034632 (fetched from block explorer)\n  // BNB Price at block 26678077: $337.67 (fetched from block explorer)\n  function testBscCustomAsset() public forkAtBlock(BSC_MAINNET, 26678077) {\n    address ankr = 0xf307910A4c7bbc79691fD374889b36d8531B08e3;\n    address ankrBNB = 0x52F24a5e03aee338Da5fd9Df68D2b6FAe1178827;\n\n    address[] memory underlyings = new address[](1);\n    SolidlyPriceOracle.AssetConfig[] memory configs = new SolidlyPriceOracle.AssetConfig[](1);\n\n    underlyings[0] = ankr;\n    // ANKR/ankrBNB\n    configs[0] = SolidlyPriceOracle.AssetConfig(0x7ef540f672Cd643B79D2488344944499F7518b1f, ankrBNB);\n\n    vm.prank(oracle.owner());\n    oracle._setSupportedBaseTokens(asArray(stable, ankrBNB));\n\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    // Assert price in $ is equal\n    assertApproxEqRel((prices[0] * 33667) / 100, 0.03463e18, 1e17); // 0.1 % error\n  }\n\n  function testBscAssets() public fork(BSC_MAINNET) {\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    address usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address hay = 0x0782b6d8c4551B9760e74c0545a9bCD90bdc41E5;\n    address bnbx = 0x1bdd3Cf7F79cfB8EdbB955f20ad99211551BA275;\n    address eth = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\n\n    address[] memory underlyings = new address[](4);\n    SolidlyPriceOracle.AssetConfig[] memory configs = new SolidlyPriceOracle.AssetConfig[](4);\n\n    underlyings[0] = hay;\n    underlyings[1] = bnbx;\n    underlyings[2] = eth;\n    underlyings[3] = usdt;\n\n    // HAY/BUSD\n    configs[0] = SolidlyPriceOracle.AssetConfig(0x93B32a8dfE10e9196403dd111974E325219aec24, busd);\n    // BNBx/WBNB\n    configs[1] = SolidlyPriceOracle.AssetConfig(0x6c83E45fE3Be4A9c12BB28cB5BA4cD210455fb55, wtoken);\n    // ETH/WBNB\n    configs[2] = SolidlyPriceOracle.AssetConfig(0x1d168C5b5DEa1c6dA0E9FD9bf4B7607e4e9D8EeC, wtoken);\n    // USDT/BUSD\n    configs[3] = SolidlyPriceOracle.AssetConfig(0x6321B57b6fdc14924be480c54e93294617E672aB, busd);\n\n    PriceExpected[] memory expPrices = new PriceExpected[](4);\n\n    expPrices[0] = PriceExpected({ price: mpo.price(hay), percentErrorAllowed: 1e18 }); // 1%\n    expPrices[1] = PriceExpected({ price: mpo.price(bnbx), percentErrorAllowed: 1e18 }); // 1%\n    expPrices[2] = PriceExpected({ price: mpo.price(eth), percentErrorAllowed: 1e17 }); // 0.1%\n    expPrices[3] = PriceExpected({ price: mpo.price(usdt), percentErrorAllowed: 1e17 }); // 0.1%\n\n    emit log_named_uint(\"USDC PRICE\", mpo.price(stable));\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertApproxEqRel(prices[i], expPrices[i].price, expPrices[i].percentErrorAllowed, \"!Price Error\");\n    }\n  }\n\n  function testArbitrumAssets() public fork(ARBITRUM_ONE) {\n    address wbtc = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n    address dai = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n    address usdt = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n\n    address[] memory underlyings = new address[](3);\n    SolidlyPriceOracle.AssetConfig[] memory configs = new SolidlyPriceOracle.AssetConfig[](3);\n\n    underlyings[0] = wbtc;\n    underlyings[1] = dai;\n    underlyings[2] = usdt;\n\n    // WBTC/WETH (8/18 decimals)\n    configs[0] = SolidlyPriceOracle.AssetConfig(0xd9D611c6943585bc0e18E51034AF8fa28778F7Da, wtoken);\n    // DAI/USDC (18/6)\n    configs[1] = SolidlyPriceOracle.AssetConfig(0x07d7F291e731A41D3F0EA4F1AE5b6d920ffb3Fe0, stable);\n    // USDT/USDC (6/6)\n    configs[2] = SolidlyPriceOracle.AssetConfig(0xC9dF93497B1852552F2200701cE58C236cC0378C, stable);\n\n    PriceExpected[] memory expPrices = new PriceExpected[](3);\n\n    expPrices[0] = PriceExpected({ price: mpo.price(wbtc), percentErrorAllowed: 1e18 }); // 1%\n    expPrices[1] = PriceExpected({ price: mpo.price(dai), percentErrorAllowed: 1e18 }); // 1%\n    expPrices[2] = PriceExpected({ price: mpo.price(usdt), percentErrorAllowed: 1e17 }); // 0.1%\n\n    emit log_named_uint(\"USDC PRICE\", mpo.price(stable));\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertApproxEqRel(prices[i], expPrices[i].price, expPrices[i].percentErrorAllowed, \"!Price Error\");\n    }\n  }\n\n  function testPolygonAssets() public fork(POLYGON_MAINNET) {\n    address usdr = 0xb5DFABd7fF7F83BAB83995E72A52B97ABb7bcf63;\n    address usdc = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\n\n    address[] memory underlyings = new address[](1);\n    SolidlyPriceOracle.AssetConfig[] memory configs = new SolidlyPriceOracle.AssetConfig[](1);\n\n    underlyings[0] = usdr;\n\n    // USDR/USDC (9/6), usinf Pearl Exchange\n    configs[0] = SolidlyPriceOracle.AssetConfig(0xf6A72Bd46F53Cd5103812ea1f4B5CF38099aB797, stable);\n\n    PriceExpected[] memory expPrices = new PriceExpected[](4);\n\n    expPrices[0] = PriceExpected({ price: mpo.price(usdc), percentErrorAllowed: 1e17 }); // 0.1%\n\n    emit log_named_uint(\"USDC PRICE\", mpo.price(stable));\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertApproxEqRel(prices[i], expPrices[i].price, expPrices[i].percentErrorAllowed, \"!Price Error\");\n    }\n  }\n\n  function getPriceFeed(address[] memory underlyings, SolidlyPriceOracle.AssetConfig[] memory configs)\n    internal\n    returns (uint256[] memory price)\n  {\n    vm.prank(oracle.owner());\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.roll(1);\n\n    price = new uint256[](underlyings.length);\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      vm.prank(address(mpo));\n      price[i] = oracle.price(underlyings[i]);\n    }\n    return price;\n  }\n\n  function testSetUnsupportedBaseToken() public fork(ARBITRUM_ONE) {\n    address dai = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n    address usdt = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n\n    address[] memory underlyings = new address[](1);\n    SolidlyPriceOracle.AssetConfig[] memory configs = new SolidlyPriceOracle.AssetConfig[](1);\n\n    underlyings[0] = dai;\n\n    // DAI/USDT\n    configs[0] = SolidlyPriceOracle.AssetConfig(0x15b9D20bcaa4f65d9004D2BEBAc4058445FD5285, usdt);\n\n    // revert if underlying is not supported\n    vm.startPrank(oracle.owner());\n    vm.expectRevert(bytes(\"Underlying token must be supported\"));\n    oracle.setPoolFeeds(underlyings, configs);\n\n    // add it successfully when suported\n    oracle._setSupportedBaseTokens(asArray(usdt, stable));\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.stopPrank();\n\n    // check prices\n    vm.prank(address(mpo));\n    uint256 price = oracle.price(dai);\n    assertApproxEqRel(price, mpo.price(dai), 1e17, \"!Price Error\");\n  }\n}\n"
    },
    "contracts/test/oracles/default/StkBNBPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { StkBNBPriceOracle } from \"../../../oracles/default/StkBNBPriceOracle.sol\";\n\ncontract StkBNBPriceOracleTest is BaseTest {\n  StkBNBPriceOracle private oracle;\n  address stkBnb = 0xc2E9d07F66A89c44062459A47a0D2Dc038E4fb16;\n\n  function afterForkSetUp() internal override {\n    oracle = new StkBNBPriceOracle();\n    oracle.initialize();\n  }\n\n  function testStkBnbOraclePrice() public forkAtBlock(BSC_MAINNET, 21952914) {\n    uint256 priceStkBnb = oracle.price(stkBnb);\n\n    assertGt(priceStkBnb, 1e18);\n    assertEq(priceStkBnb, 1006482474298479702);\n  }\n}\n"
    },
    "contracts/test/oracles/default/TwapOraclesBaseTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { UniswapTwapPriceOracleV2Factory } from \"../../../oracles/default/UniswapTwapPriceOracleV2Factory.sol\";\nimport { UniswapTwapPriceOracleV2Root } from \"../../../oracles/default/UniswapTwapPriceOracleV2Root.sol\";\nimport { UniswapTwapPriceOracleV2 } from \"../../../oracles/default/UniswapTwapPriceOracleV2.sol\";\nimport { IUniswapV2Factory } from \"../../../external/uniswap/IUniswapV2Factory.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { IUniswapV2Pair } from \"../../../external/uniswap/IUniswapV2Pair.sol\";\nimport { IUniswapV2Factory } from \"../../../external/uniswap/IUniswapV2Factory.sol\";\n\ncontract TwapOraclesBaseTest is BaseTest {\n  IUniswapV2Factory uniswapV2Factory;\n  UniswapTwapPriceOracleV2Factory twapPriceOracleFactory;\n  MasterPriceOracle mpo;\n\n  function afterForkSetUp() internal override {\n    uniswapV2Factory = IUniswapV2Factory(ap.getAddress(\"IUniswapV2Factory\"));\n    twapPriceOracleFactory = UniswapTwapPriceOracleV2Factory(ap.getAddress(\"UniswapTwapPriceOracleV2Factory\"));\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  // BOMB\n  function testBombTwapOraclePrice() public fork(BSC_MAINNET) {\n    address baseToken = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c; // WBTC\n    address testedAssetTokenAddress = 0x522348779DCb2911539e76A1042aA922F9C47Ee3; // BOMB\n\n    assertTrue(getTokenTwapPrice(testedAssetTokenAddress, baseToken) > 0);\n  }\n\n  function getTokenTwapPrice(address tokenAddress, address baseTokenAddress) internal returns (uint256) {\n    address testedPairAddress = uniswapV2Factory.getPair(tokenAddress, baseTokenAddress);\n\n    // trigger a price update\n    UniswapTwapPriceOracleV2Root twapOracleRoot = UniswapTwapPriceOracleV2Root(twapPriceOracleFactory.rootOracle());\n    address[] memory pairs = new address[](1);\n    pairs[0] = testedPairAddress;\n    twapOracleRoot.update(pairs);\n\n    // check if the base toke oracle is present in the master price oracle\n    if (address(mpo.oracles(tokenAddress)) == address(0)) {\n      // deploy or get the base token twap oracle\n      address oracleAddress = twapPriceOracleFactory.deploy(address(uniswapV2Factory), baseTokenAddress);\n      UniswapTwapPriceOracleV2 oracle = UniswapTwapPriceOracleV2(oracleAddress);\n      // add the new twap oracle to the master oracle\n      address[] memory underlyings = new address[](1);\n      underlyings[0] = tokenAddress;\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n      oracles[0] = oracle;\n      // impersonate the admin to add the oracle\n      vm.prank(mpo.admin());\n      mpo.add(underlyings, oracles);\n      emit log(\"added the oracle\");\n    } else {\n      emit log(\"found the oracle\");\n    }\n\n    // return the price denominated in W_NATIVE\n    return mpo.price(tokenAddress);\n  }\n\n  // function testChapelEthBusdOraclePrice() public {\n  //   address baseToken = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684; // USDT\n  //   address testedAssetTokenAddress = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BUSD\n  //   assertTrue(getTokenTwapPrice(testedAssetTokenAddress, baseToken) > 0);\n  // }\n}\n"
    },
    "contracts/test/oracles/default/UmbrellaPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { UmbrellaPriceOracle } from \"../../../oracles/default/UmbrellaPriceOracle.sol\";\nimport { IRegistry } from \"../../../external/umbrella/IRegistry.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\n\ncontract UmbrellaPriceOracleTest is BaseTest {\n  UmbrellaPriceOracle private oracle;\n  IRegistry public registry;\n  MasterPriceOracle mpo;\n  address stableToken;\n  address otherToken;\n  address wbtc;\n  address wtoken;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    stableToken = ap.getAddress(\"stableToken\");\n    wbtc = ap.getAddress(\"wBTCToken\");\n    wtoken = ap.getAddress(\"wtoken\");\n    oracle = new UmbrellaPriceOracle();\n\n    if (block.chainid == LINEA_MAINNET) {\n      registry = IRegistry(0x1B17DBB40fbED8735E7fE8C9eB02C20984fAdfD6);\n    } else if (block.chainid == POLYGON_MAINNET) {\n      registry = IRegistry(0x455acbbC2c15c086978083968a69B2e7E4d38d34);\n    } else {\n      revert(\"Unsupported chain\");\n    }\n  }\n\n  function setUpLinea() public {\n    vm.prank(mpo.admin());\n    oracle.initialize(\"ETH-USD\", registry);\n\n    address[] memory underlyings = new address[](3);\n    string[] memory feeds = new string[](3);\n\n    // USDT\n    otherToken = 0x1990BC6dfe2ef605Bfc08f5A23564dB75642Ad73;\n\n    underlyings[0] = stableToken;\n    underlyings[1] = otherToken;\n    underlyings[2] = wbtc;\n\n    feeds[0] = \"USDC-USD\";\n    feeds[1] = \"USDT-USD\";\n    feeds[2] = \"WBTC-USD\";\n\n    vm.prank(oracle.owner());\n    oracle.setPriceFeeds(underlyings, feeds);\n\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](3);\n    oracles[0] = oracle;\n    oracles[1] = oracle;\n    oracles[2] = oracle;\n\n    vm.prank(mpo.admin());\n    mpo.add(underlyings, oracles);\n  }\n\n  function testUmbrellaPriceOracleLinea() public fork(LINEA_MAINNET) {\n    setUpLinea();\n    vm.startPrank(address(mpo));\n    uint256 upoUsdcPrice = oracle.price(stableToken);\n    uint256 upoUsdtPrice = oracle.price(otherToken);\n    uint256 upoWbtcPrice = oracle.price(wbtc);\n    uint256 mpoWethPrice = mpo.price(wtoken);\n    vm.stopPrank();\n\n    assertApproxEqRel(upoUsdcPrice, upoUsdtPrice, 1e16);\n    assertGt(upoWbtcPrice, mpoWethPrice);\n    assertGt(mpoWethPrice, upoUsdcPrice);\n  }\n}\n"
    },
    "contracts/test/oracles/default/UniswapLikeLpTokenPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { IPair, Observation } from \"../../../external/solidly/IPair.sol\";\nimport { IRouter } from \"../../../external/solidly/IRouter.sol\";\nimport { IUniswapV2Pair } from \"../../../external/uniswap/IUniswapV2Pair.sol\";\nimport { UniswapLpTokenPriceOracle } from \"../../../oracles/default/UniswapLpTokenPriceOracle.sol\";\nimport { SolidlyLpTokenPriceOracle } from \"../../../oracles/default/SolidlyLpTokenPriceOracle.sol\";\nimport { UniswapLikeLpTokenPriceOracle } from \"../../../oracles/default/UniswapLikeLpTokenPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract UniswapLikeLpTokenPriceOracleTest is BaseTest {\n  UniswapLikeLpTokenPriceOracle uniswapLpTokenPriceOracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  function getSolidlyLpTokenPriceOracle() internal returns (UniswapLikeLpTokenPriceOracle) {\n    return new SolidlyLpTokenPriceOracle(wtoken);\n  }\n\n  function getUniswapLpTokenPriceOracle() internal returns (UniswapLikeLpTokenPriceOracle) {\n    return new UniswapLpTokenPriceOracle(wtoken);\n  }\n\n  function getLpPrice(address lpToken, UniswapLikeLpTokenPriceOracle oracle) internal returns (uint256) {\n    if (address(mpo.oracles(lpToken)) == address(0)) {\n      address[] memory underlyings = new address[](1);\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](1);\n\n      underlyings[0] = lpToken;\n      oracles[0] = oracle;\n\n      vm.prank(mpo.admin());\n      mpo.add(underlyings, oracles);\n      emit log(\"added the oracle\");\n    } else {\n      emit log(\"found the oracle\");\n    }\n    return mpo.price(lpToken);\n  }\n\n  function verifyLpPrice(\n    address lpToken,\n    uint256 price,\n    uint256 tolerance\n  ) internal {\n    uint256 priceToken0 = mpo.price(IPair(lpToken).token0());\n    uint256 priceToken1 = mpo.price(IPair(lpToken).token1());\n    uint256 token0Decimals = uint256(ERC20Upgradeable(IPair(lpToken).token0()).decimals());\n    uint256 token1Decimals = uint256(ERC20Upgradeable(IPair(lpToken).token1()).decimals());\n\n    assertApproxEqRel(\n      2 * sqrt(priceToken0 * (10**(18 - token0Decimals))) * sqrt(priceToken1 * (10**(18 - token1Decimals))),\n      price,\n      tolerance\n    );\n  }\n\n  function testBnbXBnbSolidly() public fork(BSC_MAINNET) {\n    address lpToken = 0x6c83E45fE3Be4A9c12BB28cB5BA4cD210455fb55; // Lp BNBx/WBNB (volatile AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17); // 1% tolerance\n  }\n\n  function testUsdtUsdcSolidly() public fork(BSC_MAINNET) {\n    address lpToken = 0x618f9Eb0E1a698409621f4F487B563529f003643; // Lp USDT/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17);\n  }\n\n  function testBusdWbnbSolidly() public fork(BSC_MAINNET) {\n    address lpToken = 0x483653bcF3a10d9a1c334CE16a19471a614F4385; // Lp USDT/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17);\n  }\n\n  function testWbtcWethArbiSolidly() public fork(ARBITRUM_ONE) {\n    address lpToken = 0xd9D611c6943585bc0e18E51034AF8fa28778F7Da; // Lp WBTC/WETH (volatile AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17); // 1% tolerance\n  }\n\n  function testDaitUsdcArbiSolidly() public fork(ARBITRUM_ONE) {\n    address lpToken = 0x07d7F291e731A41D3F0EA4F1AE5b6d920ffb3Fe0; // Lp DAI/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17);\n  }\n\n  function testUsdtUsdcArbiSolidly() public fork(ARBITRUM_ONE) {\n    address lpToken = 0xC9dF93497B1852552F2200701cE58C236cC0378C; // Lp USDT/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17);\n  }\n\n  function testWethGmxArbiSolidly() public fork(ARBITRUM_ONE) {\n    address lpToken = 0x06A4c4389d5C6cD1Ec63dDFFb7e9b3214254A720; // Lp WETH/GMX (volatile AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertTrue(price > 0);\n    verifyLpPrice(lpToken, price, 1e17);\n  }\n\n  // Fixed block number tests\n\n  // https://bscscan.com/tx/0xad3d5e2ddcd246bf6b76e381b8231ef32e3d82b539baf2e1d6a677b9a61967a4\n  // 2,932.668 LP tokens removed from the pool\n  // - 48,841.999 BUSD\n  // - 176,1972 WBNB\n  // =~ $97,945.00  = ~352,32 BNB (BNB price: $278)\n  // Therefor, LP price is 352,32/2,932.668 = 0,1201\n  // FAILING\n  function testForkedBusdWbnbSolidly() public debuggingOnly forkAtBlock(BSC_MAINNET, 26399998) {\n    address lpToken = 0x483653bcF3a10d9a1c334CE16a19471a614F4385; // Lp WBNB-BUSD\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 120054770949519465); // 120054770949519465/1e18 = 0,1200\n  }\n\n  // https://bscscan.com/tx/0xbc26ea6b98235d62b3d6bd48171f999e5016a39f739a35fa36c18de4462baf4b\n  // 39,3053 LP tokens removed from the pool\n  // - 896,4976 BUSD\n  // - 3,233 WBNB\n  // =~ $1,797.86  = ~6,467 BNB (BNB price: $278)\n  // Therefor, LP price is 6,467/39,3053 = 0,1645\n  function testForkedBusdWbnbUniswap() public debuggingOnly forkAtBlock(BSC_MAINNET, 26399706) {\n    address lpToken = 0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16; // Lp WBNB-BUSD\n\n    uint256 price = getLpPrice(lpToken, getUniswapLpTokenPriceOracle());\n    assertEq(price, 164507819383257850); // 164507819383257850/1e18 = 0,1645\n  }\n\n  // https://arbiscan.io/tx/0xff32f8f997d487a3e6f602552f2da9edc1e31f1e023e0e9dcacc77bd177791b1\n  // 0.015037668670 LP tokens removed from the pool\n  // - 14,546.17 DAI\n  // - 15,543.33 USDC\n  // =~ $30,119.52  = ~19.307 ETH (ETH price: $1560)\n  // Therefor, LP price is 19.307/0.015037668670 = 1283,9\n  function testForkedDaiUsdcArbiSolidly() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 67509709) {\n    address lpToken = 0x07d7F291e731A41D3F0EA4F1AE5b6d920ffb3Fe0; // Lp DAI/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 1271806681784147372847); // 1271806681784147372847/1e18 = 1271,80\n  }\n\n  // https://arbiscan.io/tx/0x8e5366d84d278c7dc5fa285c9cb3cf63697763066a77c228b7ae2a2cea9115e7\n  // 0.000000011455333328 LP tokens removed from the pool\n  // - 11,264.0276 USDT\n  // - 11,646.6401 USDC\n  // =~ $22,910  = ~14.68 ETH (ETH price: $1560)\n  // Therefor, LP price is 14.68/0.000000011455333328 = 1,2815e9\n  function testForkedUsdtUsdcArbiSolidly() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 67509709) {\n    address lpToken = 0xC9dF93497B1852552F2200701cE58C236cC0378C; // Lp USDT/USDC (stable AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 1271259093277228095541923239); // 1271259093277228095541923239/1e18 = 1,275e9\n  }\n\n  // https://arbiscan.io/tx/0xcd98ae753ca7cbe93bfb653c3090fa0973ad10ab6b096fe7005216eae3f96a0f\n  // 5.111039 LP tokens added from the pool\n  // - 1.11740494 WETH\n  // - 24.5277511 GMX\n  // =~ $3490,5  = ~2,237 ETH (ETH price: $1560)\n  // Therefor, LP price is 2,237/5,111 = 0,4377\n  function testForkeWethGmxArbiSolidly() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 67509709) {\n    address lpToken = 0x06A4c4389d5C6cD1Ec63dDFFb7e9b3214254A720; // Lp WETH/GMX (volatile AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 439388395594901356); // 439388395594901356/1e18 = 0.43939\n  }\n\n  // https://arbiscan.io/tx/0xb33c8fd30b124070c08eff4c7dd8fbf98c1a8ac8b61e7e9afb5da3c77176c4ff\n  // 0.000000084147497167 LP tokens added from the pool\n  // - 0.00222613 WBTC\n  // - 0.031808  WETH\n  // =~ $99,73  = ~0.06393 ETH (ETH price: $1560)\n  // Therefor, LP price is 0.06393/0.000000084147497167 = 759.737,391\n  function testForkeWethWbtcArbiSolidly() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 67509709) {\n    address lpToken = 0xd9D611c6943585bc0e18E51034AF8fa28778F7Da; // Lp WETH/WBTC (volatile AMM)\n\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 755603082914754302563322); // 755603649957725481578826/1e18 = 755,603.6499\n  }\n\n  // https://bscscan.com/tx/0x4f08c603fddf6d4fcc4cfd7e8fa325d5a2ed6d61f097c86204a5ef915acf4948\n  // 12,593.45 LP tokens added from the pool\n  // - 12,282.086 USDT\n  // - 12,904.8221 USDC\n  // =~ $25,211  = ~86,99 BNB (ETH price: $289,77)\n  // Therefor, LP price is 86,99/12,593.45 = 0,0069\n\n  function testForkeUsdtUsdcBscSolidly() public forkAtBlock(BSC_MAINNET, 26257339) {\n    address lpToken = 0x618f9Eb0E1a698409621f4F487B563529f003643; // Lp USDT/USDC (stable AMM)\n    uint256 price = getLpPrice(lpToken, getSolidlyLpTokenPriceOracle());\n    assertEq(price, 6999543840666976); // 6999543840666976/1e18 = 0.006999543840666965\n  }\n\n  function testSolidlyLPTokenPriceManipulationWithMintAndBurn() public debuggingOnly fork(ARBITRUM_ONE) {\n    address pairAddress = 0x15b9D20bcaa4f65d9004D2BEBAc4058445FD5285;\n    address pairWhale = 0x637DCef6f06A120e0cca5BCa079F6cF6Da9264e8;\n    IRouter router = IRouter(0xF26515D5482e2C2FD237149bF6A653dA4794b3D0);\n\n    SolidlyLpTokenPriceOracle lpOracle = new SolidlyLpTokenPriceOracle(ap.getAddress(\"wtoken\"));\n\n    vm.prank(address(mpo));\n    uint256 priceBefore = lpOracle.price(pairAddress);\n\n    uint256 initialPairBalance = ERC20Upgradeable(pairAddress).balanceOf(pairWhale);\n    emit log_named_uint(\"initialPairBalance\", initialPairBalance);\n\n    // manipulate\n    {\n      uint256 burnAmount = (initialPairBalance * 8) / 10;\n      vm.startPrank(pairWhale);\n      ERC20Upgradeable(pairAddress).approve(address(router), burnAmount);\n      (uint256 amountA, uint256 amountB) = router.removeLiquidity(\n        0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1, // dai\n        0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9, // usdt\n        true,\n        burnAmount,\n        0,\n        0,\n        pairWhale,\n        block.timestamp + 1\n      );\n      emit log_named_uint(\"amountA\", amountA);\n      emit log_named_uint(\"amountB\", amountB);\n      vm.stopPrank();\n    }\n    vm.prank(address(mpo));\n    uint256 priceAfter = lpOracle.price(pairAddress);\n    emit log_named_uint(\"price before\", priceBefore);\n    emit log_named_uint(\"price after\", priceAfter);\n  }\n\n  function testSolidlyLPTokenPriceManipulationWithSwaps() public debuggingOnly fork(ARBITRUM_ONE) {\n    address pairAddress = 0x15b9D20bcaa4f65d9004D2BEBAc4058445FD5285;\n\n    address dai = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n    address usdt = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n\n    address daiWhale = 0x969f7699fbB9C79d8B61315630CDeED95977Cfb8;\n    address usdtWhale = 0xf89d7b9c864f589bbF53a82105107622B35EaA40;\n\n    SolidlyLpTokenPriceOracle lpOracle = new SolidlyLpTokenPriceOracle(ap.getAddress(\"wtoken\"));\n\n    vm.prank(address(mpo));\n    uint256 priceBefore = lpOracle.price(pairAddress);\n    emit log_named_uint(\"price before\", priceBefore);\n\n    IPair pair = IPair(pairAddress);\n    ERC20Upgradeable daiToken = ERC20Upgradeable(pair.token0());\n    ERC20Upgradeable usdtToken = ERC20Upgradeable(pair.token1());\n\n    // manipulate\n    {\n      address hacker = address(666);\n      vm.startPrank(daiWhale);\n      daiToken.transfer(hacker, daiToken.balanceOf(daiWhale));\n      vm.stopPrank();\n\n      vm.startPrank(usdtWhale);\n      usdtToken.transfer(hacker, usdtToken.balanceOf(usdtWhale));\n      vm.stopPrank();\n\n      vm.startPrank(hacker);\n      ERC20Upgradeable tokenToSwap = daiToken;\n\n      // advance > 30 mins so an observations is recorded\n      //vm.warp(block.timestamp + 60 * 22);\n\n      uint256 amountOut = pair.getAmountOut(tokenToSwap.balanceOf(hacker) / 10, address(tokenToSwap));\n      emit log_named_uint(\"amountOut\", amountOut);\n\n      tokenToSwap.transfer(pairAddress, tokenToSwap.balanceOf(hacker) / 10);\n      pair.swap(amountOut, 0, hacker, \"\");\n      vm.stopPrank();\n      vm.prank(address(mpo));\n      emit log_named_uint(\"price after at the same block\", lpOracle.price(pairAddress));\n    }\n\n    for (uint256 i = 0; i < 10; i++) {\n      vm.warp(block.timestamp + 15);\n      pair.sync();\n\n      emit log_named_uint(\"i\", i);\n      vm.prank(address(mpo));\n      emit log_named_uint(\"price after\", lpOracle.price(pairAddress));\n    }\n  }\n}\n"
    },
    "contracts/test/oracles/default/UniswapTwapPriceOracleV2Resolver.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { UniswapTwapPriceOracleV2Root } from \"../../../oracles/default/UniswapTwapPriceOracleV2Root.sol\";\nimport { IUniswapV2Factory } from \"../../../external/uniswap/IUniswapV2Factory.sol\";\nimport { UniswapTwapPriceOracleV2Resolver } from \"../../../oracles/default/UniswapTwapPriceOracleV2Resolver.sol\";\nimport { IUniswapV2Pair } from \"../../../external/uniswap/IUniswapV2Pair.sol\";\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract UniswapTwapOracleV2ResolverTest is BaseTest {\n  UniswapTwapPriceOracleV2Root twapPriceOracleRoot;\n  UniswapTwapPriceOracleV2Resolver resolver;\n  IUniswapV2Factory uniswapV2Factory;\n  MasterPriceOracle mpo;\n\n  struct Observation {\n    uint32 timestamp;\n    uint256 price0Cumulative;\n    uint256 price1Cumulative;\n  }\n\n  function afterForkSetUp() internal override {\n    uniswapV2Factory = IUniswapV2Factory(ap.getAddress(\"IUniswapV2Factory\"));\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  function getTokenTwapPrice(address tokenAddress) internal view returns (uint256) {\n    // return the price denominated in W_NATIVE\n    return mpo.price(tokenAddress);\n  }\n}\n"
    },
    "contracts/test/oracles/default/UniswapV3PriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { UniswapV3PriceOracle } from \"../../../oracles/default/UniswapV3PriceOracle.sol\";\nimport { ChainlinkPriceOracleV2 } from \"../../../oracles/default/ChainlinkPriceOracleV2.sol\";\nimport { ConcentratedLiquidityBasePriceOracle } from \"../../../oracles/default/ConcentratedLiquidityBasePriceOracle.sol\";\nimport { IUniswapV3Pool } from \"../../../external/uniswap/IUniswapV3Pool.sol\";\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\nimport { MasterPriceOracle } from \"../../../oracles/MasterPriceOracle.sol\";\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\n\ncontract UniswapV3PriceOracleTest is BaseTest {\n  UniswapV3PriceOracle oracle;\n  MasterPriceOracle mpo;\n  address wtoken;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    // TODO: remove this after deployment\n    if (block.chainid == ETHEREUM_MAINNET) {\n      return;\n    }\n    stable = ap.getAddress(\"stableToken\"); // USDC or arbitrum\n    wtoken = ap.getAddress(\"wtoken\"); // WETH\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    oracle = new UniswapV3PriceOracle();\n\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n  }\n\n  function testPolygonRetroAlmAssets() public fork(POLYGON_MAINNET) {\n    address[] memory underlyings = new address[](1);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](1);\n\n    underlyings[0] = 0x5D066D022EDE10eFa2717eD3D79f22F949F8C175; // CASH (18 decimals)\n\n    // USDC-CASH\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x619259F699839dD1498FFC22297044462483bD27,\n      10 minutes,\n      stable\n    );\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertTrue(prices[i] > 0, \"!Price Error\");\n    }\n    uint256[] memory expPrices = new uint256[](7);\n    expPrices[0] = mpo.price(stable);\n\n    // CASH should be priced like USDC\n    assertApproxEqRel(prices[0], expPrices[0], 1e15);\n\n    bool[] memory cardinalityChecks = getCardinality(configs);\n    for (uint256 i = 0; i < cardinalityChecks.length; i++) {\n      assertEq(cardinalityChecks[i], true, \"!Cardinality Error\");\n    }\n  }\n\n  function testPolygonAssets() public fork(POLYGON_MAINNET) {\n    address[] memory underlyings = new address[](1);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](1);\n\n    underlyings[0] = 0xE5417Af564e4bFDA1c483642db72007871397896; // GNS (18 decimals)\n\n    // GNS-MATIC\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xEFa98Fdf168f372E5e9e9b910FcDfd65856f3986,\n      10 minutes,\n      wtoken\n    );\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertTrue(prices[i] > 0, \"!Price Error\");\n    }\n\n    bool[] memory cardinalityChecks = getCardinality(configs);\n    for (uint256 i = 0; i < cardinalityChecks.length; i++) {\n      assertEq(cardinalityChecks[i], true, \"!Cardinality Error\");\n    }\n  }\n\n  function testArbitrumAssets() public fork(ARBITRUM_ONE) {\n    address[] memory underlyings = new address[](1);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](1);\n\n    underlyings[0] = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f; // WBTC (18 decimals)\n    // WBTC-USDC\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE,\n      10 minutes,\n      stable\n    );\n    vm.prank(oracle.owner());\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.roll(1);\n\n    vm.prank(address(mpo));\n    uint256 oraclePrice = oracle.price(underlyings[0]);\n    uint256 mpoPrice = mpo.price(underlyings[0]);\n    assertApproxEqRel(oraclePrice, mpoPrice, 1e16, \"Oracle price != MPO price by > 1%\");\n  }\n\n  function testForkedArbitrumAssets() public debuggingOnly forkAtBlock(ARBITRUM_ONE, 122287973) {\n    address[] memory underlyings = new address[](7);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](7);\n\n    underlyings[0] = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a; // GMX (18 decimals)\n    underlyings[1] = 0x6C2C06790b3E3E3c38e12Ee22F8183b37a13EE55; // DPX (18 decimals)\n    underlyings[2] = 0x539bdE0d7Dbd336b79148AA742883198BBF60342; // MAGIC (18 decimals)\n    underlyings[3] = 0xD74f5255D557944cf7Dd0E45FF521520002D5748; // USDs (18 decimals)\n    underlyings[4] = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9; // USDT (6 decimals)\n    underlyings[5] = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a; // GMX (18 decimals)\n    underlyings[6] = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f; // WBTC (8 decimals)\n\n    // GMX-ETH\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x80A9ae39310abf666A87C743d6ebBD0E8C42158E,\n      10 minutes,\n      wtoken\n    );\n    // DPX-ETH\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xb52781C275431bD48d290a4318e338FE0dF89eb9,\n      10 minutes,\n      wtoken\n    );\n    // MAGIC-ETH\n    configs[2] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x7e7FB3CCEcA5F2ac952eDF221fd2a9f62E411980,\n      10 minutes,\n      wtoken\n    );\n    // USDs-USDC\n    configs[3] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x50450351517117Cb58189edBa6bbaD6284D45902,\n      10 minutes,\n      stable\n    );\n    // USDT-USDC\n    configs[4] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0x13398E27a21Be1218b6900cbEDF677571df42A48,\n      10 minutes,\n      stable\n    );\n    // GMX-USDC\n    configs[5] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xBed2589feFAE17d62A8a4FdAC92fa5895cAe90d2,\n      10 minutes,\n      stable\n    );\n    // WBTC-USDC\n    configs[6] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xA62aD78825E3a55A77823F00Fe0050F567c1e4EE,\n      10 minutes,\n      stable\n    );\n\n    uint256[] memory expPrices = new uint256[](7);\n    expPrices[0] = 22458983666679741; // (22458983666679741 / 1e18) * 1807 = $75.4 (17/08/2023)\n    expPrices[1] = 39909577522344847; //  (39909577522344847 / 1e18) * 1807 = $72 (17/08/2023)\n    expPrices[2] = 373271191958027; //  (373271191958027 / 1e18) * 1807 = $0.67 (17/08/2023\n    expPrices[3] = 557704868599802; // (557704868599802 / 1e18) * 1807 = $1.005 (17/08/2023\n    expPrices[4] = 559771099154822; // (559771099154822 / 1e18) * 1807 = $1.01 (17/08/2023\n    expPrices[5] = 22458983666679741; // (22458983666679741 / 1e18) * 1807 = $40,5 (17/08/2023)\n    expPrices[6] = 15955521590135476492; //  (15955521590135476492 / 1e18) * 1807 = $28.864,6 (17/08/2023)\n\n    emit log_named_uint(\"USDC PRICE\", mpo.price(stable));\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    for (uint256 i = 0; i < prices.length; i++) {\n      assertEq(prices[i], expPrices[i], \"!Price Error\");\n    }\n\n    bool[] memory cardinalityChecks = getCardinality(configs);\n    for (uint256 i = 0; i < cardinalityChecks.length; i++) {\n      assertEq(cardinalityChecks[i], true, \"!Cardinality Error\");\n    }\n  }\n\n  function testEthereumAssets() public fork(ETHEREUM_MAINNET) {\n    // TODO: Remove these after mainnet deployment\n    // Initialise MPO\n    stable = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    wtoken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    setUpBaseOracles();\n\n    // Initialise Uniswap Oracle\n    oracle = new UniswapV3PriceOracle();\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n\n    address[] memory underlyings = new address[](2);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](2);\n\n    underlyings[0] = 0x68037790A0229e9Ce6EaA8A99ea92964106C4703; // PAR (18 decimals)\n    underlyings[1] = 0x0ab87046fBb341D058F17CBC4c1133F25a20a52f; // gOHM decimals)\n    // PAR-USDC\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xD7Dcb0eb6AaB643b85ba74cf9997c840fE32e695,\n      10 minutes,\n      stable\n    );\n    // GOHM-USDC\n    configs[1] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xcF7e21b96a7DAe8e1663b5A266FD812CBE973E70,\n      10 minutes,\n      stable\n    );\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n    uint256 mpoPrice = mpo.price(underlyings[0]);\n    // Compare univ3 (PAR/USDC) vs Chainlink prices (EUR/USD)\n    assertApproxEqRel(prices[0], mpoPrice, 1e16, \"Oracle price != MPO price by > 1%\");\n    assertGt(prices[1], mpo.price(wtoken), \"gOHM price is > eth price\");\n\n    bool[] memory cardinalityChecks = getCardinality(configs);\n    for (uint256 i = 0; i < cardinalityChecks.length; i++) {\n      assertEq(cardinalityChecks[i], true, \"!Cardinality Error\");\n    }\n  }\n\n  function testForkedEthereumAssets() public forkAtBlock(ETHEREUM_MAINNET, 17065696) {\n    // TODO: Remove these after mainnet deployment\n    // Initialise MPO\n    stable = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    wtoken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    setUpBaseOracles();\n\n    // Initialise Uniswap Oracle\n    oracle = new UniswapV3PriceOracle();\n    vm.prank(mpo.admin());\n    oracle.initialize(wtoken, asArray(stable));\n\n    address[] memory underlyings = new address[](1);\n    ConcentratedLiquidityBasePriceOracle.AssetConfig[]\n      memory configs = new ConcentratedLiquidityBasePriceOracle.AssetConfig[](1);\n\n    underlyings[0] = 0x0ab87046fBb341D058F17CBC4c1133F25a20a52f; // gOHM decimals)\n    // GOHM-USDC\n    configs[0] = ConcentratedLiquidityBasePriceOracle.AssetConfig(\n      0xcF7e21b96a7DAe8e1663b5A266FD812CBE973E70,\n      10 minutes,\n      wtoken\n    );\n    uint256[] memory prices = getPriceFeed(underlyings, configs);\n\n    // 17/04/2024\n    // - ETH Price = 2096  USD\n    // - gOHM Price = 2,745.22 USD\n    // - gOHM Price = 1.30 ETH\n    assertEq(prices[0], 1296264965685839645, \"!price\");\n  }\n\n  function setUpBaseOracles() public {\n    // TODO: Remove these after mainnet deployment\n    if (block.chainid == ETHEREUM_MAINNET) {\n      setUpMpoAndAddresses();\n      BasePriceOracle[] memory oracles = new BasePriceOracle[](2);\n      ChainlinkPriceOracleV2 chainlinkOracle = new ChainlinkPriceOracleV2();\n      chainlinkOracle.initialize(stable, 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n      vm.prank(chainlinkOracle.owner());\n      chainlinkOracle.setPriceFeeds(\n        asArray(stable),\n        asArray(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4),\n        ChainlinkPriceOracleV2.FeedBaseCurrency.ETH\n      );\n      chainlinkOracle.setPriceFeeds(\n        asArray(0x68037790A0229e9Ce6EaA8A99ea92964106C4703), // PAR\n        asArray(0xb49f677943BC038e9857d61E7d053CaA2C1734C1), // EUR/USD price feed\n        ChainlinkPriceOracleV2.FeedBaseCurrency.USD\n      );\n      oracles[0] = chainlinkOracle;\n      oracles[1] = chainlinkOracle;\n\n      vm.prank(mpo.admin());\n      mpo.add(asArray(stable, 0x68037790A0229e9Ce6EaA8A99ea92964106C4703), oracles);\n    }\n  }\n\n  function setUpMpoAndAddresses() public {\n    address[] memory assets = new address[](0);\n    BasePriceOracle[] memory oracles = new BasePriceOracle[](0);\n    mpo = new MasterPriceOracle();\n    mpo.initialize(assets, oracles, BasePriceOracle(address(0)), address(this), true, address(wtoken));\n  }\n\n  function getPriceFeed(address[] memory underlyings, UniswapV3PriceOracle.AssetConfig[] memory configs)\n    internal\n    returns (uint256[] memory price)\n  {\n    vm.prank(oracle.owner());\n    oracle.setPoolFeeds(underlyings, configs);\n    vm.roll(1);\n\n    price = new uint256[](underlyings.length);\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      vm.prank(address(mpo));\n      price[i] = oracle.price(underlyings[i]);\n    }\n    return price;\n  }\n\n  function getCardinality(UniswapV3PriceOracle.AssetConfig[] memory configs) internal view returns (bool[] memory) {\n    bool[] memory checks = new bool[](configs.length);\n    for (uint256 i = 0; i < configs.length; i += 1) {\n      (, , , , uint16 observationCardinalityNext, , ) = IUniswapV3Pool(configs[i].poolAddress).slot0();\n      checks[i] = observationCardinalityNext >= 10;\n    }\n\n    return checks;\n  }\n}\n"
    },
    "contracts/test/oracles/default/WombatLpTokenPriceOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { WombatLpTokenPriceOracle } from \"../../../oracles/default/WombatLpTokenPriceOracle.sol\";\n\ncontract WombatLpTokenPriceOracleTest is BaseTest {\n  WombatLpTokenPriceOracle private oracle;\n\n  function afterForkSetUp() internal override {\n    oracle = new WombatLpTokenPriceOracle();\n  }\n\n  function testPrice() public fork(BSC_MAINNET) {\n    // price for Wombat Wrapped BNB asset\n    vm.prank(ap.getAddress(\"MasterPriceOracle\"));\n    uint256 price = oracle.price(0x74f019A5C4eD2C2950Ce16FaD7Af838549092c5b);\n    assertEq(price, 1e18);\n  }\n}\n"
    },
    "contracts/test/oracles/default/WSTEthPriceOracleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"../../config/BaseTest.t.sol\";\nimport { WSTEthPriceOracle } from \"../../../oracles/default/WSTEthPriceOracle.sol\";\n\ncontract WSTEthPriceOracleTest is BaseTest {\n  WSTEthPriceOracle private oracle;\n  address wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n  address mpo = 0xdD8d4e09Acb39C2B4DE9A84384389B79850f3271;\n\n  function afterForkSetUp() internal override {\n    oracle = new WSTEthPriceOracle();\n    oracle.initialize();\n  }\n\n  function testWstEthOraclePrice() public forkAtBlock(ETHEREUM_MAINNET, 17469681) {\n    vm.prank(mpo);\n    uint256 priceWstEth = oracle.price(wstETH);\n\n    assertGt(priceWstEth, 1e18);\n    assertEq(priceWstEth, 1006482474298479702);\n  }\n}\n"
    },
    "contracts/test/oracles/RedstoneAdapterOracleTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\nimport { RedstoneAdapterPriceOracle } from \"../../oracles/default/RedstoneAdapterPriceOracle.sol\";\n\nimport { BaseTest } from \"../config/BaseTest.t.sol\";\n\ncontract RedstoneAdapterOracleTest is BaseTest {\n  MasterPriceOracle public mpo;\n  RedstoneAdapterPriceOracle public oracle;\n  address public redstoneOracleAddress;\n  address MODE_USDC = 0xd988097fb8612cc24eeC14542bC03424c656005f;\n  address MODE_EZETH = 0x2416092f143378750bb29b79eD961ab195CcEea5;\n  address MODE_WBTC = 0xcDd475325D6F564d27247D1DddBb0DAc6fA0a5CF;\n  address MODE_WEETH = 0x028227c4dd1e5419d11Bb6fa6e661920c519D4F5;\n\n  function afterForkSetUp() internal override {\n    if (block.chainid == MODE_MAINNET) {\n      redstoneOracleAddress = 0x7C1DAAE7BB0688C9bfE3A918A4224041c7177256;\n    }\n\n    oracle = new RedstoneAdapterPriceOracle(redstoneOracleAddress);\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n  }\n\n  function testPrintPricesMode() public fork(MODE_MAINNET) {\n    emit log_named_uint(\"ezETH price (18 dec)\", oracle.price(MODE_EZETH));\n    emit log_named_uint(\"WBTC price (8 dec)\", oracle.price(MODE_WBTC));\n    emit log_named_uint(\"weETH price (18 dec)\", oracle.price(MODE_WEETH));\n  }\n\n  function testPrintMpoPricesMode() public fork(MODE_MAINNET) {\n    emit log_named_uint(\"weETH price (18 dec)\", mpo.price(MODE_WEETH));\n  }\n}\n"
    },
    "contracts/test/OraclesDecimalsScalingTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n\nimport { IERC20MetadataUpgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ncontract OraclesDecimalsScalingTest is BaseTest {\n  MasterPriceOracle mpo;\n  PoolDirectory poolDirectory;\n  address stable;\n\n  function afterForkSetUp() internal override {\n    mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\n    poolDirectory = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    stable = ap.getAddress(\"stableToken\");\n  }\n\n  function testOracleDecimalsBsc() public fork(BSC_MAINNET) {\n    testOraclesDecimals();\n  }\n\n  function testOracleDecimalsArbitrum() public fork(ARBITRUM_ONE) {\n    testOraclesDecimals();\n  }\n\n  function testOracleDecimalsPolygon() public fork(POLYGON_MAINNET) {\n    testOraclesDecimals();\n  }\n\n  function testOracleDecimalsNeon() public fork(NEON_MAINNET) {\n    vm.mockCall(stable, abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector), abi.encode(6));\n    // SOL\n    vm.mockCall(\n      0x5f38248f339Bf4e84A2caf4e4c0552862dC9F82a,\n      abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector),\n      abi.encode(9)\n    );\n    testOraclesDecimals();\n  }\n\n  function testOraclesDecimals() internal {\n    if (address(poolDirectory) != address(0)) {\n      (, PoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\n\n      for (uint8 i = 0; i < pools.length; i++) {\n        IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n        ICErc20[] memory markets = comptroller.getAllMarkets();\n        for (uint8 j = 0; j < markets.length; j++) {\n          address underlying = markets[j].underlying();\n\n          if (isSkipped(underlying)) {\n            emit log(\"the oracle for this underlying cannot be tested\");\n            emit log_address(underlying);\n            continue;\n          }\n\n          uint256 oraclePrice = mpo.price(underlying);\n          uint256 scaledPrice = mpo.getUnderlyingPrice(markets[j]);\n\n          uint8 decimals = IERC20MetadataUpgradeable(underlying).decimals();\n          uint256 expectedScaledPrice = decimals <= 18\n            ? uint256(oraclePrice) * (10**(18 - decimals))\n            : uint256(oraclePrice) / (10**(decimals - 18));\n\n          assertEq(scaledPrice, expectedScaledPrice, \"the comptroller expects prices to be scaled by 1e(36-decimals)\");\n        }\n      }\n    }\n  }\n\n  function isSkipped(address token) internal pure returns (bool) {\n    return token == 0x5f38248f339Bf4e84A2caf4e4c0552862dC9F82a; // SOL on neon, failing for unknwon reasons, works in HH\n  }\n}\n"
    },
    "contracts/test/performanceFee/ERC4626PerformanceFee.t.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity ^0.8.0;\n\n// import { BaseTest } from \"../config/BaseTest.t.sol\";\n\n// import { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n// import { IBeefyVault, BeefyERC4626, IonicERC4626 } from \"../../ionic/strategies/BeefyERC4626.sol\";\n// import { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\n// import { PoolDirectory } from \"../../PoolDirectory.sol\";\n// import { CErc20PluginDelegate } from \"../../compound/CErc20PluginDelegate.sol\";\n// import { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\n// import { IERC4626 } from \"../../compound/IERC4626.sol\";\n\n// import { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n\n// contract ERC4626PerformanceFeeTest is BaseTest {\n//   using FixedPointMathLib for uint256;\n\n//   uint256 PERFORMANCE_FEE = 5e16;\n//   uint256 DEPOSIT_AMOUNT = 100e18;\n//   uint256 BPS_DENOMINATOR = 10_000;\n\n//   BeefyERC4626 plugin;\n//   ERC20Upgradeable underlyingToken;\n//   IBeefyVault beefyVault = IBeefyVault(0x94E85B8E050F3F281CB9597cc0144F1F7AF1fe9B); // BOMB-BTCB LP\n//   address beefyStrategy = 0xEeBcd7E1f008C52fe5804B306832B7DD317e163D;\n//   address lpChef = 0x1083926054069AaD75d7238E9B809b0eF9d94e5B;\n//   address newFeeRecipient = address(5);\n\n//   function afterForkSetUp() internal override {\n//     if (block.chainid == BSC_MAINNET) {\n//       underlyingToken = ERC20Upgradeable(address(beefyVault.want()));\n//       plugin = new BeefyERC4626();\n//       plugin.initialize(underlyingToken, beefyVault, 10);\n\n//       uint256 currentPerformanceFee = plugin.performanceFee();\n//       plugin.updateFeeSettings(currentPerformanceFee, newFeeRecipient);\n//     }\n//   }\n\n//   /* --------------------- HELPER FUNCTIONS --------------------- */\n\n//   function deposit(address _owner, uint256 amount) public {\n//     vm.startPrank(_owner);\n//     underlyingToken.approve(address(plugin), amount);\n//     plugin.deposit(amount, _owner);\n//     vm.stopPrank();\n//   }\n\n//   function increaseAssetsInVault() public {\n//     deal(address(underlyingToken), address(beefyVault), 1000e18);\n//     beefyVault.earn();\n//   }\n\n//   function createPerformanceFee() public {\n//     deal(address(underlyingToken), address(this), DEPOSIT_AMOUNT);\n\n//     deposit(address(this), DEPOSIT_AMOUNT);\n\n//     increaseAssetsInVault();\n//   }\n\n//   /* --------------------- ERC4626 PERFORMANCE FEE TESTS --------------------- */\n\n//   function test__initializedValues() public fork(BSC_MAINNET) {\n//     assertEq(plugin.performanceFee(), PERFORMANCE_FEE, \"!perFee\");\n//     assertEq(plugin.feeRecipient(), newFeeRecipient, \"!feeRecipient\");\n//   }\n\n//   function test__UpdateFeeSettings() public fork(BSC_MAINNET) {\n//     uint256 newPerfFee = 100;\n//     address anotherFeeRecipient = address(10);\n\n//     plugin.updateFeeSettings(newPerfFee, anotherFeeRecipient);\n\n//     assertEq(plugin.performanceFee(), newPerfFee, \"!perfFee == newPerfFee\");\n\n//     assertEq(plugin.feeRecipient(), anotherFeeRecipient, \"!feeRecipient == anotherFeeRecipient\");\n//   }\n\n//   function testRevert__UpdateFeeSettings() public fork(BSC_MAINNET) {\n//     vm.startPrank(address(10));\n//     vm.expectRevert(\"Ownable: caller is not the owner\");\n//     plugin.updateFeeSettings(100, address(10));\n//   }\n\n//   function test__TakePerformanceFeeInUnderlyingAsset() public fork(BSC_MAINNET) {\n//     createPerformanceFee();\n\n//     uint256 oldAssets = plugin.totalAssets();\n//     uint256 oldSupply = plugin.totalSupply();\n\n//     uint256 accruedPerformanceFee = (oldAssets - DEPOSIT_AMOUNT).mulDivDown(PERFORMANCE_FEE, 1e18);\n//     // I had to change this from -1 on the current block to -2 in the pinned block. Not a 100% sure why there is this difference in returned assets from beefy\n//     uint256 expectedFeeShares = accruedPerformanceFee.mulDivDown(oldSupply, (oldAssets - accruedPerformanceFee)) - 2;\n\n//     plugin.takePerformanceFee();\n\n//     assertApproxEqAbs(\n//       plugin.totalSupply() - oldSupply,\n//       expectedFeeShares,\n//       uint256(10),\n//       \"totalSupply increase didnt match expectedFeeShares\"\n//     );\n//     assertApproxEqAbs(plugin.balanceOf(plugin.feeRecipient()), expectedFeeShares, uint256(10), \"!feeRecipient shares\");\n//     assertEq(plugin.totalAssets(), oldAssets, \"totalAssets should not change\");\n//   }\n\n//   function test__WithdrawAccruedFees() public fork(BSC_MAINNET) {\n//     plugin.updateFeeSettings(PERFORMANCE_FEE, address(10));\n\n//     createPerformanceFee();\n\n//     uint256 oldAssets = plugin.totalAssets();\n//     uint256 oldSupply = plugin.totalSupply();\n\n//     uint256 accruedPerformanceFee = (oldAssets - DEPOSIT_AMOUNT).mulDivDown(PERFORMANCE_FEE, 1e18);\n//     // I had to change this from -1 on the current block to -2 in the pinned block. Not a 100% sure why there is this difference in returned assets from beefy\n//     uint256 expectedFeeShares = accruedPerformanceFee.mulDivDown(oldSupply, (oldAssets - accruedPerformanceFee)) - 2;\n\n//     plugin.takePerformanceFee();\n\n//     assertApproxEqAbs(\n//       plugin.totalSupply() - oldSupply,\n//       expectedFeeShares,\n//       uint256(10),\n//       \"totalSupply increase didnt match expectedFeeShares\"\n//     );\n//     assertApproxEqAbs(plugin.balanceOf(plugin.feeRecipient()), expectedFeeShares, uint256(10), \"!feeShares minted\");\n\n//     plugin.withdrawAccruedFees();\n\n//     assertEq(plugin.balanceOf(plugin.feeRecipient()), 0, \"!feeRecipient plugin bal == 0\");\n//     assertEq(plugin.totalSupply(), oldSupply, \"!totalSupply == oldSupply\");\n//   }\n\n//   function testRevert__WithdrawAccruedFees() public fork(BSC_MAINNET) {\n//     vm.startPrank(address(10));\n//     vm.expectRevert(\"Ownable: caller is not the owner\");\n//     plugin.withdrawAccruedFees();\n//   }\n\n//   function testPolygonAllPluginsFeeRecipient() public debuggingOnly fork(POLYGON_MAINNET) {\n//     _testAllPluginsFeeRecipient();\n//   }\n\n//   function testBscAllPluginsFeeRecipient() public debuggingOnly fork(BSC_MAINNET) {\n//     _testAllPluginsFeeRecipient();\n//   }\n\n//   function testArbitrumAllPluginsFeeRecipient() public debuggingOnly fork(ARBITRUM_ONE) {\n//     _testAllPluginsFeeRecipient();\n//   }\n\n//   function _testAllPluginsFeeRecipient() internal {\n//     PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n//     (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n//     for (uint8 i = 0; i < pools.length; i++) {\n//       IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\n//       ICErc20[] memory markets = comptroller.getAllMarkets();\n//       for (uint8 j = 0; j < markets.length; j++) {\n//         CErc20PluginDelegate delegate = CErc20PluginDelegate(address(markets[j]));\n\n//         try delegate.plugin() returns (IERC4626 _plugin) {\n//           IonicERC4626 plugin = IonicERC4626(address(_plugin));\n\n//           address fr = plugin.feeRecipient();\n//           if (fr != ap.getAddress(\"deployer\")) emit log_named_address(\"plugin fr\", address(plugin));\n//           assertEq(fr, ap.getAddress(\"deployer\"), \"fee recipient not correct\");\n//         } catch {\n//           continue;\n//         }\n//       }\n//     }\n//   }\n// }\n"
    },
    "contracts/test/performanceFee/FlywheelPerformanceFee.t.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity ^0.8.0;\n\n// import { BaseTest } from \"../config/BaseTest.t.sol\";\n\n// import { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n// import { IonicERC4626, DotDotLpERC4626, ILpDepositor } from \"../../ionic/strategies/DotDotLpERC4626.sol\";\n// import { ERC20 } from \"solmate/tokens/ERC20.sol\";\n// import { IonicFlywheelCore } from \"../../ionic/strategies/flywheel/IonicFlywheelCore.sol\";\n// import { ComptrollerFirstExtension } from \"../../compound/ComptrollerFirstExtension.sol\";\n// import { PoolDirectory } from \"../../PoolDirectory.sol\";\n\n// import { FlywheelCore, IFlywheelRewards } from \"flywheel-v2/FlywheelCore.sol\";\n// import { FuseFlywheelDynamicRewards } from \"fuse-flywheel/rewards/FuseFlywheelDynamicRewards.sol\";\n// import { IFlywheelBooster } from \"flywheel-v2/interfaces/IFlywheelBooster.sol\";\n// import { Authority } from \"solmate/auth/Auth.sol\";\n\n// import { ERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\n// import { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// struct RewardsCycle {\n//   uint32 start;\n//   uint32 end;\n//   uint192 reward;\n// }\n\n// contract FlywheelPerformanceFeeTest is BaseTest {\n//   using FixedPointMathLib for uint256;\n\n//   uint256 PERFORMANCE_FEE = 10e16;\n//   uint256 DEPOSIT_AMOUNT = 100e18;\n//   uint256 BPS_DENOMINATOR = 10_000;\n\n//   address feeRecipient = address(16);\n//   IonicERC4626 plugin;\n//   ERC20Upgradeable underlyingToken = ERC20Upgradeable(0x1B6E11c5DB9B15DE87714eA9934a6c52371CfEA9);\n\n//   address whale = 0x0BC3a8239B0a63E945Ea1bd6722Ba747b9557e56;\n\n//   ILpDepositor lpDepositor = ILpDepositor(0x8189F0afdBf8fE6a9e13c69bA35528ac6abeB1af);\n//   ERC20 depositShare = ERC20(0xEFF5b0E496dC7C26fFaA014cEa0d2Baa83DB11c4);\n\n//   ERC20 dddToken = ERC20(0x84c97300a190676a19D1E13115629A11f8482Bd1);\n//   address flywheelOwner = address(1338);\n//   IonicFlywheelCore dddFlywheel;\n//   FuseFlywheelDynamicRewards dddRewards;\n\n//   ERC20 epxToken = ERC20(0xAf41054C1487b0e5E2B9250C0332eCBCe6CE9d71);\n//   IonicFlywheelCore epxFlywheel;\n\n//   uint256 rewardAmount = 1000e18;\n//   ERC20 marketKey;\n//   address marketAddress;\n\n//   ERC20Upgradeable[] rewardsToken;\n\n//   function afterForkSetUp() internal override {\n//     vm.startPrank(flywheelOwner);\n//     IonicFlywheelCore impl = new IonicFlywheelCore();\n//     TransparentUpgradeableProxy proxyDdd = new TransparentUpgradeableProxy(address(impl), address(dpa), \"\");\n//     dddFlywheel = IonicFlywheelCore(address(proxyDdd));\n//     dddFlywheel.initialize(dddToken, IFlywheelRewards(address(0)), IFlywheelBooster(address(0)), flywheelOwner);\n//     dddRewards = new FuseFlywheelDynamicRewards(FlywheelCore(address(dddFlywheel)), 1);\n//     dddFlywheel.setFlywheelRewards(dddRewards);\n\n//     TransparentUpgradeableProxy proxyEpx = new TransparentUpgradeableProxy(address(impl), address(dpa), \"\");\n//     epxFlywheel = IonicFlywheelCore(address(proxyEpx));\n//     epxFlywheel.initialize(epxToken, IFlywheelRewards(address(0)), IFlywheelBooster(address(0)), address(this));\n\n//     ERC20 dddFlywheelRewardToken = FlywheelCore(address(dddFlywheel)).rewardToken();\n//     rewardsToken.push(ERC20Upgradeable(address(dddFlywheelRewardToken)));\n//     ERC20 epxFlywheelRewardToken = FlywheelCore(address(epxFlywheel)).rewardToken();\n//     rewardsToken.push(ERC20Upgradeable(address(epxFlywheelRewardToken)));\n\n//     DotDotLpERC4626 dotDotLpERC4626 = new DotDotLpERC4626();\n//     dotDotLpERC4626.initialize(\n//       underlyingToken,\n//       FlywheelCore(address(dddFlywheel)),\n//       FlywheelCore(address(epxFlywheel)),\n//       ILpDepositor(address(lpDepositor)),\n//       address(flywheelOwner),\n//       rewardsToken\n//     );\n\n//     plugin = dotDotLpERC4626;\n//     marketAddress = address(plugin);\n//     marketKey = ERC20(address(plugin));\n\n//     dddFlywheel.addStrategyForRewards(marketKey);\n//     DotDotLpERC4626(address(plugin)).setRewardDestination(marketAddress);\n//     vm.stopPrank();\n\n//     vm.prank(marketAddress);\n//     dddToken.approve(address(dddRewards), type(uint256).max);\n//   }\n\n//   /* --------------------- HELPER FUNCTIONS --------------------- */\n\n//   function deposit(address _owner, uint256 amount) internal {\n//     vm.startPrank(_owner);\n//     underlyingToken.approve(address(plugin), amount);\n//     plugin.deposit(amount, _owner);\n//     vm.stopPrank();\n//   }\n\n//   function createPerformanceFee() internal {\n//     deal(address(underlyingToken), address(this), DEPOSIT_AMOUNT);\n\n//     deposit(address(this), DEPOSIT_AMOUNT);\n\n//     // Create rewards\n//     deal(address(dddToken), marketAddress, rewardAmount);\n\n//     dddFlywheel.accrue(marketKey, address(this));\n\n//     vm.warp(block.timestamp + 150);\n//     vm.roll(10);\n\n//     dddFlywheel.accrue(marketKey, address(this));\n//   }\n\n//   /* --------------------- FLYWHEEL PERFORMANCE FEE TESTS --------------------- */\n\n//   function test__initializedValues() public fork(BSC_MAINNET) {\n//     assertEq(dddFlywheel.performanceFee(), PERFORMANCE_FEE, \"!perFee\");\n//     assertEq(dddFlywheel.feeRecipient(), flywheelOwner, \"!feeRecipient\");\n//   }\n\n//   function test__UpdateFeeSettings() public fork(BSC_MAINNET) {\n//     uint256 newPerfFee = 100;\n//     address newFeeRecipient = feeRecipient;\n\n//     vm.prank(flywheelOwner);\n//     dddFlywheel.updateFeeSettings(newPerfFee, newFeeRecipient);\n\n//     assertEq(dddFlywheel.performanceFee(), newPerfFee, \"!perfFee == newPerfFee\");\n//     assertEq(dddFlywheel.feeRecipient(), newFeeRecipient, \"!feeRecipient == newFeeRecipient\");\n//   }\n\n//   function testRevert__UpdateFeeSettings() public fork(BSC_MAINNET) {\n//     vm.prank(feeRecipient);\n//     vm.expectRevert(\"Ownable: caller is not the owner\");\n//     dddFlywheel.updateFeeSettings(100, feeRecipient);\n//   }\n\n//   function test__TakePerformanceFeeInUnderlyingAsset() public fork(BSC_MAINNET) {\n//     createPerformanceFee();\n\n//     uint256 expectedPerformanceFee = (rewardAmount * dddFlywheel.performanceFee()) / 1e18;\n\n//     assertEq(\n//       dddFlywheel.rewardsAccrued(dddFlywheel.feeRecipient()),\n//       expectedPerformanceFee,\n//       \"rewards accrued of the feeRecipient dont match expectedPerformanceFee\"\n//     );\n//     // Proxy call for checking the global rewards accrued. (address(this) is the only depositor so they should receive all other rewards)\n//     assertEq(\n//       dddFlywheel.rewardsAccrued(address(this)),\n//       rewardAmount - expectedPerformanceFee,\n//       \"the rewardsState gets updated correctly\"\n//     );\n//   }\n\n//   function test__WithdrawAccruedFees() public fork(BSC_MAINNET) {\n//     vm.prank(flywheelOwner);\n//     dddFlywheel.updateFeeSettings(PERFORMANCE_FEE, feeRecipient);\n\n//     createPerformanceFee();\n\n//     uint256 expectedPerformanceFee = (rewardAmount * dddFlywheel.performanceFee()) / 1e18;\n\n//     dddFlywheel.claimRewards(feeRecipient);\n\n//     assertEq(dddToken.balanceOf(feeRecipient), expectedPerformanceFee, \"feeRecipient didnt receive their fees\");\n//     assertEq(\n//       dddToken.balanceOf(address(dddRewards)),\n//       rewardAmount - expectedPerformanceFee,\n//       \"the rewardsModule didnt properly send the fees\"\n//     );\n//     assertEq(dddFlywheel.rewardsAccrued(feeRecipient), 0, \"feeRecipient rewardsAccrued should be 0\");\n//   }\n\n//   function testPolygonAllFlywheelsFeeRecipient() public debuggingOnly fork(POLYGON_MAINNET) {\n//     _testAllFlywheelsFeeRecipient();\n//   }\n\n//   function testBscAllFlywheelsFeeRecipient() public debuggingOnly fork(BSC_MAINNET) {\n//     _testAllFlywheelsFeeRecipient();\n//   }\n\n//   function testArbitrumAllFlywheelsFeeRecipient() public debuggingOnly fork(ARBITRUM_ONE) {\n//     _testAllFlywheelsFeeRecipient();\n//   }\n\n//   function _testAllFlywheelsFeeRecipient() internal {\n//     PoolDirectory fpd = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n//     (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\n\n//     for (uint8 i = 0; i < pools.length; i++) {\n//       ComptrollerFirstExtension poolExt = ComptrollerFirstExtension(pools[i].comptroller);\n//       address[] memory fws = poolExt.getRewardsDistributors();\n//       for (uint256 j = 0; j < fws.length; j++) {\n//         address fr = IonicFlywheelCore(fws[j]).feeRecipient();\n//         if (fr != ap.getAddress(\"deployer\")) emit log_named_address(\"flywheel fr\", fws[j]);\n//         assertEq(fr, ap.getAddress(\"deployer\"), \"fee recipient not correct\");\n//       }\n//     }\n//   }\n// }\n"
    },
    "contracts/test/PermissionedLiquidationsMarketTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { MarketsTest } from \"./config/MarketsTest.t.sol\";\n\nimport { DiamondExtension, DiamondBase } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../compound/CErc20PluginDelegate.sol\";\nimport { CErc20Delegator } from \"../compound/CErc20Delegator.sol\";\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { CTokenFirstExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { ComptrollerV3Storage } from \"../compound/ComptrollerStorage.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\nimport { ILiquidator } from \"../ILiquidator.sol\";\n\nimport { IERC20Upgradeable } from \"openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport { PoolLens } from \"../PoolLens.sol\";\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\nimport { IonicUniV3Liquidator } from \"../IonicUniV3Liquidator.sol\";\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { IRedemptionStrategy } from \"../liquidators/IRedemptionStrategy.sol\";\nimport { IFundsConversionStrategy } from \"../liquidators/IFundsConversionStrategy.sol\";\n\ncontract PermissionedLiquidationsMarketTest is MarketsTest {\n  ICErc20 wethMarket;\n  ICErc20 usdtMarket;\n\n  ICErc20 wethNativeMarket;\n  ICErc20 usdcNativeMarket;\n  ICErc20 usdtNativeMarket;\n  ICErc20 modeNativeMarket;\n\n  IonicComptroller pool;\n  PoolLens lens;\n  address borrower;\n  address liquidator;\n  IonicUniV3Liquidator uniV3liquidator;\n\n  function afterForkSetUp() internal virtual override {\n    super.afterForkSetUp();\n\n    wethMarket = ICErc20(0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2);\n    usdtMarket = ICErc20(0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3);\n\n    wethNativeMarket = ICErc20(0xDb8eE6D1114021A94A045956BBeeCF35d13a30F2);\n    usdcNativeMarket = ICErc20(0xc53edEafb6D502DAEC5A7015D67936CEa0cD0F52);\n    usdtNativeMarket = ICErc20(0x3120B4907851cc9D780eef9aF88ae4d5360175Fd);\n    modeNativeMarket = ICErc20(0x4341620757Bee7EB4553912FaFC963e59C949147);\n\n    pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n    lens = PoolLens(0x70BB19a56BfAEc65aE861E6275A90163AbDF36a6);\n    ffd = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    borrower = 0xcE6cEFa163468F730206688665516952bcf83B74;\n    liquidator = 0xE000008459b74a91e306a47C808061DFA372000E;\n    uniV3liquidator = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\n\n    vm.prank(ap.owner());\n    ap.setAddress(\"PoolLens\", address(lens));\n  }\n\n  function testLiquidateNoThreshold() public debuggingOnly forkAtBlock(MODE_MAINNET, 10455052) {\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n\n    vm.prank(usdtMarket.ionicAdmin());\n    CTokenFirstExtension(address(usdtMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    address targetContract = 0x927ae5509688eA6B992ba41Ecd1d49a6e7d69109;\n    bytes\n      memory data = hex\"a9059cbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000003a000000000000000000000000000000000000000000000000000000000000002dd0b94812f2eea03a49869f95e1b5868c6f3206ee3d3002417bfdfbc000000000000000000000000ce6cefa163468f730206688665516952bcf83b740001000000000000000000000000000000000000000000000000000000006d3171ea02000000000000000000000000000000000000000000000000000000003698b8f5f0f161fda2712db8b566946122a5af183995e2ed02b702ce183b4e1faa574834715e5d4a6378d0eed3092be717340023c9e14c1bb12cb3ecbcfd3c3fb038000004a6afed9507f0f161fda2712db8b566946122a5af183995e2ed06000000000000000000000000000000000000000000000000000000003698b8f50109f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000000000000009f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000003698b8f50a94812f2eea03a49869f95e1b5868c6f3206ee3d3000024f5e3c462000000000000000000000000ce6cefa163468f730206688665516952bcf83b74002000000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d20771ef7eda2be775e5a7aa8afd02c45f059833e9d20a71ef7eda2be775e5a7aa8afd02c45f059833e9d2000004db006a7500000742000000000000000000000000000000000000060100468cc91df6f669cae6cdce766995bd7874052fbc0000000000000000000000000000000000000000000000000000000000000000010107d988097fb8612cc24eec14542bc03424c656005f0100ee8291dd97611a064a7db0e8c9252d851674e20100000000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000000000009a07f0f161fda2712db8b566946122a5af183995e2ed0100a1c6800788482ba0eeb85f47322bb789986ee2f30000000000000000000000000000000000000000000000000000000000000000000107d988097fb8612cc24eec14542bc03424c656005f0100468cc91df6f669cae6cdce766995bd7874052fbc00000000000000000000000000000000000000000000000000000000000000000001000000000000\";\n\n    vm.startPrank(liquidator);\n    (bool success, bytes memory returnData) = targetContract.call(data);\n    require(success, \"Transaction failed\");\n    vm.stopPrank();\n  }\n\n  function testLiquidateThresholdActive() public debuggingOnly forkAtBlock(MODE_MAINNET, 10455052) {\n    vm.prank(uniV3liquidator.owner());\n    uniV3liquidator.setHealthFactorThreshold(.98 * 1e18);\n\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n\n    vm.prank(usdtMarket.ionicAdmin());\n    CTokenFirstExtension(address(usdtMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    address targetContract = 0x927ae5509688eA6B992ba41Ecd1d49a6e7d69109;\n    bytes\n      memory data = hex\"a9059cbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000003a000000000000000000000000000000000000000000000000000000000000002dd0b94812f2eea03a49869f95e1b5868c6f3206ee3d3002417bfdfbc000000000000000000000000ce6cefa163468f730206688665516952bcf83b740001000000000000000000000000000000000000000000000000000000006d3171ea02000000000000000000000000000000000000000000000000000000003698b8f5f0f161fda2712db8b566946122a5af183995e2ed02b702ce183b4e1faa574834715e5d4a6378d0eed3092be717340023c9e14c1bb12cb3ecbcfd3c3fb038000004a6afed9507f0f161fda2712db8b566946122a5af183995e2ed06000000000000000000000000000000000000000000000000000000003698b8f50109f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000000000000009f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000003698b8f50a94812f2eea03a49869f95e1b5868c6f3206ee3d3000024f5e3c462000000000000000000000000ce6cefa163468f730206688665516952bcf83b74002000000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d20771ef7eda2be775e5a7aa8afd02c45f059833e9d20a71ef7eda2be775e5a7aa8afd02c45f059833e9d2000004db006a7500000742000000000000000000000000000000000000060100468cc91df6f669cae6cdce766995bd7874052fbc0000000000000000000000000000000000000000000000000000000000000000010107d988097fb8612cc24eec14542bc03424c656005f0100ee8291dd97611a064a7db0e8c9252d851674e20100000000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000000000009a07f0f161fda2712db8b566946122a5af183995e2ed0100a1c6800788482ba0eeb85f47322bb789986ee2f30000000000000000000000000000000000000000000000000000000000000000000107d988097fb8612cc24eec14542bc03424c656005f0100468cc91df6f669cae6cdce766995bd7874052fbc00000000000000000000000000000000000000000000000000000000000000000001000000000000\";\n\n    vm.startPrank(liquidator);\n    vm.expectRevert(\"Health factor not low enough for non-permissioned liquidations\");\n    (bool success, bytes memory returnData) = targetContract.call(data);\n    vm.stopPrank();\n  }\n\n  function testLiquidateHealthFactorLowerThanThreshold() public debuggingOnly forkAtBlock(MODE_MAINNET, 10455052) {\n    vm.prank(uniV3liquidator.owner());\n    uniV3liquidator.setHealthFactorThreshold(.98 * 1e18);\n\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n\n    vm.prank(usdtMarket.ionicAdmin());\n    CTokenFirstExtension(address(usdtMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    // fast forward until position unhealthy enough\n    vm.roll(block.number + 10000000);\n\n    address targetContract = 0x927ae5509688eA6B992ba41Ecd1d49a6e7d69109;\n    bytes\n      memory data = hex\"a9059cbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000003a000000000000000000000000000000000000000000000000000000000000002dd0b94812f2eea03a49869f95e1b5868c6f3206ee3d3002417bfdfbc000000000000000000000000ce6cefa163468f730206688665516952bcf83b740001000000000000000000000000000000000000000000000000000000006d3171ea02000000000000000000000000000000000000000000000000000000003698b8f5f0f161fda2712db8b566946122a5af183995e2ed02b702ce183b4e1faa574834715e5d4a6378d0eed3092be717340023c9e14c1bb12cb3ecbcfd3c3fb038000004a6afed9507f0f161fda2712db8b566946122a5af183995e2ed06000000000000000000000000000000000000000000000000000000003698b8f50109f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000000000000009f0f161fda2712db8b566946122a5af183995e2ed000044095ea7b300000000000000000000000094812f2eea03a49869f95e1b5868c6f3206ee3d3000000000000000000000000000000000000000000000000000000003698b8f50a94812f2eea03a49869f95e1b5868c6f3206ee3d3000024f5e3c462000000000000000000000000ce6cefa163468f730206688665516952bcf83b74002000000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d20771ef7eda2be775e5a7aa8afd02c45f059833e9d20a71ef7eda2be775e5a7aa8afd02c45f059833e9d2000004db006a7500000742000000000000000000000000000000000000060100468cc91df6f669cae6cdce766995bd7874052fbc0000000000000000000000000000000000000000000000000000000000000000010107d988097fb8612cc24eec14542bc03424c656005f0100ee8291dd97611a064a7db0e8c9252d851674e20100000000000000000000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000000000000000000000009a07f0f161fda2712db8b566946122a5af183995e2ed0100a1c6800788482ba0eeb85f47322bb789986ee2f30000000000000000000000000000000000000000000000000000000000000000000107d988097fb8612cc24eec14542bc03424c656005f0100468cc91df6f669cae6cdce766995bd7874052fbc00000000000000000000000000000000000000000000000000000000000000000001000000000000\";\n\n    vm.startPrank(liquidator);\n    (bool success, bytes memory returnData) = targetContract.call(data);\n    require(success, \"Transaction failed\");\n    vm.stopPrank();\n  }\n\n  function testLiquidateFromPythShouldRevert() public debuggingOnly forkAtBlock(MODE_MAINNET, 10352583) {\n    vm.prank(uniV3liquidator.owner());\n    uniV3liquidator.setHealthFactorThreshold(.98 * 1e18);\n\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n\n    vm.prank(wethMarket.ionicAdmin());\n    CTokenFirstExtension(address(wethMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    emit log_named_uint(\"hf\", lens.getHealthFactor(0x0Ff7F5043DD39186c2DF04F81cfa95672B8A3994, pool));\n\n    address targetContract = 0xa12c1E460c06B1745EFcbfC9A1f666a8749B0e3A;\n    bytes\n      memory data = hex\"55e9e8fe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000ff7f5043dd39186c2df04f81cfa95672b8a39940000000000000000000000000000000000000000000000000002fb8c3841c79600000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d200000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d2000000000000000000000000468cc91df6f669cae6cdce766995bd7874052fbc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n\n    vm.startPrank(0x1110DECC92083fbcae218a8478F75B2Ad1b9AEe6);\n    vm.expectRevert(\"invalid liquidation\");\n    (bool success, bytes memory returnData) = targetContract.call(data);\n    require(success, \"Transaction failed\");\n    vm.stopPrank();\n  }\n\n  function testLiquidateFromPyth() public debuggingOnly forkAtBlock(MODE_MAINNET, 10352583) {\n    vm.prank(uniV3liquidator.owner());\n    uniV3liquidator.setHealthFactorThreshold(.98 * 1e18);\n\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n\n    vm.prank(wethMarket.ionicAdmin());\n    CTokenFirstExtension(address(wethMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    emit log_named_uint(\"hf\", lens.getHealthFactor(0x0Ff7F5043DD39186c2DF04F81cfa95672B8A3994, pool));\n\n    address targetContract = 0xa12c1E460c06B1745EFcbfC9A1f666a8749B0e3A;\n    bytes\n      memory data = hex\"55e9e8fe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000ff7f5043dd39186c2df04f81cfa95672b8a39940000000000000000000000000000000000000000000000000002fb8c3841c79600000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d200000000000000000000000071ef7eda2be775e5a7aa8afd02c45f059833e9d2000000000000000000000000468cc91df6f669cae6cdce766995bd7874052fbc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n\n    vm.mockCall(\n      address(uniV3liquidator.expressRelay()),\n      abi.encodeWithSelector(\n        bytes4(keccak256(\"isPermissioned(address,bytes)\")),\n        address(uniV3liquidator),\n        abi.encode(0x1110DECC92083fbcae218a8478F75B2Ad1b9AEe6)\n      ),\n      abi.encode(false)\n    );\n\n    vm.startPrank(0x1110DECC92083fbcae218a8478F75B2Ad1b9AEe6);\n    vm.expectRevert(\"invalid liquidation\");\n    (bool success, bytes memory returnData) = targetContract.call(data);\n    require(success, \"Transaction failed\");\n    vm.stopPrank();\n  }\n\n  function testPostUpgradeLiquidate() public debuggingOnly fork(MODE_MAINNET) {\n    address borrower = 0xE10B38bbe359656066b3c4648DfEa7018711c35f;\n    PoolLens.PoolAsset[] memory assets = lens.getPoolAssetsByUser(pool, borrower);\n\n    for (uint i; i < assets.length; i++) {\n      emit log_named_string(\"Asset Named\", assets[i].underlyingName);\n      emit log_named_uint(\"Supply Balance\", assets[i].supplyBalance);\n      emit log_named_uint(\"Borrow Balance\", assets[i].borrowBalance);\n      emit log_named_uint(\"Liquidity\", assets[i].liquidity);\n      emit log(\"----------------------------------------------------\");\n    }\n\n    emit log_named_uint(\"HF\", lens.getHealthFactor(borrower, pool));\n\n    // vm.startPrank(0x344d9C4f488bb5519D390304457D64034618145C);\n\n    // ERC20(0xd988097fb8612cc24eeC14542bC03424c656005f).approve(address(uniV3liquidator), 4000);\n\n    // // ILiquidator.LiquidateToTokensWithFlashSwapVars memory vars = ILiquidator.LiquidateToTokensWithFlashSwapVars({\n    // //   borrower: borrower,\n    // //   repayAmount: 4000,\n    // //   cErc20: ICErc20(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038),\n    // //   cTokenCollateral: wethMarket,\n    // //   flashSwapContract: 0x468cC91dF6F669CaE6cdCE766995Bd7874052FBc,\n    // //   minProfitAmount: 0,\n    // //   redemptionStrategies: new IRedemptionStrategy[](0),\n    // //   strategyData: new bytes[](0),\n    // //   debtFundingStrategies: new IFundsConversionStrategy[](0),\n    // //   debtFundingStrategiesData: new bytes[](0)\n    // // });\n    // // uniV3liquidator.safeLiquidateToTokensWithFlashLoan(vars);\n\n    // uniV3liquidator.safeLiquidate(borrower, 4000, ICErc20(0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038), wethMarket, 0);\n\n    // vm.stopPrank();\n\n    // emit log_named_uint(\"HF\", lens.getHealthFactor(borrower, pool));\n  }\n\n  function testUpgradeNativeMarket() public debuggingOnly fork(MODE_MAINNET) {\n    _upgradeMarket(wethNativeMarket);\n    _upgradeMarket(usdcNativeMarket);\n    _upgradeMarket(usdtNativeMarket);\n    _upgradeMarket(modeNativeMarket);\n    _upgradeMarket(wethMarket);\n    _upgradeMarket(usdtMarket);\n  }\n\n  struct CErc20StorageStruct {\n    address ionicAdmin;\n    string name;\n    string symbol;\n    uint8 decimals;\n    address comptroller;\n    address interestRateModel;\n    uint256 adminFeeMantissa;\n    uint256 ionicFeeMantissa;\n    uint256 reserveFactorMantissa;\n    uint256 accrualBlockNumber;\n    uint256 borrowIndex;\n    uint256 totalBorrows;\n    uint256 totalReserves;\n    uint256 totalAdminFees;\n    uint256 totalIonicFees;\n    uint256 totalSupply;\n    uint256 protocolSeizeShareMantissa;\n    uint256 feeSeizeShareMantissa;\n    address underlying;\n    address ap;\n    uint256 cash;\n    uint256 totalBorrowsCurrent;\n    uint256 balanceOfUnderlying;\n    uint256 borrowBalanceCurrent;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 exchangeRateCurrent;\n    uint256 totalUnderlyingSupplied;\n    uint256 allowance;\n    uint256 balanceOf;\n  }\n\n  function testStorageLayoutSafe() public debuggingOnly forkAtBlock(MODE_MAINNET, 10352583) {\n    // Capture storage layout before upgrade\n    CErc20StorageStruct memory storageDataBefore;\n    CErc20StorageStruct memory storageDataAfter;\n\n    address owner = 0xbF86588d7e20502f1b250561da775343Dfdb3250; // Use a valid spender address as needed\n\n    storageDataBefore.ionicAdmin = wethMarket.ionicAdmin();\n    storageDataBefore.name = wethMarket.name();\n    storageDataBefore.symbol = wethMarket.symbol();\n    storageDataBefore.decimals = wethMarket.decimals();\n    storageDataBefore.comptroller = address(wethMarket.comptroller());\n    storageDataBefore.interestRateModel = address(wethMarket.interestRateModel());\n    storageDataBefore.adminFeeMantissa = wethMarket.adminFeeMantissa();\n    storageDataBefore.ionicFeeMantissa = wethMarket.ionicFeeMantissa();\n    storageDataBefore.reserveFactorMantissa = wethMarket.reserveFactorMantissa();\n    storageDataBefore.accrualBlockNumber = wethMarket.accrualBlockNumber();\n    storageDataBefore.borrowIndex = wethMarket.borrowIndex();\n    storageDataBefore.totalBorrows = wethMarket.totalBorrows();\n    storageDataBefore.totalReserves = wethMarket.totalReserves();\n    storageDataBefore.totalAdminFees = wethMarket.totalAdminFees();\n    storageDataBefore.totalIonicFees = wethMarket.totalIonicFees();\n    storageDataBefore.totalSupply = wethMarket.totalSupply();\n    storageDataBefore.underlying = wethMarket.underlying();\n    storageDataBefore.cash = wethMarket.getCash();\n    storageDataBefore.totalBorrowsCurrent = wethMarket.totalBorrowsCurrent();\n    storageDataBefore.balanceOfUnderlying = wethMarket.balanceOfUnderlying(owner);\n    storageDataBefore.borrowBalanceCurrent = wethMarket.borrowBalanceCurrent(owner);\n    storageDataBefore.supplyRatePerBlock = wethMarket.supplyRatePerBlock();\n    storageDataBefore.borrowRatePerBlock = wethMarket.borrowRatePerBlock();\n    storageDataBefore.exchangeRateCurrent = wethMarket.exchangeRateCurrent();\n    storageDataBefore.totalUnderlyingSupplied = wethMarket.getTotalUnderlyingSupplied();\n    storageDataBefore.balanceOf = wethMarket.balanceOf(owner);\n    storageDataBefore.protocolSeizeShareMantissa = wethMarket.protocolSeizeShareMantissa();\n    storageDataBefore.feeSeizeShareMantissa = wethMarket.feeSeizeShareMantissa();\n\n    // Upgrade the market\n    _upgradeMarket(wethMarket);\n\n    vm.prank(wethMarket.ionicAdmin());\n    CTokenFirstExtension(address(wethMarket))._setAddressesProvider(0xb0033576a9E444Dd801d5B69e1b63DBC459A6115);\n\n    storageDataAfter.ionicAdmin = wethMarket.ionicAdmin();\n    storageDataAfter.name = wethMarket.name();\n    storageDataAfter.symbol = wethMarket.symbol();\n    storageDataAfter.decimals = wethMarket.decimals();\n    storageDataAfter.comptroller = address(wethMarket.comptroller());\n    storageDataAfter.interestRateModel = address(wethMarket.interestRateModel());\n    storageDataAfter.adminFeeMantissa = wethMarket.adminFeeMantissa();\n    storageDataAfter.ionicFeeMantissa = wethMarket.ionicFeeMantissa();\n    storageDataAfter.reserveFactorMantissa = wethMarket.reserveFactorMantissa();\n    storageDataAfter.accrualBlockNumber = wethMarket.accrualBlockNumber();\n    storageDataAfter.borrowIndex = wethMarket.borrowIndex();\n    storageDataAfter.totalBorrows = wethMarket.totalBorrows();\n    storageDataAfter.totalReserves = wethMarket.totalReserves();\n    storageDataAfter.totalAdminFees = wethMarket.totalAdminFees();\n    storageDataAfter.totalIonicFees = wethMarket.totalIonicFees();\n    storageDataAfter.totalSupply = wethMarket.totalSupply();\n    storageDataAfter.underlying = wethMarket.underlying();\n    storageDataAfter.cash = wethMarket.getCash();\n    storageDataAfter.totalBorrowsCurrent = wethMarket.totalBorrowsCurrent();\n    storageDataAfter.balanceOfUnderlying = wethMarket.balanceOfUnderlying(owner);\n    storageDataAfter.borrowBalanceCurrent = wethMarket.borrowBalanceCurrent(owner);\n    storageDataAfter.supplyRatePerBlock = wethMarket.supplyRatePerBlock();\n    storageDataAfter.borrowRatePerBlock = wethMarket.borrowRatePerBlock();\n    storageDataAfter.exchangeRateCurrent = wethMarket.exchangeRateCurrent();\n    storageDataAfter.totalUnderlyingSupplied = wethMarket.getTotalUnderlyingSupplied();\n    storageDataAfter.balanceOf = wethMarket.balanceOf(owner);\n    storageDataAfter.protocolSeizeShareMantissa = wethMarket.protocolSeizeShareMantissa();\n    storageDataAfter.feeSeizeShareMantissa = wethMarket.feeSeizeShareMantissa();\n\n    emit log_named_address(\"Storage ionicAdmin (before)\", storageDataBefore.ionicAdmin);\n    emit log_named_address(\"Storage ionicAdmin (after)\", storageDataAfter.ionicAdmin);\n\n    emit log_named_string(\"Storage name (before)\", storageDataBefore.name);\n    emit log_named_string(\"Storage name (after)\", storageDataAfter.name);\n\n    emit log_named_string(\"Storage symbol (before)\", storageDataBefore.symbol);\n    emit log_named_string(\"Storage symbol (after)\", storageDataAfter.symbol);\n\n    emit log_named_uint(\"Storage decimals (before)\", storageDataBefore.decimals);\n    emit log_named_uint(\"Storage decimals (after)\", storageDataAfter.decimals);\n\n    emit log_named_address(\"Storage comptroller (before)\", storageDataBefore.comptroller);\n    emit log_named_address(\"Storage comptroller (after)\", storageDataAfter.comptroller);\n\n    emit log_named_address(\"Storage interestRateModel (before)\", storageDataBefore.interestRateModel);\n    emit log_named_address(\"Storage interestRateModel (after)\", storageDataAfter.interestRateModel);\n\n    emit log_named_uint(\"Storage adminFeeMantissa (before)\", storageDataBefore.adminFeeMantissa);\n    emit log_named_uint(\"Storage adminFeeMantissa (after)\", storageDataAfter.adminFeeMantissa);\n\n    emit log_named_uint(\"Storage ionicFeeMantissa (before)\", storageDataBefore.ionicFeeMantissa);\n    emit log_named_uint(\"Storage ionicFeeMantissa (after)\", storageDataAfter.ionicFeeMantissa);\n\n    emit log_named_uint(\"Storage reserveFactorMantissa (before)\", storageDataBefore.reserveFactorMantissa);\n    emit log_named_uint(\"Storage reserveFactorMantissa (after)\", storageDataAfter.reserveFactorMantissa);\n\n    emit log_named_uint(\"Storage accrualBlockNumber (before)\", storageDataBefore.accrualBlockNumber);\n    emit log_named_uint(\"Storage accrualBlockNumber (after)\", storageDataAfter.accrualBlockNumber);\n\n    emit log_named_uint(\"Storage borrowIndex (before)\", storageDataBefore.borrowIndex);\n    emit log_named_uint(\"Storage borrowIndex (after)\", storageDataAfter.borrowIndex);\n\n    emit log_named_uint(\"Storage totalBorrows (before)\", storageDataBefore.totalBorrows);\n    emit log_named_uint(\"Storage totalBorrows (after)\", storageDataAfter.totalBorrows);\n\n    emit log_named_uint(\"Storage totalReserves (before)\", storageDataBefore.totalReserves);\n    emit log_named_uint(\"Storage totalReserves (after)\", storageDataAfter.totalReserves);\n\n    emit log_named_uint(\"Storage totalAdminFees (before)\", storageDataBefore.totalAdminFees);\n    emit log_named_uint(\"Storage totalAdminFees (after)\", storageDataAfter.totalAdminFees);\n\n    emit log_named_uint(\"Storage totalIonicFees (before)\", storageDataBefore.totalIonicFees);\n    emit log_named_uint(\"Storage totalIonicFees (after)\", storageDataAfter.totalIonicFees);\n\n    emit log_named_uint(\"Storage totalSupply (before)\", storageDataBefore.totalSupply);\n    emit log_named_uint(\"Storage totalSupply (after)\", storageDataAfter.totalSupply);\n\n    emit log_named_uint(\"Storage protocolSeizeShareMantissa (before)\", storageDataBefore.protocolSeizeShareMantissa);\n    emit log_named_uint(\"Storage protocolSeizeShareMantissa (after)\", storageDataAfter.protocolSeizeShareMantissa);\n\n    emit log_named_uint(\"Storage feeSeizeShareMantissa (before)\", storageDataBefore.feeSeizeShareMantissa);\n    emit log_named_uint(\"Storage feeSeizeShareMantissa (after)\", storageDataAfter.feeSeizeShareMantissa);\n\n    emit log_named_address(\"Storage underlying (before)\", storageDataBefore.underlying);\n    emit log_named_address(\"Storage underlying (after)\", storageDataAfter.underlying);\n\n    emit log_named_uint(\"Storage cash (before)\", storageDataBefore.cash);\n    emit log_named_uint(\"Storage cash (after)\", storageDataAfter.cash);\n\n    emit log_named_uint(\"Storage totalBorrowsCurrent (before)\", storageDataBefore.totalBorrowsCurrent);\n    emit log_named_uint(\"Storage totalBorrowsCurrent (after)\", storageDataAfter.totalBorrowsCurrent);\n\n    emit log_named_uint(\"Storage balanceOfUnderlying (before)\", storageDataBefore.balanceOfUnderlying);\n    emit log_named_uint(\"Storage balanceOfUnderlying (after)\", storageDataAfter.balanceOfUnderlying);\n\n    emit log_named_uint(\"Storage borrowBalanceCurrent (before)\", storageDataBefore.borrowBalanceCurrent);\n    emit log_named_uint(\"Storage borrowBalanceCurrent (after)\", storageDataAfter.borrowBalanceCurrent);\n\n    emit log_named_uint(\"Storage supplyRatePerBlock (before)\", storageDataBefore.supplyRatePerBlock);\n    emit log_named_uint(\"Storage supplyRatePerBlock (after)\", storageDataAfter.supplyRatePerBlock);\n\n    emit log_named_uint(\"Storage borrowRatePerBlock (before)\", storageDataBefore.borrowRatePerBlock);\n    emit log_named_uint(\"Storage borrowRatePerBlock (after)\", storageDataAfter.borrowRatePerBlock);\n\n    emit log_named_uint(\"Storage exchangeRateCurrent (before)\", storageDataBefore.exchangeRateCurrent);\n    emit log_named_uint(\"Storage exchangeRateCurrent (after)\", storageDataAfter.exchangeRateCurrent);\n\n    emit log_named_uint(\"Storage totalUnderlyingSupplied (before)\", storageDataBefore.totalUnderlyingSupplied);\n    emit log_named_uint(\"Storage totalUnderlyingSupplied (after)\", storageDataAfter.totalUnderlyingSupplied);\n\n    emit log_named_uint(\"Storage allowance (before)\", storageDataBefore.allowance);\n    emit log_named_uint(\"Storage allowance (after)\", storageDataAfter.allowance);\n\n    emit log_named_uint(\"Storage balanceOf (before)\", storageDataBefore.balanceOf);\n    emit log_named_uint(\"Storage balanceOf (after)\", storageDataAfter.balanceOf);\n\n    emit log_named_address(\"Storage ap (before)\", storageDataBefore.ap);\n    emit log_named_address(\"Storage ap (after)\", storageDataAfter.ap);\n\n    assertEq(storageDataBefore.ionicAdmin, storageDataAfter.ionicAdmin, \"Mismatch in ionicAdmin\");\n    assertEq(storageDataBefore.name, storageDataAfter.name, \"Mismatch in name\");\n    assertEq(storageDataBefore.symbol, storageDataAfter.symbol, \"Mismatch in symbol\");\n    assertEq(storageDataBefore.decimals, storageDataAfter.decimals, \"Mismatch in decimals\");\n    assertEq(storageDataBefore.comptroller, storageDataAfter.comptroller, \"Mismatch in comptroller\");\n    assertEq(storageDataBefore.interestRateModel, storageDataAfter.interestRateModel, \"Mismatch in interestRateModel\");\n    assertEq(storageDataBefore.adminFeeMantissa, storageDataAfter.adminFeeMantissa, \"Mismatch in adminFeeMantissa\");\n    assertEq(storageDataBefore.ionicFeeMantissa, storageDataAfter.ionicFeeMantissa, \"Mismatch in ionicFeeMantissa\");\n    assertEq(\n      storageDataBefore.reserveFactorMantissa,\n      storageDataAfter.reserveFactorMantissa,\n      \"Mismatch in reserveFactorMantissa\"\n    );\n    assertEq(\n      storageDataBefore.accrualBlockNumber,\n      storageDataAfter.accrualBlockNumber,\n      \"Mismatch in accrualBlockNumber\"\n    );\n    assertEq(storageDataBefore.borrowIndex, storageDataAfter.borrowIndex, \"Mismatch in borrowIndex\");\n    assertEq(storageDataBefore.totalBorrows, storageDataAfter.totalBorrows, \"Mismatch in totalBorrows\");\n    assertEq(storageDataBefore.totalReserves, storageDataAfter.totalReserves, \"Mismatch in totalReserves\");\n    assertEq(storageDataBefore.totalAdminFees, storageDataAfter.totalAdminFees, \"Mismatch in totalAdminFees\");\n    assertEq(storageDataBefore.totalIonicFees, storageDataAfter.totalIonicFees, \"Mismatch in totalIonicFees\");\n    assertEq(storageDataBefore.totalSupply, storageDataAfter.totalSupply, \"Mismatch in totalSupply\");\n    assertEq(storageDataBefore.underlying, storageDataAfter.underlying, \"Mismatch in underlying\");\n    assertEq(storageDataBefore.cash, storageDataAfter.cash, \"Mismatch in cash\");\n    assertEq(\n      storageDataBefore.totalBorrowsCurrent,\n      storageDataAfter.totalBorrowsCurrent,\n      \"Mismatch in totalBorrowsCurrent\"\n    );\n    assertEq(\n      storageDataBefore.balanceOfUnderlying,\n      storageDataAfter.balanceOfUnderlying,\n      \"Mismatch in balanceOfUnderlying\"\n    );\n    assertEq(\n      storageDataBefore.borrowBalanceCurrent,\n      storageDataAfter.borrowBalanceCurrent,\n      \"Mismatch in borrowBalanceCurrent\"\n    );\n    assertEq(\n      storageDataBefore.supplyRatePerBlock,\n      storageDataAfter.supplyRatePerBlock,\n      \"Mismatch in supplyRatePerBlock\"\n    );\n    assertEq(\n      storageDataBefore.borrowRatePerBlock,\n      storageDataAfter.borrowRatePerBlock,\n      \"Mismatch in borrowRatePerBlock\"\n    );\n    assertEq(\n      storageDataBefore.exchangeRateCurrent,\n      storageDataAfter.exchangeRateCurrent,\n      \"Mismatch in exchangeRateCurrent\"\n    );\n    assertEq(\n      storageDataBefore.totalUnderlyingSupplied,\n      storageDataAfter.totalUnderlyingSupplied,\n      \"Mismatch in totalUnderlyingSupplied\"\n    );\n    assertEq(storageDataBefore.balanceOf, storageDataAfter.balanceOf, \"Mismatch in balanceOf\");\n    assertEq(\n      storageDataBefore.protocolSeizeShareMantissa,\n      storageDataAfter.protocolSeizeShareMantissa,\n      \"Mismatch in protocolSeizeShareMantissa\"\n    );\n    assertEq(\n      storageDataBefore.feeSeizeShareMantissa,\n      storageDataAfter.feeSeizeShareMantissa,\n      \"Mismatch in feeSeizeShareMantissa\"\n    );\n  }\n\n  function testCurrentMarkets() public debuggingOnly forkAtBlock(MODE_MAINNET, 10785800) {\n    address[] memory ionAddresses = new address[](10);\n\n    _upgradeMarket(wethMarket);\n\n    ionAddresses[0] = 0x71ef7EDa2Be775E5A7aa8afD02C45F059833e9d2;\n    ionAddresses[1] = 0x2BE717340023C9e14C1Bb12cb3ecBcfd3c3fB038;\n    ionAddresses[2] = 0x94812F2eEa03A49869f95e1b5868C6f3206ee3D3;\n    ionAddresses[3] = 0xd70254C3baD29504789714A7c69d60Ec1127375C;\n    ionAddresses[4] = 0x59e710215d45F584f44c0FEe83DA6d43D762D857;\n    ionAddresses[5] = 0x959FA710CCBb22c7Ce1e59Da82A247e686629310;\n    ionAddresses[6] = 0x49950319aBE7CE5c3A6C90698381b45989C99b46;\n    ionAddresses[7] = 0xA0D844742B4abbbc43d8931a6Edb00C56325aA18;\n    ionAddresses[8] = 0x9a9072302B775FfBd3Db79a7766E75Cf82bcaC0A;\n    ionAddresses[9] = 0x19F245782b1258cf3e11Eda25784A378cC18c108;\n\n    address ap;\n    for (uint i = 0; i < ionAddresses.length; i++) {\n      // ap = address(CTokenFirstExtension(ionAddresses[i]).ap());\n      ap = address(CTokenFirstExtension(address(wethMarket)).ap());\n      emit log_named_address(\"ap\", ap);\n    }\n  }\n}\n"
    },
    "contracts/test/PoolCapsAndBlacklistsTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./config/MarketsTest.t.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\ncontract PoolCapsAndBlacklistsTest is MarketsTest {\n  Comptroller pool;\n  ComptrollerFirstExtension asExtension;\n  address borrower = 0x28C0208b7144B511C73586Bb07dE2100495e92f3; // ANKR account\n  address otherSupplier = 0x2924973E3366690eA7aE3FCdcb2b4e136Cf7f8Cc; // Supplier of ankrBNBAnkrMkt\n  ICErc20 ankrBNBAnkrMkt = ICErc20(0x71693C84486B37096192c9942852f542543639Bf);\n  ICErc20 ankrBNBMkt = ICErc20(0xb2b01D6f953A28ba6C8f9E22986f5bDDb7653aEa);\n\n  function afterForkSetUp() internal override {\n    super.afterForkSetUp();\n\n    // ankr pool\n    pool = Comptroller(payable(0x1851e32F34565cb95754310b031C5a2Fc0a8a905));\n    asExtension = ComptrollerFirstExtension(address(pool));\n    _upgradeExistingPool(address(pool));\n\n    _upgradeMarket(ankrBNBMkt);\n    _upgradeMarket(ankrBNBAnkrMkt);\n\n    // just some logging\n    {\n      uint256 borrowedAnkr = ankrBNBMkt.borrowBalanceCurrent(borrower);\n      emit log_named_uint(\"ankrBnb borrow balance\", borrowedAnkr);\n      uint256 collateralAnkr = ankrBNBAnkrMkt.balanceOf(borrower);\n      emit log_named_uint(\"ankrBnb collateral balance of ankrBNB-ANKR\", collateralAnkr);\n\n      uint256 borrowedOther = ankrBNBMkt.borrowBalanceCurrent(otherSupplier);\n      emit log_named_uint(\"Other supplier borrower balance\", borrowedOther);\n      uint256 collateralOther = ankrBNBAnkrMkt.balanceOf(otherSupplier);\n      emit log_named_uint(\"Other supplier collateral balance of ankrBNB-ANKR\", collateralOther);\n\n      emit log(\"\");\n      emit log(\"Before collateral caps\");\n      {\n        (, , uint256 liq, uint256 sf) = pool.getAccountLiquidity(borrower);\n        emit log_named_uint(\"Liq for account 1 before setting BC\", liq); // 1366119859198693075092\n        emit log_named_uint(\"Shortfall for account 1 before setting BC\", sf); // 0\n        emit log(\"\");\n        (, , uint256 liq1, uint256 sf1) = pool.getAccountLiquidity(otherSupplier);\n        emit log_named_uint(\"Liq for account 2 before setting BC\", liq1); // 24108891649595017\n        emit log_named_uint(\"Shortfall for account 2 before setting BC\", sf1); // 0\n\n        assertGt(liq, 0, \"expected positive liquidity\");\n        assertGt(liq1, 0, \"expected positive liquidity\");\n        emit log(\"\");\n      }\n    }\n  }\n\n  // TODO test with the latest block and contracts and/or without the FSL\n  function testBorrowCapForCollateralWhitelist() public debuggingOnly forkAtBlock(BSC_MAINNET, 27827185) {\n    emit log(\"\");\n    emit log(\"Borrow Caps Set\");\n    {\n      vm.prank(pool.admin());\n      asExtension._setBorrowCapForCollateral(address(ankrBNBMkt), address(ankrBNBAnkrMkt), 1);\n      (, , uint256 liqAfter, uint256 sfAfter) = pool.getAccountLiquidity(borrower);\n      emit log_named_uint(\"Liq for account 1 after setting BC\", liqAfter);\n      emit log_named_uint(\"Shortfall for account 1 after setting BC\", sfAfter);\n      (, , uint256 liq1After, uint256 sf1After) = pool.getAccountLiquidity(otherSupplier);\n      emit log(\"\");\n      emit log_named_uint(\"Liq for account 2 after setting BC\", liq1After);\n      emit log_named_uint(\"Shortfall for account 2 after setting BC\", sf1After);\n      emit log(\"\");\n\n      assertGt(sfAfter, 0, \"expected some shortfall for ankr\");\n      assertEq(liq1After, 24108891649595017, \"expected liquidity for account 2 to decrease\");\n    }\n\n    {\n      vm.prank(pool.admin());\n      asExtension._setBorrowCapForCollateralWhitelist(address(ankrBNBMkt), address(ankrBNBAnkrMkt), borrower, true);\n\n      emit log(\"\");\n      (, , uint256 liqAfterWl, uint256 sfAfterWl) = pool.getAccountLiquidity(borrower);\n      (, , uint256 liq1AfterWl, uint256 sf1AfterWl) = pool.getAccountLiquidity(otherSupplier);\n      assertEq(sfAfterWl, 0, \"expected shortfall to go back to 0\");\n      assertEq(liqAfterWl, 1366119859198693075092, \"expected liq to go back to original\");\n\n      // expect liq for second (not whitelisted) account to stay reduced\n      assertEq(liq1AfterWl, 24108891649595017, \"expected liq to go back to prev value\");\n    }\n  }\n\n  function testBlacklistBorrowingAgainstCollateralWhitelist() public debuggingOnly fork(BSC_MAINNET) {\n    (, , uint256 liquidityBefore, uint256 shortFallBefore) = pool.getHypotheticalAccountLiquidity(\n      borrower,\n      address(ankrBNBMkt),\n      0,\n      0,\n      0\n    );\n    assertEq(shortFallBefore, 0, \"should have no shortfall before\");\n    assertGt(liquidityBefore, 0, \"should have positive liquidity before\");\n\n    vm.prank(pool.admin());\n    asExtension._blacklistBorrowingAgainstCollateral(address(ankrBNBMkt), address(ankrBNBAnkrMkt), true);\n\n    (, , uint256 liquidityAfterBlacklist, uint256 shortFallAfterBlacklist) = pool.getHypotheticalAccountLiquidity(\n      borrower,\n      address(ankrBNBMkt),\n      0,\n      0,\n      0\n    );\n    assertGt(liquidityBefore - liquidityAfterBlacklist, 0, \"should have lower liquidity after bl\");\n\n    vm.prank(pool.admin());\n    asExtension._blacklistBorrowingAgainstCollateralWhitelist(\n      address(ankrBNBMkt),\n      address(ankrBNBAnkrMkt),\n      borrower,\n      true\n    );\n\n    (, , uint256 liquidityAfterWhitelist, uint256 shortFallWhitelist) = pool.getHypotheticalAccountLiquidity(\n      borrower,\n      address(ankrBNBMkt),\n      0,\n      0,\n      0\n    );\n    assertEq(shortFallWhitelist, shortFallBefore, \"should have the same sf after wl\");\n    assertEq(liquidityAfterWhitelist, liquidityBefore, \"should have the same liquidity after wl\");\n  }\n\n  function testSupplyCapWhitelist() public fork(BSC_MAINNET) {\n    (, , uint256 liquidityBefore, uint256 shortFallBefore) = pool.getAccountLiquidity(borrower);\n    assertEq(shortFallBefore, 0, \"should have no shortfall before\");\n    assertGt(liquidityBefore, 0, \"should have positive liquidity before\");\n\n    ICErc20[] memory markets = new ICErc20[](2);\n    markets[0] = ankrBNBMkt;\n    markets[1] = ankrBNBAnkrMkt;\n\n    vm.startPrank(pool.admin());\n    asExtension._setMarketSupplyCaps(markets, asArray(1, 1));\n    asExtension._setMintPaused(ankrBNBMkt, false);\n    asExtension._setMintPaused(ankrBNBAnkrMkt, false);\n    vm.stopPrank();\n\n    (, , uint256 liquidityAfterCap, uint256 shortFallAfterCap) = pool.getAccountLiquidity(borrower);\n    assertEq(liquidityBefore, liquidityAfterCap, \"should have the same liquidity after cap\");\n    assertEq(shortFallBefore, shortFallAfterCap, \"should have the same shortfall after cap\");\n\n    vm.expectRevert(\"!supply cap\");\n    pool.mintAllowed(address(ankrBNBMkt), borrower, 2);\n\n    vm.prank(pool.admin());\n    asExtension._supplyCapWhitelist(address(ankrBNBMkt), borrower, true);\n\n    require(pool.mintAllowed(address(ankrBNBMkt), borrower, 2) == 0, \"mint not allowed after cap whitelist\");\n  }\n\n  function testBorrowCapWhitelist() public fork(BSC_MAINNET) {\n    (, , uint256 liquidityBefore, uint256 shortFallBefore) = pool.getAccountLiquidity(borrower);\n    assertEq(shortFallBefore, 0, \"should have no shortfall before\");\n    assertGt(liquidityBefore, 0, \"should have positive liquidity before\");\n\n    ICErc20[] memory markets = new ICErc20[](2);\n    markets[0] = ankrBNBMkt;\n    markets[1] = ankrBNBAnkrMkt;\n\n    vm.prank(pool.admin());\n    asExtension._setMarketBorrowCaps(markets, asArray(1, 1));\n\n    (, , uint256 liquidityAfterCap, uint256 shortFallAfterCap) = pool.getAccountLiquidity(borrower);\n    assertEq(liquidityBefore, liquidityAfterCap, \"should have the same liquidity after cap\");\n    assertEq(shortFallBefore, shortFallAfterCap, \"should have the same shortfall after cap\");\n\n    vm.expectRevert(\"!borrow:cap\");\n    pool.borrowAllowed(address(ankrBNBMkt), borrower, 2);\n\n    vm.prank(pool.admin());\n    asExtension._borrowCapWhitelist(address(ankrBNBMkt), borrower, true);\n\n    require(pool.borrowAllowed(address(ankrBNBMkt), borrower, 2) == 0, \"borrow not allowed after cap whitelist\");\n  }\n\n  function testSupplyCapValue() public debuggingOnly forkAtBlock(BSC_MAINNET, 27827185) {\n    (, , uint256 liquidityBefore, uint256 shortFallBefore) = pool.getAccountLiquidity(borrower);\n    assertEq(shortFallBefore, 0, \"should have no shortfall before\");\n    assertGt(liquidityBefore, 0, \"should have positive liquidity before\");\n\n    ICErc20[] memory markets = new ICErc20[](2);\n    markets[0] = ankrBNBMkt;\n    markets[1] = ankrBNBAnkrMkt;\n\n    vm.prank(pool.admin());\n    asExtension._setMarketSupplyCaps(markets, asArray(1, 1));\n\n    {\n      (, , uint256 liquidityAfterCap, uint256 shortFallAfterCap) = pool.getAccountLiquidity(borrower);\n      assertEq(liquidityAfterCap, 0, \"should have no liquidity after\");\n      assertGt(shortFallAfterCap, 0, \"should have positive shortfall after\");\n    }\n\n    vm.prank(pool.admin());\n    asExtension._supplyCapWhitelist(address(markets[0]), borrower, true);\n    vm.prank(pool.admin());\n    asExtension._supplyCapWhitelist(address(markets[1]), borrower, true);\n\n    {\n      (, , uint256 liquidityAfterCap, uint256 shortFallAfterCap) = pool.getAccountLiquidity(borrower);\n      assertEq(liquidityAfterCap, liquidityBefore, \"liquidity after whitelist should match before\");\n      assertEq(shortFallAfterCap, shortFallBefore, \"shortfall after whitelist should match before\");\n    }\n  }\n}\n"
    },
    "contracts/test/PoolDirectoryTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\ncontract PoolDirectoryTest is BaseTest {\n  PoolDirectory fpd;\n\n  function afterForkSetUp() internal override {\n    address fpdAddress = ap.getAddress(\"PoolDirectory\");\n    fpd = PoolDirectory(fpdAddress);\n\n    // upgrade to the current changes impl\n    {\n      PoolDirectory newImpl = new PoolDirectory();\n      TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(payable(fpdAddress));\n      bytes32 bytesAtSlot = vm.load(address(proxy), _ADMIN_SLOT);\n      address admin = address(uint160(uint256(bytesAtSlot)));\n      vm.prank(admin);\n      proxy.upgradeTo(address(newImpl));\n    }\n  }\n\n  function testDeprecatePool() public fork(BSC_MAINNET) {\n    _testDeprecatePool();\n  }\n\n  function _testDeprecatePool() internal {\n    PoolDirectory.Pool[] memory allPools = fpd.getAllPools();\n\n    PoolDirectory.Pool memory poolToDeprecate;\n\n    // BOMB pool https://app.midascapital.xyz/56/pool/0\n    uint256 index = 0;\n\n    poolToDeprecate = allPools[index];\n\n    vm.prank(fpd.owner());\n    fpd._deprecatePool(index);\n\n    (, PoolDirectory.Pool[] memory allPoolsAfter) = fpd.getActivePools();\n\n    bool poolStillThere = false;\n    for (uint256 i = 0; i < allPoolsAfter.length; i++) {\n      if (allPoolsAfter[i].comptroller == poolToDeprecate.comptroller) {\n        poolStillThere = true;\n        break;\n      }\n    }\n\n    assertTrue(!poolStillThere, \"deprecated pool is still there\");\n  }\n}\n"
    },
    "contracts/test/PoolLensTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./config/BaseTest.t.sol\";\n\nimport { PoolLens } from \"../PoolLens.sol\";\nimport \"../compound/ComptrollerInterface.sol\";\nimport { JumpRateModel } from \"../compound/JumpRateModel.sol\";\n\ncontract PoolLensTest is BaseTest {\n  function testPolygonFPL() public debuggingOnly fork(POLYGON_MAINNET) {\n    PoolLens fpl = PoolLens(0xD7225110D8F419b0E8Ad0A536977965E62fB5769);\n    fpl.getPoolAssetsWithData(IonicComptroller(0xB08A309eFBFFa41f36A06b2D0C9a4629749b17a2));\n  }\n\n  function testModeFPL() public debuggingOnly fork(MODE_MAINNET) {\n    IonicComptroller pool = IonicComptroller(0xFB3323E24743Caf4ADD0fDCCFB268565c0685556);\n    PoolLens fpl = PoolLens(0x611a68618412c2e15A36e3e59C0b979746d87AB8);\n    PoolLens.PoolAsset[] memory datas = fpl.getPoolAssetsWithData(pool);\n\n    emit log_named_uint(\"ionicFee\", datas[0].ionicFee);\n    emit log_named_uint(\"adminFee\", datas[0].adminFee);\n\n    ICErc20[] memory markets = pool.getAllMarkets();\n\n    for (uint256 i = 0; i < markets.length; i++) {\n      uint256 totalUnderlyingSupplied = markets[i].getTotalUnderlyingSupplied();\n      uint256 totalBorrows = markets[i].totalBorrows();\n      uint256 totalReserves = markets[i].totalReserves();\n      uint256 cash = markets[i].getCash();\n\n      emit log(\"\");\n      emit log(markets[i].symbol());\n      emit log_named_uint(\"totalUnderlyingSupplied\", totalUnderlyingSupplied);\n      emit log_named_uint(\"totalBorrows\", totalBorrows);\n      emit log_named_uint(\"totalReserves\", totalReserves);\n      emit log_named_uint(\"cash\", cash);\n      emit log_named_uint(\"reserves + fees\", cash + totalBorrows - totalUnderlyingSupplied);\n\n      JumpRateModel irm = JumpRateModel(markets[i].interestRateModel());\n\n      emit log_named_uint(\"blocksPerYear\", irm.blocksPerYear());\n\n      emit log_named_uint(\n        \"borrow rate per year\",\n        irm.blocksPerYear() * irm.getBorrowRate(cash, totalBorrows, totalReserves)\n      );\n      emit log_named_uint(\n        \"supply rate per year\",\n        irm.blocksPerYear() * irm.getSupplyRate(cash, totalBorrows, totalReserves, 0.1e18)\n      );\n    }\n  }\n\n  function testWhitelistsFPL() public debuggingOnly fork(BSC_CHAPEL) {\n    PoolLens fpl = PoolLens(0x604805B587C939042120D2e22398f299547A130c);\n    fpl.getSupplyCapsDataForPool(IonicComptroller(0x307BEc9d1368A459E9168fa6296C1e69025ab30f));\n  }\n}\n"
    },
    "contracts/test/ProtocolAdminTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\nimport { PoolDirectory } from \"../PoolDirectory.sol\";\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ProtocolAdminTest is BaseTest {\n  address public expectedAdmin;\n\n  function afterForkSetUp() internal virtual override {}\n\n  function _checkIfAdmin(address addr, string memory contractName) internal {\n    emit log(\"\");\n    emit log(contractName);\n    assertEq(addr, expectedAdmin, \"not the same admin address\");\n  }\n\n  function _checkSafeOwnableAdmin(string memory contractName) internal {\n    SafeOwnableUpgradeable ownable = SafeOwnableUpgradeable(ap.getAddress(contractName));\n    if (address(ownable) != address(0)) {\n      _checkIfAdmin(ownable.owner(), contractName);\n    }\n  }\n\n  function _checkOwnableAdmin(string memory contractName) internal {\n    Ownable ownable = Ownable(ap.getAddress(contractName));\n    if (address(ownable) != address(0)) {\n      _checkIfAdmin(ownable.owner(), contractName);\n    }\n  }\n\n  function testModeProtocolAdmin() public debuggingOnly fork(MODE_MAINNET) {\n    expectedAdmin = 0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2; // gnosis safe multisig contract\n    _testProtocolAdmin();\n  }\n\n  function _testProtocolAdmin() internal {\n    //expectedAdmin = ap.owner();\n    // safe ownable\n    _checkSafeOwnableAdmin(\"FeeDistributor\");\n    _checkSafeOwnableAdmin(\"PoolDirectory\");\n    _checkSafeOwnableAdmin(\"OptimizedVaultsRegistry\");\n    _checkSafeOwnableAdmin(\"AnkrCertificateTokenPriceOracle\");\n    _checkSafeOwnableAdmin(\"BalancerLpLinearPoolPriceOracle\");\n    _checkSafeOwnableAdmin(\"BalancerLpStablePoolPriceOracle\");\n    _checkSafeOwnableAdmin(\"BalancerLpTokenPriceOracle\");\n    _checkSafeOwnableAdmin(\"BalancerLpTokenPriceOracleNTokens\");\n    _checkSafeOwnableAdmin(\"BalancerRateProviderOracle\");\n    _checkSafeOwnableAdmin(\"BNBxPriceOracle\");\n    _checkSafeOwnableAdmin(\"CurveLpTokenPriceOracleNoRegistry\");\n    _checkSafeOwnableAdmin(\"CurveV2LpTokenPriceOracleNoRegistry\");\n    _checkSafeOwnableAdmin(\"CurveV2PriceOracle\");\n    _checkSafeOwnableAdmin(\"ERC4626Oracle\");\n    _checkSafeOwnableAdmin(\"GammaPoolUniswapV3PriceOracle\");\n    _checkSafeOwnableAdmin(\"GammaPoolAlgebraPriceOracle\");\n    _checkSafeOwnableAdmin(\"PythPriceOracle\");\n    _checkSafeOwnableAdmin(\"SimplePriceOracle\");\n    _checkSafeOwnableAdmin(\"SolidlyPriceOracle\");\n    _checkSafeOwnableAdmin(\"StkBNBPriceOracle\");\n    _checkSafeOwnableAdmin(\"WSTEthPriceOracle\");\n    _checkSafeOwnableAdmin(\"NativeUSDPriceOracle\");\n\n    // ownable 2 step\n    _checkSafeOwnableAdmin(\"LiquidatorsRegistry\");\n    _checkSafeOwnableAdmin(\"LeveredPositionFactory\");\n    _checkSafeOwnableAdmin(\"OptimizedAPRVault\");\n\n    _checkOwnableAdmin(\"DefaultProxyAdmin\");\n    _checkOwnableAdmin(\"DiaPriceOracle\");\n    _checkOwnableAdmin(\"PoolDirectory\");\n\n    assertEq(MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\")).admin(), expectedAdmin, \"mpo admin incorrect\");\n\n    // check all the pool admins and the flywheels owners\n    PoolDirectory poolDir = PoolDirectory(ap.getAddress(\"PoolDirectory\"));\n    PoolDirectory.Pool[] memory pools = poolDir.getAllPools();\n    for (uint256 i = 0; i < pools.length; i++) {\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\n      assertEq(pool.admin(), expectedAdmin, \"pool admin does not match\");\n\n      address[] memory flywheels = pool.getRewardsDistributors();\n      for (uint256 j = 0; j < flywheels.length; j++) {\n        assertEq(Ownable(flywheels[j]).owner(), expectedAdmin, \"flywheel owner not the admin\");\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/SafeOwnableUpgradeableTest.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract SomeOwnable is SafeOwnableUpgradeable {\n  function initialize() public initializer {\n    __SafeOwnable_init(msg.sender);\n  }\n}\n\ncontract SafeOwnableUpgradeableTest is BaseTest {\n  function testSafeOwnableUpgradeable() public {\n    SomeOwnable someOwnable = new SomeOwnable();\n    // deploy as a proxy/implementation\n    {\n      TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(\n        address(someOwnable),\n        address(dpa),\n        abi.encodeWithSelector(someOwnable.initialize.selector)\n      );\n      someOwnable = SomeOwnable(address(proxy));\n    }\n\n    address joe = address(1234);\n\n    address initOwner = someOwnable.owner();\n    assertEq(initOwner, address(this), \"owner init value\");\n\n    someOwnable._setPendingOwner(joe);\n\n    address currentOwner = someOwnable.owner();\n    assertEq(currentOwner, address(this), \"owner should not change yet\");\n\n    vm.prank(joe);\n    someOwnable._acceptOwner();\n\n    address ownerAfter = someOwnable.owner();\n\n    assertEq(ownerAfter, joe, \"ownership transfer failed\");\n  }\n}\n"
    },
    "contracts/test/UpgradesBaseTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { FeeDistributor } from \"../FeeDistributor.sol\";\nimport { Comptroller } from \"../compound/Comptroller.sol\";\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\nimport { ComptrollerFirstExtension } from \"../compound/ComptrollerFirstExtension.sol\";\nimport { CTokenFirstExtension } from \"../compound/CTokenFirstExtension.sol\";\nimport { Unitroller } from \"../compound/Unitroller.sol\";\nimport { CErc20Delegate } from \"../compound/CErc20Delegate.sol\";\nimport { CErc20PluginDelegate } from \"../compound/CErc20PluginDelegate.sol\";\nimport { CErc20PluginRewardsDelegate } from \"../compound/CErc20PluginRewardsDelegate.sol\";\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\n\nimport { BaseTest } from \"./config/BaseTest.t.sol\";\n\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\nabstract contract UpgradesBaseTest is BaseTest {\n  FeeDistributor internal ffd;\n  ComptrollerFirstExtension internal poolExt;\n  CTokenFirstExtension internal marketExt;\n\n  function afterForkSetUp() internal virtual override {\n    ffd = FeeDistributor(payable(ap.getAddress(\"FeeDistributor\")));\n    poolExt = new ComptrollerFirstExtension();\n    marketExt = new CTokenFirstExtension();\n  }\n\n  function _upgradePoolWithExtension(Unitroller asUnitroller) internal {\n    address oldComptrollerImplementation = asUnitroller.comptrollerImplementation();\n\n    // instantiate the new implementation\n    Comptroller newComptrollerImplementation = new Comptroller();\n    vm.startPrank(ffd.owner());\n    address comptrollerImplementationAddress = address(newComptrollerImplementation);\n    ffd._setLatestComptrollerImplementation(address(0), comptrollerImplementationAddress);\n    // add the extension to the auto upgrade config\n    DiamondExtension[] memory extensions = new DiamondExtension[](2);\n    extensions[0] = poolExt;\n    extensions[1] = newComptrollerImplementation;\n    ffd._setComptrollerExtensions(comptrollerImplementationAddress, extensions);\n    vm.stopPrank();\n\n    // upgrade to the new comptroller\n    vm.startPrank(asUnitroller.admin());\n    asUnitroller._registerExtension(\n      DiamondExtension(comptrollerImplementationAddress),\n      DiamondExtension(asUnitroller.comptrollerImplementation())\n    );\n    asUnitroller._upgrade();\n    vm.stopPrank();\n  }\n\n  function _upgradeMarketWithExtension(ICErc20 market) internal {\n    address implBefore = market.implementation();\n\n    // instantiate the new implementation\n    CErc20Delegate newImpl;\n    bytes memory becomeImplData = \"\";\n    if (compareStrings(\"CErc20Delegate\", market.contractType())) {\n      newImpl = new CErc20Delegate();\n    } else if (compareStrings(\"CErc20PluginDelegate\", market.contractType())) {\n      newImpl = new CErc20PluginDelegate();\n      becomeImplData = abi.encode(address(0));\n    } else {\n      newImpl = new CErc20PluginRewardsDelegate();\n      becomeImplData = abi.encode(address(0));\n    }\n\n    // set the new delegate as the latest\n    ffd._setLatestCErc20Delegate(newImpl.delegateType(), address(newImpl), abi.encode(address(0)));\n\n    // add the extension to the auto upgrade config\n    DiamondExtension[] memory cErc20DelegateExtensions = new DiamondExtension[](2);\n    cErc20DelegateExtensions[0] = marketExt;\n    cErc20DelegateExtensions[1] = newImpl;\n    vm.prank(ffd.owner());\n    ffd._setCErc20DelegateExtensions(address(newImpl), cErc20DelegateExtensions);\n\n    // upgrade to the new delegate\n    vm.prank(address(ffd));\n    market._setImplementationSafe(address(newImpl), becomeImplData);\n  }\n}\n"
    },
    "contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n  /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n  /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n  /// @param data The encoded function data for each of the calls to make to this contract\n  /// @return results The results from each of the calls passed in via data\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/utils/IW_NATIVE.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\ninterface IW_NATIVE {\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./IMulticall.sol\";\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n  /// @inheritdoc IMulticall\n  function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n      if (!success) {\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n        if (result.length < 68) revert();\n        assembly {\n          result := add(result, 0x04)\n        }\n        revert(abi.decode(result, (string)));\n      }\n\n      results[i] = result;\n    }\n  }\n}\n"
    },
    "contracts/utils/TOUCHToken.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: UNLICENSED\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\ncontract TOUCHToken is ERC20 {\n  constructor(uint256 initialSupply, address tokenOwner) ERC20(\"Midas TOUCH Token\", \"TOUCH\", 18) {\n    _mint(tokenOwner, initialSupply);\n  }\n}\n"
    },
    "contracts/utils/TRIBEToken.sol": {
      "content": "pragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: UNLICENSED\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\n\ncontract TRIBEToken is ERC20 {\n  constructor(uint256 initialSupply, address tokenOwner) ERC20(\"TRIBE Governance Token\", \"TRIBE\", 18) {\n    _mint(tokenOwner, initialSupply);\n  }\n}\n"
    },
    "ds-test/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    }\n\n    function fail() internal virtual {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"      Left\", a);\n            emit log_named_address(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"      Left\", a);\n            emit log_named_bytes32(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"      Left\", a);\n            emit log_named_int(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"      Left\", a);\n            emit log_named_string(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"      Left\", a);\n            emit log_named_bytes(\"     Right\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "forge-std/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "forge-std/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "forge-std/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    },
    "forge-std/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {DSTest} from \"ds-test/test.sol\";\nimport {stdMath} from \"./StdMath.sol\";\n\nabstract contract StdAssertions is DSTest {\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal virtual {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bool]\");\n            emit log_named_string(\"      Left\", a ? \"true\" : \"false\");\n            emit log_named_string(\"     Right\", b ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal virtual {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"      Left\", a);\n            emit log_named_array(\"     Right\", b);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\n        assertEq(uint256(a), uint256(b));\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"      Left\", a);\n            emit log_named_uint(\"     Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"      Left\", a, decimals);\n            emit log_named_decimal_uint(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"       Left\", a);\n            emit log_named_int(\"      Right\", b);\n            emit log_named_uint(\" Max Delta\", maxDelta);\n            emit log_named_uint(\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"      Left\", a, decimals);\n            emit log_named_decimal_int(\"     Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max Delta\", maxDelta, decimals);\n            emit log_named_decimal_uint(\"     Delta\", delta, decimals);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint(\"        Left\", a);\n            emit log_named_uint(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_decimal_uint(\"        Left\", a, decimals);\n            emit log_named_decimal_uint(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int(\"        Left\", a);\n            emit log_named_int(\"       Right\", b);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log(\"Error: a ~= b not satisfied [int]\");\n            emit log_named_decimal_int(\"        Left\", a, decimals);\n            emit log_named_decimal_int(\"       Right\", b, decimals);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\n        internal\n        virtual\n    {\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string(\"Error\", err);\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\n        }\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            fail();\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            fail();\n        }\n    }\n}\n"
    },
    "forge-std/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initialize` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initialize`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve `mainnet`'s RPC URL:\n *   - If you haven't set any mainnet chain info with `setChain`, you haven't specified that\n *     chain in `foundry.toml` and no env var is set, the default data and RPC URL will be returned.\n *   - If you have set a mainnet RPC URL in `foundry.toml` it will return that, if valid (e.g. if\n *     a URL is given or if an environment variable is given and that environment variable exists).\n *     Otherwise, the default data is returned.\n *   - If you specified data with `setChain` it will return that.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private initialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initialize();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initialize();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initialize();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // distinguish 'not found' from 'cannot read'\n                bytes memory notFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initialize() private {\n        if (initialized) return;\n\n        initialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://mainnet.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"goerli\", ChainData(\"Goerli\", 5, \"https://goerli.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/f4a0bdad42674adab5fc0ac077ffab2b\")\n        );\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"optimism_goerli\", ChainData(\"Optimism Goerli\", 420, \"https://goerli.optimism.io\"));\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_goerli\", ChainData(\"Arbitrum One Goerli\", 421613, \"https://goerli-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_mumbai\", ChainData(\"Polygon Mumbai\", 80001, \"https://rpc-mumbai.maticvigil.com\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "forge-std/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    function assumeNoPrecompiles(address addr) internal virtual {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        assumeNoPrecompiles(addr, chainId);\n    }\n\n    function assumeNoPrecompiles(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // a cheat for fuzzing addresses that are payable only\n    // see https://github.com/foundry-rs/foundry/issues/3631\n    function assumePayable(address addr) internal virtual {\n        (bool success,) = payable(addr).call{value: 0}(\"\");\n        vm.assume(success);\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) = token.call(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n}\n"
    },
    "forge-std/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "forge-std/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ncontract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzSelector[] private _targetedArtifactSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n}\n"
    },
    "forge-std/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"some_peth\");\n// json.parseUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"deploymentArtifact\";\n// Contract contract = new Contract();\n// json.serialize(\"contractAddress\", address(contract));\n// json = json.serialize(\"deploymentTimes\", uint(1));\n// // store the stringified JSON to the 'json' variable we have been using as a key\n// // as we won't need it any longer\n// string memory json2 = \"finalArtifact\";\n// string memory final = json2.serialize(\"depArtifact\", json);\n// final.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "forge-std/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "forge-std/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(\n                    false,\n                    \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n                );\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm.store(who, reads[i], prev);\n                    break;\n                }\n                vm.store(who, reads[i], prev);\n            }\n        } else {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.find(self);\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\n        }\n        bytes32 curr = vm.load(who, slot);\n\n        if (fdat != curr) {\n            require(\n                false,\n                \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\"\n            );\n        }\n        vm.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    // Private function so needs to be copied over\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    // Private function so needs to be copied over\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "forge-std/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "forge-std/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\n// TODO Remove import.\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log(\"Bound Result\", result);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n        console2_log(\"Bound result\", vm.toString(result));\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        // forgefmt: disable-start\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n        // forgefmt: disable-end\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\n        );\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n\n    function console2_log(string memory p0, uint256 p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n        status;\n    }\n\n    function console2_log(string memory p0, string memory p1) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n        status;\n    }\n}\n"
    },
    "forge-std/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n//  ABOUT\n// Standard Library's default Test\n\n//  MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\n\n//  BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\nimport {DSTest} from \"ds-test/test.sol\";\n\n//  TEST\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\n// Note: IS_TEST() must return true.\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\n}\n"
    },
    "forge-std/Vm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// Cheatcodes are marked as view/pure/none using the following rules:\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\n// 3. Otherwise you're `pure`.\n\ninterface VmSafe {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n        address emitter;\n    }\n\n    struct Rpc {\n        string key;\n        string url;\n    }\n\n    struct FsMetadata {\n        bool isDir;\n        bool isSymlink;\n        uint256 length;\n        bool readOnly;\n        uint256 modified;\n        uint256 accessed;\n        uint256 created;\n    }\n\n    // Loads a storage slot from an address\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n    // Signs data\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n    // Gets the address for a given private key\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n    // Gets the nonce of an account\n    function getNonce(address account) external view returns (uint64 nonce);\n    // Performs a foreign function call via the terminal\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n    // Sets environment variables\n    function setEnv(string calldata name, string calldata value) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata name) external view returns (bool value);\n    function envUint(string calldata name) external view returns (uint256 value);\n    function envInt(string calldata name) external view returns (int256 value);\n    function envAddress(string calldata name) external view returns (address value);\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n    function envString(string calldata name) external view returns (string memory value);\n    function envBytes(string calldata name) external view returns (bytes memory value);\n    // Reads environment variables as arrays\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n    // Read environment variables with default value\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\n    function envOr(string calldata name, address defaultValue) external returns (address value);\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\n    // Read environment variables as arrays with default value\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        returns (bool[] memory value);\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        returns (uint256[] memory value);\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        returns (int256[] memory value);\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        returns (address[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        returns (bytes32[] memory value);\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        returns (string[] memory value);\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        returns (bytes[] memory value);\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n    // Labels an address in call traces\n    function label(address account, string calldata newLabel) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address signer) external;\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\n    function broadcast(uint256 privateKey) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\n    function startBroadcast(address signer) external;\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\n    function startBroadcast(uint256 privateKey) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string\n    function readFile(string calldata path) external view returns (string memory data);\n    // Reads the entire content of file as binary. Path is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n    // Get the path of the current project root\n    function projectRoot() external view returns (string memory path);\n    // Get the metadata for a file/directory\n    function fsMetadata(string calldata fileOrDir) external returns (FsMetadata memory metadata);\n    // Reads next line of file to string\n    function readLine(string calldata path) external view returns (string memory line);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    function writeFile(string calldata path, string calldata data) external;\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // Path is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n    // Writes line to file, creating a file if it does not exist.\n    function writeLine(string calldata path, string calldata data) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    function closeFile(string calldata path) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    function removeFile(string calldata path) external;\n    // Convert values to a string\n    function toString(address value) external pure returns (string memory stringifiedValue);\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n    // Convert values from a string\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs\n    function getRecordedLogs() external returns (Log[] memory logs);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n    // Adds a private key to the local forge wallet and returns the address\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n    //\n    // parseJson\n    //\n    // ----\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\n    // as tuples, with the attributes in the order in which they are defined.\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\n    // a: uint256\n    // b: address\n    // To decode that json, we need to define a struct or a tuple as follows:\n    // struct json = { uint256 a; address b; }\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\n    // decode the tuple in that order, and thus fail.\n    // ----\n    // Given a string of JSON, return it as ABI-encoded\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\n    // and hex numbers '0xEF'.\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\n    // a JSON object.\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\n\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\n    // It returns the stringified version of the specific JSON file up to that moment.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    //\n    // writeJson\n    //\n    // ----\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    // Let's assume we want to write the following JSON to a file:\n    //\n    // { \"boolean\": true, \"number\": 342, \"object\": { \"title\": \"finally json serialization\" } }\n    //\n    // ```\n    //  string memory json1 = \"some key\";\n    //  vm.serializeBool(json1, \"boolean\", true);\n    //  vm.serializeBool(json1, \"number\", uint256(342));\n    //  json2 = \"some other key\";\n    //  string memory output = vm.serializeString(json2, \"title\", \"finally json serialization\");\n    //  string memory finalJson = vm.serialize(json1, \"object\", output);\n    //  vm.writeJson(finalJson, \"./output/example.json\");\n    // ```\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\n    // to serialize them as values to another JSON object.\n    //\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\n    // will find the object in-memory that is keyed by \"some key\".\n    function writeJson(string calldata json, string calldata path) external;\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n    // Returns the RPC url for the given alias\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n    // Returns all rpc urls and their aliases `[alias, url][]`\n    function rpcUrls() external view returns (string[2][] memory urls);\n    // Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n}\n\ninterface Vm is VmSafe {\n    // Sets block.timestamp\n    function warp(uint256 newTimestamp) external;\n    // Sets block.height\n    function roll(uint256 newHeight) external;\n    // Sets block.basefee\n    function fee(uint256 newBasefee) external;\n    // Sets block.difficulty\n    function difficulty(uint256 newDifficulty) external;\n    // Sets block.chainid\n    function chainId(uint256 newChainId) external;\n    // Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address account, uint64 newNonce) external;\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address msgSender) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address msgSender) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address msgSender, address txOrigin) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address msgSender, address txOrigin) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance\n    function deal(address account, uint256 newBalance) external;\n    // Sets an address' code\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata revertData) external;\n    function expectRevert(bytes4 revertData) external;\n    function expectRevert() external;\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address callee, bytes calldata data) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n    // Sets block.coinbase\n    function coinbase(address newCoinbase) external;\n    // Snapshot the current state of the evm.\n    // Returns the id of the snapshot that was created.\n    // To revert a snapshot use `revertTo`\n    function snapshot() external returns (uint256 snapshotId);\n    // Revert the state of the EVM to a previous snapshot\n    // Takes the snapshot id to revert to.\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\n    // and returns the identifier of the fork\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\n    // the transaction, returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n    // Updates the currently active fork to given block number\n    // This is similar to `roll` but for the currently active fork\n    function rollFork(uint256 blockNumber) external;\n    // Updates the currently active fork to given transaction\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\n    function rollFork(bytes32 txHash) external;\n    // Updates the given fork to given block number\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    // Meaning, changes made to the state of this account will be kept when switching forks\n    function makePersistent(address account) external;\n    function makePersistent(address account0, address account1) external;\n    function makePersistent(address account0, address account1, address account2) external;\n    function makePersistent(address[] calldata accounts) external;\n    // Revokes persistent status from the address, previously added via `makePersistent`\n    function revokePersistent(address account) external;\n    function revokePersistent(address[] calldata accounts) external;\n    // Returns true if the account is marked as persistent\n    function isPersistent(address account) external view returns (bool persistent);\n    // In forking mode, explicitly grant the given address cheatcode access\n    function allowCheatcodes(address account) external;\n    // Fetches the given transaction from the active fork and executes it on the current state\n    function transact(bytes32 txHash) external;\n    // Fetches the given transaction from the given fork and executes it on the current state\n    function transact(uint256 forkId, bytes32 txHash) external;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/interfaces/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is managed by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the\n     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../interfaces/IERC4626Upgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\n    using MathUpgradeable for uint256;\n\n    IERC20Upgradeable private _asset;\n    uint8 private _decimals;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _decimals = success ? assetDecimals : super.decimals();\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).call(\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\n        return _decimals;\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amount of shares.\n     */\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? _initialConvertToShares(assets, rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\n     */\n    function _initialConvertToShares(\n        uint256 assets,\n        MathUpgradeable.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 shares) {\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\n     */\n    function _initialConvertToAssets(\n        uint256 shares,\n        MathUpgradeable.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 assets) {\n        return shares;\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2Upgradeable {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "ops/interfaces/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IResolver {\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload);\n}\n"
    },
    "solmate/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n\n    constructor(address _owner, Authority _authority) {\n        owner = _owner;\n        authority = _authority;\n\n        emit OwnerUpdated(msg.sender, _owner);\n        emit AuthorityUpdated(msg.sender, _authority);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "solmate/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "solmate/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "solmate/test/utils/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../../../tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "solmate/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "solmate/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "solmate/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "solmate/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "solmate/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}