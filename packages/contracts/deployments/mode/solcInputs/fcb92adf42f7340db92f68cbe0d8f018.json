{
  "language": "Solidity",
  "sources": {
    "@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./OwnableUpgradeable.sol\";\r\nimport \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\r\n    function __Ownable2Step_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\r\n    }\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() external {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/ContextUpgradeable.sol\";\r\nimport \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/interfaces/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\r\n\r\n/**\r\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n *\r\n * _Available since v4.7._\r\n */\r\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\r\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\r\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 assets);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary ClonesUpgradeable {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create(0, 0x09, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n            // of the `implementation` address with the bytecode before the address.\r\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n            instance := create2(0, 0x09, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(\r\n        address implementation,\r\n        bytes32 salt,\r\n        address deployer\r\n    ) internal pure returns (address predicted) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(add(ptr, 0x38), deployer)\r\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\r\n            mstore(add(ptr, 0x14), implementation)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\r\n            mstore(add(ptr, 0x58), salt)\r\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\r\n            predicted := keccak256(add(ptr, 0x43), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt)\r\n        internal\r\n        view\r\n        returns (address predicted)\r\n    {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\nimport \"../../utils/AddressUpgradeable.sol\";\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized < type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/ContextUpgradeable.sol\";\r\nimport \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    function __Pausable_init() internal onlyInitializing {\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    function __Pausable_init_unchained() internal onlyInitializing {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\nimport \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuardUpgradeable is Initializable {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    function __ReentrancyGuard_init() internal onlyInitializing {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20Upgradeable.sol\";\r\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\r\nimport \"../../utils/ContextUpgradeable.sol\";\r\nimport \"../../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[45] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20PermitUpgradeable {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ERC20Upgradeable.sol\";\r\nimport \"../utils/SafeERC20Upgradeable.sol\";\r\nimport \"../../../interfaces/IERC4626Upgradeable.sol\";\r\nimport \"../../../utils/math/MathUpgradeable.sol\";\r\nimport \"../../../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\r\n *\r\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\r\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\r\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\r\n * contract and not the \"assets\" token which is an independent contract.\r\n *\r\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\r\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\r\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\r\n *\r\n * _Available since v4.7._\r\n */\r\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\r\n    using MathUpgradeable for uint256;\r\n\r\n    IERC20Upgradeable private _asset;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\r\n     */\r\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\r\n        __ERC4626_init_unchained(asset_);\r\n    }\r\n\r\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\r\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\r\n        _decimals = success ? assetDecimals : super.decimals();\r\n        _asset = asset_;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\r\n     */\r\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private returns (bool, uint8) {\r\n        (bool success, bytes memory encodedDecimals) = address(asset_).call(\r\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\r\n        );\r\n        if (success && encodedDecimals.length >= 32) {\r\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\r\n            if (returnedDecimals <= type(uint8).max) {\r\n                return (true, uint8(returnedDecimals));\r\n            }\r\n        }\r\n        return (false, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\r\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\r\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\r\n     * See {IERC20Metadata-decimals}.\r\n     */\r\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /** @dev See {IERC4626-asset}. */\r\n    function asset() public view virtual override returns (address) {\r\n        return address(_asset);\r\n    }\r\n\r\n    /** @dev See {IERC4626-totalAssets}. */\r\n    function totalAssets() public view virtual override returns (uint256) {\r\n        return _asset.balanceOf(address(this));\r\n    }\r\n\r\n    /** @dev See {IERC4626-convertToShares}. */\r\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    /** @dev See {IERC4626-convertToAssets}. */\r\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\r\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    /** @dev See {IERC4626-maxDeposit}. */\r\n    function maxDeposit(address) public view virtual override returns (uint256) {\r\n        return _isVaultCollateralized() ? type(uint256).max : 0;\r\n    }\r\n\r\n    /** @dev See {IERC4626-maxMint}. */\r\n    function maxMint(address) public view virtual override returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    /** @dev See {IERC4626-maxWithdraw}. */\r\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\r\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    /** @dev See {IERC4626-maxRedeem}. */\r\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\r\n        return balanceOf(owner);\r\n    }\r\n\r\n    /** @dev See {IERC4626-previewDeposit}. */\r\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    /** @dev See {IERC4626-previewMint}. */\r\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\r\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\r\n    }\r\n\r\n    /** @dev See {IERC4626-previewWithdraw}. */\r\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\r\n    }\r\n\r\n    /** @dev See {IERC4626-previewRedeem}. */\r\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\r\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    /** @dev See {IERC4626-deposit}. */\r\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\r\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\r\n\r\n        uint256 shares = previewDeposit(assets);\r\n        _deposit(_msgSender(), receiver, assets, shares);\r\n\r\n        return shares;\r\n    }\r\n\r\n    /** @dev See {IERC4626-mint}. */\r\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\r\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\r\n\r\n        uint256 assets = previewMint(shares);\r\n        _deposit(_msgSender(), receiver, assets, shares);\r\n\r\n        return assets;\r\n    }\r\n\r\n    /** @dev See {IERC4626-withdraw}. */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual override returns (uint256) {\r\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\r\n\r\n        uint256 shares = previewWithdraw(assets);\r\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\r\n\r\n        return shares;\r\n    }\r\n\r\n    /** @dev See {IERC4626-redeem}. */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual override returns (uint256) {\r\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\r\n\r\n        uint256 assets = previewRedeem(shares);\r\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\r\n\r\n        return assets;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\r\n     *\r\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\r\n     * would represent an infinite amount of shares.\r\n     */\r\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\r\n        uint256 supply = totalSupply();\r\n        return\r\n            (assets == 0 || supply == 0)\r\n                ? _initialConvertToShares(assets, rounding)\r\n                : assets.mulDiv(supply, totalAssets(), rounding);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\r\n     *\r\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\r\n     */\r\n    function _initialConvertToShares(\r\n        uint256 assets,\r\n        MathUpgradeable.Rounding /*rounding*/\r\n    ) internal view virtual returns (uint256 shares) {\r\n        return assets;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\r\n     */\r\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\r\n        uint256 supply = totalSupply();\r\n        return\r\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\r\n     *\r\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\r\n     */\r\n    function _initialConvertToAssets(\r\n        uint256 shares,\r\n        MathUpgradeable.Rounding /*rounding*/\r\n    ) internal view virtual returns (uint256 assets) {\r\n        return shares;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit/mint common workflow.\r\n     */\r\n    function _deposit(\r\n        address caller,\r\n        address receiver,\r\n        uint256 assets,\r\n        uint256 shares\r\n    ) internal virtual {\r\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\r\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\r\n        // calls the vault, which is assumed not malicious.\r\n        //\r\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\r\n        // assets are transferred and before the shares are minted, which is a valid state.\r\n        // slither-disable-next-line reentrancy-no-eth\r\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(caller, receiver, assets, shares);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw/redeem common workflow.\r\n     */\r\n    function _withdraw(\r\n        address caller,\r\n        address receiver,\r\n        address owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    ) internal virtual {\r\n        if (caller != owner) {\r\n            _spendAllowance(owner, caller, shares);\r\n        }\r\n\r\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\r\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\r\n        // calls the vault, which is assumed not malicious.\r\n        //\r\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\r\n        // shares are burned and after the assets are transferred, which is a valid state.\r\n        _burn(owner, shares);\r\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\r\n\r\n        emit Withdraw(caller, receiver, owner, assets, shares);\r\n    }\r\n\r\n    function _isVaultCollateralized() private view returns (bool) {\r\n        return totalAssets() > 0 || totalSupply() == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20Upgradeable.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20Upgradeable.sol\";\r\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\r\nimport \"../../../utils/AddressUpgradeable.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20Upgradeable {\r\n    using AddressUpgradeable for address;\r\n\r\n    function safeTransfer(\r\n        IERC20Upgradeable token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20Upgradeable token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20PermitUpgradeable token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC721Upgradeable.sol\";\r\nimport \"./IERC721ReceiverUpgradeable.sol\";\r\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\r\nimport \"../../utils/AddressUpgradeable.sol\";\r\nimport \"../../utils/ContextUpgradeable.sol\";\r\nimport \"../../utils/StringsUpgradeable.sol\";\r\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\r\nimport \"../../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\r\n    using AddressUpgradeable for address;\r\n    using StringsUpgradeable for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        __ERC721_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\r\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _ownerOf(tokenId);\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not token owner or approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        _requireMinted(tokenId);\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\r\n     */\r\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\r\n        return _owners[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _ownerOf(tokenId) != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        unchecked {\r\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\r\n            // Given that tokens are minted one by one, it is impossible in practice that\r\n            // this ever happens. Might change if we allow batch minting.\r\n            // The ERC fails to describe this case.\r\n            _balances[to] += 1;\r\n        }\r\n\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\r\n        owner = ERC721Upgradeable.ownerOf(tokenId);\r\n\r\n        // Clear approvals\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            // Cannot overflow, as that would require more tokens to be burned/transferred\r\n            // out than the owner initially received through minting and transferring in.\r\n            _balances[owner] -= 1;\r\n        }\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n\r\n        _afterTokenTransfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\r\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n\r\n        // Clear approvals from the previous owner\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\r\n            // `from`'s balance is the number of token held, which is at least one before the current\r\n            // transfer.\r\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\r\n            // all 2**256 token ids to be minted, which in practice is impossible.\r\n            _balances[from] -= 1;\r\n            _balances[to] += 1;\r\n        }\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if the `tokenId` has not been minted yet.\r\n     */\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any (single) token transfer. This includes minting and burning.\r\n     * See {_beforeConsecutiveTokenTransfer}.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any (single) transfer of tokens. This includes minting and burning.\r\n     * See {_afterConsecutiveTokenTransfer}.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called before \"consecutive token transfers\" as defined in ERC2309 and implemented in\r\n     * {ERC721Consecutive}.\r\n     * Calling conditions are similar to {_beforeTokenTransfer}.\r\n     */\r\n    function _beforeConsecutiveTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256, /*first*/\r\n        uint96 size\r\n    ) internal virtual {\r\n        if (from != address(0)) {\r\n            _balances[from] -= size;\r\n        }\r\n        if (to != address(0)) {\r\n            _balances[to] += size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called after \"consecutive token transfers\" as defined in ERC2309 and implemented in\r\n     * {ERC721Consecutive}.\r\n     * Calling conditions are similar to {_afterTokenTransfer}.\r\n     */\r\n    function _afterConsecutiveTokenTransfer(\r\n        address, /*from*/\r\n        address, /*to*/\r\n        uint256, /*first*/\r\n        uint96 /*size*/\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[44] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC721Upgradeable.sol\";\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721ReceiverUpgradeable {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721Upgradeable is IERC165Upgradeable {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\nimport \"../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Create2.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\r\n * `CREATE2` can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as 'counterfactual interactions'.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n */\r\nlibrary Create2Upgradeable {\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}.\r\n     *\r\n     * The bytecode for a contract can be obtained from Solidity with\r\n     * `type(contractName).creationCode`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bytecode` must not be empty.\r\n     * - `salt` must have not been used for `bytecode` already.\r\n     * - the factory must have a balance of at least `amount`.\r\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\r\n     */\r\n    function deploy(\r\n        uint256 amount,\r\n        bytes32 salt,\r\n        bytes memory bytecode\r\n    ) internal returns (address addr) {\r\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\r\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\r\n     * `bytecodeHash` or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\r\n        return computeAddress(salt, bytecodeHash, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(\r\n        bytes32 salt,\r\n        bytes32 bytecodeHash,\r\n        address deployer\r\n    ) internal pure returns (address addr) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40) // Get free memory pointer\r\n\r\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\r\n            // |-------------------|---------------------------------------------------------------------------|\r\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\r\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\r\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\r\n            // | 0xFF              |            FF                                                             |\r\n            // |-------------------|---------------------------------------------------------------------------|\r\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\r\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\r\n\r\n            mstore(add(ptr, 0x40), bytecodeHash)\r\n            mstore(add(ptr, 0x20), salt)\r\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\r\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\r\n            mstore8(start, 0xff)\r\n            addr := keccak256(start, 85)\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC165Upgradeable.sol\";\r\nimport \"../../proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\r\n    function __ERC165_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __ERC165_init_unchained() internal onlyInitializing {\r\n    }\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[50] private __gap;\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165Upgradeable {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary MathUpgradeable {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin-contracts-upgradeable/contracts/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./math/MathUpgradeable.sol\";\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary StringsUpgradeable {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = MathUpgradeable.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Ownable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() external {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822Proxiable {\r\n    /**\r\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n     * address.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy.\r\n     */\r\n    function proxiableUUID() external view returns (bytes32);\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function implementation() external view returns (address);\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../Proxy.sol\";\r\nimport \"./ERC1967Upgrade.sol\";\r\n\r\n/**\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n */\r\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\r\n    /**\r\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\r\n     *\r\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\r\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\r\n     */\r\n    constructor(address _logic, bytes memory _data) payable {\r\n        _upgradeToAndCall(_logic, _data, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view virtual override returns (address impl) {\r\n        return ERC1967Upgrade._getImplementation();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\nimport \"../beacon/IBeacon.sol\";\r\nimport \"../../interfaces/draft-IERC1822.sol\";\r\nimport \"../../utils/Address.sol\";\r\nimport \"../../utils/StorageSlot.sol\";\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow delegatecall\r\n */\r\nabstract contract ERC1967Upgrade {\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallUUPS(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(newImplementation);\r\n        } else {\r\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n            } catch {\r\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n            }\r\n            _upgradeToAndCall(newImplementation, data, forceCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is upgraded.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) private {\r\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            Address.isContract(IBeacon(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internal call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal virtual {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     *\r\n     * This function does not return to its internal call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal virtual {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback() external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive() external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     *\r\n     * If overridden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {}\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../ERC1967/ERC1967Proxy.sol\";\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\r\n * clashing], which can potentially be used in an attack, this contract uses the\r\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\r\n * things that go hand in hand:\r\n *\r\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\r\n * that call matches one of the admin functions exposed by the proxy itself.\r\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\r\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\r\n * \"admin cannot fallback to proxy target\".\r\n *\r\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\r\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\r\n * to sudden errors when trying to call a function from the proxy implementation.\r\n *\r\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\r\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\r\n */\r\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\r\n    /**\r\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\r\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\r\n     */\r\n    constructor(\r\n        address _logic,\r\n        address admin_,\r\n        bytes memory _data\r\n    ) payable ERC1967Proxy(_logic, _data) {\r\n        _changeAdmin(admin_);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _getAdmin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function admin() external ifAdmin returns (address admin_) {\r\n        admin_ = _getAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function implementation() external ifAdmin returns (address implementation_) {\r\n        implementation_ = _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n     */\r\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n        _changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n     */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\r\n        _upgradeToAndCall(newImplementation, data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _admin() internal view virtual returns (address) {\r\n        return _getAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\r\n     */\r\n    function _beforeFallback() internal virtual override {\r\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\r\n        super._beforeFallback();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./extensions/IERC20Metadata.sol\";\r\nimport \"../../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20.sol\";\r\nimport \"../extensions/draft-IERC20Permit.sol\";\r\nimport \"../../../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./PythStructs.sol\";\r\nimport \"./IPythEvents.sol\";\r\n\r\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\r\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\r\n/// @author Pyth Data Association\r\ninterface IPyth is IPythEvents {\r\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\r\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\r\n\r\n    /// @notice Returns the price and confidence interval.\r\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\r\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getPrice(\r\n        bytes32 id\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\r\n    /// @dev Reverts if the EMA price is not available.\r\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getEmaPrice(\r\n        bytes32 id\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Returns the price of a price feed without any sanity checks.\r\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\r\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\r\n    ///\r\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\r\n    /// sufficiently recent for their application. If you are considering using this function, it may be\r\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getPriceUnsafe(\r\n        bytes32 id\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\r\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\r\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\r\n    /// recently.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getPriceNoOlderThan(\r\n        bytes32 id,\r\n        uint age\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\r\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\r\n    /// However, if the price is not recent this function returns the latest available price.\r\n    ///\r\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\r\n    /// the returned price is recent or useful for any particular application.\r\n    ///\r\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\r\n    /// sufficiently recent for their application. If you are considering using this function, it may be\r\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getEmaPriceUnsafe(\r\n        bytes32 id\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\r\n    /// of the current time.\r\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\r\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\r\n    /// recently.\r\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\r\n    function getEmaPriceNoOlderThan(\r\n        bytes32 id,\r\n        uint age\r\n    ) external view returns (PythStructs.Price memory price);\r\n\r\n    /// @notice Update price feeds with given update messages.\r\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\r\n    /// `getUpdateFee` with the length of the `updateData` array.\r\n    /// Prices will be updated if they are more recent than the current stored prices.\r\n    /// The call will succeed even if the update is not the most recent.\r\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\r\n    /// @param updateData Array of price update data.\r\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\r\n\r\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\r\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\r\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\r\n    ///\r\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\r\n    /// `getUpdateFee` with the length of the `updateData` array.\r\n    ///\r\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\r\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\r\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\r\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\r\n    ///\r\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\r\n    /// @param updateData Array of price update data.\r\n    /// @param priceIds Array of price ids.\r\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\r\n    function updatePriceFeedsIfNecessary(\r\n        bytes[] calldata updateData,\r\n        bytes32[] calldata priceIds,\r\n        uint64[] calldata publishTimes\r\n    ) external payable;\r\n\r\n    /// @notice Returns the required fee to update an array of price updates.\r\n    /// @param updateData Array of price update data.\r\n    /// @return feeAmount The required fee in Wei.\r\n    function getUpdateFee(\r\n        bytes[] calldata updateData\r\n    ) external view returns (uint feeAmount);\r\n\r\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\r\n    /// within `minPublishTime` and `maxPublishTime`.\r\n    ///\r\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\r\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\r\n    ///\r\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\r\n    /// `getUpdateFee` with the length of the `updateData` array.\r\n    ///\r\n    ///\r\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\r\n    /// no update for any of the given `priceIds` within the given time range.\r\n    /// @param updateData Array of price update data.\r\n    /// @param priceIds Array of price ids.\r\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\r\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\r\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\r\n    function parsePriceFeedUpdates(\r\n        bytes[] calldata updateData,\r\n        bytes32[] calldata priceIds,\r\n        uint64 minPublishTime,\r\n        uint64 maxPublishTime\r\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\r\n}\r\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\n/// @title IPythEvents contains the events that Pyth contract emits.\r\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\r\ninterface IPythEvents {\r\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\r\n    /// @param id The Pyth Price Feed ID.\r\n    /// @param publishTime Publish time of the given price update.\r\n    /// @param price Price of the given price update.\r\n    /// @param conf Confidence interval of the given price update.\r\n    event PriceFeedUpdate(\r\n        bytes32 indexed id,\r\n        uint64 publishTime,\r\n        int64 price,\r\n        uint64 conf\r\n    );\r\n\r\n    /// @dev Emitted when a batch price update is processed successfully.\r\n    /// @param chainId ID of the source chain that the batch price update comes from.\r\n    /// @param sequenceNumber Sequence number of the batch price update.\r\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\r\n}\r\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\ncontract PythStructs {\r\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\r\n    //\r\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\r\n    // Both the price and confidence are stored in a fixed-point numeric representation,\r\n    // `x * (10^expo)`, where `expo` is the exponent.\r\n    //\r\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\r\n    // to how this price safely.\r\n    struct Price {\r\n        // Price\r\n        int64 price;\r\n        // Confidence interval around the price\r\n        uint64 conf;\r\n        // Price exponent\r\n        int32 expo;\r\n        // Unix timestamp describing when the price was published\r\n        uint publishTime;\r\n    }\r\n\r\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\r\n    struct PriceFeed {\r\n        // The price ID.\r\n        bytes32 id;\r\n        // Latest available price\r\n        Price price;\r\n        // Latest available exponentially-weighted moving average price\r\n        Price emaPrice;\r\n    }\r\n}\r\n"
    },
    "adrastia-periphery/rates/IHistoricalRates.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"./RateLibrary.sol\";\n\n/**\n * @title IHistoricalRates\n * @notice An interface that defines a contract that stores historical rates.\n */\ninterface IHistoricalRates {\n    /// @notice Gets an rate for a token at a specific index.\n    /// @param token The address of the token to get the rates for.\n    /// @param index The index of the rate to get, where index 0 contains the latest rate, and the last\n    ///   index contains the oldest rate (uses reverse chronological ordering).\n    /// @return rate The rate for the token at the specified index.\n    function getRateAt(address token, uint256 index) external view returns (RateLibrary.Rate memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(address token, uint256 amount) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the latest rates for a token.\n    /// @param token The address of the token to get the rates for.\n    /// @param amount The number of rates to get.\n    /// @param offset The index of the first rate to get (default: 0).\n    /// @param increment The increment between rates to get (default: 1).\n    /// @return rates The latest rates for the token, in reverse chronological order, from newest to oldest.\n    function getRates(\n        address token,\n        uint256 amount,\n        uint256 offset,\n        uint256 increment\n    ) external view returns (RateLibrary.Rate[] memory);\n\n    /// @notice Gets the number of rates for a token.\n    /// @param token The address of the token to get the number of rates for.\n    /// @return count The number of rates for the token.\n    function getRatesCount(address token) external view returns (uint256);\n\n    /// @notice Gets the capacity of rates for a token.\n    /// @param token The address of the token to get the capacity of rates for.\n    /// @return capacity The capacity of rates for the token.\n    function getRatesCapacity(address token) external view returns (uint256);\n\n    /// @notice Sets the capacity of rates for a token.\n    /// @param token The address of the token to set the capacity of rates for.\n    /// @param amount The new capacity of rates for the token.\n    function setRatesCapacity(address token, uint256 amount) external;\n}\n"
    },
    "adrastia-periphery/rates/RateLibrary.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nlibrary RateLibrary {\n    struct Rate {\n        uint64 target;\n        uint64 current;\n        uint32 timestamp;\n    }\n}\n"
    },
    "contracts/adrastia/PrudentiaLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nlibrary PrudentiaLib {\r\n  struct PrudentiaConfig {\r\n    address controller; // Adrastia Prudentia controller address\r\n    uint8 offset; // Offset for delayed rate activation\r\n    int8 decimalShift; // Positive values scale the rate up (in powers of 10), negative values scale the rate down\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title Careful Math\r\n * @author Compound\r\n * @notice Derived from OpenZeppelin's SafeMath library\r\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\ncontract CarefulMath {\r\n  /**\r\n   * @dev Possible error codes that we can return\r\n   */\r\n  enum MathError {\r\n    NO_ERROR,\r\n    DIVISION_BY_ZERO,\r\n    INTEGER_OVERFLOW,\r\n    INTEGER_UNDERFLOW\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, returns an error on overflow.\r\n   */\r\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\r\n    if (a == 0) {\r\n      return (MathError.NO_ERROR, 0);\r\n    }\r\n\r\n    uint256 c;\r\n    unchecked {\r\n      c = a * b;\r\n    }\r\n\r\n    if (c / a != b) {\r\n      return (MathError.INTEGER_OVERFLOW, 0);\r\n    } else {\r\n      return (MathError.NO_ERROR, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   */\r\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\r\n    if (b == 0) {\r\n      return (MathError.DIVISION_BY_ZERO, 0);\r\n    }\r\n\r\n    return (MathError.NO_ERROR, a / b);\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\r\n    if (b <= a) {\r\n      return (MathError.NO_ERROR, a - b);\r\n    } else {\r\n      return (MathError.INTEGER_UNDERFLOW, 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, returns an error on overflow.\r\n   */\r\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\r\n    uint256 c;\r\n    unchecked {\r\n      c = a + b;\r\n    }\r\n\r\n    if (c >= a) {\r\n      return (MathError.NO_ERROR, c);\r\n    } else {\r\n      return (MathError.INTEGER_OVERFLOW, 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev add a and b and then subtract c\r\n   */\r\n  function addThenSubUInt(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 c\r\n  ) internal pure returns (MathError, uint256) {\r\n    (MathError err0, uint256 sum) = addUInt(a, b);\r\n\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, 0);\r\n    }\r\n\r\n    return subUInt(sum, c);\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CToken.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegate Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\r\n * @author Compound\r\n */\r\ncontract CErc20Delegate is CErc20 {\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 3;\r\n\r\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\r\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\r\n\r\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\r\n      functionSelectors[i] = superFunctionSelectors[i];\r\n    }\r\n\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.contractType.selector;\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.delegateType.selector;\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this._becomeImplementation.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the delegator on a delegate to initialize it for duty\r\n   */\r\n  function _becomeImplementation(bytes memory) public virtual override {\r\n    require(msg.sender == address(this) || hasAdminRights(), \"!self || !admin\");\r\n  }\r\n\r\n  function delegateType() public pure virtual override returns (uint8) {\r\n    return 1;\r\n  }\r\n\r\n  function contractType() external pure virtual override returns (string memory) {\r\n    return \"CErc20Delegate\";\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./ComptrollerInterface.sol\";\r\nimport \"./InterestRateModel.sol\";\r\nimport \"../ionic/DiamondExtension.sol\";\r\nimport { CErc20DelegatorBase, CDelegateInterface } from \"./CTokenInterfaces.sol\";\r\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\r\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20Delegator Contract\r\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\r\n * @author Compound\r\n */\r\ncontract CErc20Delegator is CErc20DelegatorBase, DiamondBase {\r\n  /**\r\n   * @notice Emitted when implementation is changed\r\n   */\r\n  event NewImplementation(address oldImplementation, address newImplementation);\r\n\r\n  /**\r\n   * @notice Initialize the new money market\r\n   * @param underlying_ The address of the underlying asset\r\n   * @param comptroller_ The address of the Comptroller\r\n   * @param ionicAdmin_ The FeeDistributor contract address.\r\n   * @param interestRateModel_ The address of the interest rate model\r\n   * @param name_ ERC-20 name of this token\r\n   * @param symbol_ ERC-20 symbol of this token\r\n   */\r\n  constructor(\r\n    address underlying_,\r\n    IonicComptroller comptroller_,\r\n    address payable ionicAdmin_,\r\n    InterestRateModel interestRateModel_,\r\n    string memory name_,\r\n    string memory symbol_,\r\n    uint256 reserveFactorMantissa_,\r\n    uint256 adminFeeMantissa_\r\n  ) {\r\n    require(msg.sender == ionicAdmin_, \"!admin\");\r\n    uint8 decimals_ = EIP20Interface(underlying_).decimals();\r\n    {\r\n      ionicAdmin = ionicAdmin_;\r\n\r\n      // Set initial exchange rate\r\n      initialExchangeRateMantissa = 0.2e18;\r\n\r\n      // Set the comptroller\r\n      comptroller = comptroller_;\r\n\r\n      // Initialize block number and borrow index (block number mocks depend on comptroller being set)\r\n      accrualBlockNumber = block.number;\r\n      borrowIndex = 1e18;\r\n\r\n      // Set the interest rate model (depends on block number / borrow index)\r\n      require(interestRateModel_.isInterestRateModel(), \"!notIrm\");\r\n      interestRateModel = interestRateModel_;\r\n      emit NewMarketInterestRateModel(InterestRateModel(address(0)), interestRateModel_);\r\n\r\n      name = name_;\r\n      symbol = symbol_;\r\n      decimals = decimals_;\r\n\r\n      // Set reserve factor\r\n      // Check newReserveFactor ≤ maxReserveFactor\r\n      require(\r\n        reserveFactorMantissa_ + adminFeeMantissa + ionicFeeMantissa <= reserveFactorPlusFeesMaxMantissa,\r\n        \"!rf:set\"\r\n      );\r\n      reserveFactorMantissa = reserveFactorMantissa_;\r\n      emit NewReserveFactor(0, reserveFactorMantissa_);\r\n\r\n      // Set admin fee\r\n      // Sanitize adminFeeMantissa_\r\n      if (adminFeeMantissa_ == type(uint256).max) adminFeeMantissa_ = adminFeeMantissa;\r\n      // Get latest Ionic fee\r\n      uint256 newIonicFeeMantissa = IFeeDistributor(ionicAdmin).interestFeeRate();\r\n      require(\r\n        reserveFactorMantissa + adminFeeMantissa_ + newIonicFeeMantissa <= reserveFactorPlusFeesMaxMantissa,\r\n        \"!adminFee:set\"\r\n      );\r\n      adminFeeMantissa = adminFeeMantissa_;\r\n      emit NewAdminFee(0, adminFeeMantissa_);\r\n      ionicFeeMantissa = newIonicFeeMantissa;\r\n      emit NewIonicFee(0, newIonicFeeMantissa);\r\n\r\n      // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\r\n      _notEntered = true;\r\n    }\r\n\r\n    // Set underlying and sanity check it\r\n    underlying = underlying_;\r\n    EIP20Interface(underlying).totalSupply();\r\n  }\r\n\r\n  function implementation() public view returns (address) {\r\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\"delegateType()\"))));\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the admin to update the implementation of the delegator\r\n   * @param implementation_ The address of the new implementation for delegation\r\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n   */\r\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external override {\r\n    // Check admin rights\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    // Set implementation\r\n    _setImplementationInternal(implementation_, becomeImplementationData);\r\n  }\r\n\r\n  /**\r\n   * @dev upgrades the implementation if necessary\r\n   */\r\n  function _upgrade() external override {\r\n    require(msg.sender == address(this) || hasAdminRights(), \"!self or admin\");\r\n\r\n    (bool success, bytes memory data) = address(this).staticcall(abi.encodeWithSignature(\"delegateType()\"));\r\n    require(success, \"no delegate type\");\r\n\r\n    uint8 currentDelegateType = abi.decode(data, (uint8));\r\n    (address latestCErc20Delegate, bytes memory becomeImplementationData) = IFeeDistributor(ionicAdmin)\r\n      .latestCErc20Delegate(currentDelegateType);\r\n\r\n    address currentDelegate = implementation();\r\n    if (currentDelegate != latestCErc20Delegate) {\r\n      _setImplementationInternal(latestCErc20Delegate, becomeImplementationData);\r\n    } else {\r\n      // only update the extensions without reinitializing with becomeImplementationData\r\n      _updateExtensions(currentDelegate);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev register a logic extension\r\n   * @param extensionToAdd the extension whose functions are to be added\r\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\r\n   */\r\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\r\n    require(msg.sender == address(ionicAdmin), \"!unauthorized\");\r\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to update the implementation of the delegator\r\n   * @param implementation_ The address of the new implementation for delegation\r\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n   */\r\n  function _setImplementationInternal(address implementation_, bytes memory becomeImplementationData) internal {\r\n    address delegateBefore = implementation();\r\n    _updateExtensions(implementation_);\r\n\r\n    _functionCall(\r\n      address(this),\r\n      abi.encodeWithSelector(CDelegateInterface._becomeImplementation.selector, becomeImplementationData),\r\n      \"!become impl\"\r\n    );\r\n\r\n    emit NewImplementation(delegateBefore, implementation_);\r\n  }\r\n\r\n  function _updateExtensions(address newDelegate) internal {\r\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getCErc20DelegateExtensions(newDelegate);\r\n    address[] memory currentExtensions = LibDiamond.listExtensions();\r\n\r\n    // removed the current (old) extensions\r\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\r\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\r\n    }\r\n    // add the new extensions\r\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\r\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\r\n    }\r\n  }\r\n\r\n  function _functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.call(data);\r\n\r\n    if (!success) {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n\r\n    return returndata;\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20PluginDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CErc20Delegate.sol\";\r\nimport \"./EIP20Interface.sol\";\r\nimport \"./IERC4626.sol\";\r\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\r\n\r\n/**\r\n * @title Rari's CErc20Plugin's Contract\r\n * @notice CToken which outsources token logic to a plugin\r\n * @author Joey Santoro\r\n *\r\n * CErc20PluginDelegate deposits and withdraws from a plugin contract\r\n * It is also capable of delegating reward functionality to a PluginRewardsDistributor\r\n */\r\ncontract CErc20PluginDelegate is CErc20Delegate {\r\n  event NewPluginImplementation(address oldImpl, address newImpl);\r\n\r\n  /**\r\n   * @notice Plugin address\r\n   */\r\n  IERC4626 public plugin;\r\n\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 2;\r\n\r\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\r\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\r\n\r\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\r\n      functionSelectors[i] = superFunctionSelectors[i];\r\n    }\r\n\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.plugin.selector;\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this._updatePlugin.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n\r\n  /**\r\n   * @notice Delegate interface to become the implementation\r\n   * @param data The encoded arguments for becoming\r\n   */\r\n  function _becomeImplementation(bytes memory data) public virtual override {\r\n    require(msg.sender == address(this) || hasAdminRights(), \"only self and admins can call _becomeImplementation\");\r\n\r\n    address _plugin = abi.decode(data, (address));\r\n\r\n    if (_plugin == address(0) && address(plugin) != address(0)) {\r\n      // if no new plugin address is given, use the latest implementation\r\n      _plugin = IFeeDistributor(ionicAdmin).latestPluginImplementation(address(plugin));\r\n    }\r\n\r\n    if (_plugin != address(0) && _plugin != address(plugin)) {\r\n      _updatePlugin(_plugin);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Update the plugin implementation to a whitelisted implementation\r\n   * @param _plugin The address of the plugin implementation to use\r\n   */\r\n  function _updatePlugin(address _plugin) public {\r\n    require(msg.sender == address(this) || hasAdminRights(), \"only self and admins can call _updatePlugin\");\r\n\r\n    address oldImplementation = address(plugin) != address(0) ? address(plugin) : _plugin;\r\n\r\n    if (address(plugin) != address(0) && plugin.balanceOf(address(this)) != 0) {\r\n      plugin.redeem(plugin.balanceOf(address(this)), address(this), address(this));\r\n    }\r\n\r\n    plugin = IERC4626(_plugin);\r\n\r\n    EIP20Interface(underlying).approve(_plugin, type(uint256).max);\r\n\r\n    uint256 amount = EIP20Interface(underlying).balanceOf(address(this));\r\n    if (amount != 0) {\r\n      deposit(amount);\r\n    }\r\n\r\n    emit NewPluginImplementation(oldImplementation, _plugin);\r\n  }\r\n\r\n  /*** CToken Overrides ***/\r\n\r\n  /*** Safe Token ***/\r\n\r\n  /**\r\n   * @notice Gets balance of the plugin in terms of the underlying\r\n   * @return The quantity of underlying tokens owned by this contract\r\n   */\r\n  function getCashInternal() internal view override returns (uint256) {\r\n    return plugin.previewRedeem(plugin.balanceOf(address(this)));\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer the underlying to the cToken and trigger a deposit\r\n   * @param from Address to transfer funds from\r\n   * @param amount Amount of underlying to transfer\r\n   * @return The actual amount that is transferred\r\n   */\r\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\r\n    // Perform the EIP-20 transfer in\r\n    require(EIP20Interface(underlying).transferFrom(from, address(this), amount), \"send\");\r\n\r\n    deposit(amount);\r\n    return amount;\r\n  }\r\n\r\n  function deposit(uint256 amount) internal {\r\n    plugin.deposit(amount, address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer the underlying from plugin to destination\r\n   * @param to Address to transfer funds to\r\n   * @param amount Amount of underlying to transfer\r\n   */\r\n  function doTransferOut(address to, uint256 amount) internal override {\r\n    plugin.withdraw(amount, to, address(this));\r\n  }\r\n\r\n  function delegateType() public pure virtual override returns (uint8) {\r\n    return 2;\r\n  }\r\n\r\n  function contractType() external pure virtual override returns (string memory) {\r\n    return \"CErc20PluginDelegate\";\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20PluginRewardsDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CErc20PluginDelegate.sol\";\r\n\r\ncontract CErc20PluginRewardsDelegate is CErc20PluginDelegate {\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 2;\r\n\r\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\r\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\r\n\r\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\r\n      functionSelectors[i] = superFunctionSelectors[i];\r\n    }\r\n\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.claim.selector;\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.approve.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n\r\n  /// @notice A reward token claim function\r\n  /// to be overridden for use cases where rewardToken needs to be pulled in\r\n  function claim() external {}\r\n\r\n  /// @notice token approval function\r\n  function approve(address _token, address _spender) external {\r\n    require(hasAdminRights(), \"!admin\");\r\n    require(_token != underlying && _token != address(plugin), \"!token\");\r\n\r\n    EIP20Interface(_token).approve(_spender, type(uint256).max);\r\n  }\r\n\r\n  function delegateType() public pure virtual override returns (uint8) {\r\n    return 4;\r\n  }\r\n\r\n  function contractType() external pure override returns (string memory) {\r\n    return \"CErc20PluginRewardsDelegate\";\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20RewardsDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CErc20Delegate.sol\";\r\nimport \"./EIP20Interface.sol\";\r\n\r\ncontract CErc20RewardsDelegate is CErc20Delegate {\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 2;\r\n\r\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\r\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\r\n\r\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\r\n      functionSelectors[i] = superFunctionSelectors[i];\r\n    }\r\n\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.claim.selector;\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.approve.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n  \r\n  /// @notice A reward token claim function\r\n  /// to be overridden for use cases where rewardToken needs to be pulled in\r\n  function claim() external {}\r\n\r\n  /// @notice token approval function\r\n  function approve(address _token, address _spender) external {\r\n    require(hasAdminRights(), \"!admin\");\r\n    require(_token != underlying, \"!underlying\");\r\n\r\n    EIP20Interface(_token).approve(_spender, type(uint256).max);\r\n  }\r\n\r\n  function delegateType() public pure virtual override returns (uint8) {\r\n    return 3;\r\n  }\r\n\r\n  function contractType() external pure override returns (string memory) {\r\n    return \"CErc20RewardsDelegate\";\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CErc20RewardsDelegateMorpho.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CErc20RewardsDelegate.sol\";\r\n\r\ncontract CErc20RewardsDelegateMorpho is CErc20Delegate {\r\n  event RewardsClaimedAndSet(address indexed account, address indexed reward, uint256 claimedAmount);\r\n\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 1;\r\n\r\n    bytes4[] memory superFunctionSelectors = super._getExtensionFunctions();\r\n    functionSelectors = new bytes4[](superFunctionSelectors.length + fnsCount);\r\n\r\n    for (uint256 i = 0; i < superFunctionSelectors.length; i++) {\r\n      functionSelectors[i] = superFunctionSelectors[i];\r\n    }\r\n\r\n    functionSelectors[--fnsCount + superFunctionSelectors.length] = this.claim.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n\r\n  /**\r\n   * @notice Claims the reward tokens from the Morpho contract and forwards them to the FlywheelRewards contract.\r\n   * @param rewardToken The reward strategy for which the rewards are being claimed.\r\n   * @param claimable The amount of tokens to claim and forward.\r\n   * @param proof The proof required to validate the claim.\r\n   * @dev Only callable by the governance.\r\n   */\r\n  function claim(\r\n    address morphoURD,\r\n    address rewardToken,\r\n    address distributor,\r\n    uint256 claimable,\r\n    bytes32[] memory proof\r\n  ) external isAuthorized {\r\n    uint256 claimedAmount = IMorphoClaim(morphoURD).claim(address(this), rewardToken, claimable, proof);\r\n    EIP20Interface(rewardToken).approve(distributor, claimedAmount);\r\n    IDistributor(distributor).distribute(rewardToken, claimedAmount);\r\n    emit RewardsClaimedAndSet(address(this), rewardToken, claimedAmount);\r\n  }\r\n\r\n  function delegateType() public pure virtual override returns (uint8) {\r\n    return 5;\r\n  }\r\n}\r\n\r\ninterface IDistributor {\r\n  function distribute(address _rewardToken, uint256 _amount) external;\r\n}\r\n\r\ninterface IMorphoClaim {\r\n  function claim(\r\n    address account,\r\n    address reward,\r\n    uint256 claimable,\r\n    bytes32[] memory proof\r\n  ) external returns (uint256 amount);\r\n}\r\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { ComptrollerErrorReporter } from \"./ErrorReporter.sol\";\r\nimport { Exponential } from \"./Exponential.sol\";\r\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\r\nimport { Unitroller } from \"./Unitroller.sol\";\r\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\r\nimport { IIonicFlywheel } from \"../ionic/strategies/flywheel/IIonicFlywheel.sol\";\r\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\r\nimport { ComptrollerExtensionInterface, ComptrollerBase, ComptrollerInterface } from \"./ComptrollerInterface.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\n/**\r\n * @title Compound's Comptroller Contract\r\n * @author Compound\r\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\r\n */\r\ncontract Comptroller is ComptrollerBase, ComptrollerInterface, ComptrollerErrorReporter, Exponential, DiamondExtension {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  /// @notice Emitted when an admin supports a market\r\n  event MarketListed(ICErc20 cToken);\r\n\r\n  /// @notice Emitted when an account enters a market\r\n  event MarketEntered(ICErc20 cToken, address account);\r\n\r\n  /// @notice Emitted when an account exits a market\r\n  event MarketExited(ICErc20 cToken, address account);\r\n\r\n  /// @notice Emitted when close factor is changed by admin\r\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\r\n\r\n  /// @notice Emitted when a collateral factor is changed by admin\r\n  event NewCollateralFactor(ICErc20 cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\r\n\r\n  /// @notice Emitted when liquidation incentive is changed by admin\r\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\r\n\r\n  /// @notice Emitted when price oracle is changed\r\n  event NewPriceOracle(BasePriceOracle oldPriceOracle, BasePriceOracle newPriceOracle);\r\n\r\n  /// @notice Emitted when the whitelist enforcement is changed\r\n  event WhitelistEnforcementChanged(bool enforce);\r\n\r\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\r\n  event AddedRewardsDistributor(address rewardsDistributor);\r\n\r\n  // closeFactorMantissa must be strictly greater than this value\r\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\r\n\r\n  // closeFactorMantissa must not exceed this value\r\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n  // No collateralFactorMantissa may exceed this value\r\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\r\n\r\n  // liquidationIncentiveMantissa must be no less than this value\r\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\r\n\r\n  // liquidationIncentiveMantissa must be no greater than this value\r\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\r\n\r\n  modifier isAuthorized() {\r\n    require(IFeeDistributor(ionicAdmin).canCall(address(this), msg.sender, address(this), msg.sig), \"not authorized\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveSupplyCaps(\r\n    address cToken\r\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 supplyCap) {\r\n    return ComptrollerBase.effectiveSupplyCaps(cToken);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveBorrowCaps(\r\n    address cToken\r\n  ) public view override(ComptrollerBase, ComptrollerInterface) returns (uint256 borrowCap) {\r\n    return ComptrollerBase.effectiveBorrowCaps(cToken);\r\n  }\r\n\r\n  /*** Assets You Are In ***/\r\n\r\n  /**\r\n   * @notice Returns the assets an account has entered\r\n   * @param account The address of the account to pull assets for\r\n   * @return A dynamic list with the assets the account has entered\r\n   */\r\n  function getAssetsIn(address account) external view returns (ICErc20[] memory) {\r\n    ICErc20[] memory assetsIn = accountAssets[account];\r\n\r\n    return assetsIn;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns whether the given account is entered in the given asset\r\n   * @param account The address of the account to check\r\n   * @param cToken The cToken to check\r\n   * @return True if the account is in the asset, otherwise false.\r\n   */\r\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool) {\r\n    return markets[address(cToken)].accountMembership[account];\r\n  }\r\n\r\n  /**\r\n   * @notice Add assets to be included in account liquidity calculation\r\n   * @param cTokens The list of addresses of the cToken markets to be enabled\r\n   * @return Success indicator for whether each corresponding market was entered\r\n   */\r\n  function enterMarkets(address[] memory cTokens) public override isAuthorized returns (uint256[] memory) {\r\n    uint256 len = cTokens.length;\r\n\r\n    uint256[] memory results = new uint256[](len);\r\n    for (uint256 i = 0; i < len; i++) {\r\n      ICErc20 cToken = ICErc20(cTokens[i]);\r\n\r\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\r\n   * @param cToken The market to enter\r\n   * @param borrower The address of the account to modify\r\n   * @return Success indicator for whether the market was entered\r\n   */\r\n  function addToMarketInternal(ICErc20 cToken, address borrower) internal returns (Error) {\r\n    Market storage marketToJoin = markets[address(cToken)];\r\n\r\n    if (!marketToJoin.isListed) {\r\n      // market is not listed, cannot join\r\n      return Error.MARKET_NOT_LISTED;\r\n    }\r\n\r\n    if (marketToJoin.accountMembership[borrower] == true) {\r\n      // already joined\r\n      return Error.NO_ERROR;\r\n    }\r\n\r\n    // survived the gauntlet, add to list\r\n    // NOTE: we store these somewhat redundantly as a significant optimization\r\n    //  this avoids having to iterate through the list for the most common use cases\r\n    //  that is, only when we need to perform liquidity checks\r\n    //  and not whenever we want to check if an account is in a particular market\r\n    marketToJoin.accountMembership[borrower] = true;\r\n    accountAssets[borrower].push(cToken);\r\n\r\n    // Add to allBorrowers\r\n    if (!borrowers[borrower]) {\r\n      allBorrowers.push(borrower);\r\n      borrowers[borrower] = true;\r\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\r\n    }\r\n\r\n    emit MarketEntered(cToken, borrower);\r\n\r\n    return Error.NO_ERROR;\r\n  }\r\n\r\n  /**\r\n   * @notice Removes asset from sender's account liquidity calculation\r\n   * @dev Sender must not have an outstanding borrow balance in the asset,\r\n   *  or be providing necessary collateral for an outstanding borrow.\r\n   * @param cTokenAddress The address of the asset to be removed\r\n   * @return Whether or not the account successfully exited the market\r\n   */\r\n  function exitMarket(address cTokenAddress) external override isAuthorized returns (uint256) {\r\n    // TODO\r\n    require(markets[cTokenAddress].isListed, \"!Comptroller:exitMarket\");\r\n\r\n    ICErc20 cToken = ICErc20(cTokenAddress);\r\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\r\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\r\n    require(oErr == 0, \"!exitMarket\"); // semi-opaque error code\r\n\r\n    /* Fail if the sender has a borrow balance */\r\n    if (amountOwed != 0) {\r\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\r\n    }\r\n\r\n    /* Fail if the sender is not permitted to redeem all of their tokens */\r\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\r\n    }\r\n\r\n    Market storage marketToExit = markets[cTokenAddress];\r\n\r\n    /* Return true if the sender is not already ‘in’ the market */\r\n    if (!marketToExit.accountMembership[msg.sender]) {\r\n      return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /* Set cToken account membership to false */\r\n    delete marketToExit.accountMembership[msg.sender];\r\n\r\n    /* Delete cToken from the account’s list of assets */\r\n    // load into memory for faster iteration\r\n    ICErc20[] memory userAssetList = accountAssets[msg.sender];\r\n    uint256 len = userAssetList.length;\r\n    uint256 assetIndex = len;\r\n    for (uint256 i = 0; i < len; i++) {\r\n      if (userAssetList[i] == ICErc20(cTokenAddress)) {\r\n        assetIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // We *must* have found the asset in the list or our redundant data structure is broken\r\n    assert(assetIndex < len);\r\n\r\n    // copy last item in list to location of item to be removed, reduce length by 1\r\n    ICErc20[] storage storedList = accountAssets[msg.sender];\r\n    storedList[assetIndex] = storedList[storedList.length - 1];\r\n    storedList.pop();\r\n\r\n    // If the user has exited all markets, remove them from the `allBorrowers` array\r\n    if (storedList.length == 0) {\r\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\r\n      allBorrowers.pop(); // Reduce length by 1\r\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\r\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\r\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\r\n    }\r\n\r\n    emit MarketExited(ICErc20(cTokenAddress), msg.sender);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /*** Policy Hooks ***/\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to mint tokens in the given market\r\n   * @param cTokenAddress The market to verify the mint against\r\n   * @param minter The account which would get the minted tokens\r\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\r\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n   */\r\n  function mintAllowed(address cTokenAddress, address minter, uint256 mintAmount) external override returns (uint256) {\r\n    // Pausing is a very serious situation - we revert to sound the alarms\r\n    require(!mintGuardianPaused[cTokenAddress], \"!mint:paused\");\r\n\r\n    // Make sure market is listed\r\n    if (!markets[cTokenAddress].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    // Make sure minter is whitelisted\r\n    if (enforceWhitelist && !whitelist[minter]) {\r\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\r\n    }\r\n\r\n    uint256 supplyCap = effectiveSupplyCaps(cTokenAddress);\r\n\r\n    // Supply cap of 0 corresponds to unlimited supplying\r\n    if (supplyCap != 0 && !supplyCapWhitelist[cTokenAddress].contains(minter)) {\r\n      uint256 totalUnderlyingSupply = ICErc20(cTokenAddress).getTotalUnderlyingSupplied();\r\n      uint256 whitelistedSuppliersSupply = asComptrollerExtension().getWhitelistedSuppliersSupply(cTokenAddress);\r\n      uint256 nonWhitelistedTotalSupply;\r\n      if (whitelistedSuppliersSupply >= totalUnderlyingSupply) nonWhitelistedTotalSupply = 0;\r\n      else nonWhitelistedTotalSupply = totalUnderlyingSupply - whitelistedSuppliersSupply;\r\n\r\n      require(nonWhitelistedTotalSupply + mintAmount < supplyCap, \"!supply cap\");\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreSupplierAction(cTokenAddress, minter);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\r\n   * @param cToken The market to verify the redeem against\r\n   * @param redeemer The account which would redeem the tokens\r\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\r\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n   */\r\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external override returns (uint256) {\r\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\r\n    if (allowed != uint256(Error.NO_ERROR)) {\r\n      return allowed;\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreSupplierAction(cToken, redeemer);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  function redeemAllowedInternal(\r\n    address cToken,\r\n    address redeemer,\r\n    uint256 redeemTokens\r\n  ) internal view returns (uint256) {\r\n    if (!markets[cToken].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\r\n    if (!markets[cToken].accountMembership[redeemer]) {\r\n      return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\r\n    (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\r\n      redeemer,\r\n      ICErc20(cToken),\r\n      redeemTokens,\r\n      0,\r\n      0\r\n    );\r\n    if (err != Error.NO_ERROR) {\r\n      return uint256(err);\r\n    }\r\n    if (shortfall > 0) {\r\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\r\n    }\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Validates mint and reverts on rejection. May emit logs.\r\n   * @param cToken Asset being minted\r\n   * @param minter The address minting the tokens\r\n   * @param actualMintAmount The amount of the underlying asset being minted\r\n   * @param mintTokens The number of tokens being minted\r\n   */\r\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external {\r\n    // Add minter to suppliers mapping\r\n    suppliers[minter] = true;\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPostSupplierAction(cToken, minter);\r\n  }\r\n\r\n  /**\r\n   * @notice Validates redeem and reverts on rejection. May emit logs.\r\n   * @param cToken Asset being redeemed\r\n   * @param redeemer The address redeeming the tokens\r\n   * @param redeemAmount The amount of the underlying asset being redeemed\r\n   * @param redeemTokens The number of tokens being redeemed\r\n   */\r\n  function redeemVerify(\r\n    address cToken,\r\n    address redeemer,\r\n    uint256 redeemAmount,\r\n    uint256 redeemTokens\r\n  ) external override {\r\n    require(markets[msg.sender].isListed, \"!market\");\r\n\r\n    // Require tokens is zero or amount is also zero\r\n    if (redeemTokens == 0 && redeemAmount > 0) {\r\n      revert(\"!zero\");\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPostSupplierAction(cToken, redeemer);\r\n  }\r\n\r\n  function getMaxRedeemOrBorrow(\r\n    address account,\r\n    ICErc20 cTokenModify,\r\n    bool isBorrow\r\n  ) external view override returns (uint256) {\r\n    address cToken = address(cTokenModify);\r\n    // Accrue interest\r\n    uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\r\n\r\n    // Get account liquidity\r\n    (Error err, , uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\r\n      account,\r\n      isBorrow ? cTokenModify : ICErc20(address(0)),\r\n      0,\r\n      0,\r\n      0\r\n    );\r\n    require(err == Error.NO_ERROR, \"!liquidity\");\r\n    if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\r\n\r\n    // Get max borrow/redeem\r\n    uint256 maxBorrowOrRedeemAmount;\r\n\r\n    if (!isBorrow && !markets[cToken].accountMembership[account]) {\r\n      // Max redeem = balance of underlying if not used as collateral\r\n      maxBorrowOrRedeemAmount = balanceOfUnderlying;\r\n    } else {\r\n      // Avoid \"stack too deep\" error by separating this logic\r\n      maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\r\n\r\n      // Redeem only: max out at underlying balance\r\n      if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\r\n    }\r\n\r\n    // Get max borrow or redeem considering cToken liquidity\r\n    uint256 cTokenLiquidity = cTokenModify.getCash();\r\n\r\n    // Return the minimum of the two maximums\r\n    return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\r\n  }\r\n\r\n  /**\r\n   * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\r\n   */\r\n  function _getMaxRedeemOrBorrow(\r\n    uint256 liquidity,\r\n    ICErc20 cTokenModify,\r\n    bool isBorrow\r\n  ) internal view returns (uint256) {\r\n    if (liquidity == 0) return 0; // No available account liquidity, so no more borrow/redeem\r\n\r\n    // Get the normalized price of the asset\r\n    uint256 conversionFactor = oracle.getUnderlyingPrice(cTokenModify);\r\n    require(conversionFactor > 0, \"!oracle\");\r\n\r\n    // Pre-compute a conversion factor from tokens -> ether (normalized price value)\r\n    if (!isBorrow) {\r\n      uint256 collateralFactorMantissa = markets[address(cTokenModify)].collateralFactorMantissa;\r\n      conversionFactor = (collateralFactorMantissa * conversionFactor) / 1e18;\r\n    }\r\n\r\n    // Get max borrow or redeem considering excess account liquidity\r\n    return (liquidity * 1e18) / conversionFactor;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n   * @param cToken The market to verify the borrow against\r\n   * @param borrower The account which would borrow the asset\r\n   * @param borrowAmount The amount of underlying the account would borrow\r\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n   */\r\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external override returns (uint256) {\r\n    // Pausing is a very serious situation - we revert to sound the alarms\r\n    require(!borrowGuardianPaused[cToken], \"!borrow:paused\");\r\n\r\n    // Make sure market is listed\r\n    if (!markets[cToken].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    if (!markets[cToken].accountMembership[borrower]) {\r\n      // only cTokens may call borrowAllowed if borrower not in market\r\n      require(msg.sender == cToken, \"!ctoken\");\r\n\r\n      // attempt to add borrower to the market\r\n      Error err = addToMarketInternal(ICErc20(msg.sender), borrower);\r\n      if (err != Error.NO_ERROR) {\r\n        return uint256(err);\r\n      }\r\n\r\n      // it should be impossible to break the important invariant\r\n      assert(markets[cToken].accountMembership[borrower]);\r\n    }\r\n\r\n    // Make sure oracle price is available\r\n    if (oracle.getUnderlyingPrice(ICErc20(cToken)) == 0) {\r\n      return uint256(Error.PRICE_ERROR);\r\n    }\r\n\r\n    // Make sure borrower is whitelisted\r\n    if (enforceWhitelist && !whitelist[borrower]) {\r\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\r\n    }\r\n\r\n    uint256 borrowCap = effectiveBorrowCaps(cToken);\r\n\r\n    // Borrow cap of 0 corresponds to unlimited borrowing\r\n    if (borrowCap != 0 && !borrowCapWhitelist[cToken].contains(borrower)) {\r\n      uint256 totalBorrows = ICErc20(cToken).totalBorrowsCurrent();\r\n      uint256 whitelistedBorrowersBorrows = asComptrollerExtension().getWhitelistedBorrowersBorrows(cToken);\r\n      uint256 nonWhitelistedTotalBorrows;\r\n      if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\r\n      else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\r\n\r\n      require(nonWhitelistedTotalBorrows + borrowAmount < borrowCap, \"!borrow:cap\");\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreBorrowerAction(cToken, borrower);\r\n\r\n    // Perform a hypothetical liquidity check to guard against shortfall\r\n    (uint256 err, , , uint256 shortfall) = this.getHypotheticalAccountLiquidity(borrower, cToken, 0, borrowAmount, 0);\r\n    if (err != uint256(Error.NO_ERROR)) {\r\n      return err;\r\n    }\r\n    if (shortfall > 0) {\r\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\r\n    }\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Validates borrow the underlying asset of the given market\r\n   * @param cToken The market to verify the borrow against\r\n   * @param borrower The account which borrowed the asset\r\n   */\r\n  function borrowVerify(address cToken, address borrower) external override {\r\n    // Keep the flywheel moving\r\n    flywheelPostBorrowerAction(cToken, borrower);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\r\n   * @param cToken Asset whose underlying is being borrowed\r\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\r\n   */\r\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view override returns (uint256) {\r\n    // Check if min borrow exists\r\n    uint256 minBorrowEth = IFeeDistributor(ionicAdmin).minBorrowEth();\r\n\r\n    if (minBorrowEth > 0) {\r\n      // Get new underlying borrow balance of account for this cToken\r\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(ICErc20(cToken));\r\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\r\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\r\n        Exp({ mantissa: oraclePriceMantissa }),\r\n        accountBorrowsNew\r\n      );\r\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\r\n\r\n      // Check against min borrow\r\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\r\n    }\r\n\r\n    // Return no error\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\r\n   * @param cToken The market to verify the repay against\r\n   * @param payer The account which would repay the asset\r\n   * @param borrower The account which would borrowed the asset\r\n   * @param repayAmount The amount of the underlying asset the account would repay\r\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n   */\r\n  function repayBorrowAllowed(\r\n    address cToken,\r\n    address payer,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external override returns (uint256) {\r\n    // Make sure market is listed\r\n    if (!markets[cToken].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreBorrowerAction(cToken, borrower);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Validates that blacklisted balances are updated after borrow repayment\r\n   * @param cToken The market to verify the repay against\r\n   * @param payer The account which repayed the asset\r\n   * @param borrower The account which borrowed the asset\r\n   * @param repayAmount The amount of the underlying asset the account repayed\r\n   */\r\n  function repayBorrowVerify(\r\n    address cToken,\r\n    address payer,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external override {\r\n    // Keep the flywheel moving\r\n    flywheelPostBorrowerAction(cToken, borrower);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the liquidation should be allowed to occur\r\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n   * @param liquidator The address repaying the borrow and seizing the collateral\r\n   * @param borrower The address of the borrower\r\n   * @param repayAmount The amount of underlying being repaid\r\n   */\r\n  function liquidateBorrowAllowed(\r\n    address cTokenBorrowed,\r\n    address cTokenCollateral,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external override returns (uint256) {\r\n    // Make sure markets are listed\r\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    // Get borrowers' underlying borrow balance\r\n    uint256 borrowBalance = ICErc20(cTokenBorrowed).borrowBalanceCurrent(borrower);\r\n\r\n    /* allow accounts to be liquidated if the market is deprecated */\r\n    if (isDeprecated(ICErc20(cTokenBorrowed))) {\r\n      require(borrowBalance >= repayAmount, \"!borrow>repay\");\r\n    } else {\r\n      /* The borrower must have shortfall in order to be liquidateable */\r\n      (Error err, , , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\r\n        borrower,\r\n        ICErc20(address(0)),\r\n        0,\r\n        0,\r\n        0\r\n      );\r\n      if (err != Error.NO_ERROR) {\r\n        return uint256(err);\r\n      }\r\n\r\n      if (shortfall == 0) {\r\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\r\n      }\r\n\r\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\r\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\r\n      if (repayAmount > maxClose) {\r\n        return uint256(Error.TOO_MUCH_REPAY);\r\n      }\r\n    }\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the seizing of assets should be allowed to occur\r\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n   * @param liquidator The address repaying the borrow and seizing the collateral\r\n   * @param borrower The address of the borrower\r\n   * @param seizeTokens The number of collateral tokens to seize\r\n   */\r\n  function seizeAllowed(\r\n    address cTokenCollateral,\r\n    address cTokenBorrowed,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) external override returns (uint256) {\r\n    // Pausing is a very serious situation - we revert to sound the alarms\r\n    require(!seizeGuardianPaused, \"!seize:paused\");\r\n\r\n    // Make sure markets are listed\r\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\r\n      return uint256(Error.MARKET_NOT_LISTED);\r\n    }\r\n\r\n    // Make sure cToken Comptrollers are identical\r\n    if (ICErc20(cTokenCollateral).comptroller() != ICErc20(cTokenBorrowed).comptroller()) {\r\n      return uint256(Error.COMPTROLLER_MISMATCH);\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Validates that blacklisted balances are updated after seizing of assets\r\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\r\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\r\n   * @param liquidator The address repaying the borrow and seizing the collateral\r\n   * @param borrower The address of the borrower\r\n   * @param seizeTokens The number of collateral tokens to seize\r\n   */\r\n  function seizeVerify(\r\n    address cTokenCollateral,\r\n    address cTokenBorrowed,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) external override {\r\n    // Keep the flywheel moving\r\n    flywheelPostTransferAction(cTokenCollateral, borrower, liquidator);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\r\n   * @param cToken The market to verify the transfer against\r\n   * @param src The account which sources the tokens\r\n   * @param dst The account which receives the tokens\r\n   * @param transferTokens The number of cTokens to transfer\r\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\r\n   */\r\n  function transferAllowed(\r\n    address cToken,\r\n    address src,\r\n    address dst,\r\n    uint256 transferTokens\r\n  ) external override returns (uint256) {\r\n    // Pausing is a very serious situation - we revert to sound the alarms\r\n    require(!transferGuardianPaused, \"!transfer:paused\");\r\n\r\n    // Currently the only consideration is whether or not\r\n    //  the src is allowed to redeem this many tokens\r\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\r\n    if (allowed != uint256(Error.NO_ERROR)) {\r\n      return allowed;\r\n    }\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPreTransferAction(cToken, src, dst);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Validates that blacklisted balances are updated after transfering assets\r\n   * @param cToken The market to verify the transfer against\r\n   * @param src The account which sources the tokens\r\n   * @param dst The account which receives the tokens\r\n   * @param transferTokens The number of cTokens to transfer\r\n   */\r\n  function transferVerify(\r\n    address cToken,\r\n    address src,\r\n    address dst,\r\n    uint256 transferTokens\r\n  ) external override {\r\n\r\n    // Keep the flywheel moving\r\n    flywheelPostTransferAction(cToken, src, dst);\r\n  }\r\n\r\n  /*** Flywheel Hooks ***/\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\r\n   * @param cToken The relevant market\r\n   * @param supplier The minter/redeemer\r\n   */\r\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\r\n  }\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving post-mint and post-redeem\r\n   * @param cToken The relevant market\r\n   * @param supplier The minter/redeemer\r\n   */\r\n  function flywheelPostSupplierAction(address cToken, address supplier) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostSupplierAction(cToken, supplier);\r\n  }\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\r\n   * @param cToken The relevant market\r\n   * @param borrower The borrower\r\n   */\r\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\r\n  }\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving post-borrow and post-repay\r\n   * @param cToken The relevant market\r\n   * @param borrower The borrower\r\n   */\r\n  function flywheelPostBorrowerAction(address cToken, address borrower) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostBorrowerAction(cToken, borrower);\r\n  }\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\r\n   * @param cToken The relevant market\r\n   * @param src The account which sources the tokens\r\n   * @param dst The account which receives the tokens\r\n   */\r\n  function flywheelPreTransferAction(address cToken, address src, address dst) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\r\n  }\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving post-transfer and post-seize\r\n   * @param cToken The relevant market\r\n   * @param src The account which sources the tokens\r\n   * @param dst The account which receives the tokens\r\n   */\r\n  function flywheelPostTransferAction(address cToken, address src, address dst) internal {\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\r\n      IIonicFlywheel(rewardsDistributors[i]).flywheelPostTransferAction(cToken, src, dst);\r\n  }\r\n\r\n  /*** Liquidity/Liquidation Calculations ***/\r\n\r\n  /**\r\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\r\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\r\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\r\n   */\r\n  struct AccountLiquidityLocalVars {\r\n    ICErc20 asset;\r\n    uint256 sumCollateral;\r\n    uint256 sumBorrowPlusEffects;\r\n    uint256 cTokenBalance;\r\n    uint256 borrowBalance;\r\n    uint256 exchangeRateMantissa;\r\n    uint256 oraclePriceMantissa;\r\n    Exp collateralFactor;\r\n    Exp exchangeRate;\r\n    Exp oraclePrice;\r\n    Exp tokensToDenom;\r\n    uint256 borrowCapForCollateral;\r\n    uint256 borrowedAssetPrice;\r\n    uint256 assetAsCollateralValueCap;\r\n  }\r\n\r\n  function getAccountLiquidity(address account) public view override returns (uint256, uint256, uint256, uint256) {\r\n    (\r\n      Error err,\r\n      uint256 collateralValue,\r\n      uint256 liquidity,\r\n      uint256 shortfall\r\n    ) = getHypotheticalAccountLiquidityInternal(account, ICErc20(address(0)), 0, 0, 0);\r\n    return (uint256(err), collateralValue, liquidity, shortfall);\r\n  }\r\n\r\n  /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code (semi-opaque),\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n  function getHypotheticalAccountLiquidity(\r\n    address account,\r\n    address cTokenModify,\r\n    uint256 redeemTokens,\r\n    uint256 borrowAmount,\r\n    uint256 repayAmount\r\n  ) public view returns (uint256, uint256, uint256, uint256) {\r\n    (\r\n      Error err,\r\n      uint256 collateralValue,\r\n      uint256 liquidity,\r\n      uint256 shortfall\r\n    ) = getHypotheticalAccountLiquidityInternal(\r\n        account,\r\n        ICErc20(cTokenModify),\r\n        redeemTokens,\r\n        borrowAmount,\r\n        repayAmount\r\n      );\r\n    return (uint256(err), collateralValue, liquidity, shortfall);\r\n  }\r\n\r\n  /**\r\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\r\n     * @param cTokenModify The market to hypothetically redeem/borrow in\r\n     * @param account The account to determine liquidity for\r\n     * @param redeemTokens The number of tokens to hypothetically redeem\r\n     * @param borrowAmount The amount of underlying to hypothetically borrow\r\n     * @return (possible error code,\r\n                hypothetical account collateral value,\r\n                hypothetical account liquidity in excess of collateral requirements,\r\n     *          hypothetical account shortfall below collateral requirements)\r\n     */\r\n  function getHypotheticalAccountLiquidityInternal(\r\n    address account,\r\n    ICErc20 cTokenModify,\r\n    uint256 redeemTokens,\r\n    uint256 borrowAmount,\r\n    uint256 repayAmount\r\n  ) internal view returns (Error, uint256, uint256, uint256) {\r\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\r\n\r\n    if (address(cTokenModify) != address(0)) {\r\n      vars.borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\r\n    }\r\n\r\n    // For each asset the account is in\r\n    for (uint256 i = 0; i < accountAssets[account].length; i++) {\r\n      vars.asset = accountAssets[account][i];\r\n\r\n      {\r\n        // Read the balances and exchange rate from the cToken\r\n        uint256 oErr;\r\n        (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = vars.asset.getAccountSnapshot(\r\n          account\r\n        );\r\n        if (oErr != 0) {\r\n          // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\r\n          return (Error.SNAPSHOT_ERROR, 0, 0, 0);\r\n        }\r\n      }\r\n      {\r\n        vars.collateralFactor = Exp({ mantissa: markets[address(vars.asset)].collateralFactorMantissa });\r\n        vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\r\n\r\n        // Get the normalized price of the asset\r\n        vars.oraclePriceMantissa = oracle.getUnderlyingPrice(vars.asset);\r\n        if (vars.oraclePriceMantissa == 0) {\r\n          return (Error.PRICE_ERROR, 0, 0, 0);\r\n        }\r\n        vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\r\n\r\n        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\r\n        vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\r\n      }\r\n      {\r\n        // Exclude the asset-to-be-borrowed from the liquidity, except for when redeeming\r\n        vars.assetAsCollateralValueCap = asComptrollerExtension().getAssetAsCollateralValueCap(\r\n          vars.asset,\r\n          cTokenModify,\r\n          redeemTokens > 0,\r\n          account\r\n        );\r\n\r\n        // accumulate the collateral value to sumCollateral\r\n        uint256 assetCollateralValue = mul_ScalarTruncate(vars.tokensToDenom, vars.cTokenBalance);\r\n        if (assetCollateralValue > vars.assetAsCollateralValueCap)\r\n          assetCollateralValue = vars.assetAsCollateralValueCap;\r\n        vars.sumCollateral += assetCollateralValue;\r\n      }\r\n\r\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\r\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\r\n        vars.oraclePrice,\r\n        vars.borrowBalance,\r\n        vars.sumBorrowPlusEffects\r\n      );\r\n\r\n      // Calculate effects of interacting with cTokenModify\r\n      if (vars.asset == cTokenModify) {\r\n        // redeem effect\r\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\r\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\r\n          vars.tokensToDenom,\r\n          redeemTokens,\r\n          vars.sumBorrowPlusEffects\r\n        );\r\n\r\n        // borrow effect\r\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\r\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\r\n          vars.oraclePrice,\r\n          borrowAmount,\r\n          vars.sumBorrowPlusEffects\r\n        );\r\n\r\n        uint256 repayEffect = mul_ScalarTruncate(vars.oraclePrice, repayAmount);\r\n        if (repayEffect >= vars.sumBorrowPlusEffects) {\r\n          vars.sumBorrowPlusEffects = 0;\r\n        } else {\r\n          vars.sumBorrowPlusEffects -= repayEffect;\r\n        }\r\n      }\r\n    }\r\n\r\n    // These are safe, as the underflow condition is checked first\r\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\r\n      return (Error.NO_ERROR, vars.sumCollateral, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\r\n    } else {\r\n      return (Error.NO_ERROR, vars.sumCollateral, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\r\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\r\n   * @param cTokenBorrowed The address of the borrowed cToken\r\n   * @param cTokenCollateral The address of the collateral cToken\r\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\r\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\r\n   */\r\n  function liquidateCalculateSeizeTokens(\r\n    address cTokenBorrowed,\r\n    address cTokenCollateral,\r\n    uint256 actualRepayAmount\r\n  ) external view override returns (uint256, uint256) {\r\n    /* Read oracle prices for borrowed and collateral markets */\r\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenBorrowed));\r\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(ICErc20(cTokenCollateral));\r\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\r\n      return (uint256(Error.PRICE_ERROR), 0);\r\n    }\r\n\r\n    /*\r\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\r\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n     *  seizeTokens = seizeAmount / exchangeRate\r\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n     */\r\n    ICErc20 collateralCToken = ICErc20(cTokenCollateral);\r\n    uint256 exchangeRateMantissa = collateralCToken.exchangeRateCurrent();\r\n    uint256 seizeTokens;\r\n    Exp memory numerator;\r\n    Exp memory denominator;\r\n    Exp memory ratio;\r\n\r\n    uint256 protocolSeizeShareMantissa = collateralCToken.protocolSeizeShareMantissa();\r\n    uint256 feeSeizeShareMantissa = collateralCToken.feeSeizeShareMantissa();\r\n\r\n    /*\r\n     * The liquidation penalty includes\r\n     * - the liquidator incentive\r\n     * - the protocol fees (Ionic admin fees)\r\n     * - the market fee\r\n     */\r\n    Exp memory totalPenaltyMantissa = add_(\r\n      add_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: protocolSeizeShareMantissa })),\r\n      Exp({ mantissa: feeSeizeShareMantissa })\r\n    );\r\n\r\n    numerator = mul_(totalPenaltyMantissa, Exp({ mantissa: priceBorrowedMantissa }));\r\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\r\n    ratio = div_(numerator, denominator);\r\n\r\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\r\n    return (uint256(Error.NO_ERROR), seizeTokens);\r\n  }\r\n\r\n  /*** Admin Functions ***/\r\n\r\n  /**\r\n   * @notice Add a RewardsDistributor contracts.\r\n   * @dev Admin function to add a RewardsDistributor contract\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    // Check marker method\r\n    require(IIonicFlywheel(distributor).isRewardsDistributor(), \"!isRewardsDistributor\");\r\n\r\n    // Check for existing RewardsDistributor\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) require(distributor != rewardsDistributors[i], \"!added\");\r\n\r\n    // Add RewardsDistributor to array\r\n    rewardsDistributors.push(distributor);\r\n    emit AddedRewardsDistributor(distributor);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the whitelist enforcement for the comptroller\r\n   * @dev Admin function to set a new whitelist enforcement boolean\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\r\n    }\r\n\r\n    // Check if `enforceWhitelist` already equals `enforce`\r\n    if (enforceWhitelist == enforce) {\r\n      return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    // Set comptroller's `enforceWhitelist` to `enforce`\r\n    enforceWhitelist = enforce;\r\n\r\n    // Emit WhitelistEnforcementChanged(bool enforce);\r\n    emit WhitelistEnforcementChanged(enforce);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the whitelist `statuses` for `suppliers`\r\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\r\n    }\r\n\r\n    // Set whitelist statuses for suppliers\r\n    for (uint256 i = 0; i < suppliers.length; i++) {\r\n      address supplier = suppliers[i];\r\n\r\n      if (statuses[i]) {\r\n        // If not already whitelisted, add to whitelist\r\n        if (!whitelist[supplier]) {\r\n          whitelist[supplier] = true;\r\n          whitelistArray.push(supplier);\r\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\r\n        }\r\n      } else {\r\n        // If whitelisted, remove from whitelist\r\n        if (whitelist[supplier]) {\r\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\r\n          whitelistArray.pop(); // Reduce length by 1\r\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\r\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\r\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\r\n        }\r\n      }\r\n    }\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new price oracle for the comptroller\r\n   * @dev Admin function to set a new price oracle\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setPriceOracle(BasePriceOracle newOracle) public returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\r\n    }\r\n\r\n    // Track the old oracle for the comptroller\r\n    BasePriceOracle oldOracle = oracle;\r\n\r\n    // Set comptroller's oracle to newOracle\r\n    oracle = newOracle;\r\n\r\n    // Emit NewPriceOracle(oldOracle, newOracle)\r\n    emit NewPriceOracle(oldOracle, newOracle);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the closeFactor used when liquidating borrows\r\n   * @dev Admin function to set closeFactor\r\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\r\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n   */\r\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\r\n    }\r\n\r\n    // Check limits\r\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\r\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\r\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\r\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n    }\r\n\r\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\r\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\r\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\r\n    }\r\n\r\n    // Set pool close factor to new close factor, remember old value\r\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\r\n    closeFactorMantissa = newCloseFactorMantissa;\r\n\r\n    // Emit event\r\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the collateralFactor for a market\r\n   * @dev Admin function to set per-market collateralFactor\r\n   * @param cToken The market to set the factor on\r\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\r\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n   */\r\n  function _setCollateralFactor(ICErc20 cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\r\n    }\r\n\r\n    // Verify market is listed\r\n    Market storage market = markets[address(cToken)];\r\n    if (!market.isListed) {\r\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\r\n    }\r\n\r\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\r\n\r\n    // Check collateral factor <= 0.9\r\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\r\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\r\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\r\n    }\r\n\r\n    // If collateral factor != 0, fail if price == 0\r\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\r\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\r\n    }\r\n\r\n    // Set market's collateral factor to new collateral factor, remember old value\r\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\r\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\r\n\r\n    // Emit event with asset, old collateral factor, and new collateral factor\r\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets liquidationIncentive\r\n   * @dev Admin function to set liquidationIncentive\r\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\r\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\r\n   */\r\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\r\n    }\r\n\r\n    // Check de-scaled min <= newLiquidationIncentive <= max\r\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\r\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\r\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\r\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n    }\r\n\r\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\r\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\r\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\r\n    }\r\n\r\n    // Save current value for use in log\r\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\r\n\r\n    // Set liquidation incentive to new incentive\r\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\r\n\r\n    // Emit event with old incentive, new incentive\r\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Add the market to the markets mapping and set it as listed\r\n   * @dev Admin function to set isListed and add support for the market\r\n   * @param cToken The address of the market (token) to list\r\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n   */\r\n  function _supportMarket(ICErc20 cToken) internal returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n    }\r\n\r\n    // Is market already listed?\r\n    if (markets[address(cToken)].isListed) {\r\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n    }\r\n\r\n    // Check cToken.comptroller == this\r\n    require(address(cToken.comptroller()) == address(this), \"!comptroller\");\r\n\r\n    // Make sure market is not already listed\r\n    address underlying = ICErc20(address(cToken)).underlying();\r\n\r\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\r\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\r\n    }\r\n\r\n    // List market and emit event\r\n    Market storage market = markets[address(cToken)];\r\n    market.isListed = true;\r\n    market.collateralFactorMantissa = 0;\r\n    allMarkets.push(cToken);\r\n    cTokensByUnderlying[underlying] = cToken;\r\n    emit MarketListed(cToken);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\r\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\r\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n   */\r\n  function _deployMarket(\r\n    uint8 delegateType,\r\n    bytes calldata constructorData,\r\n    bytes calldata becomeImplData,\r\n    uint256 collateralFactorMantissa\r\n  ) external returns (uint256) {\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\r\n    }\r\n\r\n    // Temporarily enable Ionic admin rights for asset deployment (storing the original value)\r\n    bool oldIonicAdminHasRights = ionicAdminHasRights;\r\n    ionicAdminHasRights = true;\r\n\r\n    // Deploy via Ionic admin\r\n    ICErc20 cToken = ICErc20(IFeeDistributor(ionicAdmin).deployCErc20(delegateType, constructorData, becomeImplData));\r\n    // Reset Ionic admin rights to the original value\r\n    ionicAdminHasRights = oldIonicAdminHasRights;\r\n    // Support market here in the Comptroller\r\n    uint256 err = _supportMarket(cToken);\r\n\r\n    IFeeDistributor(ionicAdmin).authoritiesRegistry().reconfigureAuthority(address(this));\r\n\r\n    // Set collateral factor\r\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\r\n  }\r\n\r\n  function _becomeImplementation() external {\r\n    require(msg.sender == address(this), \"!self call\");\r\n\r\n    if (!_notEnteredInitialized) {\r\n      _notEntered = true;\r\n      _notEnteredInitialized = true;\r\n    }\r\n  }\r\n\r\n  /*** Helper Functions ***/\r\n\r\n  /**\r\n   * @notice Returns true if the given cToken market has been deprecated\r\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\r\n   * @param cToken The market to check if deprecated\r\n   */\r\n  function isDeprecated(ICErc20 cToken) public view returns (bool) {\r\n    return\r\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\r\n      borrowGuardianPaused[address(cToken)] == true &&\r\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.ionicFeeMantissa()) == 1e18;\r\n  }\r\n\r\n  function asComptrollerExtension() internal view returns (ComptrollerExtensionInterface) {\r\n    return ComptrollerExtensionInterface(address(this));\r\n  }\r\n\r\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory functionSelectors) {\r\n    uint8 fnsCount = 36;\r\n\r\n    functionSelectors = new bytes4[](fnsCount);\r\n\r\n    functionSelectors[--fnsCount] = this.isDeprecated.selector;\r\n    functionSelectors[--fnsCount] = this._deployMarket.selector;\r\n    functionSelectors[--fnsCount] = this.getAssetsIn.selector;\r\n    functionSelectors[--fnsCount] = this.checkMembership.selector;\r\n    functionSelectors[--fnsCount] = this._setPriceOracle.selector;\r\n    functionSelectors[--fnsCount] = this._setCloseFactor.selector;\r\n    functionSelectors[--fnsCount] = this._setCollateralFactor.selector;\r\n    functionSelectors[--fnsCount] = this._setLiquidationIncentive.selector;\r\n    functionSelectors[--fnsCount] = this._setWhitelistEnforcement.selector;\r\n    functionSelectors[--fnsCount] = this._setWhitelistStatuses.selector;\r\n    functionSelectors[--fnsCount] = this._addRewardsDistributor.selector;\r\n    functionSelectors[--fnsCount] = this.getHypotheticalAccountLiquidity.selector;\r\n    functionSelectors[--fnsCount] = this.getMaxRedeemOrBorrow.selector;\r\n    functionSelectors[--fnsCount] = this.enterMarkets.selector;\r\n    functionSelectors[--fnsCount] = this.exitMarket.selector;\r\n    functionSelectors[--fnsCount] = this.mintAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.redeemAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.redeemVerify.selector;\r\n    functionSelectors[--fnsCount] = this.borrowAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.borrowWithinLimits.selector;\r\n    functionSelectors[--fnsCount] = this.repayBorrowAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.liquidateBorrowAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.seizeAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.transferAllowed.selector;\r\n    functionSelectors[--fnsCount] = this.mintVerify.selector;\r\n    functionSelectors[--fnsCount] = this.getAccountLiquidity.selector;\r\n    functionSelectors[--fnsCount] = this.liquidateCalculateSeizeTokens.selector;\r\n    functionSelectors[--fnsCount] = this._beforeNonReentrant.selector;\r\n    functionSelectors[--fnsCount] = this._afterNonReentrant.selector;\r\n    functionSelectors[--fnsCount] = this._becomeImplementation.selector;\r\n    functionSelectors[--fnsCount] = this.effectiveSupplyCaps.selector;\r\n    functionSelectors[--fnsCount] = this.effectiveBorrowCaps.selector;\r\n    functionSelectors[--fnsCount] = this.borrowVerify.selector;\r\n    functionSelectors[--fnsCount] = this.repayBorrowVerify.selector;\r\n    functionSelectors[--fnsCount] = this.seizeVerify.selector;\r\n    functionSelectors[--fnsCount] = this.transferVerify.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n  }\r\n\r\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\r\n\r\n  /**\r\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\r\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\r\n   */\r\n  function _beforeNonReentrant() external override {\r\n    require(markets[msg.sender].isListed, \"!Comptroller:_beforeNonReentrant\");\r\n    require(_notEntered, \"!reentered\");\r\n    _notEntered = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\r\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\r\n   */\r\n  function _afterNonReentrant() external override {\r\n    require(markets[msg.sender].isListed, \"!Comptroller:_afterNonReentrant\");\r\n    _notEntered = true; // get a gas-refund post-Istanbul\r\n  }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\r\nimport { ComptrollerErrorReporter } from \"../compound/ErrorReporter.sol\";\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { ComptrollerExtensionInterface, ComptrollerBase, SFSRegister } from \"./ComptrollerInterface.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\ncontract ComptrollerFirstExtension is\r\n  DiamondExtension,\r\n  ComptrollerBase,\r\n  ComptrollerExtensionInterface,\r\n  ComptrollerErrorReporter\r\n{\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  /// @notice Emitted when supply cap for a cToken is changed\r\n  event NewSupplyCap(ICErc20 indexed cToken, uint256 newSupplyCap);\r\n\r\n  /// @notice Emitted when borrow cap for a cToken is changed\r\n  event NewBorrowCap(ICErc20 indexed cToken, uint256 newBorrowCap);\r\n\r\n  /// @notice Emitted when borrow cap guardian is changed\r\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\r\n\r\n  /// @notice Emitted when pause guardian is changed\r\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\r\n\r\n  /// @notice Emitted when an action is paused globally\r\n  event ActionPaused(string action, bool pauseState);\r\n\r\n  /// @notice Emitted when an action is paused on a market\r\n  event MarketActionPaused(ICErc20 cToken, string action, bool pauseState);\r\n\r\n  /// @notice Emitted when an admin unsupports a market\r\n  event MarketUnlisted(ICErc20 cToken);\r\n\r\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 33;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.addNonAccruingFlywheel.selector;\r\n    functionSelectors[--fnsCount] = this._setMarketSupplyCaps.selector;\r\n    functionSelectors[--fnsCount] = this._setMarketBorrowCaps.selector;\r\n    functionSelectors[--fnsCount] = this._setBorrowCapForCollateralWhitelist.selector;\r\n    functionSelectors[--fnsCount] = this._blacklistBorrowingAgainstCollateralWhitelist.selector;\r\n    functionSelectors[--fnsCount] = this._supplyCapWhitelist.selector;\r\n    functionSelectors[--fnsCount] = this._borrowCapWhitelist.selector;\r\n    functionSelectors[--fnsCount] = this._setBorrowCapGuardian.selector;\r\n    functionSelectors[--fnsCount] = this._setPauseGuardian.selector;\r\n    functionSelectors[--fnsCount] = this._setMintPaused.selector;\r\n    functionSelectors[--fnsCount] = this._setBorrowPaused.selector;\r\n    functionSelectors[--fnsCount] = this._setTransferPaused.selector;\r\n    functionSelectors[--fnsCount] = this._setSeizePaused.selector;\r\n    functionSelectors[--fnsCount] = this._unsupportMarket.selector;\r\n    functionSelectors[--fnsCount] = this.getAllMarkets.selector;\r\n    functionSelectors[--fnsCount] = this.getAllBorrowers.selector;\r\n    functionSelectors[--fnsCount] = this.getAllBorrowersCount.selector;\r\n    functionSelectors[--fnsCount] = this.getPaginatedBorrowers.selector;\r\n    functionSelectors[--fnsCount] = this.getWhitelist.selector;\r\n    functionSelectors[--fnsCount] = this.getRewardsDistributors.selector;\r\n    functionSelectors[--fnsCount] = this.isUserOfPool.selector;\r\n    functionSelectors[--fnsCount] = this.getAccruingFlywheels.selector;\r\n    functionSelectors[--fnsCount] = this._removeFlywheel.selector;\r\n    functionSelectors[--fnsCount] = this._setBorrowCapForCollateral.selector;\r\n    functionSelectors[--fnsCount] = this._blacklistBorrowingAgainstCollateral.selector;\r\n    functionSelectors[--fnsCount] = this.isBorrowCapForCollateralWhitelisted.selector;\r\n    functionSelectors[--fnsCount] = this.isBlacklistBorrowingAgainstCollateralWhitelisted.selector;\r\n    functionSelectors[--fnsCount] = this.isSupplyCapWhitelisted.selector;\r\n    functionSelectors[--fnsCount] = this.isBorrowCapWhitelisted.selector;\r\n    functionSelectors[--fnsCount] = this.getWhitelistedSuppliersSupply.selector;\r\n    functionSelectors[--fnsCount] = this.getWhitelistedBorrowersBorrows.selector;\r\n    functionSelectors[--fnsCount] = this.getAssetAsCollateralValueCap.selector;\r\n    functionSelectors[--fnsCount] = this.registerInSFS.selector;\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the accruing flyhwheel was found and replaced\r\n   * @dev Adds a flywheel to the non-accruing list and if already in the accruing, removes it from that list\r\n   * @param flywheelAddress The address of the flywheel to add to the non-accruing\r\n   */\r\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool) {\r\n    require(hasAdminRights(), \"!admin\");\r\n    require(flywheelAddress != address(0), \"!flywheel\");\r\n\r\n    for (uint256 i = 0; i < nonAccruingRewardsDistributors.length; i++) {\r\n      require(flywheelAddress != nonAccruingRewardsDistributors[i], \"!alreadyadded\");\r\n    }\r\n\r\n    // add it to the non-accruing\r\n    nonAccruingRewardsDistributors.push(flywheelAddress);\r\n\r\n    // remove it from the accruing\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) {\r\n      if (flywheelAddress == rewardsDistributors[i]) {\r\n        rewardsDistributors[i] = rewardsDistributors[rewardsDistributors.length - 1];\r\n        rewardsDistributors.pop();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function getAssetAsCollateralValueCap(\r\n    ICErc20 collateral,\r\n    ICErc20 cTokenModify,\r\n    bool redeeming,\r\n    address account\r\n  ) external view returns (uint256) {\r\n    if (address(collateral) == address(cTokenModify) && !redeeming) {\r\n      // the collateral asset counts as 0 liquidity when borrowed\r\n      return 0;\r\n    }\r\n\r\n    uint256 assetAsCollateralValueCap = type(uint256).max;\r\n    if (address(cTokenModify) != address(0)) {\r\n      // if the borrowed asset is blacklisted against this collateral & account is not whitelisted\r\n      if (\r\n        borrowingAgainstCollateralBlacklist[address(cTokenModify)][address(collateral)] &&\r\n        !borrowingAgainstCollateralBlacklistWhitelist[address(cTokenModify)][address(collateral)].contains(account)\r\n      ) {\r\n        assetAsCollateralValueCap = 0;\r\n      } else {\r\n        // for each user the value of this kind of collateral is capped regardless of the amount borrowed\r\n        // denominated in the borrowed asset\r\n        uint256 borrowCapForCollateral = borrowCapForCollateral[address(cTokenModify)][address(collateral)];\r\n        // check if set to any value & account is not whitelisted\r\n        if (\r\n          borrowCapForCollateral != 0 &&\r\n          !borrowCapForCollateralWhitelist[address(cTokenModify)][address(collateral)].contains(account)\r\n        ) {\r\n          uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(cTokenModify);\r\n          // this asset usage as collateral is capped at the native value of the borrow cap\r\n          assetAsCollateralValueCap = (borrowCapForCollateral * borrowedAssetPrice) / 1e18;\r\n        }\r\n      }\r\n    }\r\n\r\n    uint256 supplyCap = effectiveSupplyCaps(address(collateral));\r\n\r\n    // if there is any supply cap, don't allow donations to the market/plugin to go around it\r\n    if (supplyCap > 0 && !supplyCapWhitelist[address(collateral)].contains(account)) {\r\n      uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateral);\r\n      uint256 supplyCapValue = (supplyCap * collateralAssetPrice) / 1e18;\r\n      supplyCapValue = (supplyCapValue * markets[address(collateral)].collateralFactorMantissa) / 1e18;\r\n      if (supplyCapValue < assetAsCollateralValueCap) assetAsCollateralValueCap = supplyCapValue;\r\n    }\r\n\r\n    return assetAsCollateralValueCap;\r\n  }\r\n\r\n  /**\r\n   * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\r\n   * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\r\n   * @param cTokens The addresses of the markets (tokens) to change the supply caps for\r\n   * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\r\n   */\r\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\r\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\r\n\r\n    uint256 numMarkets = cTokens.length;\r\n    uint256 numSupplyCaps = newSupplyCaps.length;\r\n\r\n    require(numMarkets != 0 && numMarkets == numSupplyCaps, \"!input\");\r\n\r\n    for (uint256 i = 0; i < numMarkets; i++) {\r\n      supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\r\n      emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\r\n   * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\r\n   * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\r\n   * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\r\n   */\r\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\r\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\r\n\r\n    uint256 numMarkets = cTokens.length;\r\n    uint256 numBorrowCaps = newBorrowCaps.length;\r\n\r\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"!input\");\r\n\r\n    for (uint256 i = 0; i < numMarkets; i++) {\r\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\r\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to change the Borrow Cap Guardian\r\n   * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\r\n   */\r\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\r\n    require(msg.sender == admin, \"!admin\");\r\n\r\n    // Save current value for inclusion in log\r\n    address oldBorrowCapGuardian = borrowCapGuardian;\r\n\r\n    // Store borrowCapGuardian with value newBorrowCapGuardian\r\n    borrowCapGuardian = newBorrowCapGuardian;\r\n\r\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\r\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\r\n  }\r\n\r\n  /**\r\n   * @notice Admin function to change the Pause Guardian\r\n   * @param newPauseGuardian The address of the new Pause Guardian\r\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n   */\r\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\r\n    }\r\n\r\n    // Save current value for inclusion in log\r\n    address oldPauseGuardian = pauseGuardian;\r\n\r\n    // Store pauseGuardian with value newPauseGuardian\r\n    pauseGuardian = newPauseGuardian;\r\n\r\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\r\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  function _setMintPaused(ICErc20 cToken, bool state) public returns (bool) {\r\n    require(markets[address(cToken)].isListed, \"!market\");\r\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\r\n    require(hasAdminRights() || state == true, \"!admin\");\r\n\r\n    mintGuardianPaused[address(cToken)] = state;\r\n    emit MarketActionPaused(cToken, \"Mint\", state);\r\n    return state;\r\n  }\r\n\r\n  function _setBorrowPaused(ICErc20 cToken, bool state) public returns (bool) {\r\n    require(markets[address(cToken)].isListed, \"!market\");\r\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\r\n    require(hasAdminRights() || state == true, \"!admin\");\r\n\r\n    borrowGuardianPaused[address(cToken)] = state;\r\n    emit MarketActionPaused(cToken, \"Borrow\", state);\r\n    return state;\r\n  }\r\n\r\n  function _setTransferPaused(bool state) public returns (bool) {\r\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\r\n    require(hasAdminRights() || state == true, \"!admin\");\r\n\r\n    transferGuardianPaused = state;\r\n    emit ActionPaused(\"Transfer\", state);\r\n    return state;\r\n  }\r\n\r\n  function _setSeizePaused(bool state) public returns (bool) {\r\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"!guardian\");\r\n    require(hasAdminRights() || state == true, \"!admin\");\r\n\r\n    seizeGuardianPaused = state;\r\n    emit ActionPaused(\"Seize\", state);\r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * @notice Removed a market from the markets mapping and sets it as unlisted\r\n   * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\r\n   * @param cToken The address of the market (token) to unlist\r\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\r\n   */\r\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256) {\r\n    // Check admin rights\r\n    if (!hasAdminRights()) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\r\n\r\n    // Check if market is already unlisted\r\n    if (!markets[address(cToken)].isListed)\r\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\r\n\r\n    // Check if market is in use\r\n    if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\r\n\r\n    // Unlist market\r\n    delete markets[address(cToken)];\r\n\r\n    /* Delete cToken from allMarkets */\r\n    // load into memory for faster iteration\r\n    ICErc20[] memory _allMarkets = allMarkets;\r\n    uint256 len = _allMarkets.length;\r\n    uint256 assetIndex = len;\r\n    for (uint256 i = 0; i < len; i++) {\r\n      if (_allMarkets[i] == cToken) {\r\n        assetIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // We *must* have found the asset in the list or our redundant data structure is broken\r\n    assert(assetIndex < len);\r\n\r\n    // copy last item in list to location of item to be removed, reduce length by 1\r\n    allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\r\n    allMarkets.pop();\r\n\r\n    cTokensByUnderlying[ICErc20(address(cToken)).underlying()] = ICErc20(address(0));\r\n    emit MarketUnlisted(cToken);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n    borrowCapForCollateral[cTokenBorrow][cTokenCollateral] = borrowCap;\r\n  }\r\n\r\n  function _setBorrowCapForCollateralWhitelist(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account,\r\n    bool whitelisted\r\n  ) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    if (whitelisted) borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].add(account);\r\n    else borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].remove(account);\r\n  }\r\n\r\n  function isBorrowCapForCollateralWhitelisted(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account\r\n  ) public view returns (bool) {\r\n    return borrowCapForCollateralWhitelist[cTokenBorrow][cTokenCollateral].contains(account);\r\n  }\r\n\r\n  function _blacklistBorrowingAgainstCollateral(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    bool blacklisted\r\n  ) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n    borrowingAgainstCollateralBlacklist[cTokenBorrow][cTokenCollateral] = blacklisted;\r\n  }\r\n\r\n  function _blacklistBorrowingAgainstCollateralWhitelist(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account,\r\n    bool whitelisted\r\n  ) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    if (whitelisted) borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].add(account);\r\n    else borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].remove(account);\r\n  }\r\n\r\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account\r\n  ) public view returns (bool) {\r\n    return borrowingAgainstCollateralBlacklistWhitelist[cTokenBorrow][cTokenCollateral].contains(account);\r\n  }\r\n\r\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    if (whitelisted) supplyCapWhitelist[cToken].add(account);\r\n    else supplyCapWhitelist[cToken].remove(account);\r\n  }\r\n\r\n  function isSupplyCapWhitelisted(address cToken, address account) public view returns (bool) {\r\n    return supplyCapWhitelist[cToken].contains(account);\r\n  }\r\n\r\n  function getWhitelistedSuppliersSupply(address cToken) public view returns (uint256 supplied) {\r\n    address[] memory whitelistedSuppliers = supplyCapWhitelist[cToken].values();\r\n    for (uint256 i = 0; i < whitelistedSuppliers.length; i++) {\r\n      supplied += ICErc20(cToken).balanceOfUnderlying(whitelistedSuppliers[i]);\r\n    }\r\n  }\r\n\r\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) public {\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    if (whitelisted) borrowCapWhitelist[cToken].add(account);\r\n    else borrowCapWhitelist[cToken].remove(account);\r\n  }\r\n\r\n  function isBorrowCapWhitelisted(address cToken, address account) public view returns (bool) {\r\n    return borrowCapWhitelist[cToken].contains(account);\r\n  }\r\n\r\n  function getWhitelistedBorrowersBorrows(address cToken) public view returns (uint256 borrowed) {\r\n    address[] memory whitelistedBorrowers = borrowCapWhitelist[cToken].values();\r\n    for (uint256 i = 0; i < whitelistedBorrowers.length; i++) {\r\n      borrowed += ICErc20(cToken).borrowBalanceCurrent(whitelistedBorrowers[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Return all of the markets\r\n   * @dev The automatic getter may be used to access an individual market.\r\n   * @return The list of market addresses\r\n   */\r\n  function getAllMarkets() public view returns (ICErc20[] memory) {\r\n    return allMarkets;\r\n  }\r\n\r\n  /**\r\n   * @notice Return all of the borrowers\r\n   * @dev The automatic getter may be used to access an individual borrower.\r\n   * @return The list of borrower account addresses\r\n   */\r\n  function getAllBorrowers() public view returns (address[] memory) {\r\n    return allBorrowers;\r\n  }\r\n\r\n  function getAllBorrowersCount() public view returns (uint256) {\r\n    return allBorrowers.length;\r\n  }\r\n\r\n  function getPaginatedBorrowers(\r\n    uint256 page,\r\n    uint256 pageSize\r\n  ) public view returns (uint256 _totalPages, address[] memory _pageOfBorrowers) {\r\n    uint256 allBorrowersCount = allBorrowers.length;\r\n    if (allBorrowersCount == 0) {\r\n      return (0, new address[](0));\r\n    }\r\n\r\n    if (pageSize == 0) pageSize = 300;\r\n    uint256 currentPageSize = pageSize;\r\n    uint256 sizeOfPageFromRemainder = allBorrowersCount % pageSize;\r\n\r\n    _totalPages = allBorrowersCount / pageSize;\r\n    if (sizeOfPageFromRemainder > 0) {\r\n      _totalPages++;\r\n      if (page + 1 == _totalPages) {\r\n        currentPageSize = sizeOfPageFromRemainder;\r\n      }\r\n    }\r\n\r\n    if (page + 1 > _totalPages) {\r\n      return (_totalPages, new address[](0));\r\n    }\r\n\r\n    uint256 offset = page * pageSize;\r\n    _pageOfBorrowers = new address[](currentPageSize);\r\n    for (uint256 i = 0; i < currentPageSize; i++) {\r\n      _pageOfBorrowers[i] = allBorrowers[i + offset];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Return all of the whitelist\r\n   * @dev The automatic getter may be used to access an individual whitelist status.\r\n   * @return The list of borrower account addresses\r\n   */\r\n  function getWhitelist() external view returns (address[] memory) {\r\n    return whitelistArray;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns an array of all accruing and non-accruing flywheels\r\n   */\r\n  function getRewardsDistributors() external view returns (address[] memory) {\r\n    address[] memory allFlywheels = new address[](rewardsDistributors.length + nonAccruingRewardsDistributors.length);\r\n\r\n    uint8 i = 0;\r\n    while (i < rewardsDistributors.length) {\r\n      allFlywheels[i] = rewardsDistributors[i];\r\n      i++;\r\n    }\r\n    uint8 j = 0;\r\n    while (j < nonAccruingRewardsDistributors.length) {\r\n      allFlywheels[i + j] = nonAccruingRewardsDistributors[j];\r\n      j++;\r\n    }\r\n\r\n    return allFlywheels;\r\n  }\r\n\r\n  function getAccruingFlywheels() external view returns (address[] memory) {\r\n    return rewardsDistributors;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a flywheel from the accruing or non-accruing array\r\n   * @param flywheelAddress The address of the flywheel to remove from the accruing or non-accruing array\r\n   * @return true if the flywheel was found and removed\r\n   */\r\n  function _removeFlywheel(address flywheelAddress) external returns (bool) {\r\n    require(hasAdminRights(), \"!admin\");\r\n    require(flywheelAddress != address(0), \"!flywheel\");\r\n\r\n    // remove it from the accruing\r\n    for (uint256 i = 0; i < rewardsDistributors.length; i++) {\r\n      if (flywheelAddress == rewardsDistributors[i]) {\r\n        rewardsDistributors[i] = rewardsDistributors[rewardsDistributors.length - 1];\r\n        rewardsDistributors.pop();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // or remove it from the non-accruing\r\n    for (uint256 i = 0; i < nonAccruingRewardsDistributors.length; i++) {\r\n      if (flywheelAddress == nonAccruingRewardsDistributors[i]) {\r\n        nonAccruingRewardsDistributors[i] = nonAccruingRewardsDistributors[nonAccruingRewardsDistributors.length - 1];\r\n        nonAccruingRewardsDistributors.pop();\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function isUserOfPool(address user) external view returns (bool) {\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      address marketAddress = address(allMarkets[i]);\r\n      if (markets[marketAddress].accountMembership[user]) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function registerInSFS() external returns (uint256) {\r\n    require(hasAdminRights(), \"!admin\");\r\n    SFSRegister sfsContract = SFSRegister(0x8680CEaBcb9b56913c519c069Add6Bc3494B7020);\r\n\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      allMarkets[i].registerInSFS();\r\n    }\r\n\r\n    return sfsContract.register(0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2);\r\n  }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { BasePriceOracle } from \"../oracles/BasePriceOracle.sol\";\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\r\nimport { ComptrollerV4Storage } from \"../compound/ComptrollerStorage.sol\";\r\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\r\nimport { IHistoricalRates } from \"adrastia-periphery/rates/IHistoricalRates.sol\";\r\n\r\ninterface ComptrollerInterface {\r\n  function isDeprecated(ICErc20 cToken) external view returns (bool);\r\n\r\n  function _becomeImplementation() external;\r\n\r\n  function _deployMarket(\r\n    uint8 delegateType,\r\n    bytes memory constructorData,\r\n    bytes calldata becomeImplData,\r\n    uint256 collateralFactorMantissa\r\n  ) external returns (uint256);\r\n\r\n  function getAssetsIn(address account) external view returns (ICErc20[] memory);\r\n\r\n  function checkMembership(address account, ICErc20 cToken) external view returns (bool);\r\n\r\n  function _setPriceOracle(BasePriceOracle newOracle) external returns (uint256);\r\n\r\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\r\n\r\n  function _setCollateralFactor(ICErc20 market, uint256 newCollateralFactorMantissa) external returns (uint256);\r\n\r\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\r\n\r\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\r\n\r\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\r\n\r\n  function _addRewardsDistributor(address distributor) external returns (uint256);\r\n\r\n  function getHypotheticalAccountLiquidity(\r\n    address account,\r\n    address cTokenModify,\r\n    uint256 redeemTokens,\r\n    uint256 borrowAmount,\r\n    uint256 repayAmount\r\n  ) external view returns (uint256, uint256, uint256, uint256);\r\n\r\n  function getMaxRedeemOrBorrow(address account, ICErc20 cToken, bool isBorrow) external view returns (uint256);\r\n\r\n  /*** Assets You Are In ***/\r\n\r\n  function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\r\n\r\n  function exitMarket(address cToken) external returns (uint256);\r\n\r\n  /*** Policy Hooks ***/\r\n\r\n  function mintAllowed(address cToken, address minter, uint256 mintAmount) external returns (uint256);\r\n\r\n  function redeemAllowed(address cToken, address redeemer, uint256 redeemTokens) external returns (uint256);\r\n\r\n  function redeemVerify(address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens) external;\r\n\r\n  function borrowAllowed(address cToken, address borrower, uint256 borrowAmount) external returns (uint256);\r\n\r\n  function borrowVerify(address cToken, address borrower) external;\r\n\r\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external view returns (uint256);\r\n\r\n  function repayBorrowAllowed(\r\n    address cToken,\r\n    address payer,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external returns (uint256);\r\n\r\n  function repayBorrowVerify(\r\n    address cToken,\r\n    address payer,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external;\r\n\r\n  function liquidateBorrowAllowed(\r\n    address cTokenBorrowed,\r\n    address cTokenCollateral,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) external returns (uint256);\r\n\r\n  function seizeAllowed(\r\n    address cTokenCollateral,\r\n    address cTokenBorrowed,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) external returns (uint256);\r\n  \r\n  function seizeVerify(\r\n    address cTokenCollateral,\r\n    address cTokenBorrowed,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) external;\r\n\r\n  function transferAllowed(address cToken, address src, address dst, uint256 transferTokens) external returns (uint256);\r\n  \r\n  function transferVerify(address cToken, address src, address dst, uint256 transferTokens) external;\r\n\r\n  function mintVerify(address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens) external;\r\n\r\n  /*** Liquidity/Liquidation Calculations ***/\r\n\r\n  function getAccountLiquidity(\r\n    address account\r\n  ) external view returns (uint256 error, uint256 collateralValue, uint256 liquidity, uint256 shortfall);\r\n\r\n  function liquidateCalculateSeizeTokens(\r\n    address cTokenBorrowed,\r\n    address cTokenCollateral,\r\n    uint256 repayAmount\r\n  ) external view returns (uint256, uint256);\r\n\r\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\r\n\r\n  function _beforeNonReentrant() external;\r\n\r\n  function _afterNonReentrant() external;\r\n\r\n  /*** New supply and borrow cap view functions ***/\r\n\r\n  /**\r\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveSupplyCaps(address cToken) external view returns (uint256 supplyCap);\r\n\r\n  /**\r\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveBorrowCaps(address cToken) external view returns (uint256 borrowCap);\r\n}\r\n\r\ninterface ComptrollerStorageInterface {\r\n  function admin() external view returns (address);\r\n\r\n  function adminHasRights() external view returns (bool);\r\n\r\n  function ionicAdmin() external view returns (address);\r\n\r\n  function ionicAdminHasRights() external view returns (bool);\r\n\r\n  function pendingAdmin() external view returns (address);\r\n\r\n  function oracle() external view returns (BasePriceOracle);\r\n\r\n  function pauseGuardian() external view returns (address);\r\n\r\n  function closeFactorMantissa() external view returns (uint256);\r\n\r\n  function liquidationIncentiveMantissa() external view returns (uint256);\r\n\r\n  function isUserOfPool(address user) external view returns (bool);\r\n\r\n  function whitelist(address account) external view returns (bool);\r\n\r\n  function enforceWhitelist() external view returns (bool);\r\n\r\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\r\n\r\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\r\n\r\n  function suppliers(address account) external view returns (bool);\r\n\r\n  function cTokensByUnderlying(address) external view returns (address);\r\n\r\n  /**\r\n   * Gets the supply cap of a cToken in the units of the underlying asset.\r\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the supply cap. Instead, use\r\n   * `effectiveSupplyCaps` to get the correct supply cap.\r\n   * @param cToken The address of the cToken.\r\n   * @return The supply cap in the units of the underlying asset.\r\n   */\r\n  function supplyCaps(address cToken) external view returns (uint256);\r\n\r\n  /**\r\n   * Gets the borrow cap of a cToken in the units of the underlying asset.\r\n   * @dev WARNING: This function is misleading if Adrastia Prudentia is being used for the borrow cap. Instead, use\r\n   * `effectiveBorrowCaps` to get the correct borrow cap.\r\n   * @param cToken The address of the cToken.\r\n   * @return The borrow cap in the units of the underlying asset.\r\n   */\r\n  function borrowCaps(address cToken) external view returns (uint256);\r\n\r\n  function markets(address cToken) external view returns (bool, uint256);\r\n\r\n  function accountAssets(address, uint256) external view returns (address);\r\n\r\n  function borrowGuardianPaused(address cToken) external view returns (bool);\r\n\r\n  function mintGuardianPaused(address cToken) external view returns (bool);\r\n\r\n  function rewardsDistributors(uint256) external view returns (address);\r\n}\r\n\r\ninterface SFSRegister {\r\n  function register(address _recipient) external returns (uint256 tokenId);\r\n}\r\n\r\ninterface ComptrollerExtensionInterface {\r\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\r\n\r\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\r\n\r\n  function getAllMarkets() external view returns (ICErc20[] memory);\r\n\r\n  function getAllBorrowers() external view returns (address[] memory);\r\n\r\n  function getAllBorrowersCount() external view returns (uint256);\r\n\r\n  function getPaginatedBorrowers(\r\n    uint256 page,\r\n    uint256 pageSize\r\n  ) external view returns (uint256 _totalPages, address[] memory _pageOfBorrowers);\r\n\r\n  function getRewardsDistributors() external view returns (address[] memory);\r\n\r\n  function getAccruingFlywheels() external view returns (address[] memory);\r\n\r\n  function _supplyCapWhitelist(address cToken, address account, bool whitelisted) external;\r\n\r\n  function _setBorrowCapForCollateral(address cTokenBorrow, address cTokenCollateral, uint256 borrowCap) external;\r\n\r\n  function _setBorrowCapForCollateralWhitelist(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account,\r\n    bool whitelisted\r\n  ) external;\r\n\r\n  function isBorrowCapForCollateralWhitelisted(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account\r\n  ) external view returns (bool);\r\n\r\n  function _blacklistBorrowingAgainstCollateral(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    bool blacklisted\r\n  ) external;\r\n\r\n  function _blacklistBorrowingAgainstCollateralWhitelist(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account,\r\n    bool whitelisted\r\n  ) external;\r\n\r\n  function isBlacklistBorrowingAgainstCollateralWhitelisted(\r\n    address cTokenBorrow,\r\n    address cTokenCollateral,\r\n    address account\r\n  ) external view returns (bool);\r\n\r\n  function isSupplyCapWhitelisted(address cToken, address account) external view returns (bool);\r\n\r\n  function _borrowCapWhitelist(address cToken, address account, bool whitelisted) external;\r\n\r\n  function isBorrowCapWhitelisted(address cToken, address account) external view returns (bool);\r\n\r\n  function _removeFlywheel(address flywheelAddress) external returns (bool);\r\n\r\n  function getWhitelist() external view returns (address[] memory);\r\n\r\n  function addNonAccruingFlywheel(address flywheelAddress) external returns (bool);\r\n\r\n  function _setMarketSupplyCaps(ICErc20[] calldata cTokens, uint256[] calldata newSupplyCaps) external;\r\n\r\n  function _setMarketBorrowCaps(ICErc20[] calldata cTokens, uint256[] calldata newBorrowCaps) external;\r\n\r\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\r\n\r\n  function _setPauseGuardian(address newPauseGuardian) external returns (uint256);\r\n\r\n  function _setMintPaused(ICErc20 cToken, bool state) external returns (bool);\r\n\r\n  function _setBorrowPaused(ICErc20 cToken, bool state) external returns (bool);\r\n\r\n  function _setTransferPaused(bool state) external returns (bool);\r\n\r\n  function _setSeizePaused(bool state) external returns (bool);\r\n\r\n  function _unsupportMarket(ICErc20 cToken) external returns (uint256);\r\n\r\n  function getAssetAsCollateralValueCap(\r\n    ICErc20 collateral,\r\n    ICErc20 cTokenModify,\r\n    bool redeeming,\r\n    address account\r\n  ) external view returns (uint256);\r\n\r\n  function registerInSFS() external returns (uint256);\r\n}\r\n\r\ninterface ComptrollerPrudentiaCapsExtInterface {\r\n  /**\r\n   * @notice Retrieves Adrastia Prudentia borrow cap config from storage.\r\n   * @return The config.\r\n   */\r\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\r\n\r\n  /**\r\n   * @notice Retrieves Adrastia Prudentia supply cap config from storage.\r\n   * @return The config.\r\n   */\r\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory);\r\n\r\n  /**\r\n   * @notice Sets the Adrastia Prudentia supply cap config.\r\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native supply caps.\r\n   * @param newConfig The new config.\r\n   */\r\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\r\n\r\n  /**\r\n   * @notice Sets the Adrastia Prudentia supply cap config.\r\n   * @dev Specifying a zero address for the `controller` parameter will make the Comptroller use the native borrow caps.\r\n   * @param newConfig The new config.\r\n   */\r\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external;\r\n}\r\n\r\ninterface UnitrollerInterface {\r\n  function comptrollerImplementation() external view returns (address);\r\n\r\n  function _upgrade() external;\r\n\r\n  function _acceptAdmin() external returns (uint256);\r\n\r\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\r\n\r\n  function _toggleAdminRights(bool hasRights) external returns (uint256);\r\n}\r\n\r\ninterface IComptrollerExtension is ComptrollerExtensionInterface, ComptrollerStorageInterface {}\r\n\r\n//interface IComptrollerBase is ComptrollerInterface, ComptrollerStorageInterface {}\r\n\r\ninterface IonicComptroller is\r\n  ComptrollerInterface,\r\n  ComptrollerExtensionInterface,\r\n  UnitrollerInterface,\r\n  ComptrollerStorageInterface\r\n{\r\n\r\n}\r\n\r\nabstract contract ComptrollerBase is ComptrollerV4Storage {\r\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\r\n  bool public constant isComptroller = true;\r\n\r\n  /**\r\n   * @notice Gets the supply cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveSupplyCaps(address cToken) public view virtual returns (uint256 supplyCap) {\r\n    PrudentiaLib.PrudentiaConfig memory capConfig = supplyCapConfig;\r\n\r\n    // Check if we're using Adrastia Prudentia for the supply cap\r\n    if (capConfig.controller != address(0)) {\r\n      // We have a controller, so we're using Adrastia Prudentia\r\n\r\n      address underlyingToken = ICErc20(cToken).underlying();\r\n\r\n      // Get the supply cap from Adrastia Prudentia\r\n      supplyCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\r\n\r\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\r\n      // must scale the supply cap to get the correct amount\r\n\r\n      int256 scaleByDecimals = 18;\r\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\r\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n      if (success && data.length == 32) {\r\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\r\n      }\r\n\r\n      scaleByDecimals += capConfig.decimalShift;\r\n\r\n      if (scaleByDecimals >= 0) {\r\n        // We're scaling up, so we need to multiply\r\n        supplyCap *= 10 ** uint256(scaleByDecimals);\r\n      } else {\r\n        // We're scaling down, so we need to divide\r\n        supplyCap /= 10 ** uint256(-scaleByDecimals);\r\n      }\r\n    } else {\r\n      // We don't have a controller, so we're using the local supply cap\r\n\r\n      // Get the supply cap from the local supply cap\r\n      supplyCap = supplyCaps[cToken];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the borrow cap of a cToken in the units of the underlying asset.\r\n   * @param cToken The address of the cToken.\r\n   */\r\n  function effectiveBorrowCaps(address cToken) public view virtual returns (uint256 borrowCap) {\r\n    PrudentiaLib.PrudentiaConfig memory capConfig = borrowCapConfig;\r\n\r\n    // Check if we're using Adrastia Prudentia for the borrow cap\r\n    if (capConfig.controller != address(0)) {\r\n      // We have a controller, so we're using Adrastia Prudentia\r\n\r\n      address underlyingToken = ICErc20(cToken).underlying();\r\n\r\n      // Get the borrow cap from Adrastia Prudentia\r\n      borrowCap = IHistoricalRates(capConfig.controller).getRateAt(underlyingToken, capConfig.offset).current;\r\n\r\n      // Prudentia trims decimal points from amounts while our code requires the mantissa amount, so we\r\n      // must scale the supply cap to get the correct amount\r\n\r\n      int256 scaleByDecimals = 18;\r\n      // Not all ERC20s implement decimals(), so we use a staticcall and check the return data\r\n      (bool success, bytes memory data) = underlyingToken.staticcall(abi.encodeWithSignature(\"decimals()\"));\r\n      if (success && data.length == 32) {\r\n        scaleByDecimals = int256(uint256(abi.decode(data, (uint8))));\r\n      }\r\n\r\n      scaleByDecimals += capConfig.decimalShift;\r\n\r\n      if (scaleByDecimals >= 0) {\r\n        // We're scaling up, so we need to multiply\r\n        borrowCap *= 10 ** uint256(scaleByDecimals);\r\n      } else {\r\n        // We're scaling down, so we need to divide\r\n        borrowCap /= 10 ** uint256(-scaleByDecimals);\r\n      }\r\n    } else {\r\n      // We don't have a controller, so we're using the local borrow cap\r\n      borrowCap = borrowCaps[cToken];\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerPrudentiaCapsExt.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { ComptrollerPrudentiaCapsExtInterface, ComptrollerBase } from \"./ComptrollerInterface.sol\";\r\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\r\n\r\n/**\r\n * @title ComptrollerPrudentiaCapsExt\r\n * @author Tyler Loewen (TRILEZ SOFTWARE INC. dba. Adrastia)\r\n * @notice A diamond extension that allows the Comptroller to use Adrastia Prudentia to control supply and borrow caps.\r\n */\r\ncontract ComptrollerPrudentiaCapsExt is DiamondExtension, ComptrollerBase, ComptrollerPrudentiaCapsExtInterface {\r\n  /**\r\n   * @notice Emitted when the Adrastia Prudentia supply cap config is changed.\r\n   * @param oldConfig The old config.\r\n   * @param newConfig The new config.\r\n   */\r\n  event NewSupplyCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\r\n\r\n  /**\r\n   * @notice Emitted when the Adrastia Prudentia borrow cap config is changed.\r\n   * @param oldConfig The old config.\r\n   * @param newConfig The new config.\r\n   */\r\n  event NewBorrowCapConfig(PrudentiaLib.PrudentiaConfig oldConfig, PrudentiaLib.PrudentiaConfig newConfig);\r\n\r\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\r\n  function _setSupplyCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external {\r\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\r\n\r\n    PrudentiaLib.PrudentiaConfig memory oldConfig = supplyCapConfig;\r\n    supplyCapConfig = newConfig;\r\n\r\n    emit NewSupplyCapConfig(oldConfig, newConfig);\r\n  }\r\n\r\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\r\n  function _setBorrowCapConfig(PrudentiaLib.PrudentiaConfig calldata newConfig) external {\r\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"!admin\");\r\n\r\n    PrudentiaLib.PrudentiaConfig memory oldConfig = borrowCapConfig;\r\n    borrowCapConfig = newConfig;\r\n\r\n    emit NewBorrowCapConfig(oldConfig, newConfig);\r\n  }\r\n\r\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\r\n  function getBorrowCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory) {\r\n    return borrowCapConfig;\r\n  }\r\n\r\n  /// @inheritdoc ComptrollerPrudentiaCapsExtInterface\r\n  function getSupplyCapConfig() external view returns (PrudentiaLib.PrudentiaConfig memory) {\r\n    return supplyCapConfig;\r\n  }\r\n\r\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 4;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this._setSupplyCapConfig.selector;\r\n    functionSelectors[--fnsCount] = this._setBorrowCapConfig.selector;\r\n    functionSelectors[--fnsCount] = this.getBorrowCapConfig.selector;\r\n    functionSelectors[--fnsCount] = this.getSupplyCapConfig.selector;\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n}\r\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IFeeDistributor.sol\";\r\nimport \"../oracles/BasePriceOracle.sol\";\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { PrudentiaLib } from \"../adrastia/PrudentiaLib.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\ncontract UnitrollerAdminStorage {\r\n  /*\r\n   * Administrator for Ionic\r\n   */\r\n  address payable public ionicAdmin;\r\n\r\n  /**\r\n   * @notice Administrator for this contract\r\n   */\r\n  address public admin;\r\n\r\n  /**\r\n   * @notice Pending administrator for this contract\r\n   */\r\n  address public pendingAdmin;\r\n\r\n  /**\r\n   * @notice Whether or not the Ionic admin has admin rights\r\n   */\r\n  bool public ionicAdminHasRights = true;\r\n\r\n  /**\r\n   * @notice Whether or not the admin has admin rights\r\n   */\r\n  bool public adminHasRights = true;\r\n\r\n  /**\r\n   * @notice Returns a boolean indicating if the sender has admin rights\r\n   */\r\n  function hasAdminRights() internal view returns (bool) {\r\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(ionicAdmin) && ionicAdminHasRights);\r\n  }\r\n}\r\n\r\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\r\n  /**\r\n   * @notice Oracle which gives the price of any given asset\r\n   */\r\n  BasePriceOracle public oracle;\r\n\r\n  /**\r\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\r\n   */\r\n  uint256 public closeFactorMantissa;\r\n\r\n  /**\r\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\r\n   */\r\n  uint256 public liquidationIncentiveMantissa;\r\n\r\n  /*\r\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\r\n   */\r\n  uint256 internal maxAssets;\r\n\r\n  /**\r\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\r\n   */\r\n  mapping(address => ICErc20[]) public accountAssets;\r\n}\r\n\r\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\r\n  struct Market {\r\n    // Whether or not this market is listed\r\n    bool isListed;\r\n    // Multiplier representing the most one can borrow against their collateral in this market.\r\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\r\n    // Must be between 0 and 1, and stored as a mantissa.\r\n    uint256 collateralFactorMantissa;\r\n    // Per-market mapping of \"accounts in this asset\"\r\n    mapping(address => bool) accountMembership;\r\n  }\r\n\r\n  /**\r\n   * @notice Official mapping of cTokens -> Market metadata\r\n   * @dev Used e.g. to determine if a market is supported\r\n   */\r\n  mapping(address => Market) public markets;\r\n\r\n  /// @notice A list of all markets\r\n  ICErc20[] public allMarkets;\r\n\r\n  /**\r\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\r\n   */\r\n  mapping(address => bool) internal borrowers;\r\n\r\n  /// @notice A list of all borrowers who have entered markets\r\n  address[] public allBorrowers;\r\n\r\n  // Indexes of borrower account addresses in the `allBorrowers` array\r\n  mapping(address => uint256) internal borrowerIndexes;\r\n\r\n  /**\r\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\r\n   */\r\n  mapping(address => bool) public suppliers;\r\n\r\n  /// @notice All cTokens addresses mapped by their underlying token addresses\r\n  mapping(address => ICErc20) public cTokensByUnderlying;\r\n\r\n  /// @notice Whether or not the supplier whitelist is enforced\r\n  bool public enforceWhitelist;\r\n\r\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\r\n  mapping(address => bool) public whitelist;\r\n\r\n  /// @notice An array of all whitelisted accounts\r\n  address[] public whitelistArray;\r\n\r\n  // Indexes of account addresses in the `whitelistArray` array\r\n  mapping(address => uint256) internal whitelistIndexes;\r\n\r\n  /**\r\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\r\n   *  Actions which allow users to remove their own assets cannot be paused.\r\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\r\n   */\r\n  address public pauseGuardian;\r\n  bool public _mintGuardianPaused;\r\n  bool public _borrowGuardianPaused;\r\n  bool public transferGuardianPaused;\r\n  bool public seizeGuardianPaused;\r\n  mapping(address => bool) public mintGuardianPaused;\r\n  mapping(address => bool) public borrowGuardianPaused;\r\n}\r\n\r\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\r\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\r\n  /// @dev If Adrastia Prudentia is enabled, the values the borrow cap guardian sets are ignored.\r\n  address public borrowCapGuardian;\r\n\r\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\r\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveBorrowCaps` instead.\r\n  mapping(address => uint256) public borrowCaps;\r\n\r\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\r\n  /// @dev If Adrastia Prudentia is enabled, this value is ignored. Use `effectiveSupplyCaps` instead.\r\n  mapping(address => uint256) public supplyCaps;\r\n\r\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\r\n  address[] public rewardsDistributors;\r\n\r\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\r\n  bool internal _notEntered;\r\n\r\n  /// @dev Whether or not _notEntered has been initialized\r\n  bool internal _notEnteredInitialized;\r\n\r\n  /// @notice RewardsDistributor to list for claiming, but not to notify of flywheel changes.\r\n  address[] public nonAccruingRewardsDistributors;\r\n\r\n  /// @dev cap for each user's borrows against specific assets - denominated in the borrowed asset\r\n  mapping(address => mapping(address => uint256)) public borrowCapForCollateral;\r\n\r\n  /// @dev blacklist to disallow the borrowing of an asset against specific collateral\r\n  mapping(address => mapping(address => bool)) public borrowingAgainstCollateralBlacklist;\r\n\r\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrowing against specific collateral cap\r\n  mapping(address => mapping(address => EnumerableSet.AddressSet)) internal borrowCapForCollateralWhitelist;\r\n\r\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\r\n  mapping(address => mapping(address => EnumerableSet.AddressSet))\r\n    internal borrowingAgainstCollateralBlacklistWhitelist;\r\n\r\n  /// @dev set of whitelisted accounts that are allowed to bypass the supply cap\r\n  mapping(address => EnumerableSet.AddressSet) internal supplyCapWhitelist;\r\n\r\n  /// @dev set of whitelisted accounts that are allowed to bypass the borrow cap\r\n  mapping(address => EnumerableSet.AddressSet) internal borrowCapWhitelist;\r\n}\r\n\r\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\r\n  /// @dev Adrastia Prudentia config for controlling borrow caps.\r\n  PrudentiaLib.PrudentiaConfig internal borrowCapConfig;\r\n\r\n  /// @dev Adrastia Prudentia config for controlling supply caps.\r\n  PrudentiaLib.PrudentiaConfig internal supplyCapConfig;\r\n}\r\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { IonicComptroller } from \"./ComptrollerInterface.sol\";\r\nimport { CTokenSecondExtensionBase, ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { TokenErrorReporter } from \"./ErrorReporter.sol\";\r\nimport { Exponential } from \"./Exponential.sol\";\r\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\r\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\r\nimport { ComptrollerV3Storage } from \"./ComptrollerStorage.sol\";\r\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\r\nimport { CTokenOracleProtected } from \"./CTokenOracleProtected.sol\";\r\n\r\nimport { DiamondExtension, LibDiamond } from \"../ionic/DiamondExtension.sol\";\r\nimport { PoolLens } from \"../PoolLens.sol\";\r\nimport { IonicUniV3Liquidator } from \"../IonicUniV3Liquidator.sol\";\r\nimport { IHypernativeOracle } from \"../external/hypernative/interfaces/IHypernativeOracle.sol\";\r\n\r\n/**\r\n * @title Compound's CErc20 Contract\r\n * @notice CTokens which wrap an EIP-20 underlying\r\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\r\n * @author Compound\r\n */\r\nabstract contract CErc20 is CTokenOracleProtected, CTokenSecondExtensionBase, TokenErrorReporter, Exponential, DiamondExtension {\r\n  modifier isAuthorized() {\r\n    require(\r\n      IFeeDistributor(ionicAdmin).canCall(address(comptroller), msg.sender, address(this), msg.sig),\r\n      \"not authorized\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier isMinHFThresholdExceeded(address borrower) {\r\n    PoolLens lens = PoolLens(ap.getAddress(\"PoolLens\"));\r\n    IonicUniV3Liquidator liquidator = IonicUniV3Liquidator(payable(ap.getAddress(\"IonicUniV3Liquidator\")));\r\n\r\n    if (lens.getHealthFactor(borrower, comptroller) > liquidator.healthFactorThreshold()) {\r\n      require(msg.sender == address(liquidator), \"Health factor not low enough for non-permissioned liquidations\");\r\n      _;\r\n    } else {\r\n      _;\r\n    }\r\n  }\r\n\r\n  function _getExtensionFunctions() public pure virtual override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 13;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.mint.selector;\r\n    functionSelectors[--fnsCount] = this.redeem.selector;\r\n    functionSelectors[--fnsCount] = this.redeemUnderlying.selector;\r\n    functionSelectors[--fnsCount] = this.borrow.selector;\r\n    functionSelectors[--fnsCount] = this.repayBorrow.selector;\r\n    functionSelectors[--fnsCount] = this.repayBorrowBehalf.selector;\r\n    functionSelectors[--fnsCount] = this.liquidateBorrow.selector;\r\n    functionSelectors[--fnsCount] = this.getCash.selector;\r\n    functionSelectors[--fnsCount] = this.seize.selector;\r\n    functionSelectors[--fnsCount] = this.selfTransferOut.selector;\r\n    functionSelectors[--fnsCount] = this.selfTransferIn.selector;\r\n    functionSelectors[--fnsCount] = this._withdrawIonicFees.selector;\r\n    functionSelectors[--fnsCount] = this._withdrawAdminFees.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  /*** User Interface ***/\r\n\r\n  /**\r\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param mintAmount The amount of the underlying asset to supply\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function mint(uint256 mintAmount) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    (uint256 err, ) = mintInternal(mintAmount);\r\n    return err;\r\n  }\r\n\r\n  /**\r\n   * @notice Sender redeems cTokens in exchange for the underlying asset\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param redeemTokens The number of cTokens to redeem into underlying\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function redeem(uint256 redeemTokens) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    return redeemInternal(redeemTokens);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param redeemAmount The amount of underlying to redeem\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function redeemUnderlying(uint256 redeemAmount) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    return redeemUnderlyingInternal(redeemAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender borrows assets from the protocol to their own address\r\n   * @param borrowAmount The amount of the underlying asset to borrow\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function borrow(uint256 borrowAmount) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    return borrowInternal(borrowAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender repays their own borrow\r\n   * @param repayAmount The amount to repay\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function repayBorrow(uint256 repayAmount) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\r\n    return err;\r\n  }\r\n\r\n  /**\r\n   * @notice Sender repays a borrow belonging to borrower\r\n   * @param borrower the account with the debt being payed off\r\n   * @param repayAmount The amount to repay\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override isAuthorized onlyOracleApprovedAllowEOA returns (uint256) {\r\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\r\n    return err;\r\n  }\r\n\r\n  /**\r\n   * @notice The sender liquidates the borrowers collateral.\r\n   *  The collateral seized is transferred to the liquidator.\r\n   * @param borrower The borrower of this cToken to be liquidated\r\n   * @param repayAmount The amount of the underlying borrowed asset to repay\r\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function liquidateBorrow(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    address cTokenCollateral\r\n  ) external override isAuthorized onlyOracleApprovedAllowEOA isMinHFThresholdExceeded(borrower) returns (uint256) {\r\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\r\n    return err;\r\n  }\r\n\r\n  /**\r\n   * @notice Get cash balance of this cToken in the underlying asset\r\n   * @return The quantity of underlying asset owned by this contract\r\n   */\r\n  function getCash() external view override returns (uint256) {\r\n    return getCashInternal();\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers collateral tokens (this market) to the liquidator.\r\n   * @dev Will fail unless called by another cToken during the process of liquidation.\r\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\r\n   * @param liquidator The account receiving seized collateral\r\n   * @param borrower The account having collateral seized\r\n   * @param seizeTokens The number of cTokens to seize\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function seize(\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) external override nonReentrant(true) onlyOracleApprovedAllowEOA returns (uint256) {\r\n    return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\r\n  }\r\n\r\n  function selfTransferOut(address to, uint256 amount) external override {\r\n    require(msg.sender == address(this), \"!self\");\r\n    doTransferOut(to, amount);\r\n  }\r\n\r\n  function selfTransferIn(address from, uint256 amount) external override returns (uint256) {\r\n    require(msg.sender == address(this), \"!self\");\r\n    return doTransferIn(from, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Accrues interest and reduces Ionic fees by transferring to Ionic\r\n   * @param withdrawAmount Amount of fees to withdraw\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _withdrawIonicFees(uint256 withdrawAmount) external override nonReentrant(false) onlyOracleApproved returns (uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_IONIC_FEES_FRESH_CHECK);\r\n    }\r\n\r\n    if (getCashInternal() < withdrawAmount) {\r\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE);\r\n    }\r\n\r\n    if (withdrawAmount > totalIonicFees) {\r\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_IONIC_FEES_VALIDATION);\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    uint256 totalIonicFeesNew = totalIonicFees - withdrawAmount;\r\n    totalIonicFees = totalIonicFeesNew;\r\n\r\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n    doTransferOut(address(ionicAdmin), withdrawAmount);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Accrues interest and reduces admin fees by transferring to admin\r\n   * @param withdrawAmount Amount of fees to withdraw\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _withdrawAdminFees(uint256 withdrawAmount) external override nonReentrant(false) onlyOracleApproved returns (uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);\r\n    }\r\n\r\n    // Fail gracefully if protocol has insufficient underlying cash\r\n    if (getCashInternal() < withdrawAmount) {\r\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);\r\n    }\r\n\r\n    if (withdrawAmount > totalAdminFees) {\r\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n    totalAdminFees = totalAdminFees - withdrawAmount;\r\n\r\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n    doTransferOut(ComptrollerV3Storage(address(comptroller)).admin(), withdrawAmount);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /*** Safe Token ***/\r\n\r\n  /**\r\n   * @notice Gets balance of this contract in terms of the underlying\r\n   * @dev This excludes the value of the current message, if any\r\n   * @return The quantity of underlying tokens owned by this contract\r\n   */\r\n  function getCashInternal() internal view virtual returns (uint256) {\r\n    return EIP20Interface(underlying).balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n   *      This will revert due to insufficient balance or insufficient allowance.\r\n   *      This function returns the actual amount received,\r\n   *      which may be less than `amount` if there is a fee attached to the transfer.\r\n   *\r\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n   */\r\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\r\n    uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\r\n    _callOptionalReturn(\r\n      abi.encodeWithSelector(EIP20Interface.transferFrom.selector, from, address(this), amount),\r\n      \"TOKEN_TRANSFER_IN_FAILED\"\r\n    );\r\n\r\n    // Calculate the amount that was *actually* transferred\r\n    uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\r\n    require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\r\n  }\r\n\r\n  /**\r\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n   *      it is >= amount, this should not revert in normal conditions.\r\n   *\r\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n   */\r\n  function doTransferOut(address to, uint256 amount) internal virtual {\r\n    _callOptionalReturn(\r\n      abi.encodeWithSelector(EIP20Interface.transfer.selector, to, amount),\r\n      \"TOKEN_TRANSFER_OUT_FAILED\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n   * @param data The call data (encoded using abi.encode or one of its variants).\r\n   * @param errorMessage The revert string to return on failure.\r\n   */\r\n  function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\r\n    bytes memory returndata = _functionCall(underlying, data, errorMessage);\r\n    if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param mintAmount The amount of the underlying asset to supply\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n   */\r\n  function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\r\n    return mintFresh(msg.sender, mintAmount);\r\n  }\r\n\r\n  struct MintLocalVars {\r\n    Error err;\r\n    MathError mathErr;\r\n    uint256 exchangeRateMantissa;\r\n    uint256 mintTokens;\r\n    uint256 totalSupplyNew;\r\n    uint256 accountTokensNew;\r\n    uint256 actualMintAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice User supplies assets into the market and receives cTokens in exchange\r\n   * @dev Assumes interest has already been accrued up to the current block\r\n   * @param minter The address of the account which is supplying the assets\r\n   * @param mintAmount The amount of the underlying asset to supply\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\r\n   */\r\n  function mintFresh(address minter, uint256 mintAmount) internal returns (uint256, uint256) {\r\n    /* Fail if mint not allowed */\r\n    uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\r\n    if (allowed != 0) {\r\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n    }\r\n\r\n    /* Verify market's block number equals current block number */\r\n    if (accrualBlockNumber != block.number) {\r\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\r\n    }\r\n\r\n    MintLocalVars memory vars;\r\n\r\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\r\n\r\n    // Check max supply\r\n    // unused function\r\n    /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\r\n        if (allowed != 0) {\r\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\r\n        } */\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /*\r\n     *  We call `doTransferIn` for the minter and the mintAmount.\r\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\r\n     *  side-effects occurred. The function returns the amount actually transferred,\r\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\r\n     *  of cash.\r\n     */\r\n    vars.actualMintAmount = doTransferIn(minter, mintAmount);\r\n\r\n    /*\r\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\r\n     *  mintTokens = actualMintAmount / exchangeRate\r\n     */\r\n\r\n    // mintTokens is rounded down here - correct\r\n    (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\r\n      vars.actualMintAmount,\r\n      Exp({ mantissa: vars.exchangeRateMantissa })\r\n    );\r\n    require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\r\n    require(vars.mintTokens > 0, \"MINT_ZERO_CTOKENS_REJECTED\");\r\n\r\n    /*\r\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\r\n     *  totalSupplyNew = totalSupply + mintTokens\r\n     *  accountTokensNew = accountTokens[minter] + mintTokens\r\n     */\r\n    vars.totalSupplyNew = totalSupply + vars.mintTokens;\r\n\r\n    vars.accountTokensNew = accountTokens[minter] + vars.mintTokens;\r\n\r\n    /* We write previously calculated values into storage */\r\n    totalSupply = vars.totalSupplyNew;\r\n    accountTokens[minter] = vars.accountTokensNew;\r\n\r\n    /* We emit a Mint event, and a Transfer event */\r\n    emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\r\n    emit Transfer(address(this), minter, vars.mintTokens);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\r\n\r\n    return (uint256(Error.NO_ERROR), vars.actualMintAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender redeems cTokens in exchange for the underlying asset\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param redeemTokens The number of cTokens to redeem into underlying\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant(false) returns (uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n    return redeemFresh(msg.sender, redeemTokens, 0);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant(false) returns (uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\r\n    return redeemFresh(msg.sender, 0, redeemAmount);\r\n  }\r\n\r\n  struct RedeemLocalVars {\r\n    Error err;\r\n    MathError mathErr;\r\n    uint256 exchangeRateMantissa;\r\n    uint256 redeemTokens;\r\n    uint256 redeemAmount;\r\n    uint256 totalSupplyNew;\r\n    uint256 accountTokensNew;\r\n  }\r\n\r\n  function divRoundUp(uint256 x, uint256 y) internal pure returns (uint256 res) {\r\n    res = (x * 1e18) / y;\r\n    if (x % y != 0) res += 1;\r\n  }\r\n\r\n  /**\r\n   * @notice User redeems cTokens in exchange for the underlying asset\r\n   * @dev Assumes interest has already been accrued up to the current block\r\n   * @param redeemer The address of the account which is redeeming the tokens\r\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function redeemFresh(\r\n    address redeemer,\r\n    uint256 redeemTokensIn,\r\n    uint256 redeemAmountIn\r\n  ) internal returns (uint256) {\r\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"!redeem tokens or amount\");\r\n\r\n    RedeemLocalVars memory vars;\r\n\r\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\r\n\r\n    if (redeemTokensIn > 0) {\r\n      // don't allow dust tokens/assets to be left after\r\n      if (totalSupply - redeemTokensIn < 5000) redeemTokensIn = totalSupply;\r\n\r\n      /*\r\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\r\n       *  redeemTokens = redeemTokensIn\r\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\r\n       */\r\n      vars.redeemTokens = redeemTokensIn;\r\n\r\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\r\n        Exp({ mantissa: vars.exchangeRateMantissa }),\r\n        redeemTokensIn\r\n      );\r\n      if (vars.mathErr != MathError.NO_ERROR) {\r\n        return\r\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\r\n      }\r\n    } else {\r\n      if (redeemAmountIn == type(uint256).max) {\r\n        redeemAmountIn = comptroller.getMaxRedeemOrBorrow(redeemer, ICErc20(address(this)), false);\r\n      }\r\n\r\n      // don't allow dust tokens/assets to be left after\r\n      uint256 totalUnderlyingSupplied = asCTokenExtension().getTotalUnderlyingSupplied();\r\n      if (totalUnderlyingSupplied - redeemAmountIn < 1000) redeemAmountIn = totalUnderlyingSupplied;\r\n\r\n      /*\r\n       * We get the current exchange rate and calculate the amount to be redeemed:\r\n       *  redeemTokens = redeemAmountIn / exchangeRate\r\n       *  redeemAmount = redeemAmountIn\r\n       */\r\n\r\n      vars.redeemTokens = divRoundUp(redeemAmountIn, vars.exchangeRateMantissa);\r\n\r\n      // don't allow dust tokens/assets to be left after\r\n      if (totalSupply - vars.redeemTokens < 1000) vars.redeemTokens = totalSupply;\r\n\r\n      vars.redeemAmount = redeemAmountIn;\r\n    }\r\n\r\n    /* Fail if redeem not allowed */\r\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\r\n    }\r\n\r\n    /* Verify market's block number equals current block number */\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\r\n    }\r\n\r\n    /*\r\n     * We calculate the new total supply and redeemer balance, checking for underflow:\r\n     *  totalSupplyNew = totalSupply - redeemTokens\r\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\r\n     */\r\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return\r\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\r\n    }\r\n\r\n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return\r\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\r\n    }\r\n\r\n    /* Fail gracefully if protocol has insufficient cash */\r\n    if (getCashInternal() < vars.redeemAmount) {\r\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /* We write previously calculated values into storage */\r\n    totalSupply = vars.totalSupplyNew;\r\n    accountTokens[redeemer] = vars.accountTokensNew;\r\n\r\n    /*\r\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\r\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n     *  On success, the cToken has redeemAmount less of cash.\r\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n     */\r\n    doTransferOut(redeemer, vars.redeemAmount);\r\n\r\n    /* We emit a Transfer event, and a Redeem event */\r\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\r\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender borrows assets from the protocol to their own address\r\n   * @param borrowAmount The amount of the underlying asset to borrow\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant(false) returns (uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\r\n    return borrowFresh(msg.sender, borrowAmount);\r\n  }\r\n\r\n  struct BorrowLocalVars {\r\n    MathError mathErr;\r\n    uint256 accountBorrows;\r\n    uint256 accountBorrowsNew;\r\n    uint256 totalBorrowsNew;\r\n  }\r\n\r\n  /**\r\n   * @notice Users borrow assets from the protocol to their own address\r\n   * @param borrowAmount The amount of the underlying asset to borrow\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function borrowFresh(address borrower, uint256 borrowAmount) internal returns (uint256) {\r\n    /* Fail if borrow not allowed */\r\n    uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n    }\r\n\r\n    /* Verify market's block number equals current block number */\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\r\n    }\r\n\r\n    /* Fail gracefully if protocol has insufficient underlying cash */\r\n    uint256 cashPrior = getCashInternal();\r\n\r\n    if (cashPrior < borrowAmount) {\r\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\r\n    }\r\n\r\n    BorrowLocalVars memory vars;\r\n\r\n    /*\r\n     * We calculate the new borrower and total borrow balances, failing on overflow:\r\n     *  accountBorrowsNew = accountBorrows + borrowAmount\r\n     *  totalBorrowsNew = totalBorrows + borrowAmount\r\n     */\r\n    vars.accountBorrows = asCTokenExtension().borrowBalanceCurrent(borrower);\r\n\r\n    (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return\r\n        failOpaque(\r\n          Error.MATH_ERROR,\r\n          FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n          uint256(vars.mathErr)\r\n        );\r\n    }\r\n\r\n    // Check min borrow for this user for this asset\r\n    allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\r\n    }\r\n\r\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return\r\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /* We write the previously calculated values into storage */\r\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n    accountBorrows[borrower].interestIndex = borrowIndex;\r\n    totalBorrows = vars.totalBorrowsNew;\r\n\r\n    /*\r\n     * We invoke doTransferOut for the borrower and the borrowAmount.\r\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n     *  On success, the cToken borrowAmount less of cash.\r\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n     */\r\n    doTransferOut(borrower, borrowAmount);\r\n\r\n    /* We emit a Borrow event */\r\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.borrowVerify(address(this), borrower);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender repays their own borrow\r\n   * @param repayAmount The amount to repay\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n   */\r\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant(false) returns (uint256, uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Sender repays a borrow belonging to borrower\r\n   * @param borrower the account with the debt being payed off\r\n   * @param repayAmount The amount to repay\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n   */\r\n  function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\r\n    internal\r\n    nonReentrant(false)\r\n    returns (uint256, uint256)\r\n  {\r\n    asCTokenExtension().accrueInterest();\r\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\r\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\r\n  }\r\n\r\n  struct RepayBorrowLocalVars {\r\n    Error err;\r\n    MathError mathErr;\r\n    uint256 repayAmount;\r\n    uint256 borrowerIndex;\r\n    uint256 accountBorrows;\r\n    uint256 accountBorrowsNew;\r\n    uint256 totalBorrowsNew;\r\n    uint256 actualRepayAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Borrows are repaid by another user (possibly the borrower).\r\n   * @param payer the account paying off the borrow\r\n   * @param borrower the account with the debt being payed off\r\n   * @param repayAmount the amount of undelrying tokens being returned\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n   */\r\n  function repayBorrowFresh(\r\n    address payer,\r\n    address borrower,\r\n    uint256 repayAmount\r\n  ) internal returns (uint256, uint256) {\r\n    /* Fail if repayBorrow not allowed */\r\n    uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\r\n    if (allowed != 0) {\r\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\r\n    }\r\n\r\n    /* Verify market's block number equals current block number */\r\n    if (accrualBlockNumber != block.number) {\r\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\r\n    }\r\n\r\n    RepayBorrowLocalVars memory vars;\r\n\r\n    /* We remember the original borrowerIndex for verification purposes */\r\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n\r\n    /* We fetch the amount the borrower owes, with accumulated interest */\r\n    vars.accountBorrows = asCTokenExtension().borrowBalanceCurrent(borrower);\r\n\r\n    /* If repayAmount == -1, repayAmount = accountBorrows */\r\n    if (repayAmount == type(uint256).max) {\r\n      vars.repayAmount = vars.accountBorrows;\r\n    } else {\r\n      vars.repayAmount = repayAmount;\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /*\r\n     * We call doTransferIn for the payer and the repayAmount\r\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\r\n     *  On success, the cToken holds an additional repayAmount of cash.\r\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\r\n     *   it returns the amount actually transferred, in case of a fee.\r\n     */\r\n    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\r\n\r\n    /*\r\n     * We calculate the new borrower and total borrow balances, failing on underflow:\r\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\r\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\r\n     */\r\n    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\r\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\r\n\r\n    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\r\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\r\n\r\n    /* We write the previously calculated values into storage */\r\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\r\n    accountBorrows[borrower].interestIndex = borrowIndex;\r\n    totalBorrows = vars.totalBorrowsNew;\r\n\r\n    /* We emit a RepayBorrow event */\r\n    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount);\r\n\r\n    return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice The sender liquidates the borrowers collateral.\r\n   *  The collateral seized is transferred to the liquidator.\r\n   * @param borrower The borrower of this cToken to be liquidated\r\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n   * @param repayAmount The amount of the underlying borrowed asset to repay\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n   */\r\n  function liquidateBorrowInternal(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    address cTokenCollateral\r\n  ) internal nonReentrant(false) returns (uint256, uint256) {\r\n    asCTokenExtension().accrueInterest();\r\n    ICErc20(cTokenCollateral).accrueInterest();\r\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\r\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\r\n  }\r\n\r\n  /**\r\n   * @notice The liquidator liquidates the borrowers collateral.\r\n   *  The collateral seized is transferred to the liquidator.\r\n   * @param borrower The borrower of this cToken to be liquidated\r\n   * @param liquidator The address repaying the borrow and seizing collateral\r\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\r\n   * @param repayAmount The amount of the underlying borrowed asset to repay\r\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\r\n   */\r\n  function liquidateBorrowFresh(\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    address cTokenCollateral\r\n  ) internal returns (uint256, uint256) {\r\n    /* Fail if liquidate not allowed */\r\n    uint256 allowed = comptroller.liquidateBorrowAllowed(\r\n      address(this),\r\n      cTokenCollateral,\r\n      liquidator,\r\n      borrower,\r\n      repayAmount\r\n    );\r\n    if (allowed != 0) {\r\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\r\n    }\r\n\r\n    /* Verify market's block number equals current block number */\r\n    if (accrualBlockNumber != block.number) {\r\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\r\n    }\r\n\r\n    /* Verify cTokenCollateral market's block number equals current block number */\r\n    if (CErc20(cTokenCollateral).accrualBlockNumber() != block.number) {\r\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\r\n    }\r\n\r\n    /* Fail if borrower = liquidator */\r\n    if (borrower == liquidator) {\r\n      return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\r\n    }\r\n\r\n    /* Fail if repayAmount = 0 */\r\n    if (repayAmount == 0) {\r\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\r\n    }\r\n\r\n    /* Fail if repayAmount = -1 */\r\n    if (repayAmount == type(uint256).max) {\r\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\r\n    }\r\n\r\n    /* Fail if repayBorrow fails */\r\n    (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\r\n    if (repayBorrowError != uint256(Error.NO_ERROR)) {\r\n      return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /* We calculate the number of collateral tokens that will be seized */\r\n    (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\r\n      address(this),\r\n      cTokenCollateral,\r\n      actualRepayAmount\r\n    );\r\n    require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\r\n\r\n    /* Revert if borrower collateral token balance < seizeTokens */\r\n    require(ICErc20(cTokenCollateral).balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\r\n\r\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\r\n    uint256 seizeError;\r\n    if (cTokenCollateral == address(this)) {\r\n      seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\r\n    } else {\r\n      seizeError = CErc20(cTokenCollateral).seize(liquidator, borrower, seizeTokens);\r\n    }\r\n\r\n    /* Revert if seize tokens fails (since we cannot be sure of side effects) */\r\n    require(seizeError == uint256(Error.NO_ERROR), \"!seize\");\r\n\r\n    /* We emit a LiquidateBorrow event */\r\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, cTokenCollateral, seizeTokens);\r\n\r\n    /* We call the defense hook */\r\n    // unused function\r\n    // comptroller.liquidateBorrowVerify(address(this), cTokenCollateral, liquidator, borrower, actualRepayAmount, seizeTokens);\r\n\r\n    return (uint256(Error.NO_ERROR), actualRepayAmount);\r\n  }\r\n\r\n  struct SeizeInternalLocalVars {\r\n    MathError mathErr;\r\n    uint256 borrowerTokensNew;\r\n    uint256 liquidatorTokensNew;\r\n    uint256 liquidatorSeizeTokens;\r\n    uint256 protocolSeizeTokens;\r\n    uint256 protocolSeizeAmount;\r\n    uint256 exchangeRateMantissa;\r\n    uint256 totalReservesNew;\r\n    uint256 totalIonicFeeNew;\r\n    uint256 totalSupplyNew;\r\n    uint256 feeSeizeTokens;\r\n    uint256 feeSeizeAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers collateral tokens (this market) to the liquidator.\r\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\r\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\r\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\r\n   * @param liquidator The account receiving seized collateral\r\n   * @param borrower The account having collateral seized\r\n   * @param seizeTokens The number of cTokens to seize\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function seizeInternal(\r\n    address seizerToken,\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 seizeTokens\r\n  ) internal returns (uint256) {\r\n    /* Fail if seize not allowed */\r\n    uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\r\n    }\r\n\r\n    /* Fail if borrower = liquidator */\r\n    if (borrower == liquidator) {\r\n      return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\r\n    }\r\n\r\n    SeizeInternalLocalVars memory vars;\r\n\r\n    /*\r\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\r\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\r\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\r\n     */\r\n    (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(vars.mathErr));\r\n    }\r\n\r\n    vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\r\n    vars.feeSeizeTokens = mul_(seizeTokens, Exp({ mantissa: feeSeizeShareMantissa }));\r\n    vars.liquidatorSeizeTokens = seizeTokens - vars.protocolSeizeTokens - vars.feeSeizeTokens;\r\n\r\n    vars.exchangeRateMantissa = asCTokenExtension().exchangeRateCurrent();\r\n\r\n    vars.protocolSeizeAmount = mul_ScalarTruncate(\r\n      Exp({ mantissa: vars.exchangeRateMantissa }),\r\n      vars.protocolSeizeTokens\r\n    );\r\n    vars.feeSeizeAmount = mul_ScalarTruncate(Exp({ mantissa: vars.exchangeRateMantissa }), vars.feeSeizeTokens);\r\n\r\n    vars.totalReservesNew = totalReserves + vars.protocolSeizeAmount;\r\n    vars.totalSupplyNew = totalSupply - vars.protocolSeizeTokens - vars.feeSeizeTokens;\r\n    vars.totalIonicFeeNew = totalIonicFees + vars.feeSeizeAmount;\r\n\r\n    (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\r\n    if (vars.mathErr != MathError.NO_ERROR) {\r\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(vars.mathErr));\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    /* We write the previously calculated values into storage */\r\n    totalReserves = vars.totalReservesNew;\r\n    totalSupply = vars.totalSupplyNew;\r\n    totalIonicFees = vars.totalIonicFeeNew;\r\n\r\n    accountTokens[borrower] = vars.borrowerTokensNew;\r\n    accountTokens[liquidator] = vars.liquidatorTokensNew;\r\n\r\n    /* Emit a Transfer event */\r\n    emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\r\n    emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\r\n    emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  function asCTokenExtension() internal view returns (ICErc20) {\r\n    return ICErc20(address(this));\r\n  }\r\n\r\n  /*** Reentrancy Guard ***/\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   */\r\n  modifier nonReentrant(bool localOnly) {\r\n    _beforeNonReentrant(localOnly);\r\n    _;\r\n    _afterNonReentrant(localOnly);\r\n  }\r\n\r\n  /**\r\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\r\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\r\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\r\n   */\r\n  function _beforeNonReentrant(bool localOnly) private {\r\n    require(_notEntered, \"re-entered\");\r\n    if (!localOnly) comptroller._beforeNonReentrant();\r\n    _notEntered = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\r\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\r\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\r\n   */\r\n  function _afterNonReentrant(bool localOnly) private {\r\n    _notEntered = true; // get a gas-refund post-Istanbul\r\n    if (!localOnly) comptroller._afterNonReentrant();\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   * @param data The call data (encoded using abi.encode or one of its variants).\r\n   * @param errorMessage The revert string to return on failure.\r\n   */\r\n  function _functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.call(data);\r\n\r\n    if (!success) {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n\r\n    return returndata;\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CTokenFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { DiamondExtension } from \"../ionic/DiamondExtension.sol\";\r\nimport { IFlashLoanReceiver } from \"../ionic/IFlashLoanReceiver.sol\";\r\nimport { CErc20FirstExtensionBase, CTokenFirstExtensionInterface, ICErc20 } from \"./CTokenInterfaces.sol\";\r\nimport { SFSRegister } from \"./ComptrollerInterface.sol\";\r\nimport { TokenErrorReporter } from \"./ErrorReporter.sol\";\r\nimport { Exponential } from \"./Exponential.sol\";\r\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\r\nimport { IFeeDistributor } from \"./IFeeDistributor.sol\";\r\nimport { CTokenOracleProtected } from \"./CTokenOracleProtected.sol\";\r\n\r\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport { Multicall } from \"../utils/Multicall.sol\";\r\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\r\nimport { IHypernativeOracle } from \"../external/hypernative/interfaces/IHypernativeOracle.sol\";\r\n\r\ncontract CTokenFirstExtension is\r\n  CTokenOracleProtected,\r\n  CErc20FirstExtensionBase,\r\n  TokenErrorReporter,\r\n  Exponential,\r\n  DiamondExtension,\r\n  Multicall\r\n{\r\n  modifier isAuthorized() {\r\n    require(\r\n      IFeeDistributor(ionicAdmin).canCall(address(comptroller), msg.sender, address(this), msg.sig),\r\n      \"not authorized\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function _getExtensionFunctions() external pure virtual override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 25;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.transfer.selector;\r\n    functionSelectors[--fnsCount] = this.transferFrom.selector;\r\n    functionSelectors[--fnsCount] = this.allowance.selector;\r\n    functionSelectors[--fnsCount] = this.approve.selector;\r\n    functionSelectors[--fnsCount] = this.balanceOf.selector;\r\n    functionSelectors[--fnsCount] = this._setAdminFee.selector;\r\n    functionSelectors[--fnsCount] = this._setInterestRateModel.selector;\r\n    functionSelectors[--fnsCount] = this._setNameAndSymbol.selector;\r\n    functionSelectors[--fnsCount] = this._setAddressesProvider.selector;\r\n    functionSelectors[--fnsCount] = this._setReserveFactor.selector;\r\n    functionSelectors[--fnsCount] = this.supplyRatePerBlock.selector;\r\n    functionSelectors[--fnsCount] = this.borrowRatePerBlock.selector;\r\n    functionSelectors[--fnsCount] = this.exchangeRateCurrent.selector;\r\n    functionSelectors[--fnsCount] = this.accrueInterest.selector;\r\n    functionSelectors[--fnsCount] = this.totalBorrowsCurrent.selector;\r\n    functionSelectors[--fnsCount] = this.balanceOfUnderlying.selector;\r\n    functionSelectors[--fnsCount] = this.multicall.selector;\r\n    functionSelectors[--fnsCount] = this.supplyRatePerBlockAfterDeposit.selector;\r\n    functionSelectors[--fnsCount] = this.supplyRatePerBlockAfterWithdraw.selector;\r\n    functionSelectors[--fnsCount] = this.borrowRatePerBlockAfterBorrow.selector;\r\n    functionSelectors[--fnsCount] = this.getTotalUnderlyingSupplied.selector;\r\n    functionSelectors[--fnsCount] = this.flash.selector;\r\n    functionSelectors[--fnsCount] = this.getAccountSnapshot.selector;\r\n    functionSelectors[--fnsCount] = this.borrowBalanceCurrent.selector;\r\n    functionSelectors[--fnsCount] = this.registerInSFS.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  function getTotalUnderlyingSupplied() public view override returns (uint256) {\r\n    // (totalCash + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees))\r\n    return asCToken().getCash() + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees);\r\n  }\r\n\r\n  /* ERC20 fns */\r\n  /**\r\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n   * @dev Called by both `transfer` and `transferFrom` internally\r\n   * @param spender The address of the account performing the transfer\r\n   * @param src The address of the source account\r\n   * @param dst The address of the destination account\r\n   * @param tokens The number of tokens to transfer\r\n   * @return Whether or not the transfer succeeded\r\n   */\r\n  function transferTokens(address spender, address src, address dst, uint256 tokens) internal returns (uint256) {\r\n    /* Fail if transfer not allowed */\r\n    uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\r\n    if (allowed != 0) {\r\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\r\n    }\r\n\r\n    /* Do not allow self-transfers */\r\n    if (src == dst) {\r\n      return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n    }\r\n\r\n    /* Get the allowance, infinite for the account owner */\r\n    uint256 startingAllowance = 0;\r\n    if (spender == src) {\r\n      startingAllowance = type(uint256).max;\r\n    } else {\r\n      startingAllowance = transferAllowances[src][spender];\r\n    }\r\n\r\n    /* Do the calculations, checking for {under,over}flow */\r\n    MathError mathErr;\r\n    uint256 allowanceNew;\r\n    uint256 srcTokensNew;\r\n    uint256 dstTokensNew;\r\n\r\n    (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\r\n    if (mathErr != MathError.NO_ERROR) {\r\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\r\n    }\r\n\r\n    (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\r\n    if (mathErr != MathError.NO_ERROR) {\r\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\r\n    }\r\n\r\n    (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\r\n    if (mathErr != MathError.NO_ERROR) {\r\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\r\n    }\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n\r\n    accountTokens[src] = srcTokensNew;\r\n    accountTokens[dst] = dstTokensNew;\r\n\r\n    /* Eat some of the allowance (if necessary) */\r\n    if (startingAllowance != type(uint256).max) {\r\n      transferAllowances[src][spender] = allowanceNew;\r\n    }\r\n\r\n    /* We emit a Transfer event */\r\n    emit Transfer(src, dst, tokens);\r\n\r\n    /* We call the defense hook */\r\n    comptroller.transferVerify(address(this), src, dst, tokens);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n   * @param dst The address of the destination account\r\n   * @param amount The number of tokens to transfer\r\n   * @return Whether or not the transfer succeeded\r\n   */\r\n  function transfer(\r\n    address dst,\r\n    uint256 amount\r\n  ) public override nonReentrant(false) isAuthorized onlyOracleApprovedAllowEOA returns (bool) {\r\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` tokens from `src` to `dst`\r\n   * @param src The address of the source account\r\n   * @param dst The address of the destination account\r\n   * @param amount The number of tokens to transfer\r\n   * @return Whether or not the transfer succeeded\r\n   */\r\n  function transferFrom(\r\n    address src,\r\n    address dst,\r\n    uint256 amount\r\n  ) public override nonReentrant(false) isAuthorized onlyOracleApprovedAllowEOA returns (bool) {\r\n    return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Approve `spender` to transfer up to `amount` from `src`\r\n   * @dev This will overwrite the approval amount for `spender`\r\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n   * @param spender The address of the account which may transfer tokens\r\n   * @param amount The number of tokens that are approved (-1 means infinite)\r\n   * @return Whether or not the approval succeeded\r\n   */\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) public override isAuthorized onlyOracleApprovedAllowEOA returns (bool) {\r\n    address src = msg.sender;\r\n    transferAllowances[src][spender] = amount;\r\n    emit Approval(src, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current allowance from `owner` for `spender`\r\n   * @param owner The address of the account which owns the tokens to be spent\r\n   * @param spender The address of the account which may transfer tokens\r\n   * @return The number of tokens allowed to be spent (-1 means infinite)\r\n   */\r\n  function allowance(address owner, address spender) public view override returns (uint256) {\r\n    return transferAllowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token balance of the `owner`\r\n   * @param owner The address of the account to query\r\n   * @return The number of tokens owned by `owner`\r\n   */\r\n  function balanceOf(address owner) public view override returns (uint256) {\r\n    return accountTokens[owner];\r\n  }\r\n\r\n  /*** Admin Functions ***/\r\n\r\n  /**\r\n   * @notice updates the cToken ERC20 name and symbol\r\n   * @dev Admin function to update the cToken ERC20 name and symbol\r\n   * @param _name the new ERC20 token name to use\r\n   * @param _symbol the new ERC20 token symbol to use\r\n   */\r\n  function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\r\n    // Check caller is admin\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    // Set ERC20 name and symbol\r\n    name = _name;\r\n    symbol = _symbol;\r\n  }\r\n\r\n  function _setAddressesProvider(address _ap) external {\r\n    // Check caller is admin\r\n    require(hasAdminRights(), \"!admin\");\r\n\r\n    ap = AddressesProvider(_ap);\r\n  }\r\n\r\n  /**\r\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\r\n   * @dev Admin function to accrue interest and set a new reserve factor\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setReserveFactor(\r\n    uint256 newReserveFactorMantissa\r\n  ) public override nonReentrant(false) returns (uint256) {\r\n    accrueInterest();\r\n    // Check caller is admin\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\r\n    }\r\n\r\n    // Verify market's block number equals current block number\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\r\n    }\r\n\r\n    // Check newReserveFactor ≤ maxReserveFactor\r\n    if (newReserveFactorMantissa + adminFeeMantissa + ionicFeeMantissa > reserveFactorPlusFeesMaxMantissa) {\r\n      return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\r\n    }\r\n\r\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\r\n    reserveFactorMantissa = newReserveFactorMantissa;\r\n\r\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\r\n   * @dev Admin function to accrue interest and set a new admin fee\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setAdminFee(\r\n    uint256 newAdminFeeMantissa\r\n  ) public override nonReentrant(false) returns (uint256) {\r\n    accrueInterest();\r\n    // Verify market's block number equals current block number\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);\r\n    }\r\n\r\n    // Sanitize newAdminFeeMantissa\r\n    if (newAdminFeeMantissa == type(uint256).max) newAdminFeeMantissa = adminFeeMantissa;\r\n\r\n    // Get latest Ionic fee\r\n    uint256 newIonicFeeMantissa = IFeeDistributor(ionicAdmin).interestFeeRate();\r\n\r\n    // Check reserveFactorMantissa + newAdminFeeMantissa + newIonicFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa\r\n    if (reserveFactorMantissa + newAdminFeeMantissa + newIonicFeeMantissa > reserveFactorPlusFeesMaxMantissa) {\r\n      return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\r\n    }\r\n\r\n    // If setting admin fee\r\n    if (adminFeeMantissa != newAdminFeeMantissa) {\r\n      // Check caller is admin\r\n      if (!hasAdminRights()) {\r\n        return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);\r\n      }\r\n\r\n      // Set admin fee\r\n      uint256 oldAdminFeeMantissa = adminFeeMantissa;\r\n      adminFeeMantissa = newAdminFeeMantissa;\r\n\r\n      // Emit event\r\n      emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\r\n    }\r\n\r\n    // If setting Ionic fee\r\n    if (ionicFeeMantissa != newIonicFeeMantissa) {\r\n      // Set Ionic fee\r\n      uint256 oldIonicFeeMantissa = ionicFeeMantissa;\r\n      ionicFeeMantissa = newIonicFeeMantissa;\r\n\r\n      // Emit event\r\n      emit NewIonicFee(oldIonicFeeMantissa, newIonicFeeMantissa);\r\n    }\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\r\n   * @dev Admin function to accrue interest and update the interest rate model\r\n   * @param newInterestRateModel the new interest rate model to use\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setInterestRateModel(\r\n    InterestRateModel newInterestRateModel\r\n  ) public override nonReentrant(false) returns (uint256) {\r\n    accrueInterest();\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\r\n    }\r\n\r\n    if (accrualBlockNumber != block.number) {\r\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\r\n    }\r\n\r\n    require(newInterestRateModel.isInterestRateModel(), \"!notIrm\");\r\n\r\n    InterestRateModel oldInterestRateModel = interestRateModel;\r\n    interestRateModel = newInterestRateModel;\r\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the current per-block borrow interest rate for this cToken\r\n   * @return The borrow interest rate per block, scaled by 1e18\r\n   */\r\n  function borrowRatePerBlock() public view override returns (uint256) {\r\n    return\r\n      interestRateModel.getBorrowRate(\r\n        asCToken().getCash(),\r\n        totalBorrows,\r\n        totalReserves + totalAdminFees + totalIonicFees\r\n      );\r\n  }\r\n\r\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) public view returns (uint256) {\r\n    uint256 cash = asCToken().getCash();\r\n    require(cash >= borrowAmount, \"market cash not enough\");\r\n\r\n    return\r\n      interestRateModel.getBorrowRate(\r\n        cash - borrowAmount,\r\n        totalBorrows + borrowAmount,\r\n        totalReserves + totalAdminFees + totalIonicFees\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the current per-block supply interest rate for this cToken\r\n   * @return The supply interest rate per block, scaled by 1e18\r\n   */\r\n  function supplyRatePerBlock() public view override returns (uint256) {\r\n    return\r\n      interestRateModel.getSupplyRate(\r\n        asCToken().getCash(),\r\n        totalBorrows,\r\n        totalReserves + totalAdminFees + totalIonicFees,\r\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\r\n      );\r\n  }\r\n\r\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256) {\r\n    return\r\n      interestRateModel.getSupplyRate(\r\n        asCToken().getCash() + mintAmount,\r\n        totalBorrows,\r\n        totalReserves + totalAdminFees + totalIonicFees,\r\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\r\n      );\r\n  }\r\n\r\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256) {\r\n    uint256 cash = asCToken().getCash();\r\n    require(cash >= withdrawAmount, \"market cash not enough\");\r\n    return\r\n      interestRateModel.getSupplyRate(\r\n        cash - withdrawAmount,\r\n        totalBorrows,\r\n        totalReserves + totalAdminFees + totalIonicFees,\r\n        reserveFactorMantissa + ionicFeeMantissa + adminFeeMantissa\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @notice Accrue interest then return the up-to-date exchange rate\r\n   * @return Calculated exchange rate scaled by 1e18\r\n   */\r\n  function exchangeRateCurrent() public view override returns (uint256) {\r\n    if (block.number == accrualBlockNumber) {\r\n      return\r\n        _exchangeRateHypothetical(\r\n          totalSupply,\r\n          initialExchangeRateMantissa,\r\n          asCToken().getCash(),\r\n          totalBorrows,\r\n          totalReserves,\r\n          totalAdminFees,\r\n          totalIonicFees\r\n        );\r\n    } else {\r\n      uint256 cashPrior = asCToken().getCash();\r\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\r\n\r\n      return\r\n        _exchangeRateHypothetical(\r\n          accrual.totalSupply,\r\n          initialExchangeRateMantissa,\r\n          cashPrior,\r\n          accrual.totalBorrows,\r\n          accrual.totalReserves,\r\n          accrual.totalAdminFees,\r\n          accrual.totalIonicFees\r\n        );\r\n    }\r\n  }\r\n\r\n  function _exchangeRateHypothetical(\r\n    uint256 _totalSupply,\r\n    uint256 _initialExchangeRateMantissa,\r\n    uint256 _totalCash,\r\n    uint256 _totalBorrows,\r\n    uint256 _totalReserves,\r\n    uint256 _totalAdminFees,\r\n    uint256 _totalIonicFees\r\n  ) internal pure returns (uint256) {\r\n    if (_totalSupply == 0) {\r\n      /*\r\n       * If there are no tokens minted:\r\n       *  exchangeRate = initialExchangeRate\r\n       */\r\n      return _initialExchangeRateMantissa;\r\n    } else {\r\n      /*\r\n       * Otherwise:\r\n       *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalIonicFees + totalAdminFees)) / totalSupply\r\n       */\r\n      uint256 cashPlusBorrowsMinusReserves;\r\n      Exp memory exchangeRate;\r\n      MathError mathErr;\r\n\r\n      (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\r\n        _totalCash,\r\n        _totalBorrows,\r\n        _totalReserves + _totalAdminFees + _totalIonicFees\r\n      );\r\n      require(mathErr == MathError.NO_ERROR, \"!addThenSubUInt overflow check failed\");\r\n\r\n      (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\r\n      require(mathErr == MathError.NO_ERROR, \"!getExp overflow check failed\");\r\n\r\n      return exchangeRate.mantissa;\r\n    }\r\n  }\r\n\r\n  struct InterestAccrual {\r\n    uint256 accrualBlockNumber;\r\n    uint256 borrowIndex;\r\n    uint256 totalSupply;\r\n    uint256 totalBorrows;\r\n    uint256 totalReserves;\r\n    uint256 totalIonicFees;\r\n    uint256 totalAdminFees;\r\n    uint256 interestAccumulated;\r\n  }\r\n\r\n  function _accrueInterestHypothetical(\r\n    uint256 blockNumber,\r\n    uint256 cashPrior\r\n  ) internal view returns (InterestAccrual memory accrual) {\r\n    uint256 totalFees = totalAdminFees + totalIonicFees;\r\n    uint256 borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, totalBorrows, totalReserves + totalFees);\r\n    if (borrowRateMantissa > borrowRateMaxMantissa) {\r\n      if (cashPrior > totalFees) revert(\"!borrowRate\");\r\n      else borrowRateMantissa = borrowRateMaxMantissa;\r\n    }\r\n    (MathError mathErr, uint256 blockDelta) = subUInt(blockNumber, accrualBlockNumber);\r\n    require(mathErr == MathError.NO_ERROR, \"!blockDelta\");\r\n\r\n    /*\r\n     * Calculate the interest accumulated into borrows and reserves and the new index:\r\n     *  simpleInterestFactor = borrowRate * blockDelta\r\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n     *  totalIonicFeesNew = interestAccumulated * ionicFee + totalIonicFees\r\n     *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\r\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n     */\r\n\r\n    accrual.accrualBlockNumber = blockNumber;\r\n    accrual.totalSupply = totalSupply;\r\n    Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\r\n    accrual.interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\r\n    accrual.totalBorrows = accrual.interestAccumulated + totalBorrows;\r\n    accrual.totalReserves = mul_ScalarTruncateAddUInt(\r\n      Exp({ mantissa: reserveFactorMantissa }),\r\n      accrual.interestAccumulated,\r\n      totalReserves\r\n    );\r\n    accrual.totalIonicFees = mul_ScalarTruncateAddUInt(\r\n      Exp({ mantissa: ionicFeeMantissa }),\r\n      accrual.interestAccumulated,\r\n      totalIonicFees\r\n    );\r\n    accrual.totalAdminFees = mul_ScalarTruncateAddUInt(\r\n      Exp({ mantissa: adminFeeMantissa }),\r\n      accrual.interestAccumulated,\r\n      totalAdminFees\r\n    );\r\n    accrual.borrowIndex = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\r\n  }\r\n\r\n  /**\r\n   * @notice Applies accrued interest to total borrows and reserves\r\n   * @dev This calculates interest accrued from the last checkpointed block\r\n   *   up to the current block and writes new checkpoint to storage.\r\n   */\r\n  function accrueInterest() public override returns (uint256) {\r\n    /* Remember the initial block number */\r\n    uint256 currentBlockNumber = block.number;\r\n\r\n    /* Short-circuit accumulating 0 interest */\r\n    if (accrualBlockNumber == currentBlockNumber) {\r\n      return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    uint256 cashPrior = asCToken().getCash();\r\n    InterestAccrual memory accrual = _accrueInterestHypothetical(currentBlockNumber, cashPrior);\r\n\r\n    /////////////////////////\r\n    // EFFECTS & INTERACTIONS\r\n    // (No safe failures beyond this point)\r\n    accrualBlockNumber = currentBlockNumber;\r\n    borrowIndex = accrual.borrowIndex;\r\n    totalBorrows = accrual.totalBorrows;\r\n    totalReserves = accrual.totalReserves;\r\n    totalIonicFees = accrual.totalIonicFees;\r\n    totalAdminFees = accrual.totalAdminFees;\r\n    emit AccrueInterest(cashPrior, accrual.interestAccumulated, borrowIndex, totalBorrows);\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the current total borrows plus accrued interest\r\n   * @return The total borrows with interest\r\n   */\r\n  function totalBorrowsCurrent() external view override returns (uint256) {\r\n    if (accrualBlockNumber == block.number) {\r\n      return totalBorrows;\r\n    } else {\r\n      uint256 cashPrior = asCToken().getCash();\r\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\r\n      return accrual.totalBorrows;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\r\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\r\n   * @param account Address of the account to snapshot\r\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\r\n   */\r\n  function getAccountSnapshot(address account) external view override returns (uint256, uint256, uint256, uint256) {\r\n    uint256 cTokenBalance = accountTokens[account];\r\n    uint256 borrowBalance;\r\n    uint256 exchangeRateMantissa;\r\n\r\n    borrowBalance = borrowBalanceCurrent(account);\r\n\r\n    exchangeRateMantissa = exchangeRateCurrent();\r\n\r\n    return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\r\n  }\r\n\r\n  /**\r\n   * @notice calculate the borrowIndex and the account's borrow balance using the fresh borrowIndex\r\n   * @param account The address whose balance should be calculated after recalculating the borrowIndex\r\n   * @return The calculated balance\r\n   */\r\n  function borrowBalanceCurrent(address account) public view override returns (uint256) {\r\n    uint256 _borrowIndex;\r\n    if (accrualBlockNumber == block.number) {\r\n      _borrowIndex = borrowIndex;\r\n    } else {\r\n      uint256 cashPrior = asCToken().getCash();\r\n      InterestAccrual memory accrual = _accrueInterestHypothetical(block.number, cashPrior);\r\n      _borrowIndex = accrual.borrowIndex;\r\n    }\r\n\r\n    /* Note: we do not assert that the market is up to date */\r\n    MathError mathErr;\r\n    uint256 principalTimesIndex;\r\n    uint256 result;\r\n\r\n    /* Get borrowBalance and borrowIndex */\r\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\r\n\r\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\r\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\r\n     */\r\n    if (borrowSnapshot.principal == 0) {\r\n      return 0;\r\n    }\r\n\r\n    /* Calculate new borrow balance using the interest index:\r\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\r\n     */\r\n    (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, _borrowIndex);\r\n    require(mathErr == MathError.NO_ERROR, \"!mulUInt overflow check failed\");\r\n\r\n    (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\r\n    require(mathErr == MathError.NO_ERROR, \"!divUInt overflow check failed\");\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the underlying balance of the `owner`\r\n   * @param owner The address of the account to query\r\n   * @return The amount of underlying owned by `owner`\r\n   */\r\n  function balanceOfUnderlying(address owner) external view override returns (uint256) {\r\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\r\n    (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n    require(mErr == MathError.NO_ERROR, \"!balance\");\r\n    return balance;\r\n  }\r\n\r\n  function flash(uint256 amount, bytes calldata data) public override isAuthorized onlyOracleApprovedAllowEOA {\r\n    accrueInterest();\r\n\r\n    totalBorrows += amount;\r\n    asCToken().selfTransferOut(msg.sender, amount);\r\n\r\n    IFlashLoanReceiver(msg.sender).receiveFlashLoan(underlying, amount, data);\r\n\r\n    asCToken().selfTransferIn(msg.sender, amount);\r\n    totalBorrows -= amount;\r\n\r\n    emit Flash(msg.sender, amount);\r\n  }\r\n\r\n  /*** Reentrancy Guard ***/\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   */\r\n  modifier nonReentrant(bool localOnly) {\r\n    _beforeNonReentrant(localOnly);\r\n    _;\r\n    _afterNonReentrant(localOnly);\r\n  }\r\n\r\n  /**\r\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\r\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\r\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\r\n   */\r\n  function _beforeNonReentrant(bool localOnly) private {\r\n    require(_notEntered, \"re-entered\");\r\n    if (!localOnly) comptroller._beforeNonReentrant();\r\n    _notEntered = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\r\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\r\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\r\n   */\r\n  function _afterNonReentrant(bool localOnly) private {\r\n    _notEntered = true; // get a gas-refund post-Istanbul\r\n    if (!localOnly) comptroller._afterNonReentrant();\r\n  }\r\n\r\n  function asCToken() internal view returns (ICErc20) {\r\n    return ICErc20(address(this));\r\n  }\r\n\r\n  function multicall(\r\n    bytes[] calldata data\r\n  ) public payable override(CTokenFirstExtensionInterface, Multicall) returns (bytes[] memory results) {\r\n    return Multicall.multicall(data);\r\n  }\r\n\r\n  function registerInSFS() external returns (uint256) {\r\n    require(hasAdminRights() || msg.sender == address(comptroller), \"!admin\");\r\n    SFSRegister sfsContract = SFSRegister(0x8680CEaBcb9b56913c519c069Add6Bc3494B7020);\r\n    return sfsContract.register(0x8Fba84867Ba458E7c6E2c024D2DE3d0b5C3ea1C2);\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { IonicComptroller } from \"./ComptrollerInterface.sol\";\r\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\r\nimport { ComptrollerV3Storage } from \"./ComptrollerStorage.sol\";\r\nimport { AddressesProvider } from \"../ionic/AddressesProvider.sol\";\r\n\r\nabstract contract CTokenAdminStorage {\r\n  /*\r\n   * Administrator for Ionic\r\n   */\r\n  address payable public ionicAdmin;\r\n}\r\n\r\nabstract contract CErc20Storage is CTokenAdminStorage {\r\n  /**\r\n   * @dev Guard variable for re-entrancy checks\r\n   */\r\n  bool internal _notEntered;\r\n\r\n  /**\r\n   * @notice EIP-20 token name for this token\r\n   */\r\n  string public name;\r\n\r\n  /**\r\n   * @notice EIP-20 token symbol for this token\r\n   */\r\n  string public symbol;\r\n\r\n  /**\r\n   * @notice EIP-20 token decimals for this token\r\n   */\r\n  uint8 public decimals;\r\n\r\n  /*\r\n   * Maximum borrow rate that can ever be applied (.0005% / block)\r\n   */\r\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\r\n\r\n  /*\r\n   * Maximum fraction of interest that can be set aside for reserves + fees\r\n   */\r\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\r\n\r\n  /**\r\n   * @notice Contract which oversees inter-cToken operations\r\n   */\r\n  IonicComptroller public comptroller;\r\n\r\n  /**\r\n   * @notice Model which tells what the current interest rate should be\r\n   */\r\n  InterestRateModel public interestRateModel;\r\n\r\n  /*\r\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\r\n   */\r\n  uint256 internal initialExchangeRateMantissa;\r\n\r\n  /**\r\n   * @notice Fraction of interest currently set aside for admin fees\r\n   */\r\n  uint256 public adminFeeMantissa;\r\n\r\n  /**\r\n   * @notice Fraction of interest currently set aside for Ionic fees\r\n   */\r\n  uint256 public ionicFeeMantissa;\r\n\r\n  /**\r\n   * @notice Fraction of interest currently set aside for reserves\r\n   */\r\n  uint256 public reserveFactorMantissa;\r\n\r\n  /**\r\n   * @notice Block number that interest was last accrued at\r\n   */\r\n  uint256 public accrualBlockNumber;\r\n\r\n  /**\r\n   * @notice Accumulator of the total earned interest rate since the opening of the market\r\n   */\r\n  uint256 public borrowIndex;\r\n\r\n  /**\r\n   * @notice Total amount of outstanding borrows of the underlying in this market\r\n   */\r\n  uint256 public totalBorrows;\r\n\r\n  /**\r\n   * @notice Total amount of reserves of the underlying held in this market\r\n   */\r\n  uint256 public totalReserves;\r\n\r\n  /**\r\n   * @notice Total amount of admin fees of the underlying held in this market\r\n   */\r\n  uint256 public totalAdminFees;\r\n\r\n  /**\r\n   * @notice Total amount of Ionic fees of the underlying held in this market\r\n   */\r\n  uint256 public totalIonicFees;\r\n\r\n  /**\r\n   * @notice Total number of tokens in circulation\r\n   */\r\n  uint256 public totalSupply;\r\n\r\n  /*\r\n   * Official record of token balances for each account\r\n   */\r\n  mapping(address => uint256) internal accountTokens;\r\n\r\n  /*\r\n   * Approved token transfer amounts on behalf of others\r\n   */\r\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\r\n\r\n  /**\r\n   * @notice Container for borrow balance information\r\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\r\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\r\n   */\r\n  struct BorrowSnapshot {\r\n    uint256 principal;\r\n    uint256 interestIndex;\r\n  }\r\n\r\n  /*\r\n   * Mapping of account addresses to outstanding borrow balances\r\n   */\r\n  mapping(address => BorrowSnapshot) internal accountBorrows;\r\n\r\n  /*\r\n   * Share of seized collateral that is added to reserves\r\n   */\r\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\r\n\r\n  /*\r\n   * Share of seized collateral taken as fees\r\n   */\r\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\r\n\r\n  /**\r\n   * @notice Underlying asset for this CToken\r\n   */\r\n  address public underlying;\r\n\r\n  /**\r\n   * @notice Addresses Provider\r\n   */\r\n  AddressesProvider public ap;\r\n}\r\n\r\nabstract contract CTokenBaseEvents {\r\n  /* ERC20 */\r\n\r\n  /**\r\n   * @notice EIP20 Transfer event\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n  /*** Admin Events ***/\r\n\r\n  /**\r\n   * @notice Event emitted when interestRateModel is changed\r\n   */\r\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\r\n\r\n  /**\r\n   * @notice Event emitted when the reserve factor is changed\r\n   */\r\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\r\n\r\n  /**\r\n   * @notice Event emitted when the admin fee is changed\r\n   */\r\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\r\n\r\n  /**\r\n   * @notice Event emitted when the Ionic fee is changed\r\n   */\r\n  event NewIonicFee(uint256 oldIonicFeeMantissa, uint256 newIonicFeeMantissa);\r\n\r\n  /**\r\n   * @notice EIP20 Approval event\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n  /**\r\n   * @notice Event emitted when interest is accrued\r\n   */\r\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\r\n}\r\n\r\nabstract contract CTokenFirstExtensionEvents is CTokenBaseEvents {\r\n  event Flash(address receiver, uint256 amount);\r\n}\r\n\r\nabstract contract CTokenSecondExtensionEvents is CTokenBaseEvents {\r\n  /*** Market Events ***/\r\n\r\n  /**\r\n   * @notice Event emitted when tokens are minted\r\n   */\r\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\r\n\r\n  /**\r\n   * @notice Event emitted when tokens are redeemed\r\n   */\r\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\r\n\r\n  /**\r\n   * @notice Event emitted when underlying is borrowed\r\n   */\r\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\r\n\r\n  /**\r\n   * @notice Event emitted when a borrow is repaid\r\n   */\r\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\r\n\r\n  /**\r\n   * @notice Event emitted when a borrow is liquidated\r\n   */\r\n  event LiquidateBorrow(\r\n    address liquidator,\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    address cTokenCollateral,\r\n    uint256 seizeTokens\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when the reserves are added\r\n   */\r\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\r\n\r\n  /**\r\n   * @notice Event emitted when the reserves are reduced\r\n   */\r\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\r\n}\r\n\r\ninterface CTokenFirstExtensionInterface {\r\n  /*** User Interface ***/\r\n\r\n  function transfer(address dst, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address src, address dst, uint256 amount) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  /*** Admin Functions ***/\r\n\r\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\r\n\r\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\r\n\r\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) external returns (uint256);\r\n\r\n  function getAccountSnapshot(address account) external view returns (uint256, uint256, uint256, uint256);\r\n\r\n  function borrowRatePerBlock() external view returns (uint256);\r\n\r\n  function supplyRatePerBlock() external view returns (uint256);\r\n\r\n  function exchangeRateCurrent() external view returns (uint256);\r\n\r\n  function accrueInterest() external returns (uint256);\r\n\r\n  function totalBorrowsCurrent() external view returns (uint256);\r\n\r\n  function borrowBalanceCurrent(address account) external view returns (uint256);\r\n\r\n  function getTotalUnderlyingSupplied() external view returns (uint256);\r\n\r\n  function balanceOfUnderlying(address owner) external view returns (uint256);\r\n\r\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n\r\n  function flash(uint256 amount, bytes calldata data) external;\r\n\r\n  function supplyRatePerBlockAfterDeposit(uint256 mintAmount) external view returns (uint256);\r\n\r\n  function supplyRatePerBlockAfterWithdraw(uint256 withdrawAmount) external view returns (uint256);\r\n\r\n  function borrowRatePerBlockAfterBorrow(uint256 borrowAmount) external view returns (uint256);\r\n\r\n  function registerInSFS() external returns (uint256);\r\n}\r\n\r\ninterface CTokenSecondExtensionInterface {\r\n  function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n  function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n  function borrow(uint256 borrowAmount) external returns (uint256);\r\n\r\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\r\n\r\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\r\n\r\n  function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral) external returns (uint256);\r\n\r\n  function getCash() external view returns (uint256);\r\n\r\n  function seize(address liquidator, address borrower, uint256 seizeTokens) external returns (uint256);\r\n\r\n  /*** Admin Functions ***/\r\n\r\n  function _withdrawAdminFees(uint256 withdrawAmount) external returns (uint256);\r\n\r\n  function _withdrawIonicFees(uint256 withdrawAmount) external returns (uint256);\r\n\r\n  function selfTransferOut(address to, uint256 amount) external;\r\n\r\n  function selfTransferIn(address from, uint256 amount) external returns (uint256);\r\n}\r\n\r\ninterface CDelegatorInterface {\r\n  function implementation() external view returns (address);\r\n\r\n  /**\r\n   * @notice Called by the admin to update the implementation of the delegator\r\n   * @param implementation_ The address of the new implementation for delegation\r\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\r\n   */\r\n  function _setImplementationSafe(address implementation_, bytes calldata becomeImplementationData) external;\r\n\r\n  /**\r\n   * @dev upgrades the implementation if necessary\r\n   */\r\n  function _upgrade() external;\r\n}\r\n\r\ninterface CDelegateInterface {\r\n  /**\r\n   * @notice Called by the delegator on a delegate to initialize it for duty\r\n   * @dev Should revert if any issues arise which make it unfit for delegation\r\n   * @param data The encoded bytes data for any initialization\r\n   */\r\n  function _becomeImplementation(bytes calldata data) external;\r\n\r\n  function delegateType() external pure returns (uint8);\r\n\r\n  function contractType() external pure returns (string memory);\r\n}\r\n\r\nabstract contract CErc20AdminBase is CErc20Storage {\r\n  /**\r\n   * @notice Returns a boolean indicating if the sender has admin rights\r\n   */\r\n  function hasAdminRights() internal view returns (bool) {\r\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\r\n    return\r\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\r\n      (msg.sender == address(ionicAdmin) && comptrollerStorage.ionicAdminHasRights());\r\n  }\r\n}\r\n\r\nabstract contract CErc20FirstExtensionBase is\r\n  CErc20AdminBase,\r\n  CTokenFirstExtensionEvents,\r\n  CTokenFirstExtensionInterface\r\n{}\r\n\r\nabstract contract CTokenSecondExtensionBase is\r\n  CErc20AdminBase,\r\n  CTokenSecondExtensionEvents,\r\n  CTokenSecondExtensionInterface,\r\n  CDelegateInterface\r\n{}\r\n\r\nabstract contract CErc20DelegatorBase is CErc20AdminBase, CTokenSecondExtensionEvents, CDelegatorInterface {}\r\n\r\ninterface CErc20StorageInterface {\r\n  function admin() external view returns (address);\r\n\r\n  function adminHasRights() external view returns (bool);\r\n\r\n  function ionicAdmin() external view returns (address);\r\n\r\n  function ionicAdminHasRights() external view returns (bool);\r\n\r\n  function comptroller() external view returns (IonicComptroller);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function adminFeeMantissa() external view returns (uint256);\r\n\r\n  function ionicFeeMantissa() external view returns (uint256);\r\n\r\n  function reserveFactorMantissa() external view returns (uint256);\r\n\r\n  function protocolSeizeShareMantissa() external view returns (uint256);\r\n\r\n  function feeSeizeShareMantissa() external view returns (uint256);\r\n\r\n  function totalReserves() external view returns (uint256);\r\n\r\n  function totalAdminFees() external view returns (uint256);\r\n\r\n  function totalIonicFees() external view returns (uint256);\r\n\r\n  function totalBorrows() external view returns (uint256);\r\n\r\n  function accrualBlockNumber() external view returns (uint256);\r\n\r\n  function underlying() external view returns (address);\r\n\r\n  function borrowIndex() external view returns (uint256);\r\n\r\n  function interestRateModel() external view returns (address);\r\n}\r\n\r\ninterface CErc20PluginStorageInterface is CErc20StorageInterface {\r\n  function plugin() external view returns (address);\r\n}\r\n\r\ninterface CErc20PluginRewardsInterface is CErc20PluginStorageInterface {\r\n  function approve(address, address) external;\r\n}\r\n\r\ninterface ICErc20 is\r\n  CErc20StorageInterface,\r\n  CTokenSecondExtensionInterface,\r\n  CTokenFirstExtensionInterface,\r\n  CDelegatorInterface,\r\n  CDelegateInterface\r\n{}\r\n\r\ninterface ICErc20Plugin is CErc20PluginStorageInterface, ICErc20 {\r\n  function _updatePlugin(address _plugin) external;\r\n}\r\n\r\ninterface ICErc20PluginRewards is CErc20PluginRewardsInterface, ICErc20 {}\r\n"
    },
    "contracts/compound/CTokenMinter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CToken.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\r\n\r\ncontract CTokenMinter is Initializable, OwnableUpgradeable {\r\n  ICErc20 public collateralMarket;\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n\r\n  modifier onlyDuringMintWindow() {\r\n    require(block.timestamp >= startTime && block.timestamp <= endTime, \"Minting not allowed at this time\");\r\n    _;\r\n  }\r\n\r\n  function initialize(address _cTokenAddress, uint256 _startTime, uint256 _endTime) public initializer {\r\n    require(_startTime < _endTime, \"Invalid time window\");\r\n    __Ownable_init();\r\n    collateralMarket = ICErc20(_cTokenAddress);\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n  }\r\n\r\n  function mint(uint256 mintAmount) external onlyDuringMintWindow {\r\n    // MINT LOGIC\r\n  }\r\n\r\n  function setMintWindow(uint256 _newStartTime, uint256 _newEndTime) external onlyOwner {\r\n    require(_newStartTime < _newEndTime, \"Invalid time window\");\r\n    startTime = _newStartTime;\r\n    endTime = _newEndTime;\r\n  }\r\n}\r\n"
    },
    "contracts/compound/CTokenOracleProtected.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.22;\r\n\r\nimport { CErc20Storage } from \"./CTokenInterfaces.sol\";\r\nimport { IHypernativeOracle } from \"../external/hypernative/interfaces/IHypernativeOracle.sol\";\r\n\r\ncontract CTokenOracleProtected is CErc20Storage {\r\n  error InteractionNotAllowed();\r\n  error CallerIsNotEOA();\r\n\r\n  modifier onlyOracleApproved() {\r\n    address oracleAddress = ap.getAddress(\"HYPERNATIVE_ORACLE\");\r\n\r\n    if (oracleAddress == address(0)) {\r\n      _;\r\n      return;\r\n    }\r\n\r\n    IHypernativeOracle oracle = IHypernativeOracle(oracleAddress);\r\n    oracle.validateForbiddenContextInteraction(tx.origin, msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOracleApprovedAllowEOA() {\r\n    address oracleAddress = ap.getAddress(\"HYPERNATIVE_ORACLE\");\r\n\r\n    if (oracleAddress == address(0)) {\r\n      _;\r\n      return;\r\n    }\r\n\r\n    IHypernativeOracle oracle = IHypernativeOracle(oracleAddress);\r\n    oracle.validateBlacklistedAccountInteraction(msg.sender);\r\n    if (tx.origin == msg.sender) {\r\n      _;\r\n      return;\r\n    }\r\n\r\n    oracle.validateForbiddenContextInteraction(tx.origin, msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotBlacklistedEOA() {\r\n    address oracleAddress = ap.getAddress(\"HYPERNATIVE_ORACLE\");\r\n\r\n    if (oracleAddress == address(0)) {\r\n      _;\r\n      return;\r\n    }\r\n\r\n    IHypernativeOracle oracle = IHypernativeOracle(oracleAddress);\r\n    if (msg.sender != tx.origin) {\r\n      revert CallerIsNotEOA();\r\n    }\r\n    oracle.validateBlacklistedAccountInteraction(msg.sender);\r\n    _;\r\n  }\r\n}\r\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  /**\r\n   * @notice Get the total number of tokens in circulation\r\n   * @return uint256 The supply of tokens\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Gets the balance of the specified address\r\n   * @param owner The address from which the balance will be retrieved\r\n   * @return balance uint256 The balance\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n   * @param dst The address of the destination account\r\n   * @param amount The number of tokens to transfer\r\n   * @return success bool Whether or not the transfer succeeded\r\n   */\r\n  function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n  /**\r\n   * @notice Transfer `amount` tokens from `src` to `dst`\r\n   * @param src The address of the source account\r\n   * @param dst The address of the destination account\r\n   * @param amount The number of tokens to transfer\r\n   * @return success bool Whether or not the transfer succeeded\r\n   */\r\n  function transferFrom(\r\n    address src,\r\n    address dst,\r\n    uint256 amount\r\n  ) external returns (bool success);\r\n\r\n  /**\r\n   * @notice Approve `spender` to transfer up to `amount` from `src`\r\n   * @dev This will overwrite the approval amount for `spender`\r\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n   * @param spender The address of the account which may transfer tokens\r\n   * @param amount The number of tokens that are approved (-1 means infinite)\r\n   * @return success bool Whether or not the approval succeeded\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n  /**\r\n   * @notice Get the current allowance from `owner` for `spender`\r\n   * @param owner The address of the account which owns the tokens to be spent\r\n   * @param spender The address of the account which may transfer tokens\r\n   * @return remaining uint256 The number of tokens allowed to be spent (-1 means infinite)\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 amount);\r\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\ncontract ComptrollerErrorReporter {\r\n  enum Error {\r\n    NO_ERROR,\r\n    UNAUTHORIZED,\r\n    COMPTROLLER_MISMATCH,\r\n    INSUFFICIENT_SHORTFALL,\r\n    INSUFFICIENT_LIQUIDITY,\r\n    INVALID_CLOSE_FACTOR,\r\n    INVALID_COLLATERAL_FACTOR,\r\n    INVALID_LIQUIDATION_INCENTIVE,\r\n    MARKET_NOT_LISTED,\r\n    MARKET_ALREADY_LISTED,\r\n    MATH_ERROR,\r\n    NONZERO_BORROW_BALANCE,\r\n    PRICE_ERROR,\r\n    REJECTION,\r\n    SNAPSHOT_ERROR,\r\n    TOO_MANY_ASSETS,\r\n    TOO_MUCH_REPAY,\r\n    SUPPLIER_NOT_WHITELISTED,\r\n    BORROW_BELOW_MIN,\r\n    SUPPLY_ABOVE_MAX,\r\n    NONZERO_TOTAL_SUPPLY\r\n  }\r\n\r\n  enum FailureInfo {\r\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\r\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\r\n    EXIT_MARKET_BALANCE_OWED,\r\n    EXIT_MARKET_REJECTION,\r\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\r\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\r\n    SET_CLOSE_FACTOR_OWNER_CHECK,\r\n    SET_CLOSE_FACTOR_VALIDATION,\r\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\r\n    SET_COLLATERAL_FACTOR_VALIDATION,\r\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\r\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\r\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\r\n    SET_PENDING_ADMIN_OWNER_CHECK,\r\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\r\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\r\n    SET_PRICE_ORACLE_OWNER_CHECK,\r\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\r\n    SET_WHITELIST_STATUS_OWNER_CHECK,\r\n    SUPPORT_MARKET_EXISTS,\r\n    SUPPORT_MARKET_OWNER_CHECK,\r\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\r\n    UNSUPPORT_MARKET_OWNER_CHECK,\r\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\r\n    UNSUPPORT_MARKET_IN_USE\r\n  }\r\n\r\n  /**\r\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n   **/\r\n  event Failure(uint256 error, uint256 info, uint256 detail);\r\n\r\n  /**\r\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n   */\r\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\r\n    emit Failure(uint256(err), uint256(info), 0);\r\n\r\n    return uint256(err);\r\n  }\r\n\r\n  /**\r\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n   */\r\n  function failOpaque(\r\n    Error err,\r\n    FailureInfo info,\r\n    uint256 opaqueError\r\n  ) internal returns (uint256) {\r\n    emit Failure(uint256(err), uint256(info), opaqueError);\r\n\r\n    return uint256(err);\r\n  }\r\n}\r\n\r\ncontract TokenErrorReporter {\r\n  enum Error {\r\n    NO_ERROR,\r\n    UNAUTHORIZED,\r\n    BAD_INPUT,\r\n    COMPTROLLER_REJECTION,\r\n    COMPTROLLER_CALCULATION_ERROR,\r\n    INTEREST_RATE_MODEL_ERROR,\r\n    INVALID_ACCOUNT_PAIR,\r\n    INVALID_CLOSE_AMOUNT_REQUESTED,\r\n    INVALID_COLLATERAL_FACTOR,\r\n    MATH_ERROR,\r\n    MARKET_NOT_FRESH,\r\n    MARKET_NOT_LISTED,\r\n    TOKEN_INSUFFICIENT_ALLOWANCE,\r\n    TOKEN_INSUFFICIENT_BALANCE,\r\n    TOKEN_INSUFFICIENT_CASH,\r\n    TOKEN_TRANSFER_IN_FAILED,\r\n    TOKEN_TRANSFER_OUT_FAILED,\r\n    UTILIZATION_ABOVE_MAX\r\n  }\r\n\r\n  /*\r\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n   *       This is because FailureInfo grows significantly faster, and\r\n   *       the order of Error has some meaning, while the order of FailureInfo\r\n   *       is entirely arbitrary.\r\n   */\r\n  enum FailureInfo {\r\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_NEW_TOTAL_IONIC_FEES_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\r\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\r\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n    BORROW_ACCRUE_INTEREST_FAILED,\r\n    BORROW_CASH_NOT_AVAILABLE,\r\n    BORROW_FRESHNESS_CHECK,\r\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n    BORROW_MARKET_NOT_LISTED,\r\n    BORROW_COMPTROLLER_REJECTION,\r\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\r\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\r\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\r\n    LIQUIDATE_COMPTROLLER_REJECTION,\r\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\r\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\r\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\r\n    LIQUIDATE_FRESHNESS_CHECK,\r\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\r\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\r\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\r\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\r\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\r\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\r\n    LIQUIDATE_SEIZE_TOO_MUCH,\r\n    MINT_ACCRUE_INTEREST_FAILED,\r\n    MINT_COMPTROLLER_REJECTION,\r\n    MINT_EXCHANGE_CALCULATION_FAILED,\r\n    MINT_EXCHANGE_RATE_READ_FAILED,\r\n    MINT_FRESHNESS_CHECK,\r\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n    MINT_TRANSFER_IN_FAILED,\r\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\r\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\r\n    REDEEM_ACCRUE_INTEREST_FAILED,\r\n    REDEEM_COMPTROLLER_REJECTION,\r\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\r\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\r\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\r\n    REDEEM_FRESHNESS_CHECK,\r\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\r\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\r\n    WITHDRAW_IONIC_FEES_ACCRUE_INTEREST_FAILED,\r\n    WITHDRAW_IONIC_FEES_CASH_NOT_AVAILABLE,\r\n    WITHDRAW_IONIC_FEES_FRESH_CHECK,\r\n    WITHDRAW_IONIC_FEES_VALIDATION,\r\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\r\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\r\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\r\n    WITHDRAW_ADMIN_FEES_VALIDATION,\r\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\r\n    REDUCE_RESERVES_ADMIN_CHECK,\r\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\r\n    REDUCE_RESERVES_FRESH_CHECK,\r\n    REDUCE_RESERVES_VALIDATION,\r\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\r\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\r\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n    REPAY_BORROW_COMPTROLLER_REJECTION,\r\n    REPAY_BORROW_FRESHNESS_CHECK,\r\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\r\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\r\n    SET_COLLATERAL_FACTOR_VALIDATION,\r\n    SET_COMPTROLLER_OWNER_CHECK,\r\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\r\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\r\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\r\n    SET_PENDING_ADMIN_OWNER_CHECK,\r\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\r\n    SET_ADMIN_FEE_ADMIN_CHECK,\r\n    SET_ADMIN_FEE_FRESH_CHECK,\r\n    SET_ADMIN_FEE_BOUNDS_CHECK,\r\n    SET_IONIC_FEE_ACCRUE_INTEREST_FAILED,\r\n    SET_IONIC_FEE_FRESH_CHECK,\r\n    SET_IONIC_FEE_BOUNDS_CHECK,\r\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\r\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\r\n    SET_RESERVE_FACTOR_FRESH_CHECK,\r\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\r\n    TRANSFER_COMPTROLLER_REJECTION,\r\n    TRANSFER_NOT_ALLOWED,\r\n    TRANSFER_NOT_ENOUGH,\r\n    TRANSFER_TOO_MUCH,\r\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\r\n    ADD_RESERVES_FRESH_CHECK,\r\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\r\n  }\r\n\r\n  /**\r\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n   **/\r\n  event Failure(uint256 error, uint256 info, uint256 detail);\r\n\r\n  /**\r\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n   */\r\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\r\n    emit Failure(uint256(err), uint256(info), 0);\r\n\r\n    return uint256(err);\r\n  }\r\n\r\n  /**\r\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n   */\r\n  function failOpaque(\r\n    Error err,\r\n    FailureInfo info,\r\n    uint256 opaqueError\r\n  ) internal returns (uint256) {\r\n    emit Failure(uint256(err), uint256(info), opaqueError);\r\n\r\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\r\n  }\r\n}\r\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CarefulMath.sol\";\r\nimport \"./ExponentialNoError.sol\";\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract Exponential is CarefulMath, ExponentialNoError {\r\n  /**\r\n   * @dev Creates an exponential from numerator and denominator values.\r\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n   *            or if `denom` is zero.\r\n   */\r\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\r\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\r\n    if (err1 != MathError.NO_ERROR) {\r\n      return (err1, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two exponentials, returning a new exponential.\r\n   */\r\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\r\n\r\n    return (error, Exp({ mantissa: result }));\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two exponentials, returning a new exponential.\r\n   */\r\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\r\n\r\n    return (error, Exp({ mantissa: result }));\r\n  }\r\n\r\n  /**\r\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n   */\r\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\r\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\r\n  }\r\n\r\n  /**\r\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n   */\r\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\r\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\r\n    if (err != MathError.NO_ERROR) {\r\n      return (err, 0);\r\n    }\r\n\r\n    return (MathError.NO_ERROR, truncate(product));\r\n  }\r\n\r\n  /**\r\n   * @dev Divide an Exp by a scalar, returning a new Exp.\r\n   */\r\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\r\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\r\n  }\r\n\r\n  /**\r\n   * @dev Divide a scalar by an Exp, returning a new Exp.\r\n   */\r\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\r\n    /*\r\n          We are doing this as:\r\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\r\n\r\n          How it works:\r\n          Exp = a / b;\r\n          Scalar = s;\r\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, Exp({ mantissa: 0 }));\r\n    }\r\n    return getExp(numerator, divisor.mantissa);\r\n  }\r\n\r\n  /**\r\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\r\n   */\r\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\r\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\r\n    if (err != MathError.NO_ERROR) {\r\n      return (err, 0);\r\n    }\r\n\r\n    return (MathError.NO_ERROR, truncate(fraction));\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two exponentials, returning a new exponential.\r\n   */\r\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\r\n    if (err0 != MathError.NO_ERROR) {\r\n      return (err0, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    // We add half the scale before dividing so that we get rounding instead of truncation.\r\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\r\n    if (err1 != MathError.NO_ERROR) {\r\n      return (err1, Exp({ mantissa: 0 }));\r\n    }\r\n\r\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\r\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n    assert(err2 == MathError.NO_ERROR);\r\n\r\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\r\n   */\r\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\r\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies three exponentials, returning a new exponential.\r\n   */\r\n  function mulExp3(\r\n    Exp memory a,\r\n    Exp memory b,\r\n    Exp memory c\r\n  ) internal pure returns (MathError, Exp memory) {\r\n    (MathError err, Exp memory ab) = mulExp(a, b);\r\n    if (err != MathError.NO_ERROR) {\r\n      return (err, ab);\r\n    }\r\n    return mulExp(ab, c);\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two exponentials, returning a new exponential.\r\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n   */\r\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\r\n    return getExp(a.mantissa, b.mantissa);\r\n  }\r\n}\r\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author Compound\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n  uint256 constant expScale = 1e18;\r\n  uint256 constant doubleScale = 1e36;\r\n  uint256 constant halfExpScale = expScale / 2;\r\n  uint256 constant mantissaOne = expScale;\r\n\r\n  struct Exp {\r\n    uint256 mantissa;\r\n  }\r\n\r\n  struct Double {\r\n    uint256 mantissa;\r\n  }\r\n\r\n  /**\r\n   * @dev Truncates the given exp to a whole number value.\r\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n   */\r\n  function truncate(Exp memory exp) internal pure returns (uint256) {\r\n    // Note: We are not using careful math here as we're performing a division that cannot fail\r\n    return exp.mantissa / expScale;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n   */\r\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\r\n    Exp memory product = mul_(a, scalar);\r\n    return truncate(product);\r\n  }\r\n\r\n  /**\r\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n   */\r\n  function mul_ScalarTruncateAddUInt(\r\n    Exp memory a,\r\n    uint256 scalar,\r\n    uint256 addend\r\n  ) internal pure returns (uint256) {\r\n    Exp memory product = mul_(a, scalar);\r\n    return add_(truncate(product), addend);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if first Exp is less than second Exp.\r\n   */\r\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\r\n    return left.mantissa < right.mantissa;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if left Exp <= right Exp.\r\n   */\r\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\r\n    return left.mantissa <= right.mantissa;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if left Exp > right Exp.\r\n   */\r\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\r\n    return left.mantissa > right.mantissa;\r\n  }\r\n\r\n  /**\r\n   * @dev returns true if Exp is exactly zero\r\n   */\r\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\r\n    return value.mantissa == 0;\r\n  }\r\n\r\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\r\n    require(n < 2**224, errorMessage);\r\n    return uint224(n);\r\n  }\r\n\r\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\r\n    require(n < 2**32, errorMessage);\r\n    return uint32(n);\r\n  }\r\n\r\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\r\n  }\r\n\r\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\r\n  }\r\n\r\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return add_(a, b, \"addition overflow\");\r\n  }\r\n\r\n  function add_(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\r\n  }\r\n\r\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\r\n  }\r\n\r\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub_(a, b, \"subtraction underflow\");\r\n  }\r\n\r\n  function sub_(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    return a - b;\r\n  }\r\n\r\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\r\n  }\r\n\r\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: mul_(a.mantissa, b) });\r\n  }\r\n\r\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\r\n    return mul_(a, b.mantissa) / expScale;\r\n  }\r\n\r\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\r\n  }\r\n\r\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: mul_(a.mantissa, b) });\r\n  }\r\n\r\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\r\n    return mul_(a, b.mantissa) / doubleScale;\r\n  }\r\n\r\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mul_(a, b, \"multiplication overflow\");\r\n  }\r\n\r\n  function mul_(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, errorMessage);\r\n    return c;\r\n  }\r\n\r\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\r\n  }\r\n\r\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\r\n    return Exp({ mantissa: div_(a.mantissa, b) });\r\n  }\r\n\r\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\r\n    return div_(mul_(a, expScale), b.mantissa);\r\n  }\r\n\r\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\r\n  }\r\n\r\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: div_(a.mantissa, b) });\r\n  }\r\n\r\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\r\n    return div_(mul_(a, doubleScale), b.mantissa);\r\n  }\r\n\r\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div_(a, b, \"divide by zero\");\r\n  }\r\n\r\n  function div_(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    return a / b;\r\n  }\r\n\r\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\r\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\r\n  }\r\n}\r\n"
    },
    "contracts/compound/IERC4626.sol": {
      "content": "pragma solidity >=0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\r\n\r\ninterface IERC4626 is EIP20Interface {\r\n  /*----------------------------------------------------------------\r\n                                Events\r\n    ----------------------------------------------------------------*/\r\n\r\n  event Deposit(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Withdraw(address indexed from, address indexed to, uint256 value);\r\n\r\n  /*----------------------------------------------------------------\r\n                            Mutable Functions\r\n    ----------------------------------------------------------------*/\r\n\r\n  /**\r\n      @notice Deposit a specific amount of underlying tokens.\r\n      @param underlyingAmount The amount of the underlying token to deposit.\r\n      @param to The address to receive shares corresponding to the deposit\r\n      @return shares The shares in the vault credited to `to`\r\n    */\r\n  function deposit(uint256 underlyingAmount, address to) external returns (uint256 shares);\r\n\r\n  /**\r\n      @notice Mint an exact amount of shares for a variable amount of underlying tokens.\r\n      @param shareAmount The amount of vault shares to mint.\r\n      @param to The address to receive shares corresponding to the mint.\r\n      @return underlyingAmount The amount of the underlying tokens deposited from the mint call.\r\n    */\r\n  function mint(uint256 shareAmount, address to) external returns (uint256 underlyingAmount);\r\n\r\n  /**\r\n      @notice Withdraw a specific amount of underlying tokens.\r\n      @param underlyingAmount The amount of the underlying token to withdraw.\r\n      @param to The address to receive underlying corresponding to the withdrawal.\r\n      @param from The address to burn shares from corresponding to the withdrawal.\r\n      @return shares The shares in the vault burned from sender\r\n    */\r\n  function withdraw(\r\n    uint256 underlyingAmount,\r\n    address to,\r\n    address from\r\n  ) external returns (uint256 shares);\r\n\r\n  /**\r\n      @notice Redeem a specific amount of shares for underlying tokens.\r\n      @param shareAmount The amount of shares to redeem.\r\n      @param to The address to receive underlying corresponding to the redemption.\r\n      @param from The address to burn shares from corresponding to the redemption.\r\n      @return value The underlying amount transferred to `to`.\r\n    */\r\n  function redeem(\r\n    uint256 shareAmount,\r\n    address to,\r\n    address from\r\n  ) external returns (uint256 value);\r\n\r\n  /*----------------------------------------------------------------\r\n                            View Functions\r\n    ----------------------------------------------------------------*/\r\n  /** \r\n      @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n      @return the address of the asset\r\n    */\r\n  function asset() external view returns (address);\r\n\r\n  /** \r\n      @notice Returns a user's Vault balance in underlying tokens.\r\n      @param user The user to get the underlying balance of.\r\n      @return balance The user's Vault balance in underlying tokens.\r\n    */\r\n  function balanceOfUnderlying(address user) external view returns (uint256 balance);\r\n\r\n  /** \r\n      @notice Calculates the total amount of underlying tokens the Vault manages.\r\n      @return The total amount of underlying tokens the Vault manages.\r\n    */\r\n  function totalAssets() external view returns (uint256);\r\n\r\n  /** \r\n      @notice Returns the value in underlying terms of one vault token. \r\n     */\r\n  function exchangeRate() external view returns (uint256);\r\n\r\n  /**\r\n      @notice Returns the amount of vault tokens that would be obtained if depositing a given amount of underlying tokens in a `deposit` call.\r\n      @param underlyingAmount the input amount of underlying tokens\r\n      @return shareAmount the corresponding amount of shares out from a deposit call with `underlyingAmount` in\r\n     */\r\n  function previewDeposit(uint256 underlyingAmount) external view returns (uint256 shareAmount);\r\n\r\n  /**\r\n      @notice Returns the amount of underlying tokens that would be deposited if minting a given amount of shares in a `mint` call.\r\n      @param shareAmount the amount of shares from a mint call.\r\n      @return underlyingAmount the amount of underlying tokens corresponding to the mint call\r\n     */\r\n  function previewMint(uint256 shareAmount) external view returns (uint256 underlyingAmount);\r\n\r\n  /**\r\n      @notice Returns the amount of vault tokens that would be burned if withdrawing a given amount of underlying tokens in a `withdraw` call.\r\n      @param underlyingAmount the input amount of underlying tokens\r\n      @return shareAmount the corresponding amount of shares out from a withdraw call with `underlyingAmount` in\r\n     */\r\n  function previewWithdraw(uint256 underlyingAmount) external view returns (uint256 shareAmount);\r\n\r\n  /**\r\n      @notice Returns the amount of underlying tokens that would be obtained if redeeming a given amount of shares in a `redeem` call.\r\n      @param shareAmount the amount of shares from a redeem call.\r\n      @return underlyingAmount the amount of underlying tokens corresponding to the redeem call\r\n     */\r\n  function previewRedeem(uint256 shareAmount) external view returns (uint256 underlyingAmount);\r\n}\r\n"
    },
    "contracts/compound/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../ionic/AuthoritiesRegistry.sol\";\r\n\r\ninterface IFeeDistributor {\r\n  function minBorrowEth() external view returns (uint256);\r\n\r\n  function maxUtilizationRate() external view returns (uint256);\r\n\r\n  function interestFeeRate() external view returns (uint256);\r\n\r\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\r\n\r\n  function latestCErc20Delegate(uint8 delegateType)\r\n    external\r\n    view\r\n    returns (address cErc20Delegate, bytes memory becomeImplementationData);\r\n\r\n  function latestPluginImplementation(address oldImplementation) external view returns (address);\r\n\r\n  function getComptrollerExtensions(address comptroller) external view returns (address[] memory);\r\n\r\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (address[] memory);\r\n\r\n  function deployCErc20(\r\n    uint8 delegateType,\r\n    bytes calldata constructorData,\r\n    bytes calldata becomeImplData\r\n  ) external returns (address);\r\n\r\n  function canCall(\r\n    address pool,\r\n    address user,\r\n    address target,\r\n    bytes4 functionSig\r\n  ) external view returns (bool);\r\n\r\n  function authoritiesRegistry() external view returns (AuthoritiesRegistry);\r\n\r\n  fallback() external payable;\r\n\r\n  receive() external payable;\r\n}\r\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title Compound's InterestRateModel Interface\r\n * @author Compound\r\n */\r\nabstract contract InterestRateModel {\r\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\r\n  bool public constant isInterestRateModel = true;\r\n\r\n  /**\r\n   * @notice Calculates the current borrow interest rate per block\r\n   * @param cash The total amount of cash the market has\r\n   * @param borrows The total amount of borrows the market has outstanding\r\n   * @param reserves The total amount of reserves the market has\r\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\r\n   */\r\n  function getBorrowRate(\r\n    uint256 cash,\r\n    uint256 borrows,\r\n    uint256 reserves\r\n  ) public view virtual returns (uint256);\r\n\r\n  /**\r\n   * @notice Calculates the current supply interest rate per block\r\n   * @param cash The total amount of cash the market has\r\n   * @param borrows The total amount of borrows the market has outstanding\r\n   * @param reserves The total amount of reserves the market has\r\n   * @param reserveFactorMantissa The current reserve factor the market has\r\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\r\n   */\r\n  function getSupplyRate(\r\n    uint256 cash,\r\n    uint256 borrows,\r\n    uint256 reserves,\r\n    uint256 reserveFactorMantissa\r\n  ) public view virtual returns (uint256);\r\n}\r\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ICErc20 } from \"./CTokenInterfaces.sol\";\r\n\r\nabstract contract PriceOracle {\r\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n  bool public constant isPriceOracle = true;\r\n\r\n  /**\r\n   * @notice Get the underlying price of a cToken asset\r\n   * @param cToken The cToken to get the underlying price of\r\n   * @return The underlying asset price mantissa (scaled by 1e18).\r\n   *  Zero means the price is unavailable.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view virtual returns (uint256);\r\n}\r\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./ErrorReporter.sol\";\r\nimport \"./ComptrollerStorage.sol\";\r\nimport \"./Comptroller.sol\";\r\nimport { DiamondExtension, DiamondBase, LibDiamond } from \"../ionic/DiamondExtension.sol\";\r\n\r\n/**\r\n * @title Unitroller\r\n * @dev Storage for the comptroller is at this address, while execution is delegated via the Diamond Extensions\r\n * CTokens should reference this contract as their comptroller.\r\n */\r\ncontract Unitroller is ComptrollerV3Storage, ComptrollerErrorReporter, DiamondBase {\r\n  /**\r\n   * @notice Event emitted when the admin rights are changed\r\n   */\r\n  event AdminRightsToggled(bool hasRights);\r\n\r\n  /**\r\n   * @notice Emitted when pendingAdmin is changed\r\n   */\r\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\r\n\r\n  /**\r\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\r\n   */\r\n  event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n  constructor(address payable _ionicAdmin) {\r\n    admin = msg.sender;\r\n    ionicAdmin = _ionicAdmin;\r\n  }\r\n\r\n  /*** Admin Functions ***/\r\n\r\n  /**\r\n   * @notice Toggles admin rights.\r\n   * @param hasRights Boolean indicating if the admin is to have rights.\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\r\n    }\r\n\r\n    // Check that rights have not already been set to the desired value\r\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\r\n\r\n    adminHasRights = hasRights;\r\n    emit AdminRightsToggled(hasRights);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\r\n   * @param newPendingAdmin New pending admin.\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\r\n    if (!hasAdminRights()) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\r\n    }\r\n\r\n    address oldPendingAdmin = pendingAdmin;\r\n    pendingAdmin = newPendingAdmin;\r\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  /**\r\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\r\n   * @dev Admin function for pending admin to accept role and update admin\r\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n   */\r\n  function _acceptAdmin() public returns (uint256) {\r\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\r\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\r\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\r\n    }\r\n\r\n    // Save current values for inclusion in log\r\n    address oldAdmin = admin;\r\n    address oldPendingAdmin = pendingAdmin;\r\n\r\n    admin = pendingAdmin;\r\n    pendingAdmin = address(0);\r\n\r\n    emit NewAdmin(oldAdmin, admin);\r\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\r\n\r\n    return uint256(Error.NO_ERROR);\r\n  }\r\n\r\n  function comptrollerImplementation() public view returns (address) {\r\n    return LibDiamond.getExtensionForFunction(bytes4(keccak256(bytes(\"_deployMarket(uint8,bytes,bytes,uint256)\"))));\r\n  }\r\n\r\n  /**\r\n   * @dev upgrades the implementation if necessary\r\n   */\r\n  function _upgrade() external {\r\n    require(msg.sender == address(this) || hasAdminRights(), \"!self || !admin\");\r\n\r\n    address currentImplementation = comptrollerImplementation();\r\n    address latestComptrollerImplementation = IFeeDistributor(ionicAdmin).latestComptrollerImplementation(\r\n      currentImplementation\r\n    );\r\n\r\n    _updateExtensions(latestComptrollerImplementation);\r\n\r\n    if (currentImplementation != latestComptrollerImplementation) {\r\n      // reinitialize\r\n      _functionCall(address(this), abi.encodeWithSignature(\"_becomeImplementation()\"), \"!become impl\");\r\n    }\r\n  }\r\n\r\n  function _functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.call(data);\r\n\r\n    if (!success) {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n\r\n    return returndata;\r\n  }\r\n\r\n  function _updateExtensions(address currentComptroller) internal {\r\n    address[] memory latestExtensions = IFeeDistributor(ionicAdmin).getComptrollerExtensions(currentComptroller);\r\n    address[] memory currentExtensions = LibDiamond.listExtensions();\r\n\r\n    // removed the current (old) extensions\r\n    for (uint256 i = 0; i < currentExtensions.length; i++) {\r\n      LibDiamond.removeExtension(DiamondExtension(currentExtensions[i]));\r\n    }\r\n    // add the new extensions\r\n    for (uint256 i = 0; i < latestExtensions.length; i++) {\r\n      LibDiamond.addExtension(DiamondExtension(latestExtensions[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev register a logic extension\r\n   * @param extensionToAdd the extension whose functions are to be added\r\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\r\n   */\r\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external override {\r\n    require(hasAdminRights(), \"!unauthorized\");\r\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\r\n  }\r\n}\r\n"
    },
    "contracts/EmissionsManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\r\n\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { IonicFlywheelCore } from \"./ionic/strategies/flywheel/IonicFlywheelCore.sol\";\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\nimport { PoolDirectory } from \"./PoolDirectory.sol\";\r\nimport { IEmissionsManager } from \"./IEmissionsManager.sol\";\r\nimport { IveION } from \"./veION/interfaces/IveION.sol\";\r\n\r\ninterface Oracle {\r\n  function getUnderlyingPrice(address) external returns (uint256);\r\n}\r\n\r\ncontract EmissionsManager is IEmissionsManager, Ownable2StepUpgradeable {\r\n  using SafeTransferLib for ERC20;\r\n\r\n  address public protocolAddress;\r\n  uint256 public collateralBp;\r\n  PoolDirectory public fpd;\r\n  ERC20 public rewardToken;\r\n  address public veION;\r\n\r\n  bytes public nonBlacklistableTargetBytecode;\r\n  mapping(address => bool) public isBlacklisted;\r\n  mapping(address => bool) public nonBlacklistable;\r\n\r\n  uint256 public constant MAXIMUM_BASIS_POINTS = 10_000;\r\n  uint256 public constant BLACKLISTER_SHARE = 80;\r\n  uint256 public constant PROTOCOL_SHARE = 20;\r\n\r\n  modifier onlyBlacklistableBytecode(address _addr) {\r\n    bytes memory code = _addr.code;\r\n    require(keccak256(code) != keccak256(nonBlacklistableTargetBytecode), \"Non-blacklistable bytecode\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  function initialize(\r\n    PoolDirectory _fpd,\r\n    address _protocolAddress,\r\n    ERC20 _rewardToken,\r\n    uint256 _collateralBp,\r\n    bytes memory _nonBlacklistableTargetBytecode\r\n  ) public initializer {\r\n    if (address(_fpd) == address(0)) revert InvalidPoolDirectoryAaddress();\r\n    if (_protocolAddress == address(0)) revert InvalidProtocolAddress();\r\n    if (address(_rewardToken) == address(0)) revert InvalidRewardTokenAddress();\r\n    if (_collateralBp >= MAXIMUM_BASIS_POINTS) revert CollateralBasisPointsExceedMaximum();\r\n\r\n    __Ownable2Step_init();\r\n    protocolAddress = _protocolAddress;\r\n    fpd = _fpd;\r\n    rewardToken = _rewardToken;\r\n    collateralBp = _collateralBp;\r\n    nonBlacklistableTargetBytecode = _nonBlacklistableTargetBytecode;\r\n\r\n    emit Initialized(_protocolAddress, address(_rewardToken), _collateralBp, _nonBlacklistableTargetBytecode);\r\n  }\r\n\r\n  function setVeIon(IveION _veIon) external onlyOwner {\r\n    if (address(_veIon) == address(0)) revert InvalidVeIONAddress();\r\n    veION = address(_veIon);\r\n    emit VeIonSet(address(_veIon));\r\n  }\r\n\r\n  function setCollateralBp(uint256 _collateralBp) external onlyOwner {\r\n    if (_collateralBp >= MAXIMUM_BASIS_POINTS) revert MaximumLimitExceeded();\r\n    collateralBp = _collateralBp;\r\n    emit CollateralBpSet(_collateralBp);\r\n  }\r\n\r\n  function setNonBlacklistableAddress(address _user, bool _isNonBlacklistable) external onlyOwner {\r\n    nonBlacklistable[_user] = _isNonBlacklistable;\r\n    emit NonBlacklistableAddressSet(_user, _isNonBlacklistable);\r\n  }\r\n\r\n  function setNonBlacklistableTargetBytecode(bytes memory _newBytecode) external onlyOwner {\r\n    nonBlacklistableTargetBytecode = _newBytecode;\r\n    emit NonBlacklistableTargetBytecodeSet(_newBytecode);\r\n  }\r\n\r\n  function setProtocolAddress(address _newProtocolAddress) external onlyOwner {\r\n    require(_newProtocolAddress != address(0), \"Invalid address\");\r\n    protocolAddress = _newProtocolAddress;\r\n  }\r\n\r\n  function _getUserTotalCollateral(address _user) internal view returns (uint256) {\r\n    uint256 totalColateralInETH = 0;\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n    uint256 poolsLength = pools.length;\r\n    for (uint256 i = 0; i < poolsLength; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n      BasePriceOracle oracle = comptroller.oracle();\r\n      ICErc20[] memory cTokens = comptroller.getAllMarkets();\r\n      uint256 cTokensLength = cTokens.length;\r\n      for (uint256 j = 0; j < cTokensLength; j++) {\r\n        uint256 supplyBalance = cTokens[j].balanceOfUnderlying(_user);\r\n        if (supplyBalance > 0) {\r\n          uint256 collateralInETH = (supplyBalance * oracle.getUnderlyingPrice(cTokens[j])) / 1e18;\r\n          totalColateralInETH += collateralInETH;\r\n        }\r\n      }\r\n    }\r\n    return totalColateralInETH;\r\n  }\r\n\r\n  function getUserTotalCollateral(address _user) external view returns (uint256) {\r\n    return _getUserTotalCollateral(_user);\r\n  }\r\n\r\n  function _checkCollateralRatio(address _user) internal view returns (bool) {\r\n    uint256 userCollateralValue = _getUserTotalCollateral(_user);\r\n    if (userCollateralValue == 0) return true;\r\n    uint256 userLPValue = IveION(veION).getTotalEthValueOfTokens(_user);\r\n    if ((userLPValue * MAXIMUM_BASIS_POINTS) / userCollateralValue >= collateralBp) {\r\n      return true;\r\n    } else return false;\r\n  }\r\n\r\n  function reportUser(address _user) external onlyBlacklistableBytecode(_user) {\r\n    require(!nonBlacklistable[_user], \"Non-blacklistable user\");\r\n    require(!isBlacklisted[_user], \"Already blacklisted\");\r\n    require(!_checkCollateralRatio(_user), \"LP balance above threshold\");\r\n    isBlacklisted[_user] = true;\r\n    _blacklistUserAndClaimEmissions(_user);\r\n  }\r\n\r\n  function whitelistUser(address _user) external {\r\n    require(isBlacklisted[_user], \"Already whitelisted\");\r\n    require(_checkCollateralRatio(_user), \"LP balance below threshold\");\r\n    isBlacklisted[_user] = false;\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n    uint256 poolsLength = pools.length;\r\n    for (uint256 i = 0; i < poolsLength; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n      ICErc20[] memory cTokens = comptroller.getAllMarkets();\r\n      uint256 cTokensLength = cTokens.length;\r\n      for (uint256 j = 0; j < cTokensLength; j++) {\r\n        address[] memory flywheelAddresses = comptroller.getAccruingFlywheels();\r\n        uint256 flywheelAddressesLength = flywheelAddresses.length;\r\n        for (uint256 k = 0; k < flywheelAddressesLength; k++) {\r\n          IonicFlywheelCore flywheel = IonicFlywheelCore(flywheelAddresses[k]);\r\n          if (address(flywheel.rewardToken()) == address(rewardToken)) {\r\n            flywheel.whitelistUser(ERC20(address(cTokens[j])), _user);\r\n            flywheel.accrue(ERC20(address(cTokens[j])), _user);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function isUserBlacklisted(address _user) external view returns (bool) {\r\n    return isBlacklisted[_user];\r\n  }\r\n\r\n  function isUserBlacklistable(address _user) external view returns (bool) {\r\n    if (nonBlacklistable[_user] || keccak256(_user.code) == keccak256(nonBlacklistableTargetBytecode)) {\r\n      return false;\r\n    }\r\n    return !_checkCollateralRatio(_user) && !isBlacklisted[_user];\r\n  }\r\n\r\n  function _blacklistUserAndClaimEmissions(address user) internal {\r\n    uint256 balanceBefore = ERC20(rewardToken).balanceOf(address(this));\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n    uint256 poolsLength = pools.length;\r\n    for (uint256 i = 0; i < poolsLength; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n      ERC20[] memory markets;\r\n      {\r\n        ICErc20[] memory cerc20s = comptroller.getAllMarkets();\r\n        uint256 cerc20sLength = cerc20s.length;\r\n        markets = new ERC20[](cerc20sLength);\r\n        for (uint256 j = 0; j < cerc20sLength; j++) {\r\n          markets[j] = ERC20(address(cerc20s[j]));\r\n        }\r\n      }\r\n\r\n      address[] memory flywheelAddresses = comptroller.getAccruingFlywheels();\r\n      uint256 flywheelAddressesLength = flywheelAddresses.length;\r\n      for (uint256 k = 0; k < flywheelAddressesLength; k++) {\r\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheelAddresses[k]);\r\n        if (address(flywheel.rewardToken()) == address(rewardToken)) {\r\n          uint256 marketsLength = markets.length;\r\n          for (uint256 m = 0; m < marketsLength; m++) {\r\n            flywheel.accrue(markets[m], user);\r\n            flywheel.updateBlacklistBalances(markets[m], user);\r\n          }\r\n          flywheel.takeRewardsFromUser(user, address(this));\r\n        }\r\n      }\r\n    }\r\n\r\n    uint256 balanceAfter = ERC20(rewardToken).balanceOf(address(this));\r\n    uint256 totalClaimed = balanceAfter - balanceBefore;\r\n    if (totalClaimed > 0) {\r\n      rewardToken.safeTransfer(msg.sender, (totalClaimed * BLACKLISTER_SHARE) / 100);\r\n      rewardToken.safeTransfer(protocolAddress, (totalClaimed * PROTOCOL_SHARE) / 100);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/aerodrome/IAerodromeRouter.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20_Router {\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `to`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `from` to `to` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH is IERC20_Router {\r\n  function deposit() external payable;\r\n\r\n  function withdraw(uint256) external;\r\n}\r\n\r\ninterface IRouter_Aerodrome {\r\n  struct Route {\r\n    address from;\r\n    address to;\r\n    bool stable;\r\n    address factory;\r\n  }\r\n\r\n  error ETHTransferFailed();\r\n  error Expired();\r\n  error InsufficientAmount();\r\n  error InsufficientAmountA();\r\n  error InsufficientAmountB();\r\n  error InsufficientAmountADesired();\r\n  error InsufficientAmountBDesired();\r\n  error InsufficientAmountAOptimal();\r\n  error InsufficientLiquidity();\r\n  error InsufficientOutputAmount();\r\n  error InvalidAmountInForETHDeposit();\r\n  error InvalidTokenInForETHDeposit();\r\n  error InvalidPath();\r\n  error InvalidRouteA();\r\n  error InvalidRouteB();\r\n  error OnlyWETH();\r\n  error PoolDoesNotExist();\r\n  error PoolFactoryDoesNotExist();\r\n  error SameAddresses();\r\n  error ZeroAddress();\r\n\r\n  /// @notice Address of FactoryRegistry.sol\r\n  function factoryRegistry() external view returns (address);\r\n\r\n  /// @notice Address of Protocol PoolFactory.sol\r\n  function defaultFactory() external view returns (address);\r\n\r\n  /// @notice Address of Voter.sol\r\n  function voter() external view returns (address);\r\n\r\n  /// @notice Interface of WETH contract used for WETH => ETH wrapping/unwrapping\r\n  function weth() external view returns (IWETH);\r\n\r\n  /// @dev Represents Ether. Used by zapper to determine whether to return assets as ETH/WETH.\r\n  function ETHER() external view returns (address);\r\n\r\n  /// @dev Struct containing information necessary to zap in and out of pools\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           Stable or volatile pool\r\n  /// @param factory          factory of pool\r\n  /// @param amountOutMinA    Minimum amount expected from swap leg of zap via routesA\r\n  /// @param amountOutMinB    Minimum amount expected from swap leg of zap via routesB\r\n  /// @param amountAMin       Minimum amount of tokenA expected from liquidity leg of zap\r\n  /// @param amountBMin       Minimum amount of tokenB expected from liquidity leg of zap\r\n  struct Zap {\r\n    address tokenA;\r\n    address tokenB;\r\n    bool stable;\r\n    address factory;\r\n    uint256 amountOutMinA;\r\n    uint256 amountOutMinB;\r\n    uint256 amountAMin;\r\n    uint256 amountBMin;\r\n  }\r\n\r\n  /// @notice Sort two tokens by which address value is less than the other\r\n  /// @param tokenA   Address of token to sort\r\n  /// @param tokenB   Address of token to sort\r\n  /// @return token0  Lower address value between tokenA and tokenB\r\n  /// @return token1  Higher address value between tokenA and tokenB\r\n  function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n  /// @notice Calculate the address of a pool by its' factory.\r\n  ///         Used by all Router functions containing a `Route[]` or `_factory` argument.\r\n  ///         Reverts if _factory is not approved by the FactoryRegistry\r\n  /// @dev Returns a randomly generated address for a nonexistent pool\r\n  /// @param tokenA   Address of token to query\r\n  /// @param tokenB   Address of token to query\r\n  /// @param stable   True if pool is stable, false if volatile\r\n  /// @param _factory Address of factory which created the pool\r\n  function poolFor(address tokenA, address tokenB, bool stable, address _factory) external view returns (address pool);\r\n\r\n  /// @notice Fetch and sort the reserves for a pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @param _factory     Address of PoolFactory for tokenA and tokenB\r\n  /// @return reserveA    Amount of reserves of the sorted token A\r\n  /// @return reserveB    Amount of reserves of the sorted token B\r\n  function getReserves(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    address _factory\r\n  ) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n  /// @notice Perform chained getAmountOut calculations on any number of pools\r\n  function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);\r\n\r\n  // **** ADD LIQUIDITY ****\r\n\r\n  /// @notice Quote the amount deposited into a Pool\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param _factory         Address of PoolFactory for tokenA and tokenB\r\n  /// @param amountADesired   Amount of tokenA desired to deposit\r\n  /// @param amountBDesired   Amount of tokenB desired to deposit\r\n  /// @return amountA         Amount of tokenA to actually deposit\r\n  /// @return amountB         Amount of tokenB to actually deposit\r\n  /// @return liquidity       Amount of liquidity token returned from deposit\r\n  function quoteAddLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    address _factory,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired\r\n  ) external view returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n  /// @notice Quote the amount of liquidity removed from a Pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @param _factory     Address of PoolFactory for tokenA and tokenB\r\n  /// @param liquidity    Amount of liquidity to remove\r\n  /// @return amountA     Amount of tokenA received\r\n  /// @return amountB     Amount of tokenB received\r\n  function quoteRemoveLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    address _factory,\r\n    uint256 liquidity\r\n  ) external view returns (uint256 amountA, uint256 amountB);\r\n\r\n  /// @notice Add liquidity of two tokens to a Pool\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param amountADesired   Amount of tokenA desired to deposit\r\n  /// @param amountBDesired   Amount of tokenB desired to deposit\r\n  /// @param amountAMin       Minimum amount of tokenA to deposit\r\n  /// @param amountBMin       Minimum amount of tokenB to deposit\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountA         Amount of tokenA to actually deposit\r\n  /// @return amountB         Amount of tokenB to actually deposit\r\n  /// @return liquidity       Amount of liquidity token returned from deposit\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n  /// @notice Add liquidity of a token and WETH (transferred as ETH) to a Pool\r\n  /// @param token                .\r\n  /// @param stable               True if pool is stable, false if volatile\r\n  /// @param amountTokenDesired   Amount of token desired to deposit\r\n  /// @param amountTokenMin       Minimum amount of token to deposit\r\n  /// @param amountETHMin         Minimum amount of ETH to deposit\r\n  /// @param to                   Recipient of liquidity token\r\n  /// @param deadline             Deadline to add liquidity\r\n  /// @return amountToken         Amount of token to actually deposit\r\n  /// @return amountETH           Amount of tokenETH to actually deposit\r\n  /// @return liquidity           Amount of liquidity token returned from deposit\r\n  function addLiquidityETH(\r\n    address token,\r\n    bool stable,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n  // **** REMOVE LIQUIDITY ****\r\n\r\n  /// @notice Remove liquidity of two tokens from a Pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @param liquidity    Amount of liquidity to remove\r\n  /// @param amountAMin   Minimum amount of tokenA to receive\r\n  /// @param amountBMin   Minimum amount of tokenB to receive\r\n  /// @param to           Recipient of tokens received\r\n  /// @param deadline     Deadline to remove liquidity\r\n  /// @return amountA     Amount of tokenA received\r\n  /// @return amountB     Amount of tokenB received\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  /// @notice Remove liquidity of a token and WETH (returned as ETH) from a Pool\r\n  /// @param token            .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param liquidity        Amount of liquidity to remove\r\n  /// @param amountTokenMin   Minimum amount of token to receive\r\n  /// @param amountETHMin     Minimum amount of ETH to receive\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountToken     Amount of token received\r\n  /// @return amountETH       Amount of ETH received\r\n  function removeLiquidityETH(\r\n    address token,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  /// @notice Remove liquidity of a fee-on-transfer token and WETH (returned as ETH) from a Pool\r\n  /// @param token            .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param liquidity        Amount of liquidity to remove\r\n  /// @param amountTokenMin   Minimum amount of token to receive\r\n  /// @param amountETHMin     Minimum amount of ETH to receive\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountETH       Amount of ETH received\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  // **** SWAP ****\r\n\r\n  /// @notice Swap one token for another\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  /// @notice Swap ETH for a token\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  /// @notice Swap a token for WETH (returned as ETH)\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired ETH\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  /// @notice Swap one token for another without slippage protection\r\n  /// @return amounts     Array of amounts to swap  per route\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  function UNSAFE_swapExactTokensForTokens(\r\n    uint256[] memory amounts,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory);\r\n\r\n  // **** SWAP (supporting fee-on-transfer tokens) ****\r\n\r\n  /// @notice Swap one token for another supporting fee-on-transfer tokens\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  /// @notice Swap ETH for a token supporting fee-on-transfer tokens\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  /// @notice Swap a token for WETH (returned as ETH) supporting fee-on-transfer tokens\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired ETH\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  /// @notice Zap a token A into a pool (B, C). (A can be equal to B or C).\r\n  ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\r\n  ///         Slippage is required for the initial swap.\r\n  ///         Additional slippage may be required when adding liquidity as the\r\n  ///         price of the token may have changed.\r\n  /// @param tokenIn      Token you are zapping in from (i.e. input token).\r\n  /// @param amountInA    Amount of input token you wish to send down routesA\r\n  /// @param amountInB    Amount of input token you wish to send down routesB\r\n  /// @param zapInPool    Contains zap struct information. See Zap struct.\r\n  /// @param routesA      Route used to convert input token to tokenA\r\n  /// @param routesB      Route used to convert input token to tokenB\r\n  /// @param to           Address you wish to mint liquidity to.\r\n  /// @param stake        Auto-stake liquidity in corresponding gauge.\r\n  /// @return liquidity   Amount of LP tokens created from zapping in.\r\n  function zapIn(\r\n    address tokenIn,\r\n    uint256 amountInA,\r\n    uint256 amountInB,\r\n    Zap calldata zapInPool,\r\n    Route[] calldata routesA,\r\n    Route[] calldata routesB,\r\n    address to,\r\n    bool stake\r\n  ) external payable returns (uint256 liquidity);\r\n\r\n  /// @notice Zap out a pool (B, C) into A.\r\n  ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\r\n  ///         Slippage is required for the removal of liquidity.\r\n  ///         Additional slippage may be required on the swap as the\r\n  ///         price of the token may have changed.\r\n  /// @param tokenOut     Token you are zapping out to (i.e. output token).\r\n  /// @param liquidity    Amount of liquidity you wish to remove.\r\n  /// @param zapOutPool   Contains zap struct information. See Zap struct.\r\n  /// @param routesA      Route used to convert tokenA into output token.\r\n  /// @param routesB      Route used to convert tokenB into output token.\r\n  function zapOut(\r\n    address tokenOut,\r\n    uint256 liquidity,\r\n    Zap calldata zapOutPool,\r\n    Route[] calldata routesA,\r\n    Route[] calldata routesB\r\n  ) external;\r\n\r\n  /// @notice Used to generate params required for zapping in.\r\n  ///         Zap in => remove liquidity then swap.\r\n  ///         Apply slippage to expected swap values to account for changes in reserves in between.\r\n  /// @dev Output token refers to the token you want to zap in from.\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           .\r\n  /// @param _factory         .\r\n  /// @param amountInA        Amount of input token you wish to send down routesA\r\n  /// @param amountInB        Amount of input token you wish to send down routesB\r\n  /// @param routesA          Route used to convert input token to tokenA\r\n  /// @param routesB          Route used to convert input token to tokenB\r\n  /// @return amountOutMinA   Minimum output expected from swapping input token to tokenA.\r\n  /// @return amountOutMinB   Minimum output expected from swapping input token to tokenB.\r\n  /// @return amountAMin      Minimum amount of tokenA expected from depositing liquidity.\r\n  /// @return amountBMin      Minimum amount of tokenB expected from depositing liquidity.\r\n  function generateZapInParams(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    address _factory,\r\n    uint256 amountInA,\r\n    uint256 amountInB,\r\n    Route[] calldata routesA,\r\n    Route[] calldata routesB\r\n  ) external view returns (uint256 amountOutMinA, uint256 amountOutMinB, uint256 amountAMin, uint256 amountBMin);\r\n\r\n  /// @notice Used to generate params required for zapping out.\r\n  ///         Zap out => swap then add liquidity.\r\n  ///         Apply slippage to expected liquidity values to account for changes in reserves in between.\r\n  /// @dev Output token refers to the token you want to zap out of.\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           .\r\n  /// @param _factory         .\r\n  /// @param liquidity        Amount of liquidity being zapped out of into a given output token.\r\n  /// @param routesA          Route used to convert tokenA into output token.\r\n  /// @param routesB          Route used to convert tokenB into output token.\r\n  /// @return amountOutMinA   Minimum output expected from swapping tokenA into output token.\r\n  /// @return amountOutMinB   Minimum output expected from swapping tokenB into output token.\r\n  /// @return amountAMin      Minimum amount of tokenA expected from withdrawing liquidity.\r\n  /// @return amountBMin      Minimum amount of tokenB expected from withdrawing liquidity.\r\n  function generateZapOutParams(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    address _factory,\r\n    uint256 liquidity,\r\n    Route[] calldata routesA,\r\n    Route[] calldata routesB\r\n  ) external view returns (uint256 amountOutMinA, uint256 amountOutMinB, uint256 amountAMin, uint256 amountBMin);\r\n\r\n  /// @notice Used by zapper to determine appropriate ratio of A to B to deposit liquidity. Assumes stable pool.\r\n  /// @dev Returns stable liquidity ratio of B to (A + B).\r\n  ///      E.g. if ratio is 0.4, it means there is more of A than there is of B.\r\n  ///      Therefore you should deposit more of token A than B.\r\n  /// @param tokenA   tokenA of stable pool you are zapping into.\r\n  /// @param tokenB   tokenB of stable pool you are zapping into.\r\n  /// @param factory  Factory that created stable pool.\r\n  /// @return ratio   Ratio of token0 to token1 required to deposit into zap.\r\n  function quoteStableLiquidityRatio(\r\n    address tokenA,\r\n    address tokenB,\r\n    address factory\r\n  ) external view returns (uint256 ratio);\r\n}\r\n"
    },
    "contracts/external/api3/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IProxy {\r\n  function read() external view returns (int224 value, uint32 timestamp);\r\n\r\n  function api3ServerV1() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n"
    },
    "contracts/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IPriceOracle.sol\";\r\nimport \"./ICToken.sol\";\r\nimport \"./IUnitroller.sol\";\r\nimport \"./IRewardsDistributor.sol\";\r\n\r\n/**\r\n * @title Compound's Comptroller Contract\r\n * @author Compound\r\n */\r\ninterface IComptroller {\r\n  function admin() external view returns (address);\r\n\r\n  function adminHasRights() external view returns (bool);\r\n\r\n  function ionicAdminHasRights() external view returns (bool);\r\n\r\n  function oracle() external view returns (IPriceOracle);\r\n\r\n  function pauseGuardian() external view returns (address);\r\n\r\n  function closeFactorMantissa() external view returns (uint256);\r\n\r\n  function liquidationIncentiveMantissa() external view returns (uint256);\r\n\r\n  function markets(address cToken) external view returns (bool, uint256);\r\n\r\n  function getAssetsIn(address account) external view returns (ICToken[] memory);\r\n\r\n  function checkMembership(address account, ICToken cToken) external view returns (bool);\r\n\r\n  function getHypotheticalAccountLiquidity(\r\n    address account,\r\n    address cTokenModify,\r\n    uint256 redeemTokens,\r\n    uint256 borrowAmount,\r\n    uint256 repayAmount\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function getAccountLiquidity(address account)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function _setPriceOracle(IPriceOracle newOracle) external returns (uint256);\r\n\r\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\r\n\r\n  function _setCollateralFactor(ICToken market, uint256 newCollateralFactorMantissa) external returns (uint256);\r\n\r\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\r\n\r\n  function _become(IUnitroller unitroller) external;\r\n\r\n  function borrowGuardianPaused(address cToken) external view returns (bool);\r\n\r\n  function mintGuardianPaused(address cToken) external view returns (bool);\r\n\r\n  function getRewardsDistributors() external view returns (address[] memory);\r\n\r\n  function getAllMarkets() external view returns (ICToken[] memory);\r\n\r\n  function getAllBorrowers() external view returns (address[] memory);\r\n\r\n  function suppliers(address account) external view returns (bool);\r\n\r\n  function supplyCaps(address cToken) external view returns (uint256);\r\n\r\n  function borrowCaps(address cToken) external view returns (uint256);\r\n\r\n  function enforceWhitelist() external view returns (bool);\r\n\r\n  function enterMarkets(address[] memory cTokens) external returns (uint256[] memory);\r\n\r\n  function exitMarket(address cTokenAddress) external returns (uint256);\r\n\r\n  function autoImplementation() external view returns (bool);\r\n\r\n  function isUserOfPool(address user) external view returns (bool);\r\n\r\n  function whitelist(address account) external view returns (bool);\r\n\r\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\r\n\r\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\r\n\r\n  function _toggleAutoImplementations(bool enabled) external returns (uint256);\r\n\r\n  function _deployMarket(\r\n    bool isCEther,\r\n    bytes memory constructorData,\r\n    bytes calldata becomeImplData,\r\n    uint256 collateralFactorMantissa\r\n  ) external returns (uint256);\r\n\r\n  function getMaxRedeemOrBorrow(\r\n    address account,\r\n    ICToken cTokenModify,\r\n    bool isBorrow\r\n  ) external view returns (uint256);\r\n\r\n  function borrowCapForCollateral(address borrowed, address collateral) external view returns (uint256);\r\n\r\n  function borrowingAgainstCollateralBlacklist(address borrowed, address collateral) external view returns (bool);\r\n\r\n  function isDeprecated(ICToken cToken) external view returns (bool);\r\n\r\n  function getWhitelistedSuppliersSupply(address cToken) external view returns (uint256 supplied);\r\n\r\n  function getWhitelistedBorrowersBorrows(address cToken) external view returns (uint256 borrowed);\r\n}\r\n"
    },
    "contracts/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title Compound's CToken Contract\r\n * @notice Abstract base for CTokens\r\n * @author Compound\r\n */\r\ninterface ICToken {\r\n  function admin() external view returns (address);\r\n\r\n  function adminHasRights() external view returns (bool);\r\n\r\n  function ionicAdminHasRights() external view returns (bool);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function comptroller() external view returns (address);\r\n\r\n  function adminFeeMantissa() external view returns (uint256);\r\n\r\n  function ionicFeeMantissa() external view returns (uint256);\r\n\r\n  function reserveFactorMantissa() external view returns (uint256);\r\n\r\n  function totalReserves() external view returns (uint256);\r\n\r\n  function totalAdminFees() external view returns (uint256);\r\n\r\n  function totalIonicFees() external view returns (uint256);\r\n\r\n  function isCToken() external view returns (bool);\r\n\r\n  function isCEther() external view returns (bool);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n  function borrowRatePerBlock() external view returns (uint256);\r\n\r\n  function supplyRatePerBlock() external view returns (uint256);\r\n\r\n  function totalBorrowsCurrent() external returns (uint256);\r\n\r\n  function totalBorrows() external view returns (uint256);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function borrowBalanceStored(address account) external view returns (uint256);\r\n\r\n  function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n  function exchangeRateCurrent() external returns (uint256);\r\n\r\n  function exchangeRateStored() external view returns (uint256);\r\n\r\n  function accrueInterest() external returns (uint256);\r\n\r\n  function getCash() external view returns (uint256);\r\n\r\n  function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n  function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n  function borrow(uint256 borrowAmount) external returns (uint256);\r\n\r\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\r\n\r\n  function protocolSeizeShareMantissa() external view returns (uint256);\r\n\r\n  function feeSeizeShareMantissa() external view returns (uint256);\r\n\r\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\r\n\r\n  function _setAdminFee(uint256 newAdminFeeMantissa) external returns (uint256);\r\n}\r\n"
    },
    "contracts/external/compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./ICToken.sol\";\r\n\r\ninterface IPriceOracle {\r\n  /**\r\n   * @notice Get the underlying price of a cToken asset\r\n   * @param cToken The cToken to get the underlying price of\r\n   * @return The underlying asset price mantissa (scaled by 1e18).\r\n   *  Zero means the price is unavailable.\r\n   */\r\n  function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./ICToken.sol\";\r\n\r\n/**\r\n * @title RewardsDistributor\r\n * @author Compound\r\n */\r\ninterface IRewardsDistributor {\r\n  /// @dev The token to reward (i.e., COMP)\r\n  function rewardToken() external view returns (address);\r\n\r\n  /// @notice The portion of compRate that each market currently receives\r\n  function compSupplySpeeds(address) external view returns (uint256);\r\n\r\n  /// @notice The portion of compRate that each market currently receives\r\n  function compBorrowSpeeds(address) external view returns (uint256);\r\n\r\n  /// @notice The COMP accrued but not yet transferred to each user\r\n  function compAccrued(address) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\r\n   * @dev Called by the Comptroller\r\n   * @param cToken The relevant market\r\n   * @param supplier The minter/redeemer\r\n   */\r\n  function flywheelPreSupplierAction(address cToken, address supplier) external;\r\n\r\n  /**\r\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\r\n   * @dev Called by the Comptroller\r\n   * @param cToken The relevant market\r\n   * @param borrower The borrower\r\n   */\r\n  function flywheelPreBorrowerAction(address cToken, address borrower) external;\r\n\r\n  /**\r\n   * @notice Returns an array of all markets.\r\n   */\r\n  function getAllMarkets() external view returns (ICToken[] memory);\r\n}\r\n"
    },
    "contracts/external/compound/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @title ComptrollerCore\r\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\r\n * CTokens should reference this contract as their comptroller.\r\n */\r\ninterface IUnitroller {\r\n  function _setPendingImplementation(address newPendingImplementation) external returns (uint256);\r\n\r\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\r\n}\r\n"
    },
    "contracts/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ninterface ICurvePool is IERC20Upgradeable {\r\n  function get_virtual_price() external view returns (uint256);\r\n\r\n  function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\r\n\r\n  function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\r\n\r\n  function add_liquidity(uint256[2] calldata _amounts, uint256 _min_mint_amount) external returns (uint256);\r\n\r\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\r\n\r\n  function get_dy(int128 i, int128 j, uint256 _dx) external view returns (uint256);\r\n\r\n  function coins(uint256 index) external view returns (address);\r\n\r\n  function lp_token() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/curve/ICurveV2Pool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ICurvePool } from \"./ICurvePool.sol\";\r\n\r\ninterface ICurveV2Pool is ICurvePool {\r\n  function price_oracle() external view returns (uint256);\r\n\r\n  function lp_price() external view returns (uint256);\r\n\r\n  function coins(uint256 arg0) external view returns (address);\r\n}\r\n"
    },
    "contracts/external/hypernative/interfaces/IHypernativeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.22;\r\n\r\ninterface IHypernativeOracle {\r\n    function register(address account, bool isStrictMode) external;\r\n    function validateForbiddenAccountInteraction(address sender) external view;\r\n    function validateForbiddenContextInteraction(address origin, address sender) external view;\r\n    function validateBlacklistedAccountInteraction(address sender) external;\r\n}"
    },
    "contracts/external/pyth/IExpressRelay.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.0;\r\n\r\ninterface IExpressRelay {\r\n    // Check if the combination of protocol and permissionKey is allowed within this transaction.\r\n    // This will return true if and only if it's being called while executing the auction winner(s) call.\r\n    // @param protocolFeeReceiver The address of the protocol that is gating an action behind this permission\r\n    // @param permissionId The id that represents the action being gated\r\n    // @return permissioned True if the permission is allowed, false otherwise\r\n    function isPermissioned(\r\n        address protocolFeeReceiver,\r\n        bytes calldata permissionId\r\n    ) external view returns (bool permissioned);\r\n}\r\n"
    },
    "contracts/external/pyth/IExpressRelayFeeReceiver.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\r\npragma solidity ^0.8.0;\r\n\r\ninterface IExpressRelayFeeReceiver {\r\n    // Receive the proceeds of an auction.\r\n    // @param permissionKey The permission key where the auction was conducted on.\r\n    function receiveAuctionProceedings(\r\n        bytes calldata permissionKey\r\n    ) external payable;\r\n}\r\n"
    },
    "contracts/external/redstone/IRedstoneOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\ninterface IRedstoneOracle {\r\n  function priceOf(address asset) external view returns (uint256);\r\n\r\n  function priceOfETH() external view returns (uint256);\r\n\r\n  function getDataFeedIdForAsset(address asset) external view returns (bytes32);\r\n\r\n  function getDataFeedIds() external view returns (bytes32[] memory dataFeedIds);\r\n}\r\n"
    },
    "contracts/external/uniswap/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// From Uniswap3 Core\r\n\r\n// Updated to Solidity 0.8 by Midas Capital:\r\n//   * Rewrite unary negation of denominator, which is a uint\r\n//   * Wrapped function bodies with \"unchecked {}\" so as to not add any extra gas costs\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n  function mulDiv(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      // 512-bit multiply [prod1 prod0] = a * b\r\n      // Compute the product mod 2**256 and mod 2**256 - 1\r\n      // then use the Chinese Remainder Theorem to reconstruct\r\n      // the 512 bit result. The result is stored in two 256\r\n      // variables such that product = prod1 * 2**256 + prod0\r\n      uint256 prod0; // Least significant 256 bits of the product\r\n      uint256 prod1; // Most significant 256 bits of the product\r\n      assembly {\r\n        let mm := mulmod(a, b, not(0))\r\n        prod0 := mul(a, b)\r\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n      }\r\n\r\n      // Handle non-overflow cases, 256 by 256 division\r\n      if (prod1 == 0) {\r\n        require(denominator > 0);\r\n        assembly {\r\n          result := div(prod0, denominator)\r\n        }\r\n        return result;\r\n      }\r\n\r\n      // Make sure the result is less than 2**256.\r\n      // Also prevents denominator == 0\r\n      require(denominator > prod1);\r\n\r\n      ///////////////////////////////////////////////\r\n      // 512 by 256 division.\r\n      ///////////////////////////////////////////////\r\n\r\n      // Make division exact by subtracting the remainder from [prod1 prod0]\r\n      // Compute remainder using mulmod\r\n      uint256 remainder;\r\n      assembly {\r\n        remainder := mulmod(a, b, denominator)\r\n      }\r\n      // Subtract 256 bit number from 512 bit number\r\n      assembly {\r\n        prod1 := sub(prod1, gt(remainder, prod0))\r\n        prod0 := sub(prod0, remainder)\r\n      }\r\n\r\n      // Factor powers of two out of denominator\r\n      // Compute largest power of two divisor of denominator.\r\n      // Always >= 1.\r\n      uint256 twos = denominator & (~denominator + 1);\r\n\r\n      // Divide denominator by power of two\r\n      assembly {\r\n        denominator := div(denominator, twos)\r\n      }\r\n\r\n      // Divide [prod1 prod0] by the factors of two\r\n      assembly {\r\n        prod0 := div(prod0, twos)\r\n      }\r\n      // Shift in bits from prod1 into prod0. For this we need\r\n      // to flip `twos` such that it is 2**256 / twos.\r\n      // If twos is zero, then it becomes one\r\n      assembly {\r\n        twos := add(div(sub(0, twos), twos), 1)\r\n      }\r\n      prod0 |= prod1 * twos;\r\n\r\n      // Invert denominator mod 2**256\r\n      // Now that denominator is an odd number, it has an inverse\r\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n      // Compute the inverse by starting with a seed that is correct\r\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n      uint256 inv = (3 * denominator) ^ 2;\r\n      // Now use Newton-Raphson iteration to improve the precision.\r\n      // Thanks to Hensel's lifting lemma, this also works in modular\r\n      // arithmetic, doubling the correct bits in each step.\r\n      inv *= 2 - denominator * inv; // inverse mod 2**8\r\n      inv *= 2 - denominator * inv; // inverse mod 2**16\r\n      inv *= 2 - denominator * inv; // inverse mod 2**32\r\n      inv *= 2 - denominator * inv; // inverse mod 2**64\r\n      inv *= 2 - denominator * inv; // inverse mod 2**128\r\n      inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n      // Because the division is now exact we can divide by multiplying\r\n      // with the modular inverse of denominator. This will give us the\r\n      // correct result modulo 2**256. Since the precoditions guarantee\r\n      // that the outcome is less than 2**256, this is the final result.\r\n      // We don't need to compute the high bits of the result and prod1\r\n      // is no longer required.\r\n      result = prod0 * inv;\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  function mulDivRoundingUp(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      result = mulDiv(a, b, denominator);\r\n      if (mulmod(a, b, denominator) > 0) {\r\n        require(result < type(uint256).max);\r\n        result++;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\ninterface IUniswapV2Callee {\r\n  function uniswapV2Call(\r\n    address sender,\r\n    uint256 amount0,\r\n    uint256 amount1,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n  function feeTo() external view returns (address);\r\n\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n  function allPairs(uint256) external view returns (address pair);\r\n\r\n  function allPairsLength() external view returns (uint256);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n  function setFeeTo(address) external;\r\n\r\n  function setFeeToSetter(address) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function name() external pure returns (string memory);\r\n\r\n  function symbol() external pure returns (string memory);\r\n\r\n  function decimals() external pure returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n  function nonces(address owner) external view returns (uint256);\r\n\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n  event Swap(\r\n    address indexed sender,\r\n    uint256 amount0In,\r\n    uint256 amount1In,\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n  function factory() external view returns (address);\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function price0CumulativeLast() external view returns (uint256);\r\n\r\n  function price1CumulativeLast() external view returns (uint256);\r\n\r\n  function kLast() external view returns (uint256);\r\n\r\n  function mint(address to) external returns (uint256 liquidity);\r\n\r\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  function swap(\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address to,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function skim(address to) external;\r\n\r\n  function sync() external;\r\n\r\n  function initialize(address, address) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    payable\r\n    returns (\r\n      uint256 amountToken,\r\n      uint256 amountETH,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) external pure returns (uint256 amountB);\r\n\r\n  function getAmountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountOut);\r\n\r\n  function getAmountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountIn);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IUniswapV2Router01.sol\";\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    address referrer,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Callback for IUniswapV3PoolActions#flash\r\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\r\ninterface IUniswapV3FlashCallback {\r\n  /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\r\n  /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\r\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n  /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\r\n  /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\r\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\r\n  function uniswapV3FlashCallback(\r\n    uint256 fee0,\r\n    uint256 fee1,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IUniswapV3PoolActions.sol\";\r\n\r\ninterface IUniswapV3Pool is IUniswapV3PoolActions {\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function fee() external view returns (uint24);\r\n\r\n  function slot0()\r\n    external\r\n    view\r\n    returns (\r\n      uint160 sqrtPriceX96,\r\n      int24 tick,\r\n      uint16 observationIndex,\r\n      uint16 observationCardinality,\r\n      uint16 observationCardinalityNext,\r\n      uint8 feeProtocol,\r\n      bool unlocked\r\n    );\r\n\r\n  function liquidity() external view returns (uint128);\r\n\r\n  function observe(uint32[] calldata secondsAgos)\r\n    external\r\n    view\r\n    returns (int56[] memory tickCumulatives, uint160[] memory liquidityCumulatives);\r\n\r\n  function observations(uint256 index)\r\n    external\r\n    view\r\n    returns (\r\n      uint32 blockTimestamp,\r\n      int56 tickCumulative,\r\n      uint160 liquidityCumulative,\r\n      bool initialized\r\n    );\r\n\r\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n\r\n  function ticks(int24 tick)\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityGross,\r\n      int128 liquidityNet,\r\n      uint256 feeGrowthOutside0X128,\r\n      uint256 feeGrowthOutside1X128,\r\n      int56 tickCumulativeOutside,\r\n      uint160 secondsPerLiquidityOutsideX128,\r\n      uint32 secondsOutside,\r\n      bool initialized\r\n    );\r\n\r\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n\r\n  function positions(bytes32 key)\r\n    external\r\n    view\r\n    returns (\r\n      uint128 _liquidity,\r\n      uint256 feeGrowthInside0LastX128,\r\n      uint256 feeGrowthInside1LastX128,\r\n      uint128 tokensOwed0,\r\n      uint128 tokensOwed1\r\n    );\r\n}\r\n"
    },
    "contracts/external/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Permissionless pool actions\r\n/// @notice Contains pool methods that can be called by anyone\r\ninterface IUniswapV3PoolActions {\r\n  /// @notice Sets the initial price for the pool\r\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\r\n  function initialize(uint160 sqrtPriceX96) external;\r\n\r\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\r\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\r\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\r\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\r\n  /// @param recipient The address for which the liquidity will be created\r\n  /// @param tickLower The lower tick of the position in which to add liquidity\r\n  /// @param tickUpper The upper tick of the position in which to add liquidity\r\n  /// @param amount The amount of liquidity to mint\r\n  /// @param data Any data that should be passed through to the callback\r\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n  function mint(\r\n    address recipient,\r\n    int24 tickLower,\r\n    int24 tickUpper,\r\n    uint128 amount,\r\n    bytes calldata data\r\n  ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  /// @notice Collects tokens owed to a position\r\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\r\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\r\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\r\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\r\n  /// @param recipient The address which should receive the fees collected\r\n  /// @param tickLower The lower tick of the position for which to collect fees\r\n  /// @param tickUpper The upper tick of the position for which to collect fees\r\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\r\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\r\n  /// @return amount0 The amount of fees collected in token0\r\n  /// @return amount1 The amount of fees collected in token1\r\n  function collect(\r\n    address recipient,\r\n    int24 tickLower,\r\n    int24 tickUpper,\r\n    uint128 amount0Requested,\r\n    uint128 amount1Requested\r\n  ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\r\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\r\n  /// @dev Fees must be collected separately via a call to #collect\r\n  /// @param tickLower The lower tick of the position for which to burn liquidity\r\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\r\n  /// @param amount How much liquidity to burn\r\n  /// @return amount0 The amount of token0 sent to the recipient\r\n  /// @return amount1 The amount of token1 sent to the recipient\r\n  function burn(\r\n    int24 tickLower,\r\n    int24 tickUpper,\r\n    uint128 amount\r\n  ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  /// @notice Swap token0 for token1, or token1 for token0\r\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\r\n  /// @param recipient The address to receive the output of the swap\r\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n  /// @param data Any data to be passed through to the callback\r\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n  function swap(\r\n    address recipient,\r\n    bool zeroForOne,\r\n    int256 amountSpecified,\r\n    uint160 sqrtPriceLimitX96,\r\n    bytes calldata data\r\n  ) external returns (int256 amount0, int256 amount1);\r\n\r\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\r\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\r\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\r\n  /// @param recipient The address which will receive the token0 and token1 amounts\r\n  /// @param amount0 The amount of token0 to send\r\n  /// @param amount1 The amount of token1 to send\r\n  /// @param data Any data to be passed through to the callback\r\n  function flash(\r\n    address recipient,\r\n    uint256 amount0,\r\n    uint256 amount1,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\r\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\r\n  /// the input observationCardinalityNext.\r\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\r\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IUniswapV3Quoter {\r\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n  /// @param amountIn The amount of the first token to swap\r\n  /// @return amountOut The amount of the last token that would be received\r\n  function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\r\n\r\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n  /// @param tokenIn The token being swapped in\r\n  /// @param tokenOut The token being swapped out\r\n  /// @param fee The fee of the token pool to consider for the pair\r\n  /// @param amountIn The desired input amount\r\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n  /// @return amountOut The amount of `tokenOut` that would be received\r\n  function quoteExactInputSingle(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint24 fee,\r\n    uint256 amountIn,\r\n    uint160 sqrtPriceLimitX96\r\n  ) external returns (uint256 amountOut);\r\n\r\n  /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n  /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\r\n  /// @param amountOut The amount of the last token to receive\r\n  /// @return amountIn The amount of first token required to be paid\r\n  function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\r\n\r\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n  /// @param tokenIn The token being swapped in\r\n  /// @param tokenOut The token being swapped out\r\n  /// @param fee The fee of the token pool to consider for the pair\r\n  /// @param amountOut The desired output amount\r\n  /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n  function quoteExactOutputSingle(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint24 fee,\r\n    uint256 amountOut,\r\n    uint160 sqrtPriceLimitX96\r\n  ) external returns (uint256 amountIn);\r\n}\r\n"
    },
    "contracts/external/uniswap/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\n\r\n// From Uniswap3 Core\r\n\r\n// Updated to Solidity 0.8 by Midas Capital:\r\n//   * Cast MAX_TICK to int256 before casting to uint\r\n//   * Wrapped function bodies with \"unchecked {}\" so as to not add any extra gas costs\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n  int24 internal constant MIN_TICK = -887272;\r\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n  int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n  /// @dev Throws if |tick| > max tick\r\n  /// @param tick The input tick for the above formula\r\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n  /// at the given tick\r\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n    unchecked {\r\n      uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n      require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n      uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n      if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n      sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n  /// ever return.\r\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n  function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n    unchecked {\r\n      // second inequality must be < because the price can never reach the price at the max tick\r\n      require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\r\n      uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n      uint256 r = ratio;\r\n      uint256 msb = 0;\r\n\r\n      assembly {\r\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(5, gt(r, 0xFFFFFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(4, gt(r, 0xFFFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(3, gt(r, 0xFF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(2, gt(r, 0xF))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := shl(1, gt(r, 0x3))\r\n        msb := or(msb, f)\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        let f := gt(r, 0x1)\r\n        msb := or(msb, f)\r\n      }\r\n\r\n      if (msb >= 128) r = ratio >> (msb - 127);\r\n      else r = ratio << (127 - msb);\r\n\r\n      int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(63, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(62, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(61, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(60, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(59, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(58, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(57, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(56, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(55, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(54, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(53, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(52, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(51, f))\r\n        r := shr(f, r)\r\n      }\r\n      assembly {\r\n        r := shr(127, mul(r, r))\r\n        let f := shr(128, r)\r\n        log_2 := or(log_2, shl(50, f))\r\n      }\r\n\r\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/uniswap/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\n\r\nlibrary UniswapV2Library {\r\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n  }\r\n\r\n  function pairFor(\r\n    address factory,\r\n    address tokenA,\r\n    address tokenB\r\n  ) internal view returns (address pair) {\r\n    return IUniswapV2Factory(factory).getPair(tokenA, tokenB);\r\n  }\r\n\r\n  // fetches and sorts the reserves for a pair\r\n  function getReserves(\r\n    address factory,\r\n    address tokenA,\r\n    address tokenB\r\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n    (address token0, ) = sortTokens(tokenA, tokenB);\r\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n  }\r\n\r\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) internal pure returns (uint256 amountB) {\r\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\r\n    require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n    amountB = (amountA * reserveB) / reserveA;\r\n  }\r\n\r\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n  function getAmountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut,\r\n    uint8 flashSwapFee\r\n  ) internal pure returns (uint256 amountOut) {\r\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n    uint256 amountInWithFee = amountIn * (10000 - flashSwapFee);\r\n    uint256 numerator = amountInWithFee * reserveOut;\r\n    uint256 denominator = reserveIn * 10000 + amountInWithFee;\r\n    amountOut = numerator / denominator;\r\n  }\r\n\r\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n  function getAmountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut,\r\n    uint8 flashSwapFee\r\n  ) internal pure returns (uint256 amountIn) {\r\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n    uint256 numerator = reserveIn * amountOut * 10000;\r\n    uint256 denominator = (reserveOut - amountOut) * (10000 - flashSwapFee);\r\n    amountIn = numerator / denominator + 1;\r\n  }\r\n\r\n  // performs chained getAmountOut calculations on any number of pairs\r\n  function getAmountsOut(\r\n    address factory,\r\n    uint256 amountIn,\r\n    address[] memory path,\r\n    uint8 flashSwapFee\r\n  ) internal view returns (uint256[] memory amounts) {\r\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n    amounts = new uint256[](path.length);\r\n    amounts[0] = amountIn;\r\n    for (uint256 i; i < path.length - 1; i++) {\r\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, flashSwapFee);\r\n    }\r\n  }\r\n\r\n  // performs chained getAmountIn calculations on any number of pairs\r\n  function getAmountsIn(\r\n    address factory,\r\n    uint256 amountOut,\r\n    address[] memory path,\r\n    uint8 flashSwapFee\r\n  ) internal view returns (uint256[] memory amounts) {\r\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n    amounts = new uint256[](path.length);\r\n    amounts[amounts.length - 1] = amountOut;\r\n    for (uint256 i = path.length - 1; i > 0; i--) {\r\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, flashSwapFee);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/external/velodrome/IVelodromeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRouter_Velodrome {\r\n  struct Route {\r\n    address from;\r\n    address to;\r\n    bool stable;\r\n  }\r\n\r\n  error ETHTransferFailed();\r\n  error Expired();\r\n  error InsufficientAmount();\r\n  error InsufficientAmountA();\r\n  error InsufficientAmountB();\r\n  error InsufficientAmountADesired();\r\n  error InsufficientAmountBDesired();\r\n  error InsufficientLiquidity();\r\n  error InsufficientOutputAmount();\r\n  error InvalidPath();\r\n  error OnlyWETH();\r\n  error SameAddresses();\r\n  error ZeroAddress();\r\n\r\n  /// @notice Address of Velodrome v2 pool factory\r\n  function factory() external view returns (address);\r\n\r\n  /// @notice Address of Velodrome v2 pool implementation\r\n  function poolImplementation() external view returns (address);\r\n\r\n  /// @notice Sort two tokens by which address value is less than the other\r\n  /// @param tokenA   Address of token to sort\r\n  /// @param tokenB   Address of token to sort\r\n  /// @return token0  Lower address value between tokenA and tokenB\r\n  /// @return token1  Higher address value between tokenA and tokenB\r\n  function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\r\n\r\n  /// @notice Calculate the address of a pool by its' factory.\r\n  /// @dev Returns a randomly generated address for a nonexistent pool\r\n  /// @param tokenA   Address of token to query\r\n  /// @param tokenB   Address of token to query\r\n  /// @param stable   True if pool is stable, false if volatile\r\n  function poolFor(address tokenA, address tokenB, bool stable) external view returns (address pool);\r\n\r\n  /// @notice Fetch and sort the reserves for a pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @return reserveA    Amount of reserves of the sorted token A\r\n  /// @return reserveB    Amount of reserves of the sorted token B\r\n  function getReserves(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable\r\n  ) external view returns (uint256 reserveA, uint256 reserveB);\r\n\r\n  /// @notice Perform chained getAmountOut calculations on any number of pools\r\n  function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);\r\n\r\n  // **** ADD LIQUIDITY ****\r\n\r\n  /// @notice Quote the amount deposited into a Pool\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param amountADesired   Amount of tokenA desired to deposit\r\n  /// @param amountBDesired   Amount of tokenB desired to deposit\r\n  /// @return amountA         Amount of tokenA to actually deposit\r\n  /// @return amountB         Amount of tokenB to actually deposit\r\n  /// @return liquidity       Amount of liquidity token returned from deposit\r\n  function quoteAddLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired\r\n  ) external view returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n  /// @notice Quote the amount of liquidity removed from a Pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @param liquidity    Amount of liquidity to remove\r\n  /// @return amountA     Amount of tokenA received\r\n  /// @return amountB     Amount of tokenB received\r\n  function quoteRemoveLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 liquidity\r\n  ) external view returns (uint256 amountA, uint256 amountB);\r\n\r\n  /// @notice Add liquidity of two tokens to a Pool\r\n  /// @param tokenA           .\r\n  /// @param tokenB           .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param amountADesired   Amount of tokenA desired to deposit\r\n  /// @param amountBDesired   Amount of tokenB desired to deposit\r\n  /// @param amountAMin       Minimum amount of tokenA to deposit\r\n  /// @param amountBMin       Minimum amount of tokenB to deposit\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountA         Amount of tokenA to actually deposit\r\n  /// @return amountB         Amount of tokenB to actually deposit\r\n  /// @return liquidity       Amount of liquidity token returned from deposit\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n  /// @notice Add liquidity of a token and WETH (transferred as ETH) to a Pool\r\n  /// @param token                .\r\n  /// @param stable               True if pool is stable, false if volatile\r\n  /// @param amountTokenDesired   Amount of token desired to deposit\r\n  /// @param amountTokenMin       Minimum amount of token to deposit\r\n  /// @param amountETHMin         Minimum amount of ETH to deposit\r\n  /// @param to                   Recipient of liquidity token\r\n  /// @param deadline             Deadline to add liquidity\r\n  /// @return amountToken         Amount of token to actually deposit\r\n  /// @return amountETH           Amount of tokenETH to actually deposit\r\n  /// @return liquidity           Amount of liquidity token returned from deposit\r\n  function addLiquidityETH(\r\n    address token,\r\n    bool stable,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n  // **** REMOVE LIQUIDITY ****\r\n\r\n  /// @notice Remove liquidity of two tokens from a Pool\r\n  /// @param tokenA       .\r\n  /// @param tokenB       .\r\n  /// @param stable       True if pool is stable, false if volatile\r\n  /// @param liquidity    Amount of liquidity to remove\r\n  /// @param amountAMin   Minimum amount of tokenA to receive\r\n  /// @param amountBMin   Minimum amount of tokenB to receive\r\n  /// @param to           Recipient of tokens received\r\n  /// @param deadline     Deadline to remove liquidity\r\n  /// @return amountA     Amount of tokenA received\r\n  /// @return amountB     Amount of tokenB received\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  /// @notice Remove liquidity of a token and WETH (returned as ETH) from a Pool\r\n  /// @param token            .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param liquidity        Amount of liquidity to remove\r\n  /// @param amountTokenMin   Minimum amount of token to receive\r\n  /// @param amountETHMin     Minimum amount of ETH to receive\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountToken     Amount of token received\r\n  /// @return amountETH       Amount of ETH received\r\n  function removeLiquidityETH(\r\n    address token,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  /// @notice Remove liquidity of a fee-on-transfer token and WETH (returned as ETH) from a Pool\r\n  /// @param token            .\r\n  /// @param stable           True if pool is stable, false if volatile\r\n  /// @param liquidity        Amount of liquidity to remove\r\n  /// @param amountTokenMin   Minimum amount of token to receive\r\n  /// @param amountETHMin     Minimum amount of ETH to receive\r\n  /// @param to               Recipient of liquidity token\r\n  /// @param deadline         Deadline to receive liquidity\r\n  /// @return amountETH       Amount of ETH received\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    bool stable,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  /// @notice Swap one token for another\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  /// @notice Swap ETH for a token\r\n  /// @param amountOutMin Minimum amount of desired token received\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  /// @notice Swap a token for WETH (returned as ETH)\r\n  /// @param amountIn     Amount of token in\r\n  /// @param amountOutMin Minimum amount of desired ETH\r\n  /// @param routes       Array of trade routes used in the swap\r\n  /// @param to           Recipient of the tokens received\r\n  /// @param deadline     Deadline to receive tokens\r\n  /// @return amounts     Array of amounts returned per route\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    Route[] calldata routes,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/FeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\r\n\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\nimport { CErc20Delegator } from \"./compound/CErc20Delegator.sol\";\r\nimport { CErc20PluginDelegate } from \"./compound/CErc20PluginDelegate.sol\";\r\nimport { SafeOwnableUpgradeable } from \"./ionic/SafeOwnableUpgradeable.sol\";\r\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\r\nimport { DiamondExtension, DiamondBase } from \"./ionic/DiamondExtension.sol\";\r\nimport { AuthoritiesRegistry } from \"./ionic/AuthoritiesRegistry.sol\";\r\n\r\ncontract FeeDistributorStorage {\r\n  struct CDelegateUpgradeData {\r\n    address implementation;\r\n    bytes becomeImplementationData;\r\n  }\r\n\r\n  /**\r\n   * @notice Maps Unitroller (Comptroller proxy) addresses to the proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   * @dev A value of 0 means unset whereas a negative value means 0.\r\n   */\r\n  mapping(address => int256) public customInterestFeeRates;\r\n\r\n  /**\r\n   * @dev Latest Comptroller implementation for each existing implementation.\r\n   */\r\n  mapping(address => address) internal _latestComptrollerImplementation;\r\n\r\n  /**\r\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\r\n   */\r\n  mapping(uint8 => CDelegateUpgradeData) internal _latestCErc20Delegate;\r\n\r\n  /**\r\n   * @dev Latest Plugin implementation for each existing implementation.\r\n   */\r\n  mapping(address => address) internal _latestPluginImplementation;\r\n\r\n  mapping(address => DiamondExtension[]) public comptrollerExtensions;\r\n\r\n  mapping(address => DiamondExtension[]) public cErc20DelegateExtensions;\r\n\r\n  AuthoritiesRegistry public authoritiesRegistry;\r\n\r\n  /**\r\n   * @dev used as salt for the creation of new markets\r\n   */\r\n  uint256 public marketsCounter;\r\n\r\n  /**\r\n   * @dev Minimum borrow balance (in ETH) per user per Ionic pool asset (only checked on new borrows, not redemptions).\r\n   */\r\n  uint256 public minBorrowEth;\r\n\r\n  /**\r\n   * @dev Maximum utilization rate (scaled by 1e18) for Ionic pool assets (only checked on new borrows, not redemptions).\r\n   * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\r\n   */\r\n  uint256 public maxUtilizationRate;\r\n\r\n  /**\r\n   * @notice The proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   */\r\n  uint256 public defaultInterestFeeRate;\r\n}\r\n\r\n/**\r\n * @title FeeDistributor\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice FeeDistributor controls and receives protocol fees from Ionic pools and relays admin actions to Ionic pools.\r\n */\r\ncontract FeeDistributor is SafeOwnableUpgradeable, FeeDistributorStorage {\r\n  using AddressUpgradeable for address;\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  /**\r\n   * @dev Initializer that sets initial values of state variables.\r\n   * @param _defaultInterestFeeRate The default proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   */\r\n  function initialize(uint256 _defaultInterestFeeRate) public initializer {\r\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\r\n    __SafeOwnable_init(msg.sender);\r\n    defaultInterestFeeRate = _defaultInterestFeeRate;\r\n    maxUtilizationRate = type(uint256).max;\r\n  }\r\n\r\n  function reinitialize(AuthoritiesRegistry _ar) public onlyOwnerOrAdmin {\r\n    authoritiesRegistry = _ar;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the default proportion of Ionic pool interest taken as a protocol fee.\r\n   * @param _defaultInterestFeeRate The default proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   */\r\n  function _setDefaultInterestFeeRate(uint256 _defaultInterestFeeRate) external onlyOwner {\r\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\r\n    defaultInterestFeeRate = _defaultInterestFeeRate;\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws accrued fees on interest.\r\n   * @param erc20Contract The ERC20 token address to withdraw. Set to the zero address to withdraw ETH.\r\n   */\r\n  function _withdrawAssets(address erc20Contract) external {\r\n    if (erc20Contract == address(0)) {\r\n      uint256 balance = address(this).balance;\r\n      require(balance > 0, \"No balance available to withdraw.\");\r\n      (bool success, ) = owner().call{ value: balance }(\"\");\r\n      require(success, \"Failed to transfer ETH balance to msg.sender.\");\r\n    } else {\r\n      IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\r\n      uint256 balance = token.balanceOf(address(this));\r\n      require(balance > 0, \"No token balance available to withdraw.\");\r\n      token.safeTransfer(owner(), balance);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the proportion of Ionic pool interest taken as a protocol fee.\r\n   * @param _minBorrowEth Minimum borrow balance (in ETH) per user per Ionic pool asset (only checked on new borrows, not redemptions).\r\n   * @param _maxUtilizationRate Maximum utilization rate (scaled by 1e18) for Ionic pool assets (only checked on new borrows, not redemptions).\r\n   */\r\n  function _setPoolLimits(uint256 _minBorrowEth, uint256 _maxUtilizationRate) external onlyOwner {\r\n    minBorrowEth = _minBorrowEth;\r\n    maxUtilizationRate = _maxUtilizationRate;\r\n  }\r\n\r\n  function getMinBorrowEth(ICErc20 _ctoken) public view returns (uint256) {\r\n    (, , uint256 borrowBalance, ) = _ctoken.getAccountSnapshot(_msgSender());\r\n    if (borrowBalance == 0) return minBorrowEth;\r\n    IonicComptroller comptroller = IonicComptroller(address(_ctoken.comptroller()));\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n    uint256 underlyingPriceEth = oracle.price(ICErc20(address(_ctoken)).underlying());\r\n    uint256 underlyingDecimals = _ctoken.decimals();\r\n    uint256 borrowBalanceEth = (underlyingPriceEth * borrowBalance) / 10 ** underlyingDecimals;\r\n    if (borrowBalanceEth > minBorrowEth) {\r\n      return 0;\r\n    }\r\n    return minBorrowEth - borrowBalanceEth;\r\n  }\r\n\r\n  /**\r\n   * @dev Receives native fees.\r\n   */\r\n  receive() external payable {}\r\n\r\n  /**\r\n   * @dev Sends data to a contract.\r\n   * @param targets The contracts to which `data` will be sent.\r\n   * @param data The data to be sent to each of `targets`.\r\n   */\r\n  function _callPool(address[] calldata targets, bytes[] calldata data) external onlyOwner {\r\n    require(targets.length > 0 && targets.length == data.length, \"Array lengths must be equal and greater than 0.\");\r\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data[i]);\r\n  }\r\n\r\n  /**\r\n   * @dev Sends data to a contract.\r\n   * @param targets The contracts to which `data` will be sent.\r\n   * @param data The data to be sent to each of `targets`.\r\n   */\r\n  function _callPool(address[] calldata targets, bytes calldata data) external onlyOwner {\r\n    require(targets.length > 0, \"No target addresses specified.\");\r\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data);\r\n  }\r\n\r\n  /**\r\n   * @dev Deploys a CToken for an underlying ERC20\r\n   * @param constructorData Encoded construction data for `CToken initialize()`\r\n   */\r\n  function deployCErc20(\r\n    uint8 delegateType,\r\n    bytes calldata constructorData,\r\n    bytes calldata becomeImplData\r\n  ) external returns (address) {\r\n    // Make sure comptroller == msg.sender\r\n    (address underlying, address comptroller) = abi.decode(constructorData[0:64], (address, address));\r\n    require(comptroller == msg.sender, \"Comptroller is not sender.\");\r\n\r\n    // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\r\n    bytes32 salt = keccak256(abi.encodePacked(msg.sender, underlying, ++marketsCounter));\r\n\r\n    bytes memory cErc20DelegatorCreationCode = abi.encodePacked(type(CErc20Delegator).creationCode, constructorData);\r\n    address proxy = Create2Upgradeable.deploy(0, salt, cErc20DelegatorCreationCode);\r\n\r\n    CDelegateUpgradeData memory data = _latestCErc20Delegate[delegateType];\r\n    DiamondExtension delegateAsExtension = DiamondExtension(data.implementation);\r\n    // register the first extension\r\n    DiamondBase(proxy)._registerExtension(delegateAsExtension, DiamondExtension(address(0)));\r\n    // derive and configure the other extensions\r\n    DiamondExtension[] memory ctokenExts = cErc20DelegateExtensions[address(delegateAsExtension)];\r\n    for (uint256 i = 0; i < ctokenExts.length; i++) {\r\n      if (ctokenExts[i] == delegateAsExtension) continue;\r\n      DiamondBase(proxy)._registerExtension(ctokenExts[i], DiamondExtension(address(0)));\r\n    }\r\n    CErc20PluginDelegate(address(proxy))._becomeImplementation(becomeImplData);\r\n\r\n    return proxy;\r\n  }\r\n\r\n  /**\r\n   * @dev Latest Comptroller implementation for each existing implementation.\r\n   */\r\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address) {\r\n    return\r\n      _latestComptrollerImplementation[oldImplementation] != address(0)\r\n        ? _latestComptrollerImplementation[oldImplementation]\r\n        : oldImplementation;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the latest `Comptroller` upgrade implementation address.\r\n   * @param oldImplementation The old `Comptroller` implementation address to upgrade from.\r\n   * @param newImplementation Latest `Comptroller` implementation address.\r\n   */\r\n  function _setLatestComptrollerImplementation(\r\n    address oldImplementation,\r\n    address newImplementation\r\n  ) external onlyOwner {\r\n    _latestComptrollerImplementation[oldImplementation] = newImplementation;\r\n  }\r\n\r\n  /**\r\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\r\n   */\r\n  function latestCErc20Delegate(uint8 delegateType) external view returns (address, bytes memory) {\r\n    CDelegateUpgradeData memory data = _latestCErc20Delegate[delegateType];\r\n    bytes memory emptyBytes;\r\n    return\r\n      data.implementation != address(0)\r\n        ? (data.implementation, data.becomeImplementationData)\r\n        : (address(0), emptyBytes);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the latest `CErc20Delegate` upgrade implementation address and data.\r\n   * @param delegateType The old `CErc20Delegate` implementation address to upgrade from.\r\n   * @param newImplementation Latest `CErc20Delegate` implementation address.\r\n   * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\r\n   */\r\n  function _setLatestCErc20Delegate(\r\n    uint8 delegateType,\r\n    address newImplementation,\r\n    bytes calldata becomeImplementationData\r\n  ) external onlyOwner {\r\n    _latestCErc20Delegate[delegateType] = CDelegateUpgradeData(newImplementation, becomeImplementationData);\r\n  }\r\n\r\n  /**\r\n   * @dev Latest Plugin implementation for each existing implementation.\r\n   */\r\n  function latestPluginImplementation(address oldImplementation) external view returns (address) {\r\n    return\r\n      _latestPluginImplementation[oldImplementation] != address(0)\r\n        ? _latestPluginImplementation[oldImplementation]\r\n        : oldImplementation;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the latest plugin upgrade implementation address.\r\n   * @param oldImplementation The old plugin implementation address to upgrade from.\r\n   * @param newImplementation Latest plugin implementation address.\r\n   */\r\n  function _setLatestPluginImplementation(address oldImplementation, address newImplementation) external onlyOwner {\r\n    _latestPluginImplementation[oldImplementation] = newImplementation;\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades a plugin of a CErc20PluginDelegate market to the latest implementation\r\n   * @param cDelegator the proxy address\r\n   * @return if the plugin was upgraded or not\r\n   */\r\n  function _upgradePluginToLatestImplementation(address cDelegator) external onlyOwner returns (bool) {\r\n    CErc20PluginDelegate market = CErc20PluginDelegate(cDelegator);\r\n\r\n    address oldPluginAddress = address(market.plugin());\r\n    market._updatePlugin(_latestPluginImplementation[oldPluginAddress]);\r\n    address newPluginAddress = address(market.plugin());\r\n\r\n    return newPluginAddress != oldPluginAddress;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   */\r\n  function interestFeeRate() external view returns (uint256) {\r\n    (bool success, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(\"comptroller()\"));\r\n\r\n    if (success && data.length == 32) {\r\n      address comptroller = abi.decode(data, (address));\r\n      int256 customRate = customInterestFeeRates[comptroller];\r\n      if (customRate > 0) return uint256(customRate);\r\n      if (customRate < 0) return 0;\r\n    }\r\n\r\n    return defaultInterestFeeRate;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the proportion of Ionic pool interest taken as a protocol fee.\r\n   * @param comptroller The Unitroller (Comptroller proxy) address.\r\n   * @param rate The proportion of Ionic pool interest taken as a protocol fee (scaled by 1e18).\r\n   */\r\n  function _setCustomInterestFeeRate(address comptroller, int256 rate) external onlyOwner {\r\n    require(rate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\r\n    customInterestFeeRates[comptroller] = rate;\r\n  }\r\n\r\n  function getComptrollerExtensions(address comptroller) external view returns (DiamondExtension[] memory) {\r\n    return comptrollerExtensions[comptroller];\r\n  }\r\n\r\n  function _setComptrollerExtensions(address comptroller, DiamondExtension[] calldata extensions) external onlyOwner {\r\n    comptrollerExtensions[comptroller] = extensions;\r\n  }\r\n\r\n  function _registerComptrollerExtension(\r\n    address payable pool,\r\n    DiamondExtension extensionToAdd,\r\n    DiamondExtension extensionToReplace\r\n  ) external onlyOwner {\r\n    DiamondBase(pool)._registerExtension(extensionToAdd, extensionToReplace);\r\n  }\r\n\r\n  function getCErc20DelegateExtensions(address cErc20Delegate) external view returns (DiamondExtension[] memory) {\r\n    return cErc20DelegateExtensions[cErc20Delegate];\r\n  }\r\n\r\n  function _setCErc20DelegateExtensions(\r\n    address cErc20Delegate,\r\n    DiamondExtension[] calldata extensions\r\n  ) external onlyOwner {\r\n    cErc20DelegateExtensions[cErc20Delegate] = extensions;\r\n  }\r\n\r\n  function autoUpgradePool(IonicComptroller pool) external onlyOwner {\r\n    ICErc20[] memory markets = pool.getAllMarkets();\r\n\r\n    // auto upgrade the pool\r\n    pool._upgrade();\r\n\r\n    for (uint8 i = 0; i < markets.length; i++) {\r\n      // upgrade the market\r\n      markets[i]._upgrade();\r\n    }\r\n  }\r\n\r\n  function canCall(address pool, address user, address target, bytes4 functionSig) external view returns (bool) {\r\n    return authoritiesRegistry.canCall(pool, user, target, functionSig);\r\n  }\r\n}\r\n"
    },
    "contracts/GlobalPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\r\n\r\ninterface IPoolDirectory {\r\n  struct Pool {\r\n    string name;\r\n    address creator;\r\n    address comptroller;\r\n    uint256 blockPosted;\r\n    uint256 timestampPosted;\r\n  }\r\n\r\n  function getActivePools() external view returns (uint256, Pool[] memory);\r\n}\r\n\r\ncontract GlobalPauser is Ownable2Step {\r\n  IPoolDirectory public poolDirectory;\r\n  mapping(address => bool) public pauseGuardian;\r\n\r\n  modifier onlyPauseGuardian() {\r\n    require(pauseGuardian[msg.sender], \"!guardian\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _poolDirectory) Ownable2Step() {\r\n    poolDirectory = IPoolDirectory(_poolDirectory);\r\n  }\r\n\r\n  function setPauseGuardian(address _pauseGuardian, bool _isPauseGuardian) external onlyOwner {\r\n    pauseGuardian[_pauseGuardian] = _isPauseGuardian;\r\n  }\r\n\r\n  function pauseAll() external onlyPauseGuardian {\r\n    (, IPoolDirectory.Pool[] memory pools) = poolDirectory.getActivePools();\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      ICErc20[] memory markets = IonicComptroller(pools[i].comptroller).getAllMarkets();\r\n      for (uint256 j = 0; j < markets.length; j++) {\r\n        bool isPaused = IonicComptroller(pools[i].comptroller).borrowGuardianPaused(address(markets[j]));\r\n        if (!isPaused) {\r\n          IonicComptroller(pools[i].comptroller)._setBorrowPaused(markets[j], true);\r\n        }\r\n\r\n        isPaused = IonicComptroller(pools[i].comptroller).mintGuardianPaused(address(markets[j]));\r\n        if (!isPaused) {\r\n          IonicComptroller(pools[i].comptroller)._setMintPaused(markets[j], true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/IEmissionsManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\ninterface IEmissionsManager {\r\n  error InvalidPoolDirectoryAaddress();\r\n  error InvalidProtocolAddress();\r\n  error InvalidRewardTokenAddress();\r\n  error CollateralBasisPointsExceedMaximum();\r\n  error InvalidVeIONAddress();\r\n  error MaximumLimitExceeded();\r\n\r\n  event Initialized(\r\n    address indexed protocolAddress,\r\n    address indexed rewardToken,\r\n    uint256 collateralBp,\r\n    bytes nonBlacklistableTargetBytecode\r\n  );\r\n  event VeIonSet(address indexed veIon);\r\n  event CollateralBpSet(uint256 collateralBp);\r\n  event NonBlacklistableAddressSet(address indexed user, bool isNonBlacklistable);\r\n  event NonBlacklistableTargetBytecodeSet(bytes newBytecode);\r\n\r\n  function isUserBlacklisted(address _user) external view returns (bool);\r\n  function isUserBlacklistable(address _user) external view returns (bool);\r\n}\r\n"
    },
    "contracts/ILiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\nimport \"./liquidators/IRedemptionStrategy.sol\";\r\nimport \"./liquidators/IFundsConversionStrategy.sol\";\r\n\r\ninterface ILiquidator {\r\n  /**\r\n   * borrower The borrower's Ethereum address.\r\n   * repayAmount The amount to repay to liquidate the unhealthy loan.\r\n   * cErc20 The borrowed CErc20 contract to repay.\r\n   * cTokenCollateral The cToken collateral contract to be liquidated.\r\n   * minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\r\n   * redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\r\n   * strategyData The data for the chosen IRedemptionStrategy contracts, if any.\r\n   */\r\n  struct LiquidateToTokensWithFlashSwapVars {\r\n    address borrower;\r\n    uint256 repayAmount;\r\n    ICErc20 cErc20;\r\n    ICErc20 cTokenCollateral;\r\n    address flashSwapContract;\r\n    uint256 minProfitAmount;\r\n    IRedemptionStrategy[] redemptionStrategies;\r\n    bytes[] strategyData;\r\n    IFundsConversionStrategy[] debtFundingStrategies;\r\n    bytes[] debtFundingStrategiesData;\r\n  }\r\n\r\n  function redemptionStrategiesWhitelist(address strategy) external view returns (bool);\r\n\r\n  function safeLiquidate(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) external returns (uint256);\r\n\r\n  function safeLiquidateToTokensWithFlashLoan(LiquidateToTokensWithFlashSwapVars calldata vars)\r\n    external\r\n    returns (uint256);\r\n\r\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external;\r\n\r\n  function _whitelistRedemptionStrategies(IRedemptionStrategy[] calldata strategies, bool[] calldata whitelisted)\r\n    external;\r\n\r\n  function setExpressRelay(address _expressRelay) external;\r\n\r\n  function setPoolLens(address _poolLens) external;\r\n\r\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external;\r\n}\r\n"
    },
    "contracts/ionic/AddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title AddressesProvider\r\n * @notice The Addresses Provider serves as a central storage of system internal and external\r\n *         contract addresses that change between deploys and across chains\r\n * @author Veliko Minkov <veliko@midascapital.xyz>\r\n */\r\ncontract AddressesProvider is SafeOwnableUpgradeable {\r\n  mapping(string => address) private _addresses;\r\n  mapping(address => Contract) public plugins;\r\n  mapping(address => Contract) public flywheelRewards;\r\n  mapping(address => RedemptionStrategy) public redemptionStrategiesConfig;\r\n  mapping(address => FundingStrategy) public fundingStrategiesConfig;\r\n  JarvisPool[] public jarvisPoolsConfig;\r\n  CurveSwapPool[] public curveSwapPoolsConfig;\r\n  mapping(address => mapping(address => address)) public balancerPoolForTokens;\r\n\r\n  /// @dev Initializer to set the admin that can set and change contracts addresses\r\n  function initialize(address owner) public initializer {\r\n    __SafeOwnable_init(owner);\r\n  }\r\n\r\n  /**\r\n   * @dev The contract address and a string that uniquely identifies the contract's interface\r\n   */\r\n  struct Contract {\r\n    address addr;\r\n    string contractInterface;\r\n  }\r\n\r\n  struct RedemptionStrategy {\r\n    address addr;\r\n    string contractInterface;\r\n    address outputToken;\r\n  }\r\n\r\n  struct FundingStrategy {\r\n    address addr;\r\n    string contractInterface;\r\n    address inputToken;\r\n  }\r\n\r\n  struct JarvisPool {\r\n    address syntheticToken;\r\n    address collateralToken;\r\n    address liquidityPool;\r\n    uint256 expirationTime;\r\n  }\r\n\r\n  struct CurveSwapPool {\r\n    address poolAddress;\r\n    address[] coins;\r\n  }\r\n\r\n  /**\r\n   * @dev sets the address and contract interface ID of the flywheel for the reward token\r\n   * @param rewardToken the reward token address\r\n   * @param flywheelRewardsModule the flywheel rewards module address\r\n   * @param contractInterface a string that uniquely identifies the contract's interface\r\n   */\r\n  function setFlywheelRewards(\r\n    address rewardToken,\r\n    address flywheelRewardsModule,\r\n    string calldata contractInterface\r\n  ) public onlyOwner {\r\n    flywheelRewards[rewardToken] = Contract(flywheelRewardsModule, contractInterface);\r\n  }\r\n\r\n  /**\r\n   * @dev sets the address and contract interface ID of the ERC4626 plugin for the asset\r\n   * @param asset the asset address\r\n   * @param plugin the ERC4626 plugin address\r\n   * @param contractInterface a string that uniquely identifies the contract's interface\r\n   */\r\n  function setPlugin(\r\n    address asset,\r\n    address plugin,\r\n    string calldata contractInterface\r\n  ) public onlyOwner {\r\n    plugins[asset] = Contract(plugin, contractInterface);\r\n  }\r\n\r\n  /**\r\n   * @dev sets the address and contract interface ID of the redemption strategy for the asset\r\n   * @param asset the asset address\r\n   * @param strategy redemption strategy address\r\n   * @param contractInterface a string that uniquely identifies the contract's interface\r\n   */\r\n  function setRedemptionStrategy(\r\n    address asset,\r\n    address strategy,\r\n    string calldata contractInterface,\r\n    address outputToken\r\n  ) public onlyOwner {\r\n    redemptionStrategiesConfig[asset] = RedemptionStrategy(strategy, contractInterface, outputToken);\r\n  }\r\n\r\n  function getRedemptionStrategy(address asset) public view returns (RedemptionStrategy memory) {\r\n    return redemptionStrategiesConfig[asset];\r\n  }\r\n\r\n  /**\r\n   * @dev sets the address and contract interface ID of the funding strategy for the asset\r\n   * @param asset the asset address\r\n   * @param strategy funding strategy address\r\n   * @param contractInterface a string that uniquely identifies the contract's interface\r\n   */\r\n  function setFundingStrategy(\r\n    address asset,\r\n    address strategy,\r\n    string calldata contractInterface,\r\n    address inputToken\r\n  ) public onlyOwner {\r\n    fundingStrategiesConfig[asset] = FundingStrategy(strategy, contractInterface, inputToken);\r\n  }\r\n\r\n  function getFundingStrategy(address asset) public view returns (FundingStrategy memory) {\r\n    return fundingStrategiesConfig[asset];\r\n  }\r\n\r\n  /**\r\n   * @dev configures the Jarvis pool of a Jarvis synthetic token\r\n   * @param syntheticToken the synthetic token address\r\n   * @param collateralToken the collateral token address\r\n   * @param liquidityPool the liquidity pool address\r\n   * @param expirationTime the operation expiration time\r\n   */\r\n  function setJarvisPool(\r\n    address syntheticToken,\r\n    address collateralToken,\r\n    address liquidityPool,\r\n    uint256 expirationTime\r\n  ) public onlyOwner {\r\n    jarvisPoolsConfig.push(JarvisPool(syntheticToken, collateralToken, liquidityPool, expirationTime));\r\n  }\r\n\r\n  function setCurveSwapPool(address poolAddress, address[] calldata coins) public onlyOwner {\r\n    curveSwapPoolsConfig.push(CurveSwapPool(poolAddress, coins));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets an address for an id replacing the address saved in the addresses map\r\n   * @param id The id\r\n   * @param newAddress The address to set\r\n   */\r\n  function setAddress(string calldata id, address newAddress) external onlyOwner {\r\n    _addresses[id] = newAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an address by id\r\n   * @return The address\r\n   */\r\n  function getAddress(string calldata id) public view returns (address) {\r\n    return _addresses[id];\r\n  }\r\n\r\n  function getCurveSwapPools() public view returns (CurveSwapPool[] memory) {\r\n    return curveSwapPoolsConfig;\r\n  }\r\n\r\n  function getJarvisPools() public view returns (JarvisPool[] memory) {\r\n    return jarvisPoolsConfig;\r\n  }\r\n\r\n  function setBalancerPoolForTokens(\r\n    address inputToken,\r\n    address outputToken,\r\n    address pool\r\n  ) external onlyOwner {\r\n    balancerPoolForTokens[inputToken][outputToken] = pool;\r\n  }\r\n\r\n  function getBalancerPoolForTokens(address inputToken, address outputToken) external view returns (address) {\r\n    return balancerPoolForTokens[inputToken][outputToken];\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/AuthoritiesRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { PoolRolesAuthority } from \"../ionic/PoolRolesAuthority.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../ionic/SafeOwnableUpgradeable.sol\";\r\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\r\n\r\nimport { TransparentUpgradeableProxy } from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract AuthoritiesRegistry is SafeOwnableUpgradeable {\r\n  mapping(address => PoolRolesAuthority) public poolsAuthorities;\r\n  PoolRolesAuthority public poolAuthLogic;\r\n  address public leveredPositionsFactory;\r\n  bool public noAuthRequired;\r\n\r\n  function initialize(address _leveredPositionsFactory) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    leveredPositionsFactory = _leveredPositionsFactory;\r\n    poolAuthLogic = new PoolRolesAuthority();\r\n  }\r\n\r\n  function reinitialize(address _leveredPositionsFactory) public onlyOwnerOrAdmin {\r\n    leveredPositionsFactory = _leveredPositionsFactory;\r\n    poolAuthLogic = new PoolRolesAuthority();\r\n    // for Neon the auth is not required\r\n    noAuthRequired = block.chainid == 245022934;\r\n  }\r\n\r\n  function createPoolAuthority(address pool) public onlyOwner returns (PoolRolesAuthority auth) {\r\n    require(address(poolsAuthorities[pool]) == address(0), \"already created\");\r\n\r\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(address(poolAuthLogic), _getProxyAdmin(), \"\");\r\n    auth = PoolRolesAuthority(address(proxy));\r\n    auth.initialize(address(this));\r\n    poolsAuthorities[pool] = auth;\r\n\r\n    auth.openPoolSupplierCapabilities(IonicComptroller(pool));\r\n    auth.setUserRole(address(this), auth.REGISTRY_ROLE(), true);\r\n    // sets the registry owner as the auth owner\r\n    reconfigureAuthority(pool);\r\n  }\r\n\r\n  function reconfigureAuthority(address poolAddress) public {\r\n    IonicComptroller pool = IonicComptroller(poolAddress);\r\n    PoolRolesAuthority auth = poolsAuthorities[address(pool)];\r\n\r\n    if (msg.sender != poolAddress || address(auth) != address(0)) {\r\n      require(address(auth) != address(0), \"no such authority\");\r\n      require(msg.sender == owner() || msg.sender == poolAddress, \"not owner or pool\");\r\n\r\n      auth.configureRegistryCapabilities();\r\n      auth.configurePoolSupplierCapabilities(pool);\r\n      auth.configurePoolBorrowerCapabilities(pool);\r\n      // everyone can be a liquidator\r\n      auth.configureOpenPoolLiquidatorCapabilities(pool);\r\n      auth.configureLeveredPositionCapabilities(pool);\r\n\r\n      if (auth.owner() != owner()) {\r\n        auth.setOwner(owner());\r\n      }\r\n    }\r\n  }\r\n\r\n  function canCall(\r\n    address pool,\r\n    address user,\r\n    address target,\r\n    bytes4 functionSig\r\n  ) external view returns (bool) {\r\n    PoolRolesAuthority authorityForPool = poolsAuthorities[pool];\r\n    if (address(authorityForPool) == address(0)) {\r\n      return noAuthRequired;\r\n    } else {\r\n      // allow only if an auth exists and it allows the action\r\n      return authorityForPool.canCall(user, target, functionSig);\r\n    }\r\n  }\r\n\r\n  function setUserRole(\r\n    address pool,\r\n    address user,\r\n    uint8 role,\r\n    bool enabled\r\n  ) external {\r\n    PoolRolesAuthority poolAuth = poolsAuthorities[pool];\r\n\r\n    require(address(poolAuth) != address(0), \"auth does not exist\");\r\n    require(msg.sender == owner() || msg.sender == leveredPositionsFactory, \"not owner or factory\");\r\n    require(msg.sender != leveredPositionsFactory || role == poolAuth.LEVERED_POSITION_ROLE(), \"only lev pos role\");\r\n\r\n    poolAuth.setUserRole(user, role, enabled);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/CollateralSwap.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.22;\r\n\r\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\r\n\r\nimport { IFlashLoanReceiver } from \"./IFlashLoanReceiver.sol\";\r\nimport { Exponential } from \"../compound/Exponential.sol\";\r\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\r\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\r\n\r\ncontract CollateralSwap is Ownable2Step, Exponential, IFlashLoanReceiver {\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 public feeBps;\r\n  address public feeRecipient;\r\n  IonicComptroller public comptroller;\r\n  mapping(address => bool) public allowedSwapTargets;\r\n\r\n  error SwapCollateralFailed();\r\n  error TransferFailed(address market, address user, address target);\r\n  error MintFailed(address market, uint256 errorCode);\r\n  error RedeemFailed(address market, uint256 errorCode);\r\n  error InvalidFlashloanCaller(address caller);\r\n  error InvalidSwapTarget(address target);\r\n\r\n  constructor(\r\n    uint256 _feeBps,\r\n    address _feeRecipient,\r\n    address _comptroller,\r\n    address[] memory _allowedSwapTargets\r\n  ) Ownable2Step() {\r\n    feeBps = _feeBps;\r\n    feeRecipient = _feeRecipient;\r\n    comptroller = IonicComptroller(_comptroller);\r\n    for (uint256 i = 0; i < _allowedSwapTargets.length; i++) {\r\n      allowedSwapTargets[_allowedSwapTargets[i]] = true;\r\n    }\r\n  }\r\n\r\n  // ADMIN FUNCTIONS\r\n\r\n  function setFeeBps(uint256 _feeBps) public onlyOwner {\r\n    feeBps = _feeBps;\r\n  }\r\n\r\n  function setFeeRecipient(address _feeRecipient) public onlyOwner {\r\n    feeRecipient = _feeRecipient;\r\n  }\r\n\r\n  function setAllowedSwapTarget(address _target, bool _allowed) public onlyOwner {\r\n    allowedSwapTargets[_target] = _allowed;\r\n  }\r\n\r\n  function sweep(address token) public onlyOwner {\r\n    IERC20(token).safeTransfer(owner(), IERC20(token).balanceOf(address(this)));\r\n  }\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  function swapCollateral(\r\n    uint256 amountUnderlying,\r\n    ICErc20 oldCollateralMarket,\r\n    ICErc20 newCollateralMarket,\r\n    address swapTarget,\r\n    bytes calldata swapData\r\n  ) public {\r\n    oldCollateralMarket.flash(\r\n      amountUnderlying,\r\n      abi.encode(msg.sender, oldCollateralMarket, newCollateralMarket, swapTarget, swapData)\r\n    );\r\n  }\r\n\r\n  function receiveFlashLoan(address borrowedAsset, uint256 borrowedAmount, bytes calldata data) external {\r\n    // make sure the caller is a valid market\r\n    {\r\n      ICErc20[] memory markets = comptroller.getAllMarkets();\r\n      bool isAllowed = false;\r\n      for (uint256 i = 0; i < markets.length; i++) {\r\n        if (msg.sender == address(markets[i])) {\r\n          isAllowed = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!isAllowed) {\r\n        revert InvalidFlashloanCaller(msg.sender);\r\n      }\r\n    }\r\n\r\n    (\r\n      address borrower,\r\n      ICErc20 oldCollateralMarket,\r\n      ICErc20 newCollateralMarket,\r\n      address swapTarget,\r\n      bytes memory swapData\r\n    ) = abi.decode(data, (address, ICErc20, ICErc20, address, bytes));\r\n\r\n    // swap the collateral\r\n    {\r\n      if (!allowedSwapTargets[swapTarget]) {\r\n        revert InvalidSwapTarget(swapTarget);\r\n      }\r\n      IERC20(borrowedAsset).approve(swapTarget, borrowedAmount);\r\n      (bool success, ) = swapTarget.call(swapData);\r\n      if (!success) {\r\n        revert SwapCollateralFailed();\r\n      }\r\n    }\r\n\r\n    // mint the new collateral\r\n    {\r\n      IERC20 newCollateralAsset = IERC20(newCollateralMarket.underlying());\r\n      uint256 outputAmount = newCollateralAsset.balanceOf(address(this));\r\n      uint256 fee = (outputAmount * feeBps) / 10_000;\r\n      outputAmount -= fee;\r\n      if (fee > 0) {\r\n        newCollateralAsset.safeTransfer(feeRecipient, fee);\r\n      }\r\n      newCollateralAsset.approve(address(newCollateralMarket), outputAmount);\r\n      uint256 mintResult = newCollateralMarket.mint(outputAmount);\r\n      if (mintResult != 0) {\r\n        revert MintFailed(address(newCollateralMarket), mintResult);\r\n      }\r\n    }\r\n\r\n    // transfer the new collateral to the borrower\r\n    {\r\n      uint256 cTokenBalance = IERC20(address(newCollateralMarket)).balanceOf(address(this));\r\n      IERC20(address(newCollateralMarket)).safeTransfer(borrower, cTokenBalance);\r\n    }\r\n\r\n    // withdraw the old collateral\r\n    {\r\n      (MathError mErr, uint256 amountCTokensToSwap) = divScalarByExpTruncate(\r\n        borrowedAmount,\r\n        Exp({ mantissa: oldCollateralMarket.exchangeRateCurrent() })\r\n      );\r\n      require(mErr == MathError.NO_ERROR, \"exchange rate error\");\r\n      bool transferStatus = oldCollateralMarket.transferFrom(borrower, address(this), amountCTokensToSwap + 1);\r\n      if (!transferStatus) {\r\n        revert TransferFailed(address(oldCollateralMarket), borrower, address(this));\r\n      }\r\n      uint256 redeemResult = oldCollateralMarket.redeemUnderlying(type(uint256).max);\r\n      if (redeemResult != 0) {\r\n        revert RedeemFailed(address(oldCollateralMarket), redeemResult);\r\n      }\r\n      IERC20(borrowedAsset).approve(address(oldCollateralMarket), borrowedAmount);\r\n    }\r\n    // flashloan gets paid back from redeemed collateral\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/DiamondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\n/**\r\n * @notice a base contract for logic extensions that use the diamond pattern storage\r\n * to map the functions when looking up the extension contract to delegate to.\r\n */\r\nabstract contract DiamondExtension {\r\n  /**\r\n   * @return a list of all the function selectors that this logic extension exposes\r\n   */\r\n  function _getExtensionFunctions() external pure virtual returns (bytes4[] memory);\r\n}\r\n\r\n// When no function exists for function called\r\nerror FunctionNotFound(bytes4 _functionSelector);\r\n\r\n// When no extension exists for function called\r\nerror ExtensionNotFound(bytes4 _functionSelector);\r\n\r\n// When the function is already added\r\nerror FunctionAlreadyAdded(bytes4 _functionSelector, address _currentImpl);\r\n\r\nabstract contract DiamondBase {\r\n  /**\r\n   * @dev register a logic extension\r\n   * @param extensionToAdd the extension whose functions are to be added\r\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\r\n   */\r\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) external virtual;\r\n\r\n  function _listExtensions() public view returns (address[] memory) {\r\n    return LibDiamond.listExtensions();\r\n  }\r\n\r\n  fallback() external {\r\n    address extension = LibDiamond.getExtensionForFunction(msg.sig);\r\n    if (extension == address(0)) revert FunctionNotFound(msg.sig);\r\n    // Execute external function from extension using delegatecall and return any value.\r\n    assembly {\r\n      // copy function selector and any arguments\r\n      calldatacopy(0, 0, calldatasize())\r\n      // execute function call using the extension\r\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\r\n      // get any return value\r\n      returndatacopy(0, 0, returndatasize())\r\n      // return any return value or error back to the caller\r\n      switch result\r\n      case 0 {\r\n        revert(0, returndatasize())\r\n      }\r\n      default {\r\n        return(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @notice a library to use in a contract, whose logic is extended with diamond extension\r\n */\r\nlibrary LibDiamond {\r\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.extensions.diamond.storage\");\r\n\r\n  struct Function {\r\n    address extension;\r\n    bytes4 selector;\r\n  }\r\n\r\n  struct LogicStorage {\r\n    Function[] functions;\r\n    address[] extensions;\r\n  }\r\n\r\n  function getExtensionForFunction(bytes4 msgSig) internal view returns (address) {\r\n    return getExtensionForSelector(msgSig, diamondStorage());\r\n  }\r\n\r\n  function diamondStorage() internal pure returns (LogicStorage storage ds) {\r\n    bytes32 position = DIAMOND_STORAGE_POSITION;\r\n    assembly {\r\n      ds.slot := position\r\n    }\r\n  }\r\n\r\n  function listExtensions() internal view returns (address[] memory) {\r\n    return diamondStorage().extensions;\r\n  }\r\n\r\n  function registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace) internal {\r\n    if (address(extensionToReplace) != address(0)) {\r\n      removeExtension(extensionToReplace);\r\n    }\r\n    addExtension(extensionToAdd);\r\n  }\r\n\r\n  function removeExtension(DiamondExtension extension) internal {\r\n    LogicStorage storage ds = diamondStorage();\r\n    // remove all functions of the extension to replace\r\n    removeExtensionFunctions(extension);\r\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\r\n      if (ds.extensions[i] == address(extension)) {\r\n        ds.extensions[i] = ds.extensions[ds.extensions.length - 1];\r\n        ds.extensions.pop();\r\n      }\r\n    }\r\n  }\r\n\r\n  function addExtension(DiamondExtension extension) internal {\r\n    LogicStorage storage ds = diamondStorage();\r\n    for (uint8 i = 0; i < ds.extensions.length; i++) {\r\n      require(ds.extensions[i] != address(extension), \"extension already added\");\r\n    }\r\n    addExtensionFunctions(extension);\r\n    ds.extensions.push(address(extension));\r\n  }\r\n\r\n  function removeExtensionFunctions(DiamondExtension extension) internal {\r\n    bytes4[] memory fnsToRemove = extension._getExtensionFunctions();\r\n    LogicStorage storage ds = diamondStorage();\r\n    for (uint16 i = 0; i < fnsToRemove.length; i++) {\r\n      bytes4 selectorToRemove = fnsToRemove[i];\r\n      // must never fail\r\n      assert(address(extension) == getExtensionForSelector(selectorToRemove, ds));\r\n      // swap with the last element in the selectorAtIndex array and remove the last element\r\n      uint16 indexToKeep = getIndexForSelector(selectorToRemove, ds);\r\n      ds.functions[indexToKeep] = ds.functions[ds.functions.length - 1];\r\n      ds.functions.pop();\r\n    }\r\n  }\r\n\r\n  function addExtensionFunctions(DiamondExtension extension) internal {\r\n    bytes4[] memory fnsToAdd = extension._getExtensionFunctions();\r\n    LogicStorage storage ds = diamondStorage();\r\n    uint16 functionsCount = uint16(ds.functions.length);\r\n    for (uint256 functionsIndex = 0; functionsIndex < fnsToAdd.length; functionsIndex++) {\r\n      bytes4 selector = fnsToAdd[functionsIndex];\r\n      address oldImplementation = getExtensionForSelector(selector, ds);\r\n      if (oldImplementation != address(0)) revert FunctionAlreadyAdded(selector, oldImplementation);\r\n      ds.functions.push(Function(address(extension), selector));\r\n      functionsCount++;\r\n    }\r\n  }\r\n\r\n  function getExtensionForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (address) {\r\n    uint256 fnsLen = ds.functions.length;\r\n    for (uint256 i = 0; i < fnsLen; i++) {\r\n      if (ds.functions[i].selector == selector) return ds.functions[i].extension;\r\n    }\r\n\r\n    return address(0);\r\n  }\r\n\r\n  function getIndexForSelector(bytes4 selector, LogicStorage storage ds) internal view returns (uint16) {\r\n    uint16 fnsLen = uint16(ds.functions.length);\r\n    for (uint16 i = 0; i < fnsLen; i++) {\r\n      if (ds.functions[i].selector == selector) return i;\r\n    }\r\n\r\n    return type(uint16).max;\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\ninterface IFlashLoanReceiver {\r\n  function receiveFlashLoan(\r\n    address borrowedAsset,\r\n    uint256 borrowedAmount,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n"
    },
    "contracts/ionic/levered/ILeveredPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\r\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\r\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ninterface ILeveredPositionFactoryStorage {\r\n  function feeDistributor() external view returns (IFeeDistributor);\r\n\r\n  function liquidatorsRegistry() external view returns (ILiquidatorsRegistry);\r\n\r\n  function blocksPerYear() external view returns (uint256);\r\n\r\n  function owner() external view returns (address);\r\n}\r\n\r\ninterface ILeveredPositionFactoryBase {\r\n  function _setLiquidatorsRegistry(ILiquidatorsRegistry _liquidatorsRegistry) external;\r\n\r\n  function _setPairWhitelisted(ICErc20 _collateralMarket, ICErc20 _stableMarket, bool _whitelisted) external;\r\n}\r\n\r\ninterface ILeveredPositionFactoryFirstExtension {\r\n  function getRedemptionStrategies(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData);\r\n\r\n  function getMinBorrowNative() external view returns (uint256);\r\n\r\n  function removeClosedPosition(address closedPosition) external returns (bool removed);\r\n\r\n  function closeAndRemoveUserPosition(LeveredPosition position) external returns (bool);\r\n\r\n  function getPositionsByAccount(address account) external view returns (address[] memory, bool[] memory);\r\n\r\n  function getAccountsWithOpenPositions() external view returns (address[] memory);\r\n\r\n  function getWhitelistedCollateralMarkets() external view returns (address[] memory);\r\n\r\n  function getBorrowableMarketsByCollateral(ICErc20 _collateralMarket) external view returns (address[] memory);\r\n\r\n  function getPositionsExtension(bytes4 msgSig) external view returns (address);\r\n\r\n  function _setPositionsExtension(bytes4 msgSig, address extension) external;\r\n}\r\n\r\ninterface ILeveredPositionFactorySecondExtension {\r\n  function createPosition(ICErc20 _collateralMarket, ICErc20 _stableMarket) external returns (LeveredPosition);\r\n\r\n  function createAndFundPosition(\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    IERC20Upgradeable _fundingAsset,\r\n    uint256 _fundingAmount\r\n  ) external returns (LeveredPosition);\r\n\r\n  function createAndFundPositionAtRatio(\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    IERC20Upgradeable _fundingAsset,\r\n    uint256 _fundingAmount,\r\n    uint256 _leverageRatio\r\n  ) external returns (LeveredPosition);\r\n}\r\n\r\ninterface ILeveredPositionFactoryExtension is\r\n  ILeveredPositionFactoryFirstExtension,\r\n  ILeveredPositionFactorySecondExtension\r\n{}\r\n\r\ninterface ILeveredPositionFactory is\r\n  ILeveredPositionFactoryStorage,\r\n  ILeveredPositionFactoryBase,\r\n  ILeveredPositionFactoryExtension\r\n{}\r\n"
    },
    "contracts/ionic/levered/LeveredPosition.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\r\nimport { IFundsConversionStrategy } from \"../../liquidators/IFundsConversionStrategy.sol\";\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\r\nimport { IFlashLoanReceiver } from \"../IFlashLoanReceiver.sol\";\r\nimport { IonicFlywheel } from \"../../ionic/strategies/flywheel/IonicFlywheel.sol\";\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\nimport { LeveredPositionStorage } from \"./LeveredPositionStorage.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ninterface IFlywheelLensRouter_LP {\r\n  function claimAllRewardTokens(address user) external returns (address[] memory, uint256[] memory);\r\n}\r\n\r\ncontract LeveredPosition is LeveredPositionStorage, IFlashLoanReceiver {\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  error OnlyWhenClosed();\r\n  error NotPositionOwner();\r\n  error OnlyFactoryOwner();\r\n  error AssetNotRescuable();\r\n  error RepayFlashLoanFailed(address asset, uint256 currentBalance, uint256 repayAmount);\r\n\r\n  error ConvertFundsFailed();\r\n  error ExitFailed(uint256 errorCode);\r\n  error RedeemFailed(uint256 errorCode);\r\n  error SupplyCollateralFailed(uint256 errorCode);\r\n  error BorrowStableFailed(uint256 errorCode);\r\n  error RepayBorrowFailed(uint256 errorCode);\r\n  error RedeemCollateralFailed(uint256 errorCode);\r\n  error ExtNotFound(bytes4 _functionSelector);\r\n\r\n  constructor(\r\n    address _positionOwner,\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket\r\n  ) LeveredPositionStorage(_positionOwner) {\r\n    IonicComptroller collateralPool = _collateralMarket.comptroller();\r\n    IonicComptroller stablePool = _stableMarket.comptroller();\r\n    require(collateralPool == stablePool, \"markets pools differ\");\r\n    pool = collateralPool;\r\n\r\n    collateralMarket = _collateralMarket;\r\n    collateralAsset = IERC20Upgradeable(_collateralMarket.underlying());\r\n    stableMarket = _stableMarket;\r\n    stableAsset = IERC20Upgradeable(_stableMarket.underlying());\r\n\r\n    factory = ILeveredPositionFactory(msg.sender);\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                          Mutable Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  function fundPosition(IERC20Upgradeable fundingAsset, uint256 amount) public {\r\n    fundingAsset.safeTransferFrom(msg.sender, address(this), amount);\r\n    _supplyCollateral(fundingAsset);\r\n\r\n    if (!pool.checkMembership(address(this), collateralMarket)) {\r\n      address[] memory cTokens = new address[](1);\r\n      cTokens[0] = address(collateralMarket);\r\n      pool.enterMarkets(cTokens);\r\n    }\r\n  }\r\n\r\n  function closePosition() public returns (uint256) {\r\n    return closePosition(msg.sender);\r\n  }\r\n\r\n  function closePosition(address withdrawTo) public returns (uint256 withdrawAmount) {\r\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\r\n\r\n    _leverDown(1e18);\r\n\r\n    // calling accrue and exit allows to redeem the full underlying balance\r\n    collateralMarket.accrueInterest();\r\n    uint256 errorCode = pool.exitMarket(address(collateralMarket));\r\n    if (errorCode != 0) revert ExitFailed(errorCode);\r\n\r\n    // redeem all cTokens should leave no dust\r\n    errorCode = collateralMarket.redeem(collateralMarket.balanceOf(address(this)));\r\n    if (errorCode != 0) revert RedeemFailed(errorCode);\r\n\r\n    if (stableAsset.balanceOf(address(this)) > 0) {\r\n      // convert all overborrowed leftovers/profits to the collateral asset\r\n      convertAllTo(stableAsset, collateralAsset);\r\n    }\r\n\r\n    // withdraw the redeemed collateral\r\n    withdrawAmount = collateralAsset.balanceOf(address(this));\r\n    collateralAsset.safeTransfer(withdrawTo, withdrawAmount);\r\n  }\r\n\r\n  function adjustLeverageRatio(uint256 targetRatioMantissa) public returns (uint256) {\r\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\r\n\r\n    // anything under 1x means removing the leverage\r\n    if (targetRatioMantissa <= 1e18) _leverDown(1e18);\r\n\r\n    if (getCurrentLeverageRatio() < targetRatioMantissa) _leverUp(targetRatioMantissa);\r\n    else _leverDown(targetRatioMantissa);\r\n\r\n    // return the de facto achieved ratio\r\n    return getCurrentLeverageRatio();\r\n  }\r\n\r\n  function receiveFlashLoan(address assetAddress, uint256 borrowedAmount, bytes calldata data) external override {\r\n    if (msg.sender == address(collateralMarket)) {\r\n      // increasing the leverage ratio\r\n      uint256 stableBorrowAmount = abi.decode(data, (uint256));\r\n      _leverUpPostFL(stableBorrowAmount);\r\n      uint256 positionCollateralBalance = collateralAsset.balanceOf(address(this));\r\n      if (positionCollateralBalance < borrowedAmount)\r\n        revert RepayFlashLoanFailed(address(collateralAsset), positionCollateralBalance, borrowedAmount);\r\n    } else if (msg.sender == address(stableMarket)) {\r\n      // decreasing the leverage ratio\r\n      uint256 amountToRedeem = abi.decode(data, (uint256));\r\n      _leverDownPostFL(borrowedAmount, amountToRedeem);\r\n      uint256 positionStableBalance = stableAsset.balanceOf(address(this));\r\n      if (positionStableBalance < borrowedAmount)\r\n        revert RepayFlashLoanFailed(address(stableAsset), positionStableBalance, borrowedAmount);\r\n    } else {\r\n      revert(\"!fl not from either markets\");\r\n    }\r\n\r\n    // repay FL\r\n    IERC20Upgradeable(assetAddress).approve(msg.sender, borrowedAmount);\r\n  }\r\n\r\n  function withdrawStableLeftovers(address withdrawTo) public returns (uint256) {\r\n    if (msg.sender != positionOwner) revert NotPositionOwner();\r\n    if (!isPositionClosed()) revert OnlyWhenClosed();\r\n\r\n    uint256 stableLeftovers = stableAsset.balanceOf(address(this));\r\n    stableAsset.safeTransfer(withdrawTo, stableLeftovers);\r\n    return stableLeftovers;\r\n  }\r\n\r\n  function claimRewards() public {\r\n    claimRewards(msg.sender);\r\n  }\r\n\r\n  function claimRewards(address withdrawTo) public {\r\n    if (msg.sender != positionOwner && msg.sender != address(factory)) revert NotPositionOwner();\r\n\r\n    address[] memory flywheels = pool.getRewardsDistributors();\r\n\r\n    for (uint256 i = 0; i < flywheels.length; i++) {\r\n      IonicFlywheel fw = IonicFlywheel(flywheels[i]);\r\n      fw.accrue(ERC20(address(collateralMarket)), address(this));\r\n      fw.accrue(ERC20(address(stableMarket)), address(this));\r\n      fw.claimRewards(address(this));\r\n      ERC20 rewardToken = fw.rewardToken();\r\n      uint256 rewardsAccrued = rewardToken.balanceOf(address(this));\r\n      if (rewardsAccrued > 0) {\r\n        rewardToken.transfer(withdrawTo, rewardsAccrued);\r\n      }\r\n    }\r\n  }\r\n\r\n  function rescueTokens(IERC20Upgradeable asset) external {\r\n    if (msg.sender != factory.owner()) revert OnlyFactoryOwner();\r\n    if (asset == stableAsset || asset == collateralAsset) revert AssetNotRescuable();\r\n\r\n    asset.transfer(positionOwner, asset.balanceOf(address(this)));\r\n  }\r\n\r\n  function claimRewardsFromRouter(address _flr) external returns (address[] memory, uint256[] memory) {\r\n    IFlywheelLensRouter_LP flr = IFlywheelLensRouter_LP(_flr);\r\n    (address[] memory rewardTokens, uint256[] memory rewards) = flr.claimAllRewardTokens(address(this));\r\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n      IERC20Upgradeable(rewardTokens[i]).safeTransfer(positionOwner, rewards[i]);\r\n    }\r\n    return (rewardTokens, rewards);\r\n  }\r\n\r\n  fallback() external {\r\n    address extension = factory.getPositionsExtension(msg.sig);\r\n    if (extension == address(0)) revert ExtNotFound(msg.sig);\r\n    // Execute external function from extension using delegatecall and return any value.\r\n    assembly {\r\n      // copy function selector and any arguments\r\n      calldatacopy(0, 0, calldatasize())\r\n      // execute function call using the extension\r\n      let result := delegatecall(gas(), extension, 0, calldatasize(), 0, 0)\r\n      // get any return value\r\n      returndatacopy(0, 0, returndatasize())\r\n      // return any return value or error back to the caller\r\n      switch result\r\n      case 0 {\r\n        revert(0, returndatasize())\r\n      }\r\n      default {\r\n        return(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                          View Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  /// @notice this is a lens fn, it is not intended to be used on-chain\r\n  function getAccruedRewards()\r\n    external\r\n    returns (\r\n      /*view*/\r\n      ERC20[] memory rewardTokens,\r\n      uint256[] memory amounts\r\n    )\r\n  {\r\n    address[] memory flywheels = pool.getRewardsDistributors();\r\n\r\n    rewardTokens = new ERC20[](flywheels.length);\r\n    amounts = new uint256[](flywheels.length);\r\n\r\n    for (uint256 i = 0; i < flywheels.length; i++) {\r\n      IonicFlywheel fw = IonicFlywheel(flywheels[i]);\r\n      fw.accrue(ERC20(address(collateralMarket)), address(this));\r\n      fw.accrue(ERC20(address(stableMarket)), address(this));\r\n      rewardTokens[i] = fw.rewardToken();\r\n      amounts[i] = fw.rewardsAccrued(address(this));\r\n    }\r\n  }\r\n\r\n  function getCurrentLeverageRatio() public view returns (uint256) {\r\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\r\n    if (positionSupplyAmount == 0) return 0;\r\n\r\n    BasePriceOracle oracle = pool.oracle();\r\n\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n    uint256 positionValue = (collateralAssetPrice * positionSupplyAmount) / 1e18;\r\n\r\n    uint256 debtValue = 0;\r\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\r\n    if (debtAmount > 0) {\r\n      uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n      debtValue = (borrowedAssetPrice * debtAmount) / 1e18;\r\n    }\r\n\r\n    // TODO check if positionValue > debtValue\r\n    // s / ( s - b )\r\n    return (positionValue * 1e18) / (positionValue - debtValue);\r\n  }\r\n\r\n  function getMinLeverageRatio() public view returns (uint256) {\r\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\r\n    if (positionSupplyAmount == 0) return 0;\r\n\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 minStableBorrowAmount = (factory.getMinBorrowNative() * 1e18) / borrowedAssetPrice;\r\n    return _getLeverageRatioAfterBorrow(minStableBorrowAmount, positionSupplyAmount, 0);\r\n  }\r\n\r\n  function getMaxLeverageRatio() public view returns (uint256) {\r\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\r\n    if (positionSupplyAmount == 0) return 0;\r\n\r\n    uint256 maxBorrow = pool.getMaxRedeemOrBorrow(address(this), stableMarket, true);\r\n    uint256 positionBorrowAmount = stableMarket.borrowBalanceCurrent(address(this));\r\n    return _getLeverageRatioAfterBorrow(maxBorrow, positionSupplyAmount, positionBorrowAmount);\r\n  }\r\n\r\n  function _getLeverageRatioAfterBorrow(\r\n    uint256 newBorrowsAmount,\r\n    uint256 positionSupplyAmount,\r\n    uint256 positionBorrowAmount\r\n  ) internal view returns (uint256 r) {\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n\r\n    uint256 currentBorrowsValue = (positionBorrowAmount * stableAssetPrice) / 1e18;\r\n    uint256 newBorrowsValue = (newBorrowsAmount * stableAssetPrice) / 1e18;\r\n    uint256 positionValue = (positionSupplyAmount * collateralAssetPrice) / 1e18;\r\n\r\n    // accounting for swaps slippage\r\n    uint256 assumedSlippage = factory.liquidatorsRegistry().getSlippage(stableAsset, collateralAsset);\r\n    {\r\n      // add 10 bps just to not go under the min borrow value\r\n      assumedSlippage += 10;\r\n    }\r\n    uint256 topUpCollateralValue = (newBorrowsValue * 10000) / (10000 + assumedSlippage);\r\n\r\n    int256 s = int256(positionValue);\r\n    int256 b = int256(currentBorrowsValue);\r\n    int256 x = int256(topUpCollateralValue);\r\n\r\n    r = uint256(((s + x) * 1e18) / (s + x - b - int256(newBorrowsValue)));\r\n  }\r\n\r\n  function isPositionClosed() public view returns (bool) {\r\n    return collateralMarket.balanceOfUnderlying(address(this)) == 0;\r\n  }\r\n\r\n  function getEquityAmount() external view returns (uint256 equityAmount) {\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 borrowedAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\r\n    uint256 positionValue = (collateralAssetPrice * positionSupplyAmount) / 1e18;\r\n\r\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\r\n    uint256 debtValue = (borrowedAssetPrice * debtAmount) / 1e18;\r\n\r\n    uint256 equityValue = positionValue - debtValue;\r\n    equityAmount = (equityValue * 1e18) / collateralAssetPrice;\r\n  }\r\n\r\n  function getSupplyAmountDelta(uint256 targetRatio) public view returns (uint256, uint256) {\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n\r\n    uint256 currentRatio = getCurrentLeverageRatio();\r\n    bool up = targetRatio > currentRatio;\r\n    return _getSupplyAmountDelta(up, targetRatio, collateralAssetPrice, stableAssetPrice);\r\n  }\r\n\r\n  function _getSupplyAmountDelta(\r\n    bool up,\r\n    uint256 targetRatio,\r\n    uint256 collateralAssetPrice,\r\n    uint256 borrowedAssetPrice\r\n  ) internal view returns (uint256 supplyDelta, uint256 borrowsDelta) {\r\n    uint256 positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(this));\r\n    uint256 debtAmount = stableMarket.borrowBalanceCurrent(address(this));\r\n    uint256 assumedSlippage;\r\n    if (up) assumedSlippage = factory.liquidatorsRegistry().getSlippage(stableAsset, collateralAsset);\r\n    else assumedSlippage = factory.liquidatorsRegistry().getSlippage(collateralAsset, stableAsset);\r\n    uint256 slippageFactor = (1e18 * (10000 + assumedSlippage)) / 10000;\r\n\r\n    uint256 supplyValueDeltaAbs;\r\n    {\r\n      // s = supply value before\r\n      // b = borrow value before\r\n      // r = target ratio after\r\n      // c = borrow value coefficient to account for the slippage\r\n      int256 s = int256((collateralAssetPrice * positionSupplyAmount) / 1e18);\r\n      int256 b = int256((borrowedAssetPrice * debtAmount) / 1e18);\r\n      int256 r = int256(targetRatio);\r\n      int256 r1 = r - 1e18;\r\n      int256 c = int256(slippageFactor);\r\n\r\n      // some math magic here\r\n      // https://www.wolframalpha.com/input?i2d=true&i=r%3D%5C%2840%29Divide%5B%5C%2840%29s%2Bx%5C%2841%29%2C%5C%2840%29s%2Bx-b-c*x%5C%2841%29%5D+%5C%2841%29+solve+for+x\r\n\r\n      // x = supplyValueDelta\r\n      int256 supplyValueDelta = (((r1 * s) - (b * r)) * 1e18) / ((c * r) - (1e18 * r1));\r\n      supplyValueDeltaAbs = uint256((supplyValueDelta < 0) ? -supplyValueDelta : supplyValueDelta);\r\n    }\r\n\r\n    supplyDelta = (supplyValueDeltaAbs * 1e18) / collateralAssetPrice;\r\n    borrowsDelta = (supplyValueDeltaAbs * 1e18) / borrowedAssetPrice;\r\n\r\n    if (up) {\r\n      // stables to borrow = c * x\r\n      borrowsDelta = (borrowsDelta * slippageFactor) / 1e18;\r\n    } else {\r\n      // amount to redeem = c * x\r\n      supplyDelta = (supplyDelta * slippageFactor) / 1e18;\r\n    }\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                            Internal Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  function _supplyCollateral(IERC20Upgradeable fundingAsset) internal returns (uint256 amountToSupply) {\r\n    // in case the funding is with a different asset\r\n    if (address(collateralAsset) != address(fundingAsset)) {\r\n      // swap for collateral asset\r\n      convertAllTo(fundingAsset, collateralAsset);\r\n    }\r\n\r\n    // supply the collateral\r\n    amountToSupply = collateralAsset.balanceOf(address(this));\r\n    collateralAsset.approve(address(collateralMarket), amountToSupply);\r\n    uint256 errorCode = collateralMarket.mint(amountToSupply);\r\n    if (errorCode != 0) revert SupplyCollateralFailed(errorCode);\r\n  }\r\n\r\n  // @dev flash loan the needed amount, then borrow stables and swap them for the amount needed to repay the FL\r\n  function _leverUp(uint256 targetRatio) internal {\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n\r\n    (uint256 flashLoanCollateralAmount, uint256 stableToBorrow) = _getSupplyAmountDelta(\r\n      true,\r\n      targetRatio,\r\n      collateralAssetPrice,\r\n      stableAssetPrice\r\n    );\r\n\r\n    collateralMarket.flash(flashLoanCollateralAmount, abi.encode(stableToBorrow));\r\n    // the execution will first receive a callback to receiveFlashLoan()\r\n    // then it continues from here\r\n\r\n    // all stables are swapped for collateral to repay the FL\r\n    uint256 collateralLeftovers = collateralAsset.balanceOf(address(this));\r\n    if (collateralLeftovers > 0) {\r\n      collateralAsset.approve(address(collateralMarket), collateralLeftovers);\r\n      collateralMarket.mint(collateralLeftovers);\r\n    }\r\n  }\r\n\r\n  // @dev supply the flash loaned collateral and then borrow stables with it\r\n  function _leverUpPostFL(uint256 stableToBorrow) internal {\r\n    // supply the flash loaned collateral\r\n    _supplyCollateral(collateralAsset);\r\n\r\n    // borrow stables that will be swapped to repay the FL\r\n    uint256 errorCode = stableMarket.borrow(stableToBorrow);\r\n    if (errorCode != 0) revert BorrowStableFailed(errorCode);\r\n\r\n    // swap for the FL asset\r\n    convertAllTo(stableAsset, collateralAsset);\r\n  }\r\n\r\n  // @dev redeems the supplied collateral by first repaying the debt with which it was levered\r\n  function _leverDown(uint256 targetRatio) internal {\r\n    uint256 amountToRedeem;\r\n    uint256 borrowsToRepay;\r\n\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(collateralMarket);\r\n\r\n    if (targetRatio <= 1e18) {\r\n      // if max levering down, then derive the amount to redeem from the debt to be repaid\r\n      borrowsToRepay = stableMarket.borrowBalanceCurrent(address(this));\r\n      uint256 borrowsToRepayValueScaled = borrowsToRepay * stableAssetPrice;\r\n      // accounting for swaps slippage\r\n      uint256 assumedSlippage = factory.liquidatorsRegistry().getSlippage(collateralAsset, stableAsset);\r\n      uint256 amountToRedeemValueScaled = (borrowsToRepayValueScaled * (10000 + assumedSlippage)) / 10000;\r\n      amountToRedeem = amountToRedeemValueScaled / collateralAssetPrice;\r\n      // round up when dividing in order to redeem enough (otherwise calcs could be exploited)\r\n      if (amountToRedeemValueScaled % collateralAssetPrice > 0) amountToRedeem += 1;\r\n    } else {\r\n      // else derive the debt to be repaid from the amount to redeem\r\n      (amountToRedeem, borrowsToRepay) = _getSupplyAmountDelta(\r\n        false,\r\n        targetRatio,\r\n        collateralAssetPrice,\r\n        stableAssetPrice\r\n      );\r\n      // the slippage is already accounted for in _getSupplyAmountDelta\r\n    }\r\n\r\n    if (borrowsToRepay > 0) {\r\n      ICErc20(address(stableMarket)).flash(borrowsToRepay, abi.encode(amountToRedeem));\r\n      // the execution will first receive a callback to receiveFlashLoan()\r\n      // then it continues from here\r\n    }\r\n\r\n    // all the redeemed collateral is swapped for stables to repay the FL\r\n    uint256 stableLeftovers = stableAsset.balanceOf(address(this));\r\n    if (stableLeftovers > 0) {\r\n      uint256 borrowBalance = stableMarket.borrowBalanceCurrent(address(this));\r\n      if (borrowBalance > 0) {\r\n        // whatever is smaller\r\n        uint256 amountToRepay = borrowBalance > stableLeftovers ? stableLeftovers : borrowBalance;\r\n        stableAsset.approve(address(stableMarket), amountToRepay);\r\n        stableMarket.repayBorrow(amountToRepay);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _leverDownPostFL(uint256 _flashLoanedCollateral, uint256 _amountToRedeem) internal {\r\n    // repay the borrows\r\n    uint256 borrowBalance = stableMarket.borrowBalanceCurrent(address(this));\r\n    uint256 repayAmount = _flashLoanedCollateral < borrowBalance ? _flashLoanedCollateral : borrowBalance;\r\n    stableAsset.approve(address(stableMarket), repayAmount);\r\n    uint256 errorCode = stableMarket.repayBorrow(repayAmount);\r\n    if (errorCode != 0) revert RepayBorrowFailed(errorCode);\r\n\r\n    // redeem the corresponding amount needed to repay the FL\r\n    errorCode = collateralMarket.redeemUnderlying(_amountToRedeem);\r\n    if (errorCode != 0) revert RedeemCollateralFailed(errorCode);\r\n\r\n    // swap for the FL asset\r\n    convertAllTo(collateralAsset, stableAsset);\r\n  }\r\n\r\n  function convertAllTo(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) private returns (uint256 outputAmount) {\r\n    uint256 inputAmount = inputToken.balanceOf(address(this));\r\n    (IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategiesData) = factory\r\n      .getRedemptionStrategies(inputToken, outputToken);\r\n\r\n    if (redemptionStrategies.length == 0) revert ConvertFundsFailed();\r\n\r\n    for (uint256 i = 0; i < redemptionStrategies.length; i++) {\r\n      IRedemptionStrategy redemptionStrategy = redemptionStrategies[i];\r\n      bytes memory strategyData = strategiesData[i];\r\n      (outputToken, outputAmount) = convertCustomFunds(inputToken, inputAmount, redemptionStrategy, strategyData);\r\n      inputAmount = outputAmount;\r\n      inputToken = outputToken;\r\n    }\r\n  }\r\n\r\n  function convertCustomFunds(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IRedemptionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.redeem.selector, inputToken, inputAmount, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\r\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\r\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\r\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\r\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\r\nimport { DiamondBase, DiamondExtension, LibDiamond } from \"../../ionic/DiamondExtension.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\ncontract LeveredPositionFactory is LeveredPositionFactoryStorage, DiamondBase {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  /*----------------------------------------------------------------\r\n                            Constructor\r\n  ----------------------------------------------------------------*/\r\n\r\n  constructor(IFeeDistributor _feeDistributor, ILiquidatorsRegistry _registry, uint256 _blocksPerYear) {\r\n    feeDistributor = _feeDistributor;\r\n    liquidatorsRegistry = _registry;\r\n    blocksPerYear = _blocksPerYear;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                            Admin Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  function _setPairWhitelisted(ICErc20 _collateralMarket, ICErc20 _stableMarket, bool _whitelisted) external onlyOwner {\r\n    require(_collateralMarket.comptroller() == _stableMarket.comptroller(), \"markets not of the same pool\");\r\n\r\n    if (_whitelisted) {\r\n      collateralMarkets.add(address(_collateralMarket));\r\n      borrowableMarketsByCollateral[_collateralMarket].add(address(_stableMarket));\r\n    } else {\r\n      borrowableMarketsByCollateral[_collateralMarket].remove(address(_stableMarket));\r\n      if (borrowableMarketsByCollateral[_collateralMarket].length() == 0)\r\n        collateralMarkets.remove(address(_collateralMarket));\r\n    }\r\n  }\r\n\r\n  function _setLiquidatorsRegistry(ILiquidatorsRegistry _liquidatorsRegistry) external onlyOwner {\r\n    liquidatorsRegistry = _liquidatorsRegistry;\r\n  }\r\n\r\n  function _registerExtension(\r\n    DiamondExtension extensionToAdd,\r\n    DiamondExtension extensionToReplace\r\n  ) public override onlyOwner {\r\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionFactoryFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../../ionic/DiamondExtension.sol\";\r\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\r\nimport { ILeveredPositionFactoryFirstExtension } from \"./ILeveredPositionFactory.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\r\nimport { IComptroller, IPriceOracle } from \"../../external/compound/IComptroller.sol\";\r\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\r\nimport { AuthoritiesRegistry } from \"../AuthoritiesRegistry.sol\";\r\nimport { PoolRolesAuthority } from \"../PoolRolesAuthority.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\ncontract LeveredPositionFactoryFirstExtension is\r\n  LeveredPositionFactoryStorage,\r\n  DiamondExtension,\r\n  ILeveredPositionFactoryFirstExtension\r\n{\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  error PairNotWhitelisted();\r\n  error NoSuchPosition();\r\n  error PositionNotClosed();\r\n\r\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 10;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.removeClosedPosition.selector;\r\n    functionSelectors[--fnsCount] = this.closeAndRemoveUserPosition.selector;\r\n    functionSelectors[--fnsCount] = this.getMinBorrowNative.selector;\r\n    functionSelectors[--fnsCount] = this.getRedemptionStrategies.selector;\r\n    functionSelectors[--fnsCount] = this.getBorrowableMarketsByCollateral.selector;\r\n    functionSelectors[--fnsCount] = this.getWhitelistedCollateralMarkets.selector;\r\n    functionSelectors[--fnsCount] = this.getAccountsWithOpenPositions.selector;\r\n    functionSelectors[--fnsCount] = this.getPositionsByAccount.selector;\r\n    functionSelectors[--fnsCount] = this.getPositionsExtension.selector;\r\n    functionSelectors[--fnsCount] = this._setPositionsExtension.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                          Mutable Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  // @return true if removed, otherwise false\r\n  function removeClosedPosition(address closedPosition) external returns (bool) {\r\n    return _removeClosedPosition(closedPosition, msg.sender);\r\n  }\r\n\r\n  function closeAndRemoveUserPosition(LeveredPosition position) external onlyOwner returns (bool) {\r\n    address positionOwner = position.positionOwner();\r\n    position.closePosition(positionOwner);\r\n    return _removeClosedPosition(address(position), positionOwner);\r\n  }\r\n\r\n  function _removeClosedPosition(address closedPosition, address positionOwner) internal returns (bool removed) {\r\n    EnumerableSet.AddressSet storage userPositions = positionsByAccount[positionOwner];\r\n    if (!userPositions.contains(closedPosition)) revert NoSuchPosition();\r\n    if (!LeveredPosition(closedPosition).isPositionClosed()) revert PositionNotClosed();\r\n\r\n    removed = userPositions.remove(closedPosition);\r\n    if (userPositions.length() == 0) accountsWithOpenPositions.remove(positionOwner);\r\n  }\r\n\r\n  function _setPositionsExtension(bytes4 msgSig, address extension) external onlyOwner {\r\n    _positionsExtensions[msgSig] = extension;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                            View Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  function getMinBorrowNative() external view returns (uint256) {\r\n    return feeDistributor.minBorrowEth();\r\n  }\r\n\r\n  function getRedemptionStrategies(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData) {\r\n    return liquidatorsRegistry.getRedemptionStrategies(inputToken, outputToken);\r\n  }\r\n\r\n  function getPositionsByAccount(\r\n    address account\r\n  ) external view returns (address[] memory positions, bool[] memory closed) {\r\n    positions = positionsByAccount[account].values();\r\n    closed = new bool[](positions.length);\r\n    for (uint256 i = 0; i < positions.length; i++) {\r\n      closed[i] = LeveredPosition(positions[i]).isPositionClosed();\r\n    }\r\n  }\r\n\r\n  function getAccountsWithOpenPositions() external view returns (address[] memory) {\r\n    return accountsWithOpenPositions.values();\r\n  }\r\n\r\n  function getWhitelistedCollateralMarkets() external view returns (address[] memory) {\r\n    return collateralMarkets.values();\r\n  }\r\n\r\n  function getBorrowableMarketsByCollateral(ICErc20 _collateralMarket) external view returns (address[] memory) {\r\n    return borrowableMarketsByCollateral[_collateralMarket].values();\r\n  }\r\n\r\n  function getPositionsExtension(bytes4 msgSig) external view returns (address) {\r\n    return _positionsExtensions[msgSig];\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionFactorySecondExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../../ionic/DiamondExtension.sol\";\r\nimport { LeveredPositionFactoryStorage } from \"./LeveredPositionFactoryStorage.sol\";\r\nimport { ILeveredPositionFactorySecondExtension } from \"./ILeveredPositionFactory.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\r\nimport { IComptroller, IPriceOracle } from \"../../external/compound/IComptroller.sol\";\r\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\r\nimport { AuthoritiesRegistry } from \"../AuthoritiesRegistry.sol\";\r\nimport { PoolRolesAuthority } from \"../PoolRolesAuthority.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\ncontract LeveredPositionFactorySecondExtension is\r\n  LeveredPositionFactoryStorage,\r\n  DiamondExtension,\r\n  ILeveredPositionFactorySecondExtension\r\n{\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  error PairNotWhitelisted();\r\n\r\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 3;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.createPosition.selector;\r\n    functionSelectors[--fnsCount] = this.createAndFundPosition.selector;\r\n    functionSelectors[--fnsCount] = this.createAndFundPositionAtRatio.selector;\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                          Mutable Functions\r\n  ----------------------------------------------------------------*/\r\n\r\n  function createPosition(ICErc20 _collateralMarket, ICErc20 _stableMarket) public returns (LeveredPosition) {\r\n    if (!borrowableMarketsByCollateral[_collateralMarket].contains(address(_stableMarket))) revert PairNotWhitelisted();\r\n\r\n    LeveredPosition position = new LeveredPosition(msg.sender, _collateralMarket, _stableMarket);\r\n\r\n    accountsWithOpenPositions.add(msg.sender);\r\n    positionsByAccount[msg.sender].add(address(position));\r\n\r\n    AuthoritiesRegistry authoritiesRegistry = feeDistributor.authoritiesRegistry();\r\n    address poolAddress = address(_collateralMarket.comptroller());\r\n    PoolRolesAuthority poolAuth = authoritiesRegistry.poolsAuthorities(poolAddress);\r\n    if (address(poolAuth) != address(0)) {\r\n      authoritiesRegistry.setUserRole(poolAddress, address(position), poolAuth.LEVERED_POSITION_ROLE(), true);\r\n    }\r\n\r\n    return position;\r\n  }\r\n\r\n  function createAndFundPosition(\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    IERC20Upgradeable _fundingAsset,\r\n    uint256 _fundingAmount\r\n  ) public returns (LeveredPosition) {\r\n    LeveredPosition position = createPosition(_collateralMarket, _stableMarket);\r\n    _fundingAsset.safeTransferFrom(msg.sender, address(this), _fundingAmount);\r\n    _fundingAsset.approve(address(position), _fundingAmount);\r\n    position.fundPosition(_fundingAsset, _fundingAmount);\r\n    return position;\r\n  }\r\n\r\n  function createAndFundPositionAtRatio(\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    IERC20Upgradeable _fundingAsset,\r\n    uint256 _fundingAmount,\r\n    uint256 _leverageRatio\r\n  ) external returns (LeveredPosition) {\r\n    LeveredPosition position = createAndFundPosition(_collateralMarket, _stableMarket, _fundingAsset, _fundingAmount);\r\n    if (_leverageRatio > 1e18) {\r\n      position.adjustLeverageRatio(_leverageRatio);\r\n    }\r\n    return position;\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport { SafeOwnable } from \"../../ionic/SafeOwnable.sol\";\r\nimport { IFeeDistributor } from \"../../compound/IFeeDistributor.sol\";\r\nimport { ILiquidatorsRegistry } from \"../../liquidators/registry/ILiquidatorsRegistry.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nabstract contract LeveredPositionFactoryStorage is SafeOwnable {\r\n  EnumerableSet.AddressSet internal accountsWithOpenPositions;\r\n  mapping(address => EnumerableSet.AddressSet) internal positionsByAccount;\r\n  EnumerableSet.AddressSet internal collateralMarkets;\r\n  mapping(ICErc20 => EnumerableSet.AddressSet) internal borrowableMarketsByCollateral;\r\n\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) private __unused;\r\n\r\n  IFeeDistributor public feeDistributor;\r\n  ILiquidatorsRegistry public liquidatorsRegistry;\r\n  uint256 public blocksPerYear;\r\n\r\n  mapping(bytes4 => address) internal _positionsExtensions;\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionsLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\r\nimport { LeveredPosition } from \"./LeveredPosition.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\r\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\r\nimport { Initializable } from \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\ncontract LeveredPositionsLens is Initializable {\r\n  ILeveredPositionFactory public factory;\r\n\r\n  function initialize(ILeveredPositionFactory _factory) external initializer {\r\n    factory = _factory;\r\n  }\r\n\r\n  function reinitialize(ILeveredPositionFactory _factory) external reinitializer(2) {\r\n    factory = _factory;\r\n  }\r\n\r\n  /// @notice this is a lens fn, it is not intended to be used on-chain\r\n  /// @dev returns lists of the market addresses, names and symbols of the underlying assets of those collateral markets that are whitelisted\r\n  function getCollateralMarkets()\r\n    external\r\n    view\r\n    returns (\r\n      address[] memory markets,\r\n      IonicComptroller[] memory poolOfMarket,\r\n      address[] memory underlyings,\r\n      uint256[] memory underlyingPrices,\r\n      string[] memory names,\r\n      string[] memory symbols,\r\n      uint8[] memory decimals,\r\n      uint256[] memory totalUnderlyingSupplied,\r\n      uint256[] memory ratesPerBlock\r\n    )\r\n  {\r\n    markets = factory.getWhitelistedCollateralMarkets();\r\n    poolOfMarket = new IonicComptroller[](markets.length);\r\n    underlyings = new address[](markets.length);\r\n    underlyingPrices = new uint256[](markets.length);\r\n    names = new string[](markets.length);\r\n    symbols = new string[](markets.length);\r\n    totalUnderlyingSupplied = new uint256[](markets.length);\r\n    decimals = new uint8[](markets.length);\r\n    ratesPerBlock = new uint256[](markets.length);\r\n    for (uint256 i = 0; i < markets.length; i++) {\r\n      ICErc20 market = ICErc20(markets[i]);\r\n      poolOfMarket[i] = market.comptroller();\r\n      underlyingPrices[i] = BasePriceOracle(poolOfMarket[i].oracle()).getUnderlyingPrice(market);\r\n      underlyings[i] = market.underlying();\r\n      ERC20Upgradeable underlying = ERC20Upgradeable(underlyings[i]);\r\n      names[i] = underlying.name();\r\n      symbols[i] = underlying.symbol();\r\n      decimals[i] = underlying.decimals();\r\n      totalUnderlyingSupplied[i] = market.getTotalUnderlyingSupplied();\r\n      ratesPerBlock[i] = market.supplyRatePerBlock();\r\n    }\r\n  }\r\n\r\n  /// @notice this is a lens fn, it is not intended to be used on-chain\r\n  /// @dev returns the Rate for the chosen borrowable at the specified leverage ratio and supply amount\r\n  function getBorrowRateAtRatio(\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    uint256 _equityAmount,\r\n    uint256 _targetLeverageRatio\r\n  ) external view returns (uint256) {\r\n    IonicComptroller pool = IonicComptroller(_stableMarket.comptroller());\r\n    BasePriceOracle oracle = pool.oracle();\r\n    uint256 stableAssetPrice = oracle.getUnderlyingPrice(_stableMarket);\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(_collateralMarket);\r\n\r\n    uint256 borrowAmount = ((_targetLeverageRatio - 1e18) * _equityAmount * collateralAssetPrice) /\r\n      (stableAssetPrice * 1e18);\r\n    return _stableMarket.borrowRatePerBlockAfterBorrow(borrowAmount) * factory.blocksPerYear();\r\n  }\r\n\r\n  /// @notice this is a lens fn, it is not intended to be used on-chain\r\n  /// @dev returns lists of the market addresses, names, symbols and the current Rate for each Borrowable asset\r\n  function getBorrowableMarketsAndRates(\r\n    ICErc20 _collateralMarket\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address[] memory markets,\r\n      address[] memory underlyings,\r\n      uint256[] memory underlyingsPrices,\r\n      string[] memory names,\r\n      string[] memory symbols,\r\n      uint256[] memory rates,\r\n      uint8[] memory decimals\r\n    )\r\n  {\r\n    markets = factory.getBorrowableMarketsByCollateral(_collateralMarket);\r\n    underlyings = new address[](markets.length);\r\n    names = new string[](markets.length);\r\n    symbols = new string[](markets.length);\r\n    rates = new uint256[](markets.length);\r\n    decimals = new uint8[](markets.length);\r\n    underlyingsPrices = new uint256[](markets.length);\r\n    for (uint256 i = 0; i < markets.length; i++) {\r\n      ICErc20 market = ICErc20(markets[i]);\r\n      address underlyingAddress = market.underlying();\r\n      underlyings[i] = underlyingAddress;\r\n      ERC20Upgradeable underlying = ERC20Upgradeable(underlyingAddress);\r\n      names[i] = underlying.name();\r\n      symbols[i] = underlying.symbol();\r\n      rates[i] = market.borrowRatePerBlock();\r\n      decimals[i] = underlying.decimals();\r\n      underlyingsPrices[i] = market.comptroller().oracle().getUnderlyingPrice(market);\r\n    }\r\n  }\r\n\r\n  /// @notice this is a lens fn, it is not intended to be used on-chain\r\n  function getNetAPY(\r\n    uint256 _supplyAPY,\r\n    uint256 _supplyAmount,\r\n    ICErc20 _collateralMarket,\r\n    ICErc20 _stableMarket,\r\n    uint256 _targetLeverageRatio\r\n  ) public view returns (int256 netAPY) {\r\n    if (_supplyAmount == 0 || _targetLeverageRatio <= 1e18) return 0;\r\n\r\n    IonicComptroller pool = IonicComptroller(_collateralMarket.comptroller());\r\n    BasePriceOracle oracle = pool.oracle();\r\n    // TODO the calcs can be implemented without using collateralAssetPrice\r\n    uint256 collateralAssetPrice = oracle.getUnderlyingPrice(_collateralMarket);\r\n\r\n    // total collateral = base collateral + levered collateral\r\n    uint256 totalCollateral = (_supplyAmount * _targetLeverageRatio) / 1e18;\r\n    uint256 yieldFromTotalSupplyScaled = _supplyAPY * totalCollateral;\r\n    int256 yieldValueScaled = int256((yieldFromTotalSupplyScaled * collateralAssetPrice) / 1e18);\r\n\r\n    uint256 borrowedValueScaled = (totalCollateral - _supplyAmount) * collateralAssetPrice;\r\n    uint256 _borrowRate = _stableMarket.borrowRatePerBlock() * factory.blocksPerYear();\r\n    int256 borrowInterestValueScaled = int256((_borrowRate * borrowedValueScaled) / 1e18);\r\n\r\n    int256 netValueDiffScaled = yieldValueScaled - borrowInterestValueScaled;\r\n\r\n    netAPY = ((netValueDiffScaled / int256(collateralAssetPrice)) * 1e18) / int256(_supplyAmount);\r\n  }\r\n\r\n  function getPositionsInfo(\r\n    LeveredPosition[] calldata positions,\r\n    uint256[] calldata supplyApys\r\n  ) external view returns (PositionInfo[] memory infos) {\r\n    infos = new PositionInfo[](positions.length);\r\n    for (uint256 i = 0; i < positions.length; i++) {\r\n      infos[i] = getPositionInfo(positions[i], supplyApys[i]);\r\n    }\r\n  }\r\n\r\n  function getLeverageRatioAfterFunding(LeveredPosition pos, uint256 newFunding) public view returns (uint256) {\r\n    uint256 equityAmount = pos.getEquityAmount();\r\n    if (equityAmount == 0 && newFunding == 0) return 0;\r\n\r\n    uint256 suppliedCollateralCurrent = pos.collateralMarket().balanceOfUnderlying(address(pos));\r\n    return ((suppliedCollateralCurrent + newFunding) * 1e18) / (equityAmount + newFunding);\r\n  }\r\n\r\n  function getNetApyForPositionAfterFunding(\r\n    LeveredPosition pos,\r\n    uint256 supplyAPY,\r\n    uint256 newFunding\r\n  ) public view returns (int256) {\r\n    return\r\n      getNetAPY(\r\n        supplyAPY,\r\n        pos.getEquityAmount() + newFunding,\r\n        pos.collateralMarket(),\r\n        pos.stableMarket(),\r\n        getLeverageRatioAfterFunding(pos, newFunding)\r\n      );\r\n  }\r\n\r\n  function getNetApyForPosition(LeveredPosition pos, uint256 supplyAPY) public view returns (int256) {\r\n    return getNetApyForPositionAfterFunding(pos, supplyAPY, 0);\r\n  }\r\n\r\n  struct PositionInfo {\r\n    uint256 collateralAssetPrice;\r\n    uint256 borrowedAssetPrice;\r\n    uint256 positionSupplyAmount;\r\n    uint256 positionValue;\r\n    uint256 debtAmount;\r\n    uint256 debtValue;\r\n    uint256 equityAmount;\r\n    uint256 equityValue;\r\n    int256 currentApy;\r\n    uint256 debtRatio;\r\n    uint256 liquidationThreshold;\r\n    uint256 safetyBuffer;\r\n  }\r\n\r\n  function getPositionInfo(LeveredPosition pos, uint256 supplyApy) public view returns (PositionInfo memory info) {\r\n    ICErc20 collateralMarket = pos.collateralMarket();\r\n    IonicComptroller pool = pos.pool();\r\n    info.collateralAssetPrice = pool.oracle().getUnderlyingPrice(collateralMarket);\r\n    {\r\n      info.positionSupplyAmount = collateralMarket.balanceOfUnderlying(address(pos));\r\n      info.positionValue = (info.collateralAssetPrice * info.positionSupplyAmount) / 1e18;\r\n      info.currentApy = getNetApyForPosition(pos, supplyApy);\r\n    }\r\n\r\n    {\r\n      ICErc20 stableMarket = pos.stableMarket();\r\n      info.borrowedAssetPrice = pool.oracle().getUnderlyingPrice(stableMarket);\r\n      info.debtAmount = stableMarket.borrowBalanceCurrent(address(pos));\r\n      info.debtValue = (info.borrowedAssetPrice * info.debtAmount) / 1e18;\r\n      info.equityValue = info.positionValue - info.debtValue;\r\n      info.debtRatio = info.positionValue == 0 ? 0 : (info.debtValue * 1e18) / info.positionValue;\r\n      info.equityAmount = (info.equityValue * 1e18) / info.collateralAssetPrice;\r\n    }\r\n\r\n    {\r\n      (, uint256 collateralFactor) = pool.markets(address(collateralMarket));\r\n      info.liquidationThreshold = collateralFactor;\r\n      info.safetyBuffer = collateralFactor - info.debtRatio;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/levered/LeveredPositionStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport { ILeveredPositionFactory } from \"./ILeveredPositionFactory.sol\";\r\nimport { IonicComptroller } from \"../../compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ncontract LeveredPositionStorage {\r\n  address public immutable positionOwner;\r\n  ILeveredPositionFactory public factory;\r\n\r\n  ICErc20 public collateralMarket;\r\n  ICErc20 public stableMarket;\r\n  IonicComptroller public pool;\r\n\r\n  IERC20Upgradeable public collateralAsset;\r\n  IERC20Upgradeable public stableAsset;\r\n\r\n  constructor(address _positionOwner) {\r\n    positionOwner = _positionOwner;\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/MorphoBribeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { IBribeRewards } from \"../veION/interfaces/IBribeRewards.sol\";\r\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title MorphoBribeDistributor\r\n * @dev This contract handles the distribution of bribe tokens to the Morpho protocol.\r\n */\r\ncontract MorphoBribeDistributor is OwnableUpgradeable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @notice Address of the Morpho market\r\n  address public morphoMarket;\r\n  /// @notice Address of the Morpho bribes contract\r\n  address public morphoBribes;\r\n\r\n  event Initialized(address indexed morphoMarket, address indexed morphoBribes);\r\n  event Distributed(address indexed from, uint256 amount);\r\n  event MorphoMarketSet(address indexed newMorphoMarket);\r\n  event MorphoBribesSet(address indexed newMorphoBribes);\r\n  event BribeTokenSet(address indexed newBribeToken);\r\n\r\n  /**\r\n   * @dev Modifier to restrict access to only the Morpho market\r\n   */\r\n  modifier onlyMorphoMarket() {\r\n    require(msg.sender == morphoMarket, \"Caller is not the Morpho Market\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes the MorphoBribeDistributor contract\r\n   * @param _morphoMarket Address of the Morpho market\r\n   * @param _morphoBribes Address of the Morpho bribes contract\r\n   */\r\n  function initialize(address _morphoMarket, address _morphoBribes) public initializer {\r\n    __Ownable_init();\r\n    morphoMarket = _morphoMarket;\r\n    morphoBribes = _morphoBribes;\r\n    emit Initialized(_morphoMarket, _morphoBribes);\r\n  }\r\n\r\n  /**\r\n   * @notice Distributes bribe tokens to the Morpho bribes contract\r\n   * @param _amount Amount of tokens to distribute\r\n   */\r\n  function distribute(address _rewardToken, uint256 _amount) external onlyMorphoMarket {\r\n    IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n    IERC20(_rewardToken).approve(morphoBribes, _amount);\r\n    IBribeRewards(morphoBribes).notifyRewardAmount(_rewardToken, _amount);\r\n    emit Distributed(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the address of the Morpho market\r\n   * @param _morphoMarket New address of the Morpho market\r\n   */\r\n  function setMorphoMarket(address _morphoMarket) external onlyOwner {\r\n    morphoMarket = _morphoMarket;\r\n    emit MorphoMarketSet(_morphoMarket);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the address of the Morpho bribes contract\r\n   * @param _morphoBribes New address of the Morpho bribes contract\r\n   */\r\n  function setMorphoBribes(address _morphoBribes) external onlyOwner {\r\n    morphoBribes = _morphoBribes;\r\n    emit MorphoBribesSet(_morphoBribes);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/PoolRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { IonicComptroller, ComptrollerInterface } from \"../compound/ComptrollerInterface.sol\";\r\nimport { ICErc20, CTokenSecondExtensionInterface, CTokenFirstExtensionInterface } from \"../compound/CTokenInterfaces.sol\";\r\n\r\nimport { RolesAuthority, Authority } from \"solmate/auth/authorities/RolesAuthority.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\n\r\ncontract PoolRolesAuthority is RolesAuthority, Initializable {\r\n  constructor() RolesAuthority(address(0), Authority(address(0))) {\r\n    _disableInitializers();\r\n  }\r\n\r\n  function initialize(address _owner) public initializer {\r\n    owner = _owner;\r\n    authority = this;\r\n  }\r\n\r\n  // up to 256 roles\r\n  uint8 public constant REGISTRY_ROLE = 0;\r\n  uint8 public constant SUPPLIER_ROLE = 1;\r\n  uint8 public constant BORROWER_ROLE = 2;\r\n  uint8 public constant LIQUIDATOR_ROLE = 3;\r\n  uint8 public constant LEVERED_POSITION_ROLE = 4;\r\n\r\n  function configureRegistryCapabilities() external requiresAuth {\r\n    setRoleCapability(REGISTRY_ROLE, address(this), PoolRolesAuthority.configureRegistryCapabilities.selector, true);\r\n    setRoleCapability(\r\n      REGISTRY_ROLE,\r\n      address(this),\r\n      PoolRolesAuthority.configurePoolSupplierCapabilities.selector,\r\n      true\r\n    );\r\n    setRoleCapability(\r\n      REGISTRY_ROLE,\r\n      address(this),\r\n      PoolRolesAuthority.configurePoolBorrowerCapabilities.selector,\r\n      true\r\n    );\r\n    setRoleCapability(\r\n      REGISTRY_ROLE,\r\n      address(this),\r\n      PoolRolesAuthority.configureClosedPoolLiquidatorCapabilities.selector,\r\n      true\r\n    );\r\n    setRoleCapability(\r\n      REGISTRY_ROLE,\r\n      address(this),\r\n      PoolRolesAuthority.configureOpenPoolLiquidatorCapabilities.selector,\r\n      true\r\n    );\r\n    setRoleCapability(\r\n      REGISTRY_ROLE,\r\n      address(this),\r\n      PoolRolesAuthority.configureLeveredPositionCapabilities.selector,\r\n      true\r\n    );\r\n    setRoleCapability(REGISTRY_ROLE, address(this), RolesAuthority.setUserRole.selector, true);\r\n  }\r\n\r\n  function openPoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\r\n    _setPublicPoolSupplierCapabilities(pool, true);\r\n  }\r\n\r\n  function closePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\r\n    _setPublicPoolSupplierCapabilities(pool, false);\r\n  }\r\n\r\n  function _setPublicPoolSupplierCapabilities(IonicComptroller pool, bool setPublic) internal {\r\n    setPublicCapability(address(pool), pool.enterMarkets.selector, setPublic);\r\n    setPublicCapability(address(pool), pool.exitMarket.selector, setPublic);\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      bytes4[] memory selectors = getSupplierMarketSelectors();\r\n      for (uint256 j = 0; j < selectors.length; j++) {\r\n        setPublicCapability(address(allMarkets[i]), selectors[j], setPublic);\r\n      }\r\n    }\r\n  }\r\n\r\n  function configurePoolSupplierCapabilities(IonicComptroller pool) external requiresAuth {\r\n    _configurePoolSupplierCapabilities(pool, SUPPLIER_ROLE);\r\n  }\r\n\r\n  function getSupplierMarketSelectors() internal pure returns (bytes4[] memory selectors) {\r\n    uint8 fnsCount = 6;\r\n    selectors = new bytes4[](fnsCount);\r\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.mint.selector;\r\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeem.selector;\r\n    selectors[--fnsCount] = CTokenSecondExtensionInterface.redeemUnderlying.selector;\r\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transfer.selector;\r\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.transferFrom.selector;\r\n    selectors[--fnsCount] = CTokenFirstExtensionInterface.approve.selector;\r\n\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return selectors;\r\n  }\r\n\r\n  function _configurePoolSupplierCapabilities(IonicComptroller pool, uint8 role) internal {\r\n    setRoleCapability(role, address(pool), pool.enterMarkets.selector, true);\r\n    setRoleCapability(role, address(pool), pool.exitMarket.selector, true);\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      bytes4[] memory selectors = getSupplierMarketSelectors();\r\n      for (uint256 j = 0; j < selectors.length; j++) {\r\n        setRoleCapability(role, address(allMarkets[i]), selectors[j], true);\r\n      }\r\n    }\r\n  }\r\n\r\n  function openPoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\r\n    _setPublicPoolBorrowerCapabilities(pool, true);\r\n  }\r\n\r\n  function closePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\r\n    _setPublicPoolBorrowerCapabilities(pool, false);\r\n  }\r\n\r\n  function _setPublicPoolBorrowerCapabilities(IonicComptroller pool, bool setPublic) internal {\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].borrow.selector, setPublic);\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrow.selector, setPublic);\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, setPublic);\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].flash.selector, setPublic);\r\n    }\r\n  }\r\n\r\n  function configurePoolBorrowerCapabilities(IonicComptroller pool) external requiresAuth {\r\n    // borrowers have the SUPPLIER_ROLE capabilities by default\r\n    _configurePoolSupplierCapabilities(pool, BORROWER_ROLE);\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\r\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\r\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrowBehalf.selector, true);\r\n      setRoleCapability(BORROWER_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\r\n    }\r\n  }\r\n\r\n  function configureClosedPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, false);\r\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\r\n      setRoleCapability(LIQUIDATOR_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\r\n    }\r\n  }\r\n\r\n  function configureOpenPoolLiquidatorCapabilities(IonicComptroller pool) external requiresAuth {\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].liquidateBorrow.selector, true);\r\n      // TODO this leaves redeeming open for everyone\r\n      setPublicCapability(address(allMarkets[i]), allMarkets[i].redeem.selector, true);\r\n    }\r\n  }\r\n\r\n  function configureLeveredPositionCapabilities(IonicComptroller pool) external requiresAuth {\r\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.enterMarkets.selector, true);\r\n    setRoleCapability(LEVERED_POSITION_ROLE, address(pool), pool.exitMarket.selector, true);\r\n    ICErc20[] memory allMarkets = pool.getAllMarkets();\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].mint.selector, true);\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeem.selector, true);\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].redeemUnderlying.selector, true);\r\n\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].borrow.selector, true);\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].repayBorrow.selector, true);\r\n      setRoleCapability(LEVERED_POSITION_ROLE, address(allMarkets[i]), allMarkets[i].flash.selector, true);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\r\n\r\nabstract contract SafeOwnable is Ownable2Step {\r\n  function renounceOwnership() public override onlyOwner {\r\n    revert(\"renounce ownership not allowed\");\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/SafeOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @dev Ownable extension that requires a two-step process of setting the pending owner and the owner accepting it.\r\n * @notice Existing OwnableUpgradeable contracts cannot be upgraded due to the extra storage variable\r\n * that will shift the other.\r\n */\r\nabstract contract SafeOwnableUpgradeable is OwnableUpgradeable {\r\n  /**\r\n   * @notice Pending owner of this contract\r\n   */\r\n  address public pendingOwner;\r\n\r\n  function __SafeOwnable_init(address owner_) internal onlyInitializing {\r\n    __Ownable_init();\r\n    _transferOwnership(owner_);\r\n  }\r\n\r\n  struct AddressSlot {\r\n    address value;\r\n  }\r\n\r\n  modifier onlyOwnerOrAdmin() {\r\n    bool isOwner = owner() == _msgSender();\r\n    if (!isOwner) {\r\n      address admin = _getProxyAdmin();\r\n      bool isAdmin = admin == _msgSender();\r\n      require(isAdmin, \"Ownable: caller is neither the owner nor the admin\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Emitted when pendingOwner is changed\r\n   */\r\n  event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\r\n\r\n  /**\r\n   * @notice Emitted when pendingOwner is accepted, which means owner is updated\r\n   */\r\n  event NewOwner(address oldOwner, address newOwner);\r\n\r\n  /**\r\n   * @notice Begins transfer of owner rights. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\r\n   * @dev Owner function to begin change of owner. The newPendingOwner must call `_acceptOwner` to finalize the transfer.\r\n   * @param newPendingOwner New pending owner.\r\n   */\r\n  function _setPendingOwner(address newPendingOwner) public onlyOwner {\r\n    // Save current value, if any, for inclusion in log\r\n    address oldPendingOwner = pendingOwner;\r\n\r\n    // Store pendingOwner with value newPendingOwner\r\n    pendingOwner = newPendingOwner;\r\n\r\n    // Emit NewPendingOwner(oldPendingOwner, newPendingOwner)\r\n    emit NewPendingOwner(oldPendingOwner, newPendingOwner);\r\n  }\r\n\r\n  /**\r\n   * @notice Accepts transfer of owner rights. msg.sender must be pendingOwner\r\n   * @dev Owner function for pending owner to accept role and update owner\r\n   */\r\n  function _acceptOwner() public {\r\n    // Check caller is pendingOwner and pendingOwner ≠ address(0)\r\n    require(msg.sender == pendingOwner, \"not the pending owner\");\r\n\r\n    // Save current values for inclusion in log\r\n    address oldOwner = owner();\r\n    address oldPendingOwner = pendingOwner;\r\n\r\n    // Store owner with value pendingOwner\r\n    _transferOwnership(pendingOwner);\r\n\r\n    // Clear the pending value\r\n    pendingOwner = address(0);\r\n\r\n    emit NewOwner(oldOwner, pendingOwner);\r\n    emit NewPendingOwner(oldPendingOwner, pendingOwner);\r\n  }\r\n\r\n  function renounceOwnership() public override onlyOwner {\r\n    // do not remove this overriding fn\r\n    revert(\"not used anymore\");\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public override onlyOwner {\r\n    emit NewPendingOwner(pendingOwner, newOwner);\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  function _getProxyAdmin() internal view returns (address admin) {\r\n    bytes32 _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n    AddressSlot storage adminSlot;\r\n    assembly {\r\n      adminSlot.slot := _ADMIN_SLOT\r\n    }\r\n    admin = adminSlot.value;\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IFlywheelBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\r\n\r\n/**\r\n @title Balance Booster Module for Flywheel\r\n @notice Flywheel is a general framework for managing token incentives.\r\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\r\n\r\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \r\n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\r\n        \r\n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\r\n\r\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\r\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\r\n*/\r\ninterface IFlywheelBooster {\r\n    /**\r\n      @notice calculate the boosted supply of a strategy.\r\n      @param strategy the strategy to calculate boosted supply of\r\n      @return the boosted supply\r\n     */\r\n    function boostedTotalSupply(ERC20 strategy) external view returns (uint256);\r\n\r\n    /**\r\n      @notice calculate the boosted balance of a user in a given strategy.\r\n      @param strategy the strategy to calculate boosted balance of\r\n      @param user the user to calculate boosted balance of\r\n      @return the boosted balance\r\n     */\r\n    function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IIonicFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\n\r\ninterface IIonicFlywheel {\r\n  function isRewardsDistributor() external returns (bool);\r\n\r\n  function isFlywheel() external returns (bool);\r\n\r\n  function flywheelPreSupplierAction(address market, address supplier) external;\r\n\r\n  function flywheelPostSupplierAction(address market, address supplier) external;\r\n\r\n  function flywheelPreBorrowerAction(address market, address borrower) external;\r\n\r\n  function flywheelPostBorrowerAction(address market, address borrower) external;\r\n\r\n  function flywheelPreTransferAction(address market, address src, address dst) external;\r\n\r\n  function flywheelPostTransferAction(address market, address src, address dst) external;\r\n\r\n  function compAccrued(address user) external view returns (uint256);\r\n\r\n  function addMarketForRewards(ERC20 strategy) external;\r\n\r\n  function marketState(ERC20 strategy) external view returns (uint224 index, uint32 lastUpdatedTimestamp);\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IIonicFlywheelBorrowBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\r\n\r\n/**\r\n @title Balance Booster Module for Flywheel\r\n @notice Flywheel is a general framework for managing token incentives.\r\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\r\n\r\n         The Booster module is an optional module for virtually boosting or otherwise transforming user balances. \r\n         If a booster is not configured, the strategies ERC-20 balanceOf/totalSupply will be used instead.\r\n        \r\n         Boosting logic can be associated with referrals, vote-escrow, or other strategies.\r\n\r\n         SECURITY NOTE: similar to how Core needs to be notified any time the strategy user composition changes, the booster would need to be notified of any conditions which change the boosted balances atomically.\r\n         This prevents gaming of the reward calculation function by using manipulated balances when accruing.\r\n*/\r\ninterface IIonicFlywheelBorrowBooster {\r\n  /**\r\n      @notice calculate the boosted supply of a strategy.\r\n      @param strategy the strategy to calculate boosted supply of\r\n      @return the boosted supply\r\n     */\r\n  function boostedTotalSupply(ICErc20 strategy) external view returns (uint256);\r\n\r\n  /**\r\n      @notice calculate the boosted balance of a user in a given strategy.\r\n      @param strategy the strategy to calculate boosted balance of\r\n      @param user the user to calculate boosted balance of\r\n      @return the boosted balance\r\n     */\r\n  function boostedBalanceOf(ICErc20 strategy, address user) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheel.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\nimport { IonicFlywheelCore } from \"./IonicFlywheelCore.sol\";\r\nimport \"./IIonicFlywheel.sol\";\r\n\r\ncontract IonicFlywheel is IonicFlywheelCore, IIonicFlywheel {\r\n  bool public constant isRewardsDistributor = true;\r\n  bool public constant isFlywheel = true;\r\n\r\n  function flywheelPreSupplierAction(address market, address supplier) external {\r\n    accrue(ERC20(market), supplier);\r\n  }\r\n\r\n  function flywheelPostSupplierAction(address market, address supplier) external {\r\n    _updateBlacklistBalances(ERC20(market), supplier);\r\n  }\r\n\r\n  function flywheelPreBorrowerAction(address market, address borrower) external {}\r\n\r\n  function flywheelPostBorrowerAction(address market, address borrower) external {}\r\n\r\n  function flywheelPreTransferAction(address market, address src, address dst) external {\r\n    accrue(ERC20(market), src, dst);\r\n  }\r\n\r\n  function flywheelPostTransferAction(address market, address src, address dst) external {\r\n    _updateBlacklistBalances(ERC20(market), src);\r\n    _updateBlacklistBalances(ERC20(market), dst);\r\n  }\r\n\r\n  function compAccrued(address user) external view returns (uint256) {\r\n    return _rewardsAccrued[user];\r\n  }\r\n\r\n  function addMarketForRewards(ERC20 strategy) external onlyOwner {\r\n    _addStrategyForRewards(strategy);\r\n  }\r\n\r\n  function marketState(ERC20 strategy) external view returns (uint224, uint32) {\r\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelBorrowBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\r\nimport \"./IIonicFlywheelBorrowBooster.sol\";\r\n\r\ncontract IonicFlywheelBorrowBooster is IIonicFlywheelBorrowBooster {\r\n  string public constant BOOSTER_TYPE = \"FlywheelBorrowBooster\";\r\n\r\n  /**\r\n      @notice calculate the boosted supply of a strategy.\r\n      @param strategy the strategy to calculate boosted supply of\r\n      @return the boosted supply\r\n     */\r\n  function boostedTotalSupply(ICErc20 strategy) external view returns (uint256) {\r\n    return strategy.totalBorrows();\r\n  }\r\n\r\n  /**\r\n      @notice calculate the boosted balance of a user in a given strategy.\r\n      @param strategy the strategy to calculate boosted balance of\r\n      @param user the user to calculate boosted balance of\r\n      @return the boosted balance\r\n     */\r\n  function boostedBalanceOf(ICErc20 strategy, address user) external view returns (uint256) {\r\n    return strategy.borrowBalanceCurrent(user);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelCore.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\r\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\r\n\r\nimport { IFlywheelRewards } from \"./rewards/IFlywheelRewards.sol\";\r\nimport { IFlywheelBooster } from \"./IFlywheelBooster.sol\";\r\nimport { IEmissionsManager } from \"../../../IEmissionsManager.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\n\r\ncontract IonicFlywheelCore is Ownable2StepUpgradeable {\r\n  using SafeTransferLib for ERC20;\r\n  using SafeCastLib for uint256;\r\n\r\n  /// @notice How much rewardsToken will be send to treasury\r\n  uint256 public performanceFee;\r\n\r\n  /// @notice Address that gets rewardsToken accrued by performanceFee\r\n  address public feeRecipient;\r\n\r\n  /// @notice The token to reward\r\n  ERC20 public rewardToken;\r\n\r\n  /// @notice append-only list of strategies added\r\n  ERC20[] public allStrategies;\r\n\r\n  /// @notice the rewards contract for managing streams\r\n  IFlywheelRewards public flywheelRewards;\r\n\r\n  /// @notice optional booster module for calculating virtual balances on strategies\r\n  IFlywheelBooster public flywheelBooster;\r\n\r\n  IEmissionsManager public emissionsManager;\r\n\r\n  /// @notice The accrued but not yet transferred rewards for each user\r\n  mapping(address => uint256) internal _rewardsAccrued;\r\n\r\n  /// @notice The strategy index and last updated per strategy\r\n  mapping(ERC20 => RewardsState) internal _strategyState;\r\n\r\n  /// @notice user index per strategy\r\n  mapping(ERC20 => mapping(address => uint224)) internal _userIndex;\r\n\r\n  /// @notice user blacklisted supply per strategy\r\n  mapping(ERC20 => mapping(address => uint256)) public userBlacklistedSupply;\r\n\r\n  /// @notice blacklisted supply per strategy\r\n  mapping(ERC20 => uint256) public blacklistedSupply;\r\n\r\n  modifier onlyEmissionsManager() {\r\n    require(address(emissionsManager) == msg.sender, \"!emissionsManager\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  function initialize(\r\n    ERC20 _rewardToken,\r\n    IFlywheelRewards _flywheelRewards,\r\n    IFlywheelBooster _flywheelBooster,\r\n    address _owner\r\n  ) public initializer {\r\n    __Ownable2Step_init();\r\n\r\n    rewardToken = _rewardToken;\r\n    flywheelRewards = _flywheelRewards;\r\n    flywheelBooster = _flywheelBooster;\r\n\r\n    performanceFee = 10e16; // 10%\r\n    feeRecipient = _owner;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                        ACCRUE/CLAIM LOGIC\r\n    ----------------------------------------------------------------*/\r\n\r\n  /** \r\n      @notice Emitted when a user's rewards accrue to a given strategy.\r\n      @param strategy the updated rewards strategy\r\n      @param user the user of the rewards\r\n      @param rewardsDelta how many new rewards accrued to the user\r\n      @param rewardsIndex the market index for rewards per token accrued\r\n    */\r\n  event AccrueRewards(ERC20 indexed strategy, address indexed user, uint256 rewardsDelta, uint256 rewardsIndex);\r\n\r\n  /** \r\n      @notice Emitted when a user claims accrued rewards.\r\n      @param user the user of the rewards\r\n      @param amount the amount of rewards claimed\r\n    */\r\n  event ClaimRewards(address indexed user, uint256 amount);\r\n\r\n  /** \r\n      @notice accrue rewards for a single user on a strategy\r\n      @param strategy the strategy to accrue a user's rewards on\r\n      @param user the user to be accrued\r\n      @return the cumulative amount of rewards accrued to user (including prior)\r\n    */\r\n  function accrue(ERC20 strategy, address user) public returns (uint256) {\r\n    (uint224 index, uint32 ts) = strategyState(strategy);\r\n    RewardsState memory state = RewardsState(index, ts);\r\n\r\n    if (state.index == 0) return 0;\r\n\r\n    state = accrueStrategy(strategy, state);\r\n    return accrueUser(strategy, user, state);\r\n  }\r\n\r\n  /** \r\n      @notice accrue rewards for a two users on a strategy\r\n      @param strategy the strategy to accrue a user's rewards on\r\n      @param user the first user to be accrued\r\n      @param user the second user to be accrued\r\n      @return the cumulative amount of rewards accrued to the first user (including prior)\r\n      @return the cumulative amount of rewards accrued to the second user (including prior)\r\n    */\r\n  function accrue(ERC20 strategy, address user, address secondUser) public returns (uint256, uint256) {\r\n    (uint224 index, uint32 ts) = strategyState(strategy);\r\n    RewardsState memory state = RewardsState(index, ts);\r\n\r\n    if (state.index == 0) return (0, 0);\r\n\r\n    state = accrueStrategy(strategy, state);\r\n    return (accrueUser(strategy, user, state), accrueUser(strategy, secondUser, state));\r\n  }\r\n\r\n  /** \r\n      @notice claim rewards for a given user\r\n      @param user the user claiming rewards\r\n      @dev this function is public, and all rewards transfer to the user\r\n    */\r\n  function claimRewards(address user) external {\r\n    require(!emissionsManager.isUserBlacklisted(user), \"blacklisted\");\r\n    require(!emissionsManager.isUserBlacklistable(user), \"blacklistable\");\r\n    uint256 accrued = rewardsAccrued(user);\r\n\r\n    if (accrued != 0) {\r\n      _rewardsAccrued[user] = 0;\r\n\r\n      rewardToken.safeTransferFrom(address(flywheelRewards), user, accrued);\r\n\r\n      emit ClaimRewards(user, accrued);\r\n    }\r\n  }\r\n\r\n  /** \r\n      @notice take rewards for a given user\r\n      @param user the user claiming rewards\r\n      @param receiver the address that receives the rewards\r\n      @dev this function is public, and all rewards transfer to the receiver\r\n    */\r\n  function takeRewardsFromUser(address user, address receiver) external onlyEmissionsManager {\r\n    uint256 accrued = rewardsAccrued(user);\r\n\r\n    if (accrued != 0) {\r\n      _rewardsAccrued[user] = 0;\r\n\r\n      rewardToken.safeTransferFrom(address(flywheelRewards), receiver, accrued);\r\n\r\n      emit ClaimRewards(user, accrued);\r\n    }\r\n  }\r\n\r\n  /** \r\n      @notice set user balances to zero\r\n      @param strategy strategy to whitelist user for\r\n      @param user the user to be whitelisted\r\n      @dev this function is public, and all user and strategy blacklisted supplies are reset\r\n    */\r\n  function whitelistUser(ERC20 strategy, address user) external onlyEmissionsManager {\r\n    blacklistedSupply[strategy] -= userBlacklistedSupply[strategy][user];\r\n    userBlacklistedSupply[strategy][user] = 0;\r\n    (uint224 index, uint32 ts) = strategyState(strategy);\r\n    RewardsState memory state = RewardsState(index, ts);\r\n    state = accrueStrategy(strategy, state);\r\n    _userIndex[strategy][user] = state.index;\r\n  }\r\n\r\n  /** \r\n      @notice update user blacklisted balances\r\n      @param strategy strategy to update blacklisted balances\r\n      @param user the user to be blacklisted\r\n      @dev this function is public\r\n    */\r\n  function updateBlacklistBalances(ERC20 strategy, address user) external onlyEmissionsManager {\r\n    _updateBlacklistBalances(strategy, user);\r\n  }\r\n\r\n  /** \r\n      @notice update user blacklisted balances\r\n      @param strategy strategy to update blacklisted balances\r\n      @param user the user to be blacklisted\r\n      @dev this function is private\r\n    */\r\n  function _updateBlacklistBalances(ERC20 strategy, address user) internal {\r\n    if (emissionsManager.isUserBlacklisted(user)) {\r\n      uint256 _oldUserBlacklistedSupply = userBlacklistedSupply[strategy][user];\r\n      uint256 supplierTokens = address(flywheelBooster) != address(0)\r\n        ? flywheelBooster.boostedBalanceOf(ERC20(strategy), user)\r\n        : ERC20(strategy).balanceOf(user);\r\n\r\n      if (supplierTokens >= _oldUserBlacklistedSupply) {\r\n        blacklistedSupply[strategy] += supplierTokens - _oldUserBlacklistedSupply;\r\n        userBlacklistedSupply[strategy][user] = supplierTokens;\r\n      } else {\r\n        blacklistedSupply[strategy] -= _oldUserBlacklistedSupply - supplierTokens;\r\n        userBlacklistedSupply[strategy][user] = supplierTokens;\r\n      }\r\n    }\r\n  }\r\n  /*----------------------------------------------------------------\r\n                          ADMIN LOGIC\r\n    ----------------------------------------------------------------*/\r\n\r\n  /** \r\n      @notice Emitted when a new strategy is added to flywheel by the admin\r\n      @param newStrategy the new added strategy\r\n    */\r\n  event AddStrategy(address indexed newStrategy);\r\n\r\n  /// @notice initialize a new strategy\r\n  function setEmissionsManager(IEmissionsManager _emissionsManager) external onlyOwner {\r\n    emissionsManager = _emissionsManager;\r\n  }\r\n\r\n  /// @notice initialize a new strategy\r\n  function addStrategyForRewards(ERC20 strategy) external onlyOwner {\r\n    _addStrategyForRewards(strategy);\r\n  }\r\n\r\n  function _addStrategyForRewards(ERC20 strategy) internal {\r\n    (uint224 index, ) = strategyState(strategy);\r\n    require(index == 0, \"strategy\");\r\n    _strategyState[strategy] = RewardsState({\r\n      index: (10 ** rewardToken.decimals()).safeCastTo224(),\r\n      lastUpdatedTimestamp: block.timestamp.safeCastTo32()\r\n    });\r\n\r\n    allStrategies.push(strategy);\r\n    emit AddStrategy(address(strategy));\r\n  }\r\n\r\n  function getAllStrategies() external view returns (ERC20[] memory) {\r\n    return allStrategies;\r\n  }\r\n\r\n  /** \r\n      @notice Emitted when the rewards module changes\r\n      @param newFlywheelRewards the new rewards module\r\n    */\r\n  event FlywheelRewardsUpdate(address indexed newFlywheelRewards);\r\n\r\n  /// @notice swap out the flywheel rewards contract\r\n  function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external onlyOwner {\r\n    if (address(flywheelRewards) != address(0)) {\r\n      uint256 oldRewardBalance = rewardToken.balanceOf(address(flywheelRewards));\r\n      if (oldRewardBalance > 0) {\r\n        rewardToken.safeTransferFrom(address(flywheelRewards), address(newFlywheelRewards), oldRewardBalance);\r\n      }\r\n    }\r\n\r\n    flywheelRewards = newFlywheelRewards;\r\n\r\n    emit FlywheelRewardsUpdate(address(newFlywheelRewards));\r\n  }\r\n\r\n  /** \r\n      @notice Emitted when the booster module changes\r\n      @param newBooster the new booster module\r\n    */\r\n  event FlywheelBoosterUpdate(address indexed newBooster);\r\n\r\n  /// @notice swap out the flywheel booster contract\r\n  function setBooster(IFlywheelBooster newBooster) external onlyOwner {\r\n    flywheelBooster = newBooster;\r\n\r\n    emit FlywheelBoosterUpdate(address(newBooster));\r\n  }\r\n\r\n  event UpdatedFeeSettings(\r\n    uint256 oldPerformanceFee,\r\n    uint256 newPerformanceFee,\r\n    address oldFeeRecipient,\r\n    address newFeeRecipient\r\n  );\r\n\r\n  /**\r\n   * @notice Update performanceFee and/or feeRecipient\r\n   * @dev Claim rewards first from the previous feeRecipient before changing it\r\n   */\r\n  function updateFeeSettings(uint256 _performanceFee, address _feeRecipient) external onlyOwner {\r\n    _updateFeeSettings(_performanceFee, _feeRecipient);\r\n  }\r\n\r\n  function _updateFeeSettings(uint256 _performanceFee, address _feeRecipient) internal {\r\n    emit UpdatedFeeSettings(performanceFee, _performanceFee, feeRecipient, _feeRecipient);\r\n\r\n    if (feeRecipient != _feeRecipient) {\r\n      _rewardsAccrued[_feeRecipient] += rewardsAccrued(feeRecipient);\r\n      _rewardsAccrued[feeRecipient] = 0;\r\n    }\r\n    performanceFee = _performanceFee;\r\n    feeRecipient = _feeRecipient;\r\n  }\r\n\r\n  /*----------------------------------------------------------------\r\n                    INTERNAL ACCOUNTING LOGIC\r\n    ----------------------------------------------------------------*/\r\n\r\n  struct RewardsState {\r\n    /// @notice The strategy's last updated index\r\n    uint224 index;\r\n    /// @notice The timestamp the index was last updated at\r\n    uint32 lastUpdatedTimestamp;\r\n  }\r\n\r\n  /// @notice accumulate global rewards on a strategy\r\n  function accrueStrategy(\r\n    ERC20 strategy,\r\n    RewardsState memory state\r\n  ) private returns (RewardsState memory rewardsState) {\r\n    // calculate accrued rewards through module\r\n    uint256 strategyRewardsAccrued = flywheelRewards.getAccruedRewards(strategy, state.lastUpdatedTimestamp);\r\n\r\n    rewardsState = state;\r\n\r\n    if (strategyRewardsAccrued > 0) {\r\n      // use the booster or token supply to calculate reward index denominator\r\n      uint256 supplyTokens = address(flywheelBooster) != address(0)\r\n        ? flywheelBooster.boostedTotalSupply(strategy) - blacklistedSupply[strategy]\r\n        : strategy.totalSupply() - blacklistedSupply[strategy];\r\n\r\n      // 100% = 100e16\r\n      uint256 accruedFees = (strategyRewardsAccrued * performanceFee) / uint224(100e16);\r\n\r\n      _rewardsAccrued[feeRecipient] += accruedFees;\r\n      strategyRewardsAccrued -= accruedFees;\r\n\r\n      uint224 deltaIndex;\r\n\r\n      if (supplyTokens != 0)\r\n        deltaIndex = ((strategyRewardsAccrued * (10 ** strategy.decimals())) / supplyTokens).safeCastTo224();\r\n\r\n      // accumulate rewards per token onto the index, multiplied by fixed-point factor\r\n      rewardsState = RewardsState({\r\n        index: state.index + deltaIndex,\r\n        lastUpdatedTimestamp: block.timestamp.safeCastTo32()\r\n      });\r\n      _strategyState[strategy] = rewardsState;\r\n    }\r\n  }\r\n\r\n  /// @notice accumulate rewards on a strategy for a specific user\r\n  function accrueUser(ERC20 strategy, address user, RewardsState memory state) private returns (uint256) {\r\n    // load indices\r\n    uint224 strategyIndex = state.index;\r\n    uint224 supplierIndex = userIndex(strategy, user);\r\n\r\n    // sync user index to global\r\n    _userIndex[strategy][user] = strategyIndex;\r\n\r\n    // if user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\r\n    // zero balances will have no effect other than syncing to global index\r\n    if (supplierIndex == 0) {\r\n      supplierIndex = (10 ** rewardToken.decimals()).safeCastTo224();\r\n    }\r\n\r\n    uint224 deltaIndex = strategyIndex - supplierIndex;\r\n    // use the booster or token balance to calculate reward balance multiplier\r\n    uint256 supplierTokens = address(flywheelBooster) != address(0)\r\n      ? flywheelBooster.boostedBalanceOf(strategy, user) - userBlacklistedSupply[strategy][user]\r\n      : strategy.balanceOf(user) - userBlacklistedSupply[strategy][user];\r\n\r\n    // accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\r\n    uint256 supplierDelta = (deltaIndex * supplierTokens) / (10 ** strategy.decimals());\r\n    uint256 supplierAccrued = rewardsAccrued(user) + supplierDelta;\r\n\r\n    _rewardsAccrued[user] = supplierAccrued;\r\n\r\n    emit AccrueRewards(strategy, user, supplierDelta, strategyIndex);\r\n\r\n    return supplierAccrued;\r\n  }\r\n\r\n  function rewardsAccrued(address user) public virtual returns (uint256) {\r\n    return _rewardsAccrued[user];\r\n  }\r\n\r\n  function userIndex(ERC20 strategy, address user) public virtual returns (uint224) {\r\n    return _userIndex[strategy][user];\r\n  }\r\n\r\n  function strategyState(ERC20 strategy) public virtual returns (uint224 index, uint32 lastUpdatedTimestamp) {\r\n    return (_strategyState[strategy].index, _strategyState[strategy].lastUpdatedTimestamp);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/IonicFlywheelLensRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\r\n\r\nimport { IonicFlywheelCore } from \"./IonicFlywheelCore.sol\";\r\nimport { IonicComptroller } from \"../../../compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\r\nimport { BasePriceOracle } from \"../../../oracles/BasePriceOracle.sol\";\r\nimport { PoolDirectory } from \"../../../PoolDirectory.sol\";\r\n\r\ninterface IPriceOracle_IFLR {\r\n  function getUnderlyingPrice(ERC20 cToken) external view returns (uint256);\r\n\r\n  function price(address underlying) external view returns (uint256);\r\n}\r\n\r\ncontract IonicFlywheelLensRouter {\r\n  PoolDirectory public fpd;\r\n\r\n  constructor(PoolDirectory _fpd) {\r\n    fpd = _fpd;\r\n  }\r\n\r\n  struct MarketRewardsInfo {\r\n    /// @dev comptroller oracle price of market underlying\r\n    uint256 underlyingPrice;\r\n    ICErc20 market;\r\n    RewardsInfo[] rewardsInfo;\r\n  }\r\n\r\n  struct RewardsInfo {\r\n    /// @dev rewards in `rewardToken` paid per underlying staked token in `market` per second\r\n    uint256 rewardSpeedPerSecondPerToken;\r\n    /// @dev comptroller oracle price of reward token\r\n    uint256 rewardTokenPrice;\r\n    /// @dev APR scaled by 1e18. Calculated as rewardSpeedPerSecondPerToken * rewardTokenPrice * 365.25 days / underlyingPrice * 1e18 / market.exchangeRate\r\n    uint256 formattedAPR;\r\n    address flywheel;\r\n    address rewardToken;\r\n  }\r\n\r\n  function getPoolMarketRewardsInfo(IonicComptroller comptroller) external returns (MarketRewardsInfo[] memory) {\r\n    ICErc20[] memory markets = comptroller.getAllMarkets();\r\n    return _getMarketRewardsInfo(markets, comptroller);\r\n  }\r\n\r\n  function getMarketRewardsInfo(ICErc20[] memory markets) external returns (MarketRewardsInfo[] memory) {\r\n    IonicComptroller pool;\r\n    for (uint256 i = 0; i < markets.length; i++) {\r\n      ICErc20 asMarket = ICErc20(address(markets[i]));\r\n      if (address(pool) == address(0)) pool = asMarket.comptroller();\r\n      else require(asMarket.comptroller() == pool);\r\n    }\r\n    return _getMarketRewardsInfo(markets, pool);\r\n  }\r\n\r\n  function _getMarketRewardsInfo(ICErc20[] memory markets, IonicComptroller comptroller)\r\n    internal\r\n    returns (MarketRewardsInfo[] memory)\r\n  {\r\n    if (address(comptroller) == address(0) || markets.length == 0) return new MarketRewardsInfo[](0);\r\n\r\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\r\n    address[] memory rewardTokens = new address[](flywheels.length);\r\n    uint256[] memory rewardTokenPrices = new uint256[](flywheels.length);\r\n    uint256[] memory rewardTokenDecimals = new uint256[](flywheels.length);\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n\r\n    MarketRewardsInfo[] memory infoList = new MarketRewardsInfo[](markets.length);\r\n    for (uint256 i = 0; i < markets.length; i++) {\r\n      RewardsInfo[] memory rewardsInfo = new RewardsInfo[](flywheels.length);\r\n\r\n      ICErc20 market = ICErc20(address(markets[i]));\r\n      uint256 price = oracle.price(market.underlying()); // scaled to 1e18\r\n\r\n      if (i == 0) {\r\n        for (uint256 j = 0; j < flywheels.length; j++) {\r\n          ERC20 rewardToken = IonicFlywheelCore(flywheels[j]).rewardToken();\r\n          rewardTokens[j] = address(rewardToken);\r\n          rewardTokenPrices[j] = oracle.price(address(rewardToken)); // scaled to 1e18\r\n          rewardTokenDecimals[j] = uint256(rewardToken.decimals());\r\n        }\r\n      }\r\n\r\n      for (uint256 j = 0; j < flywheels.length; j++) {\r\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\r\n\r\n        uint256 rewardSpeedPerSecondPerToken = getRewardSpeedPerSecondPerToken(\r\n          flywheel,\r\n          market,\r\n          rewardTokenDecimals[j]\r\n        );\r\n        uint256 apr = getApr(\r\n          rewardSpeedPerSecondPerToken,\r\n          rewardTokenPrices[j],\r\n          price, \r\n          market.exchangeRateCurrent(),\r\n          address(flywheel.flywheelBooster()) != address(0)\r\n        );\r\n\r\n        rewardsInfo[j] = RewardsInfo({\r\n          rewardSpeedPerSecondPerToken: rewardSpeedPerSecondPerToken, // scaled in 1e18\r\n          rewardTokenPrice: rewardTokenPrices[j],\r\n          formattedAPR: apr, // scaled in 1e18\r\n          flywheel: address(flywheel),\r\n          rewardToken: rewardTokens[j]\r\n        });\r\n      }\r\n\r\n      infoList[i] = MarketRewardsInfo({ market: market, rewardsInfo: rewardsInfo, underlyingPrice: price });\r\n    }\r\n\r\n    return infoList;\r\n  }\r\n\r\n  function scaleIndexDiff(uint256 indexDiff, uint256 decimals) internal pure returns (uint256) {\r\n    return decimals <= 18 ? uint256(indexDiff) * (10**(18 - decimals)) : uint256(indexDiff) / (10**(decimals - 18));\r\n  }\r\n\r\n  function getRewardSpeedPerSecondPerToken(\r\n    IonicFlywheelCore flywheel,\r\n    ICErc20 market,\r\n    uint256 decimals\r\n  ) internal returns (uint256 rewardSpeedPerSecondPerToken) {\r\n    ERC20 strategy = ERC20(address(market));\r\n    (uint224 indexBefore, uint32 lastUpdatedTimestampBefore) = flywheel.strategyState(strategy);\r\n    flywheel.accrue(strategy, address(0));\r\n    (uint224 indexAfter, uint32 lastUpdatedTimestampAfter) = flywheel.strategyState(strategy);\r\n    if (lastUpdatedTimestampAfter > lastUpdatedTimestampBefore) {\r\n      rewardSpeedPerSecondPerToken =\r\n        scaleIndexDiff((indexAfter - indexBefore), decimals) /\r\n        (lastUpdatedTimestampAfter - lastUpdatedTimestampBefore);\r\n    }\r\n  }\r\n\r\n  function getApr(\r\n    uint256 rewardSpeedPerSecondPerToken,\r\n    uint256 rewardTokenPrice,\r\n    uint256 underlyingPrice,\r\n    uint256 exchangeRate,\r\n    bool isBorrow\r\n  ) internal pure returns (uint256) {\r\n    if (rewardSpeedPerSecondPerToken == 0) return 0;\r\n    uint256 nativeSpeedPerSecondPerCToken = rewardSpeedPerSecondPerToken * rewardTokenPrice; // scaled to 1e36\r\n    uint256 nativeSpeedPerYearPerCToken = nativeSpeedPerSecondPerCToken * 365.25 days; // scaled to 1e36\r\n    uint256 assetSpeedPerYearPerCToken = nativeSpeedPerYearPerCToken / underlyingPrice; // scaled to 1e18\r\n    uint256 assetSpeedPerYearPerCTokenScaled = assetSpeedPerYearPerCToken * 1e18; // scaled to 1e36\r\n    uint256 apr = assetSpeedPerYearPerCTokenScaled;\r\n    if (!isBorrow) {\r\n      // if not borrowing, use exchange rate to scale\r\n      apr = assetSpeedPerYearPerCTokenScaled / exchangeRate; // scaled to 1e18\r\n    } else {\r\n      apr = assetSpeedPerYearPerCTokenScaled / 1e18; // scaled to 1e18\r\n    }\r\n    return apr;\r\n  }\r\n\r\n  function getRewardsAprForMarket(ICErc20 market) internal returns (int256 totalMarketRewardsApr) {\r\n    IonicComptroller comptroller = market.comptroller();\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n    uint256 underlyingPrice = oracle.getUnderlyingPrice(market);\r\n\r\n    address[] memory flywheels = comptroller.getAccruingFlywheels();\r\n    for (uint256 j = 0; j < flywheels.length; j++) {\r\n      IonicFlywheelCore flywheel = IonicFlywheelCore(flywheels[j]);\r\n      ERC20 rewardToken = flywheel.rewardToken();\r\n\r\n      uint256 rewardSpeedPerSecondPerToken = getRewardSpeedPerSecondPerToken(\r\n        flywheel,\r\n        market,\r\n        uint256(rewardToken.decimals())\r\n      );\r\n\r\n      uint256 marketApr = getApr(\r\n        rewardSpeedPerSecondPerToken,\r\n        oracle.price(address(rewardToken)),\r\n        underlyingPrice,\r\n        market.exchangeRateCurrent(),\r\n        address(flywheel.flywheelBooster()) != address(0)\r\n      );\r\n\r\n      totalMarketRewardsApr += int256(marketApr);\r\n    }\r\n  }\r\n\r\n  function getUserNetValueDeltaForMarket(\r\n    address user,\r\n    ICErc20 market,\r\n    int256 offchainApr,\r\n    int256 blocksPerYear\r\n  ) internal returns (int256) {\r\n    IonicComptroller comptroller = market.comptroller();\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n    int256 netApr = getRewardsAprForMarket(market) +\r\n      getUserInterestAprForMarket(user, market, blocksPerYear) +\r\n      offchainApr;\r\n    return (netApr * int256(market.balanceOfUnderlying(user)) * int256(oracle.getUnderlyingPrice(market))) / 1e36;\r\n  }\r\n\r\n  function getUserInterestAprForMarket(\r\n    address user,\r\n    ICErc20 market,\r\n    int256 blocksPerYear\r\n  ) internal returns (int256) {\r\n    uint256 borrows = market.borrowBalanceCurrent(user);\r\n    uint256 supplied = market.balanceOfUnderlying(user);\r\n    uint256 supplyRatePerBlock = market.supplyRatePerBlock();\r\n    uint256 borrowRatePerBlock = market.borrowRatePerBlock();\r\n\r\n    IonicComptroller comptroller = market.comptroller();\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n    uint256 assetPrice = oracle.getUnderlyingPrice(market);\r\n    uint256 collateralValue = (supplied * assetPrice) / 1e18;\r\n    uint256 borrowsValue = (borrows * assetPrice) / 1e18;\r\n\r\n    uint256 yieldValuePerBlock = collateralValue * supplyRatePerBlock;\r\n    uint256 interestOwedValuePerBlock = borrowsValue * borrowRatePerBlock;\r\n\r\n    if (collateralValue == 0) return 0;\r\n    return ((int256(yieldValuePerBlock) - int256(interestOwedValuePerBlock)) * blocksPerYear) / int256(collateralValue);\r\n  }\r\n\r\n  struct AdjustedUserNetAprVars {\r\n    int256 userNetAssetsValue;\r\n    int256 userNetValueDelta;\r\n    BasePriceOracle oracle;\r\n    ICErc20[] markets;\r\n    IonicComptroller pool;\r\n  }\r\n\r\n  function getAdjustedUserNetApr(\r\n    address user,\r\n    int256 blocksPerYear,\r\n    address[] memory offchainRewardsAprMarkets,\r\n    int256[] memory offchainRewardsAprs\r\n  ) public returns (int256) {\r\n    AdjustedUserNetAprVars memory vars;\r\n\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\r\n      vars.oracle = pool.oracle();\r\n      vars.markets = pool.getAllMarkets();\r\n      for (uint256 j = 0; j < vars.markets.length; j++) {\r\n        int256 offchainRewardsApr = 0;\r\n        for (uint256 k = 0; k < offchainRewardsAprMarkets.length; k++) {\r\n          if (offchainRewardsAprMarkets[k] == address(vars.markets[j])) offchainRewardsApr = offchainRewardsAprs[k];\r\n        }\r\n        vars.userNetAssetsValue +=\r\n          int256(vars.markets[j].balanceOfUnderlying(user) * vars.oracle.getUnderlyingPrice(vars.markets[j])) /\r\n          1e18;\r\n        vars.userNetValueDelta += getUserNetValueDeltaForMarket(\r\n          user,\r\n          vars.markets[j],\r\n          offchainRewardsApr,\r\n          blocksPerYear\r\n        );\r\n      }\r\n    }\r\n\r\n    if (vars.userNetAssetsValue == 0) return 0;\r\n    else return (vars.userNetValueDelta * 1e18) / vars.userNetAssetsValue;\r\n  }\r\n\r\n  function getUserNetApr(address user, int256 blocksPerYear) external returns (int256) {\r\n    address[] memory emptyAddrArray = new address[](0);\r\n    int256[] memory emptyIntArray = new int256[](0);\r\n    return getAdjustedUserNetApr(user, blocksPerYear, emptyAddrArray, emptyIntArray);\r\n  }\r\n\r\n  function getAllRewardTokens() public view returns (address[] memory uniqueRewardTokens) {\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n\r\n    uint256 rewardTokensCounter;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\r\n      address[] memory fws = pool.getRewardsDistributors();\r\n\r\n      rewardTokensCounter += fws.length;\r\n    }\r\n\r\n    address[] memory rewardTokens = new address[](rewardTokensCounter);\r\n\r\n    uint256 uniqueRewardTokensCounter = 0;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\r\n      address[] memory fws = pool.getRewardsDistributors();\r\n\r\n      for (uint256 j = 0; j < fws.length; j++) {\r\n        address rwToken = address(IonicFlywheelCore(fws[j]).rewardToken());\r\n        if (rwToken == address(0)) break;\r\n\r\n        bool added;\r\n        for (uint256 k = 0; k < rewardTokens.length; k++) {\r\n          if (rwToken == rewardTokens[k]) {\r\n            added = true;\r\n            break;\r\n          }\r\n        }\r\n        if (!added) rewardTokens[uniqueRewardTokensCounter++] = rwToken;\r\n      }\r\n    }\r\n\r\n    uniqueRewardTokens = new address[](uniqueRewardTokensCounter);\r\n    for (uint256 i = 0; i < uniqueRewardTokensCounter; i++) {\r\n      uniqueRewardTokens[i] = rewardTokens[i];\r\n    }\r\n  }\r\n\r\n  function claimAllRewardTokens(address user) external returns (address[] memory, uint256[] memory) {\r\n    address[] memory rewardTokens = getAllRewardTokens();\r\n    uint256[] memory rewardsClaimedForToken = new uint256[](rewardTokens.length);\r\n\r\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n      rewardsClaimedForToken[i] = claimRewardsOfRewardToken(user, rewardTokens[i]);\r\n    }\r\n\r\n    return (rewardTokens, rewardsClaimedForToken);\r\n  }\r\n\r\n  function claimRewardsOfRewardToken(address user, address rewardToken) public returns (uint256 rewardsClaimed) {\r\n    uint256 balanceBefore = ERC20(rewardToken).balanceOf(user);\r\n    (, PoolDirectory.Pool[] memory pools) = fpd.getActivePools();\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller pool = IonicComptroller(pools[i].comptroller);\r\n      ERC20[] memory markets;\r\n      {\r\n        ICErc20[] memory cerc20s = pool.getAllMarkets();\r\n        markets = new ERC20[](cerc20s.length);\r\n        for (uint256 j = 0; j < cerc20s.length; j++) {\r\n          markets[j] = ERC20(address(cerc20s[j]));\r\n        }\r\n      }\r\n\r\n      address[] memory flywheelAddresses = pool.getAccruingFlywheels();\r\n      for (uint256 k = 0; k < flywheelAddresses.length; k++) {\r\n        IonicFlywheelCore flywheel = IonicFlywheelCore(flywheelAddresses[k]);\r\n        if (address(flywheel.rewardToken()) == rewardToken) {\r\n          for (uint256 m = 0; m < markets.length; m++) {\r\n            flywheel.accrue(markets[m], user);\r\n          }\r\n          flywheel.claimRewards(user);\r\n        }\r\n      }\r\n    }\r\n\r\n    uint256 balanceAfter = ERC20(rewardToken).balanceOf(user);\r\n    return balanceAfter - balanceBefore;\r\n  }\r\n\r\n  function claimRewardsForMarket(\r\n    address user,\r\n    ERC20 market,\r\n    IonicFlywheelCore[] calldata flywheels,\r\n    bool[] calldata accrue\r\n  )\r\n    external\r\n    returns (\r\n      IonicFlywheelCore[] memory,\r\n      address[] memory rewardTokens,\r\n      uint256[] memory rewards\r\n    )\r\n  {\r\n    uint256 size = flywheels.length;\r\n    rewards = new uint256[](size);\r\n    rewardTokens = new address[](size);\r\n\r\n    for (uint256 i = 0; i < size; i++) {\r\n      uint256 newRewards;\r\n      if (accrue[i]) {\r\n        newRewards = flywheels[i].accrue(market, user);\r\n      } else {\r\n        newRewards = flywheels[i].rewardsAccrued(user);\r\n      }\r\n\r\n      // Take the max, because rewards are cumulative.\r\n      rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\r\n\r\n      flywheels[i].claimRewards(user);\r\n      rewardTokens[i] = address(flywheels[i].rewardToken());\r\n    }\r\n\r\n    return (flywheels, rewardTokens, rewards);\r\n  }\r\n\r\n  function claimRewardsForPool(address user, IonicComptroller comptroller)\r\n    public\r\n    returns (\r\n      IonicFlywheelCore[] memory,\r\n      address[] memory,\r\n      uint256[] memory\r\n    )\r\n  {\r\n    ICErc20[] memory cerc20s = comptroller.getAllMarkets();\r\n    ERC20[] memory markets = new ERC20[](cerc20s.length);\r\n    address[] memory flywheelAddresses = comptroller.getAccruingFlywheels();\r\n    IonicFlywheelCore[] memory flywheels = new IonicFlywheelCore[](flywheelAddresses.length);\r\n    bool[] memory accrue = new bool[](flywheelAddresses.length);\r\n\r\n    for (uint256 j = 0; j < flywheelAddresses.length; j++) {\r\n      flywheels[j] = IonicFlywheelCore(flywheelAddresses[j]);\r\n      accrue[j] = true;\r\n    }\r\n\r\n    for (uint256 j = 0; j < cerc20s.length; j++) {\r\n      markets[j] = ERC20(address(cerc20s[j]));\r\n    }\r\n\r\n    return claimRewardsForMarkets(user, markets, flywheels, accrue);\r\n  }\r\n\r\n  function claimRewardsForMarkets(\r\n    address user,\r\n    ERC20[] memory markets,\r\n    IonicFlywheelCore[] memory flywheels,\r\n    bool[] memory accrue\r\n  )\r\n    public\r\n    returns (\r\n      IonicFlywheelCore[] memory,\r\n      address[] memory rewardTokens,\r\n      uint256[] memory rewards\r\n    )\r\n  {\r\n    rewards = new uint256[](flywheels.length);\r\n    rewardTokens = new address[](flywheels.length);\r\n\r\n    for (uint256 i = 0; i < flywheels.length; i++) {\r\n      for (uint256 j = 0; j < markets.length; j++) {\r\n        ERC20 market = markets[j];\r\n\r\n        uint256 newRewards;\r\n        if (accrue[i]) {\r\n          newRewards = flywheels[i].accrue(market, user);\r\n        } else {\r\n          newRewards = flywheels[i].rewardsAccrued(user);\r\n        }\r\n\r\n        // Take the max, because rewards are cumulative.\r\n        rewards[i] = rewards[i] >= newRewards ? rewards[i] : newRewards;\r\n      }\r\n\r\n      flywheels[i].claimRewards(user);\r\n      rewardTokens[i] = address(flywheels[i].rewardToken());\r\n    }\r\n\r\n    return (flywheels, rewardTokens, rewards);\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/LooplessFlywheelBooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./IFlywheelBooster.sol\";\r\nimport { ICErc20 } from \"../../../compound/CTokenInterfaces.sol\";\r\n\r\ncontract LooplessFlywheelBooster is IFlywheelBooster {\r\n  string public constant BOOSTER_TYPE = \"LooplessFlywheelBooster\";\r\n\r\n  /**\r\n      @notice calculate the boosted supply of a strategy.\r\n      @param strategy the strategy to calculate boosted supply of\r\n      @return the boosted supply\r\n     */\r\n  function boostedTotalSupply(ERC20 strategy) external view returns (uint256) {\r\n    return strategy.totalSupply();\r\n  }\r\n\r\n  /**\r\n      @notice calculate the boosted balance of a user in a given strategy.\r\n      @param strategy the strategy to calculate boosted balance of\r\n      @param user the user to calculate boosted balance of\r\n      @return the boosted balance\r\n     */\r\n  function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256) {\r\n    uint256 cTokensBalance = strategy.balanceOf(user);\r\n    ICErc20 asMarket = ICErc20(address(strategy));\r\n    uint256 cTokensBorrow = (asMarket.borrowBalanceCurrent(user) * 1e18) / asMarket.exchangeRateCurrent();\r\n    return (cTokensBalance > cTokensBorrow) ? cTokensBalance - cTokensBorrow : 0;\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/BaseFlywheelRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport {SafeTransferLib, ERC20} from \"solmate/utils/SafeTransferLib.sol\";\r\nimport {IFlywheelRewards} from \"./IFlywheelRewards.sol\";\r\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\r\n\r\n/** \r\n @title Flywheel Reward Module\r\n @notice Determines how many rewards accrue to each strategy globally over a given time period.\r\n @dev approves the flywheel core for the reward token to allow balances to be managed by the module but claimed from core.\r\n*/\r\nabstract contract BaseFlywheelRewards is IFlywheelRewards {\r\n    using SafeTransferLib for ERC20;\r\n\r\n    /// @notice thrown when caller is not the flywheel\r\n    error FlywheelError();\r\n\r\n    /// @notice the reward token paid\r\n    ERC20 public immutable override rewardToken;\r\n\r\n    /// @notice the flywheel core contract\r\n    IonicFlywheelCore public immutable override flywheel;\r\n\r\n    constructor(IonicFlywheelCore _flywheel) {\r\n        flywheel = _flywheel;\r\n        ERC20 _rewardToken = _flywheel.rewardToken();\r\n        rewardToken = _rewardToken;\r\n\r\n        _rewardToken.safeApprove(address(_flywheel), type(uint256).max);\r\n    }\r\n\r\n    modifier onlyFlywheel() {\r\n        if (msg.sender != address(flywheel)) revert FlywheelError();\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/FlywheelInstantRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport { Auth, Authority } from \"solmate/auth/Auth.sol\";\r\nimport { BaseFlywheelRewards } from \"./BaseFlywheelRewards.sol\";\r\nimport { SafeTransferLib, ERC20 } from \"solmate/utils/SafeTransferLib.sol\";\r\nimport { IonicFlywheelCore } from \"../IonicFlywheelCore.sol\";\r\n\r\n/**\r\n * @title FlywheelInstantRewards\r\n * @author Jourdan DUnkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n * @notice This contract handles the instant reward distribution for strategies.\r\n * It allows setting and transferring rewards for specific strategies.\r\n */\r\ncontract FlywheelInstantRewards is Auth, BaseFlywheelRewards {\r\n  using SafeTransferLib for ERC20;\r\n\r\n  event RewardsSet(ERC20 indexed strategy, uint256 amount);\r\n\r\n  /// @notice Mapping to store the reward amount for each strategy.\r\n  mapping(ERC20 => uint256) rewardAmount;\r\n  /// @notice Mapping to track if a strategy has new rewards to be distributed.\r\n  mapping(ERC20 => bool) rewardsNew;\r\n\r\n  /**\r\n   * @notice Constructor to initialize the FlywheelInstantRewards contract.\r\n   * @param _flywheel The flywheel core contract.\r\n   * @param _owner The owner of the contract.\r\n   * @param _authority The authority contract for authentication.\r\n   */\r\n  constructor(\r\n    IonicFlywheelCore _flywheel,\r\n    address _owner,\r\n    Authority _authority\r\n  ) Auth(_owner, _authority) BaseFlywheelRewards(_flywheel) {}\r\n\r\n  /**\r\n   * @notice Set the reward amount for a specific strategy.\r\n   * @param _amount The amount of rewards to be set for the strategy.\r\n   * @param _strategy The strategy for which the rewards are being set.\r\n   * @dev Requires authentication to execute.\r\n   */\r\n  function setRewards(ERC20 _strategy, uint256 _amount) external requiresAuth {\r\n    rewardAmount[_strategy] = _amount;\r\n    rewardsNew[_strategy] = true;\r\n    rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n    emit RewardsSet(_strategy, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate and transfer accrued rewards to the flywheel core.\r\n   * @param strategy The strategy to accrue rewards for.\r\n   * @return amount The amount of tokens accrued and transferred.\r\n   * @dev This function can only be called by the flywheel core.\r\n   */\r\n  function getAccruedRewards(\r\n    ERC20 strategy,\r\n    uint32 /* lastUpdatedTimestamp */\r\n  ) external override onlyFlywheel returns (uint256 amount) {\r\n    if (rewardsNew[strategy]) {\r\n      amount = rewardAmount[strategy];\r\n      rewardsNew[strategy] = false;\r\n    } else {\r\n      amount = 0;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/ionic/strategies/flywheel/rewards/IFlywheelRewards.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.10;\r\n\r\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\r\nimport {IonicFlywheelCore} from \"../IonicFlywheelCore.sol\";\r\n\r\n/**\r\n @title Rewards Module for Flywheel\r\n @notice Flywheel is a general framework for managing token incentives.\r\n         It takes reward streams to various *strategies* such as staking LP tokens and divides them among *users* of those strategies.\r\n\r\n         The Rewards module is responsible for:\r\n         * determining the ongoing reward amounts to entire strategies (core handles the logic for dividing among users)\r\n         * actually holding rewards that are yet to be claimed\r\n\r\n         The reward stream can follow arbitrary logic as long as the amount of rewards passed to flywheel core has been sent to this contract.\r\n\r\n         Different module strategies include:\r\n         * a static reward rate per second\r\n         * a decaying reward rate\r\n         * a dynamic just-in-time reward stream\r\n         * liquid governance reward delegation (Curve Gauge style)\r\n\r\n         SECURITY NOTE: The rewards strategy should be smooth and continuous, to prevent gaming the reward distribution by frontrunning.\r\n */\r\ninterface IFlywheelRewards {\r\n    /**\r\n     @notice calculate the rewards amount accrued to a strategy since the last update.\r\n     @param strategy the strategy to accrue rewards for.\r\n     @param lastUpdatedTimestamp the last time rewards were accrued for the strategy.\r\n     @return rewards the amount of rewards accrued to the market\r\n    */\r\n    function getAccruedRewards(ERC20 strategy, uint32 lastUpdatedTimestamp) external returns (uint256 rewards);\r\n\r\n    /// @notice return the flywheel core address\r\n    function flywheel() external view returns (IonicFlywheelCore);\r\n\r\n    /// @notice return the reward token associated with flywheel core.\r\n    function rewardToken() external view returns (ERC20);\r\n}\r\n"
    },
    "contracts/ionic/strategies/IonicERC4626.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\r\n\r\nimport { PausableUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/PausableUpgradeable.sol\";\r\nimport { ERC4626Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol\";\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport { SafeERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\nabstract contract IonicERC4626 is SafeOwnableUpgradeable, PausableUpgradeable, ERC4626Upgradeable {\r\n  using FixedPointMathLib for uint256;\r\n  using SafeERC20Upgradeable for ERC20Upgradeable;\r\n\r\n  /* ========== STATE VARIABLES ========== */\r\n\r\n  uint256 public vaultShareHWM;\r\n  uint256 public performanceFee;\r\n  address public feeRecipient;\r\n\r\n  /* ========== EVENTS ========== */\r\n\r\n  event UpdatedFeeSettings(\r\n    uint256 oldPerformanceFee,\r\n    uint256 newPerformanceFee,\r\n    address oldFeeRecipient,\r\n    address newFeeRecipient\r\n  );\r\n\r\n  event UpdatedRewardsRecipient(address oldRewardsRecipient, address newRewardsRecipient);\r\n\r\n  /* ========== INITIALIZER ========== */\r\n\r\n  function __IonicER4626_init(ERC20Upgradeable asset_) internal onlyInitializing {\r\n    __SafeOwnable_init(msg.sender);\r\n    __Pausable_init();\r\n    __Context_init();\r\n    __ERC20_init(\r\n      string(abi.encodePacked(\"Ionic \", asset_.name(), \" Vault\")),\r\n      string(abi.encodePacked(\"iv\", asset_.symbol()))\r\n    );\r\n    __ERC4626_init(asset_);\r\n\r\n    vaultShareHWM = 10 ** asset_.decimals();\r\n    feeRecipient = msg.sender;\r\n  }\r\n\r\n  function _asset() internal view returns (ERC20Upgradeable) {\r\n    return ERC20Upgradeable(super.asset());\r\n  }\r\n\r\n  /* ========== DEPOSIT/WITHDRAW FUNCTIONS ========== */\r\n\r\n  function deposit(uint256 assets, address receiver) public override whenNotPaused returns (uint256 shares) {\r\n    // Check for rounding error since we round down in previewDeposit.\r\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\r\n\r\n    // Need to transfer before minting or ERC777s could reenter.\r\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n    _mint(receiver, shares);\r\n\r\n    emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n    afterDeposit(assets, shares);\r\n  }\r\n\r\n  function mint(uint256 shares, address receiver) public override whenNotPaused returns (uint256 assets) {\r\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\r\n\r\n    // Need to transfer before minting or ERC777s could reenter.\r\n    _asset().safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n    _mint(receiver, shares);\r\n\r\n    emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n    afterDeposit(assets, shares);\r\n  }\r\n\r\n  function withdraw(uint256 assets, address receiver, address owner) public override returns (uint256 shares) {\r\n    shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\r\n\r\n    if (msg.sender != owner) {\r\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\r\n\r\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\r\n    }\r\n\r\n    if (!paused()) {\r\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\r\n\r\n      beforeWithdraw(assets, shares);\r\n\r\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\r\n    }\r\n\r\n    _burn(owner, shares);\r\n\r\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n    _asset().safeTransfer(receiver, assets);\r\n  }\r\n\r\n  function redeem(uint256 shares, address receiver, address owner) public override returns (uint256 assets) {\r\n    if (msg.sender != owner) {\r\n      uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals.\r\n\r\n      if (allowed != type(uint256).max) _approve(owner, msg.sender, allowed - shares);\r\n    }\r\n\r\n    // Check for rounding error since we round down in previewRedeem.\r\n    require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\r\n\r\n    if (!paused()) {\r\n      uint256 balanceBeforeWithdraw = _asset().balanceOf(address(this));\r\n\r\n      beforeWithdraw(assets, shares);\r\n\r\n      assets = _asset().balanceOf(address(this)) - balanceBeforeWithdraw;\r\n    }\r\n\r\n    _burn(owner, shares);\r\n\r\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n    _asset().safeTransfer(receiver, assets);\r\n  }\r\n\r\n  /* ========== FEE FUNCTIONS ========== */\r\n\r\n  /**\r\n   * @notice Take the performance fee that has accrued since last fee harvest.\r\n   * @dev Performance fee is based on a vault share high water mark value. If vault share value has increased above the\r\n   *   HWM in a fee period, issue fee shares to the vault equal to the performance fee.\r\n   */\r\n  function takePerformanceFee() external onlyOwner {\r\n    require(feeRecipient != address(0), \"fee recipient not initialized\");\r\n\r\n    uint256 currentAssets = totalAssets();\r\n    uint256 shareValue = convertToAssets(10 ** _asset().decimals());\r\n\r\n    require(shareValue > vaultShareHWM, \"shareValue !> vaultShareHWM\");\r\n    // cache value\r\n    uint256 supply = totalSupply();\r\n\r\n    uint256 accruedPerformanceFee = (performanceFee * (shareValue - vaultShareHWM) * supply) / 1e36;\r\n    _mint(feeRecipient, accruedPerformanceFee.mulDivDown(supply, (currentAssets - accruedPerformanceFee)));\r\n\r\n    vaultShareHWM = convertToAssets(10 ** _asset().decimals());\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer accrued fees to rewards manager contract. Caller must be a registered keeper.\r\n   * @dev We must make sure that feeRecipient is not address(0) before withdrawing fees\r\n   */\r\n  function withdrawAccruedFees() external onlyOwner {\r\n    redeem(balanceOf(feeRecipient), feeRecipient, feeRecipient);\r\n  }\r\n\r\n  /**\r\n   * @notice Update performanceFee and/or feeRecipient\r\n   */\r\n  function updateFeeSettings(uint256 newPerformanceFee, address newFeeRecipient) external onlyOwner {\r\n    emit UpdatedFeeSettings(performanceFee, newPerformanceFee, feeRecipient, newFeeRecipient);\r\n\r\n    performanceFee = newPerformanceFee;\r\n\r\n    if (newFeeRecipient != feeRecipient) {\r\n      if (feeRecipient != address(0)) {\r\n        uint256 oldFees = balanceOf(feeRecipient);\r\n\r\n        _burn(feeRecipient, oldFees);\r\n        _approve(feeRecipient, owner(), 0);\r\n        _mint(newFeeRecipient, oldFees);\r\n      }\r\n\r\n      _approve(newFeeRecipient, owner(), type(uint256).max);\r\n    }\r\n\r\n    feeRecipient = newFeeRecipient;\r\n  }\r\n\r\n  /* ========== EMERGENCY FUNCTIONS ========== */\r\n\r\n  // Should withdraw all funds from the strategy and pause the contract\r\n  function emergencyWithdrawAndPause() external virtual;\r\n\r\n  function unpause() external virtual;\r\n\r\n  function shutdown(address market) external onlyOwner whenPaused returns (uint256) {\r\n    ERC20Upgradeable theAsset = _asset();\r\n    uint256 endBalance = theAsset.balanceOf(address(this));\r\n    theAsset.transfer(market, endBalance);\r\n    return endBalance;\r\n  }\r\n\r\n  /* ========== INTERNAL HOOKS LOGIC ========== */\r\n\r\n  function beforeWithdraw(uint256 assets, uint256 shares) internal virtual;\r\n\r\n  function afterDeposit(uint256 assets, uint256 shares) internal virtual;\r\n}\r\n"
    },
    "contracts/ionic/strategies/IonicMarketERC4626.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.22;\r\nimport { IonicERC4626, ERC20Upgradeable } from \"./IonicERC4626.sol\";\r\nimport { SafeERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\nimport { ComptrollerErrorReporter } from \"../../compound/ErrorReporter.sol\";\r\n\r\ninterface IonicFlywheelLensRouter_4626 {\r\n  function claimAllRewardTokens(address user) external returns (address[] memory, uint256[] memory);\r\n}\r\n\r\ncontract IonicMarketERC4626 is IonicERC4626 {\r\n  using SafeERC20Upgradeable for ERC20Upgradeable;\r\n\r\n  error IonicMarketERC4626__CompoundError(ComptrollerErrorReporter.Error);\r\n\r\n  // STATE VARIABLES\r\n  address public rewardsRecipient;\r\n  IonicFlywheelLensRouter_4626 public flywheelLensRouter;\r\n  ICErc20 public cToken;\r\n\r\n  function initialize(\r\n    ERC20Upgradeable asset_,\r\n    ICErc20 cToken_,\r\n    address flywheelLensRouter_,\r\n    address rewardsRecipient_\r\n  ) public initializer {\r\n    __IonicER4626_init(asset_);\r\n    cToken = cToken_;\r\n    rewardsRecipient = rewardsRecipient_;\r\n    flywheelLensRouter = IonicFlywheelLensRouter_4626(flywheelLensRouter_);\r\n  }\r\n\r\n  /* ========== VIEW FUNCTIONS ========== */\r\n  function totalAssets() public view virtual override returns (uint256) {\r\n    return cToken.balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /// @notice maximum amount of underlying tokens that can be deposited into the underlying protocol\r\n  function maxDeposit(address) public view override returns (uint256) {\r\n    if (cToken.comptroller().mintGuardianPaused(address(cToken))) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 supplyCap = cToken.comptroller().supplyCaps(address(cToken));\r\n    if (supplyCap != 0) {\r\n      uint256 currentExchangeRate = cToken.exchangeRateCurrent();\r\n      uint256 _totalSupply = cToken.totalSupply();\r\n      uint256 totalSupplies = (_totalSupply * currentExchangeRate) / 1e18; /// exchange rate is scaled up by 1e18, so needs to be divided off to get accurate total supply\r\n\r\n      // uint256 totalCash = MToken(address(mToken)).getCash();\r\n      // uint256 totalBorrows = MToken(address(mToken)).totalBorrows();\r\n      // uint256 totalReserves = MToken(address(mToken)).totalReserves();\r\n\r\n      // // (Pseudocode) totalSupplies = totalCash + totalBorrows - totalReserves\r\n      // uint256 totalSupplies = (totalCash + totalBorrows) - totalReserves;\r\n\r\n      // supply cap is      3\r\n      // total supplies is  1\r\n      /// no room for additional supplies\r\n\r\n      // supply cap is      3\r\n      // total supplies is  0\r\n      /// room for 1 additional supplies\r\n\r\n      // supply cap is      4\r\n      // total supplies is  1\r\n      /// room for 1 additional supplies\r\n\r\n      /// total supplies could exceed supply cap as interest accrues, need to handle this edge case\r\n      /// going to subtract 2 from supply cap to account for rounding errors\r\n      if (totalSupplies + 2 >= supplyCap) {\r\n        return 0;\r\n      }\r\n\r\n      return supplyCap - totalSupplies - 2;\r\n    }\r\n\r\n    return type(uint256).max;\r\n  }\r\n\r\n  /// @notice Returns the maximum amount of tokens that can be supplied\r\n  /// no way for this function to ever revert unless comptroller or mToken is broken\r\n  /// @dev accrue interest must be called before this function is called, otherwise\r\n  /// an outdated value will be fetched, and the returned value will be incorrect\r\n  /// (greater than actual amount available to be minted will be returned)\r\n  function maxMint(address) public view override returns (uint256) {\r\n    uint256 mintAmount = maxDeposit(address(0));\r\n\r\n    return mintAmount == type(uint256).max ? mintAmount : convertToShares(mintAmount);\r\n  }\r\n\r\n  /// @notice maximum amount of underlying tokens that can be withdrawn\r\n  /// @param owner The address that owns the shares\r\n  function maxWithdraw(address owner) public view override returns (uint256) {\r\n    uint256 cash = cToken.getCash();\r\n    uint256 assetsBalance = convertToAssets(balanceOf(owner));\r\n    return cash < assetsBalance ? cash : assetsBalance;\r\n  }\r\n\r\n  /// @notice maximum amount of shares that can be withdrawn\r\n  /// @param owner The address that owns the shares\r\n  function maxRedeem(address owner) public view override returns (uint256) {\r\n    uint256 cash = cToken.getCash();\r\n    uint256 cashInShares = convertToShares(cash);\r\n    uint256 shareBalance = balanceOf(owner);\r\n    return cashInShares < shareBalance ? cashInShares : shareBalance;\r\n  }\r\n\r\n  /* ========== REWARDS FUNCTIONS ========== */\r\n\r\n  function updateRewardsRecipient(address newRewardsRecipient) external onlyOwner {\r\n    emit UpdatedRewardsRecipient(rewardsRecipient, newRewardsRecipient);\r\n    rewardsRecipient = newRewardsRecipient;\r\n  }\r\n\r\n  function claimRewards() external {\r\n    (address[] memory tokens, uint256[] memory amounts) = flywheelLensRouter.claimAllRewardTokens(address(this));\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      _asset().safeTransfer(rewardsRecipient, amounts[i]);\r\n    }\r\n  }\r\n\r\n  /* ========== EMERGENCY FUNCTIONS ========== */\r\n\r\n  // Should withdraw all funds from the strategy and pause the contract\r\n  function emergencyWithdrawAndPause() external override onlyOwner {\r\n    _pause();\r\n  }\r\n\r\n  function unpause() external override onlyOwner {\r\n    _unpause();\r\n  }\r\n\r\n  /* ========== INTERNAL HOOKS LOGIC ========== */\r\n\r\n  function beforeWithdraw(uint256 assets, uint256 /*shares*/) internal override {\r\n    /// -----------------------------------------------------------------------\r\n    /// Withdraw assets from Ionic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    uint256 errorCode = cToken.redeemUnderlying(assets);\r\n    if (errorCode != uint256(ComptrollerErrorReporter.Error.NO_ERROR)) {\r\n      revert IonicMarketERC4626__CompoundError(ComptrollerErrorReporter.Error(errorCode));\r\n    }\r\n  }\r\n\r\n  function afterDeposit(uint256 assets, uint256 /*shares*/) internal override {\r\n    /// -----------------------------------------------------------------------\r\n    /// Deposit assets into Ionic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    // approve to cToken\r\n    _asset().safeApprove(address(cToken), assets);\r\n\r\n    // deposit into cToken\r\n    uint256 errorCode = cToken.mint(assets);\r\n    if (errorCode != uint256(ComptrollerErrorReporter.Error.NO_ERROR)) {\r\n      revert IonicMarketERC4626__CompoundError(ComptrollerErrorReporter.Error(errorCode));\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/IonicLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\nimport \"./liquidators/IRedemptionStrategy.sol\";\r\nimport \"./liquidators/IFundsConversionStrategy.sol\";\r\nimport \"./ILiquidator.sol\";\r\n\r\nimport \"./utils/IW_NATIVE.sol\";\r\n\r\nimport \"./external/uniswap/IUniswapV2Router02.sol\";\r\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\r\nimport \"./external/uniswap/IUniswapV2Callee.sol\";\r\nimport \"./external/uniswap/UniswapV2Library.sol\";\r\nimport \"./external/pyth/IExpressRelay.sol\";\r\nimport \"./external/pyth/IExpressRelayFeeReceiver.sol\";\r\n\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\n\r\nimport \"./PoolLens.sol\";\r\n\r\n/**\r\n * @title IonicLiquidator\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice IonicLiquidator safely liquidates unhealthy borrowers (with flashloan support).\r\n * @dev Do not transfer NATIVE or tokens directly to this address. Only send NATIVE here when using a method, and only approve tokens for transfer to here when using a method. Direct NATIVE transfers will be rejected and direct token transfers will be lost.\r\n */\r\ncontract IonicLiquidator is OwnableUpgradeable, ILiquidator, IUniswapV2Callee, IExpressRelayFeeReceiver {\r\n  using AddressUpgradeable for address payable;\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  event VaultReceivedETH(address sender, uint256 amount, bytes permissionKey);\r\n\r\n  /**\r\n   * @dev W_NATIVE contract address.\r\n   */\r\n  address public W_NATIVE_ADDRESS;\r\n\r\n  /**\r\n   * @dev UniswapV2Router02 contract object. (Is interchangable with any UniV2 forks)\r\n   */\r\n  IUniswapV2Router02 public UNISWAP_V2_ROUTER_02;\r\n\r\n  /**\r\n   * @dev Cached liquidator profit exchange source.\r\n   * ERC20 token address or the zero address for NATIVE.\r\n   * For use in `safeLiquidateToTokensWithFlashLoan` after it is set by `postFlashLoanTokens`.\r\n   */\r\n  address private _liquidatorProfitExchangeSource;\r\n\r\n  mapping(address => bool) public redemptionStrategiesWhitelist;\r\n\r\n  /**\r\n   * @dev Cached flash swap amount.\r\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\r\n   */\r\n  uint256 private _flashSwapAmount;\r\n\r\n  /**\r\n   * @dev Cached flash swap token.\r\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\r\n   */\r\n  address private _flashSwapToken;\r\n  /**\r\n   * @dev Percentage of the flash swap fee, measured in basis points.\r\n   */\r\n  uint8 public flashSwapFee;\r\n\r\n  /**\r\n   * @dev Addres of Pyth Express Relay for preventing value leakage in liquidations.\r\n   */\r\n  IExpressRelay public expressRelay;\r\n  /**\r\n   * @dev Pool Lens.\r\n   */\r\n  PoolLens public lens;\r\n  /**\r\n   * @dev Health Factor below which PER permissioning is bypassed.\r\n   */\r\n  uint256 public healthFactorThreshold;\r\n\r\n  modifier onlyLowHF(address borrower, ICErc20 cToken) {\r\n    uint256 currentHealthFactor = lens.getHealthFactor(borrower, cToken.comptroller());\r\n    require(currentHealthFactor < healthFactorThreshold, \"HF not low enough, reserving for PYTH\");\r\n    _;\r\n  }\r\n\r\n  function initialize(address _wtoken, address _uniswapV2router, uint8 _flashSwapFee) external initializer {\r\n    __Ownable_init();\r\n    require(_uniswapV2router != address(0), \"_uniswapV2router not defined.\");\r\n    W_NATIVE_ADDRESS = _wtoken;\r\n    UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(_uniswapV2router);\r\n    flashSwapFee = _flashSwapFee;\r\n  }\r\n\r\n  function _becomeImplementation(bytes calldata data) external {}\r\n\r\n  /**\r\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\r\n   */\r\n  function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\r\n    uint256 allowance = token.allowance(address(this), to);\r\n\r\n    if (allowance < minAmount) {\r\n      if (allowance > 0) token.safeApprove(to, 0);\r\n      token.safeApprove(to, type(uint256).max);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to approve\r\n   */\r\n  function justApprove(IERC20Upgradeable token, address to, uint256 amount) private {\r\n    token.approve(to, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\r\n   * @param borrower The borrower's Ethereum address.\r\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\r\n   * @param cErc20 The borrowed cErc20 to repay.\r\n   * @param cTokenCollateral The cToken collateral to be liquidated.\r\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\r\n   */\r\n  function _safeLiquidate(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) internal returns (uint256) {\r\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\r\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\r\n    IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\r\n    underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\r\n    justApprove(underlying, address(cErc20), repayAmount);\r\n    require(cErc20.liquidateBorrow(borrower, repayAmount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\r\n\r\n    // Redeem seized cTokens for underlying asset\r\n    uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\r\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n    uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\r\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n\r\n    return transferSeizedFunds(address(cTokenCollateral.underlying()), minOutputAmount);\r\n  }\r\n\r\n  function safeLiquidate(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) external onlyLowHF(borrower, cTokenCollateral) returns (uint256) {\r\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\r\n  }\r\n\r\n  function safeLiquidatePyth(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) external returns (uint256) {\r\n    require(expressRelay.isPermissioned(address(this), abi.encode(borrower)), \"invalid liquidation\");\r\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers seized funds to the sender.\r\n   * @param erc20Contract The address of the token to transfer.\r\n   * @param minOutputAmount The minimum amount to transfer.\r\n   */\r\n  function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\r\n    IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\r\n    uint256 seizedOutputAmount = token.balanceOf(address(this));\r\n    require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\r\n    if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\r\n\r\n    return seizedOutputAmount;\r\n  }\r\n\r\n  function safeLiquidateWithAggregator(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    address aggregatorTarget,\r\n    bytes memory aggregatorData\r\n  ) external {\r\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\r\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\r\n    cErc20.flash(\r\n      repayAmount,\r\n      abi.encode(borrower, cErc20, cTokenCollateral, aggregatorTarget, aggregatorData, msg.sender)\r\n    );\r\n  }\r\n\r\n  function receiveFlashLoan(address _underlyingBorrow, uint256 amount, bytes calldata data) external {\r\n    (\r\n      address borrower,\r\n      ICErc20 cErc20,\r\n      ICErc20 cTokenCollateral,\r\n      address aggregatorTarget,\r\n      bytes memory aggregatorData,\r\n      address liquidator\r\n    ) = abi.decode(data, (address, ICErc20, ICErc20, address, bytes, address));\r\n    IERC20Upgradeable underlyingBorrow = IERC20Upgradeable(_underlyingBorrow);\r\n    underlyingBorrow.approve(address(cErc20), amount);\r\n    require(cErc20.liquidateBorrow(borrower, amount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\r\n\r\n    // Redeem seized cTokens for underlying asset\r\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cTokenCollateral.underlying());\r\n    {\r\n      uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\r\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n      uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\r\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n      uint256 underlyingCollateralRedeemed = underlyingCollateral.balanceOf(address(this));\r\n\r\n      // Call the aggregator\r\n      underlyingCollateral.approve(aggregatorTarget, underlyingCollateralRedeemed);\r\n      (bool success, ) = aggregatorTarget.call(aggregatorData);\r\n      require(success, \"Aggregator call failed\");\r\n    }\r\n\r\n    // receive profits\r\n    {\r\n      uint256 receivedAmount = underlyingBorrow.balanceOf(address(this));\r\n      require(receivedAmount >= amount, \"Not received enough collateral after swap.\");\r\n      uint256 profitBorrow = receivedAmount - amount;\r\n      if (profitBorrow > 0) {\r\n        underlyingBorrow.safeTransfer(liquidator, profitBorrow);\r\n      }\r\n\r\n      uint256 profitCollateral = underlyingCollateral.balanceOf(address(this));\r\n      if (profitCollateral > 0) {\r\n        underlyingCollateral.safeTransfer(liquidator, profitCollateral);\r\n      }\r\n    }\r\n\r\n    // pay back flashloan\r\n    underlyingBorrow.approve(address(cErc20), amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in NATIVE profit is seized.\r\n   * @param vars @see LiquidateToTokensWithFlashSwapVars.\r\n   */\r\n  function safeLiquidateToTokensWithFlashLoan(\r\n    LiquidateToTokensWithFlashSwapVars calldata vars\r\n  ) external onlyLowHF(vars.borrower, vars.cTokenCollateral) returns (uint256) {\r\n    // Input validation\r\n    require(vars.repayAmount > 0, \"Repay amount must be greater than 0.\");\r\n\r\n    // we want to calculate the needed flashSwapAmount on-chain to\r\n    // avoid errors due to changing market conditions\r\n    // between the time of calculating and including the tx in a block\r\n    uint256 fundingAmount = vars.repayAmount;\r\n    IERC20Upgradeable fundingToken;\r\n    if (vars.debtFundingStrategies.length > 0) {\r\n      require(\r\n        vars.debtFundingStrategies.length == vars.debtFundingStrategiesData.length,\r\n        \"Funding IFundsConversionStrategy contract array and strategy data bytes array must be the same length.\"\r\n      );\r\n      // estimate the initial (flash-swapped token) input from the expected output (debt token)\r\n      for (uint256 i = 0; i < vars.debtFundingStrategies.length; i++) {\r\n        bytes memory strategyData = vars.debtFundingStrategiesData[i];\r\n        IFundsConversionStrategy fcs = vars.debtFundingStrategies[i];\r\n        (fundingToken, fundingAmount) = fcs.estimateInputAmount(fundingAmount, strategyData);\r\n      }\r\n    } else {\r\n      fundingToken = IERC20Upgradeable(ICErc20(address(vars.cErc20)).underlying());\r\n    }\r\n\r\n    // the last outputs from estimateInputAmount are the ones to be flash-swapped\r\n    _flashSwapAmount = fundingAmount;\r\n    _flashSwapToken = address(fundingToken);\r\n\r\n    IUniswapV2Pair flashSwapPair = IUniswapV2Pair(vars.flashSwapContract);\r\n    bool token0IsFlashSwapFundingToken = flashSwapPair.token0() == address(fundingToken);\r\n    flashSwapPair.swap(\r\n      token0IsFlashSwapFundingToken ? fundingAmount : 0,\r\n      !token0IsFlashSwapFundingToken ? fundingAmount : 0,\r\n      address(this),\r\n      msg.data\r\n    );\r\n\r\n    return transferSeizedFunds(_liquidatorProfitExchangeSource, vars.minProfitAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Receives NATIVE from liquidations and flashloans.\r\n   * Requires that `msg.sender` is W_NATIVE, a CToken, or a Uniswap V2 Router, or another contract.\r\n   */\r\n  receive() external payable {\r\n    require(payable(msg.sender).isContract(), \"Sender is not a contract.\");\r\n  }\r\n\r\n  /**\r\n   * @notice receiveAuctionProceedings function - receives native token from the express relay\r\n   * You can use permission key to distribute the received funds to users who got liquidated, LPs, etc...\r\n   */\r\n  function receiveAuctionProceedings(bytes calldata permissionKey) external payable {\r\n    emit VaultReceivedETH(msg.sender, msg.value, permissionKey);\r\n  }\r\n\r\n  function withdrawAll() external onlyOwner {\r\n    uint256 balance = address(this).balance;\r\n    require(balance > 0, \"No Ether left to withdraw\");\r\n\r\n    // Transfer all Ether to the owner\r\n    (bool sent, ) = msg.sender.call{ value: balance }(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n  }\r\n\r\n  /**\r\n   * @dev Callback function for Uniswap flashloans.\r\n   */\r\n  function uniswapV2Call(address, uint256, uint256, bytes calldata data) public override {\r\n    // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\r\n    // Decode params\r\n    LiquidateToTokensWithFlashSwapVars memory vars = abi.decode(data[4:], (LiquidateToTokensWithFlashSwapVars));\r\n\r\n    // Post token flashloan\r\n    // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\r\n    _liquidatorProfitExchangeSource = postFlashLoanTokens(vars);\r\n  }\r\n\r\n  /**\r\n   * @dev Callback function for PCS flashloans.\r\n   */\r\n  function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\r\n    uniswapV2Call(sender, amount0, amount1, data);\r\n  }\r\n\r\n  function moraswapCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\r\n    uniswapV2Call(sender, amount0, amount1, data);\r\n  }\r\n\r\n  /**\r\n   * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\r\n   */\r\n  function postFlashLoanTokens(LiquidateToTokensWithFlashSwapVars memory vars) private returns (address) {\r\n    IERC20Upgradeable debtRepaymentToken = IERC20Upgradeable(_flashSwapToken);\r\n    uint256 debtRepaymentAmount = _flashSwapAmount;\r\n\r\n    if (vars.debtFundingStrategies.length > 0) {\r\n      // loop backwards to convert the initial (flash-swapped token) input to the final expected output (debt token)\r\n      for (uint256 i = vars.debtFundingStrategies.length; i > 0; i--) {\r\n        (debtRepaymentToken, debtRepaymentAmount) = convertCustomFunds(\r\n          debtRepaymentToken,\r\n          debtRepaymentAmount,\r\n          vars.debtFundingStrategies[i - 1],\r\n          vars.debtFundingStrategiesData[i - 1]\r\n        );\r\n      }\r\n    }\r\n\r\n    // Approve the debt repayment transfer, liquidate and redeem the seized collateral\r\n    {\r\n      address underlyingBorrow = vars.cErc20.underlying();\r\n      require(\r\n        address(debtRepaymentToken) == underlyingBorrow,\r\n        \"the debt repayment funds should be converted to the underlying debt token\"\r\n      );\r\n      require(debtRepaymentAmount >= vars.repayAmount, \"debt repayment amount not enough\");\r\n      // Approve repayAmount to cErc20\r\n      justApprove(IERC20Upgradeable(underlyingBorrow), address(vars.cErc20), vars.repayAmount);\r\n\r\n      // Liquidate borrow\r\n      require(\r\n        vars.cErc20.liquidateBorrow(vars.borrower, vars.repayAmount, address(vars.cTokenCollateral)) == 0,\r\n        \"Liquidation failed.\"\r\n      );\r\n\r\n      // Redeem seized cTokens for underlying asset\r\n      uint256 seizedCTokenAmount = vars.cTokenCollateral.balanceOf(address(this));\r\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n      uint256 redeemResult = vars.cTokenCollateral.redeem(seizedCTokenAmount);\r\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n    }\r\n\r\n    // Repay flashloan\r\n    return repayTokenFlashLoan(vars.cTokenCollateral, vars.redemptionStrategies, vars.strategyData);\r\n  }\r\n\r\n  /**\r\n   * @dev Repays token flashloans.\r\n   */\r\n  function repayTokenFlashLoan(\r\n    ICErc20 cTokenCollateral,\r\n    IRedemptionStrategy[] memory redemptionStrategies,\r\n    bytes[] memory strategyData\r\n  ) private returns (address) {\r\n    // Calculate flashloan return amount\r\n    uint256 flashSwapReturnAmount = (_flashSwapAmount * 10000) / (10000 - flashSwapFee);\r\n    if ((_flashSwapAmount * 10000) % (10000 - flashSwapFee) > 0) flashSwapReturnAmount++; // Round up if division resulted in a remainder\r\n\r\n    // Swap cTokenCollateral for cErc20 via Uniswap\r\n    // Check underlying collateral seized\r\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\r\n    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\r\n\r\n    // Redeem custom collateral if liquidation strategy is set\r\n    if (redemptionStrategies.length > 0) {\r\n      require(\r\n        redemptionStrategies.length == strategyData.length,\r\n        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\r\n      );\r\n      for (uint256 i = 0; i < redemptionStrategies.length; i++)\r\n        (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\r\n          underlyingCollateral,\r\n          underlyingCollateralSeized,\r\n          redemptionStrategies[i],\r\n          strategyData[i]\r\n        );\r\n    }\r\n\r\n    IUniswapV2Pair pair = IUniswapV2Pair(msg.sender);\r\n\r\n    // Check if we can repay directly one of the sides with collateral\r\n    if (address(underlyingCollateral) == pair.token0() || address(underlyingCollateral) == pair.token1()) {\r\n      // Repay flashloan directly with collateral\r\n      uint256 collateralRequired;\r\n      if (address(underlyingCollateral) == _flashSwapToken) {\r\n        // repay amount for the borrow side\r\n        collateralRequired = flashSwapReturnAmount;\r\n      } else {\r\n        // repay amount for the non-borrow side\r\n        collateralRequired = UniswapV2Library.getAmountsIn(\r\n          UNISWAP_V2_ROUTER_02.factory(),\r\n          _flashSwapAmount, //flashSwapReturnAmount,\r\n          array(address(underlyingCollateral), _flashSwapToken),\r\n          flashSwapFee\r\n        )[0];\r\n      }\r\n\r\n      // Repay flashloan\r\n      require(\r\n        collateralRequired <= underlyingCollateralSeized,\r\n        \"Token flashloan return amount greater than seized collateral.\"\r\n      );\r\n      require(\r\n        underlyingCollateral.transfer(msg.sender, collateralRequired),\r\n        \"Failed to repay token flashloan on borrow side.\"\r\n      );\r\n\r\n      return address(underlyingCollateral);\r\n    } else {\r\n      // exchange the collateral to W_NATIVE to repay the borrow side\r\n      uint256 wethRequired;\r\n      if (_flashSwapToken == W_NATIVE_ADDRESS) {\r\n        wethRequired = flashSwapReturnAmount;\r\n      } else {\r\n        // Get W_NATIVE required to repay flashloan\r\n        wethRequired = UniswapV2Library.getAmountsIn(\r\n          UNISWAP_V2_ROUTER_02.factory(),\r\n          flashSwapReturnAmount,\r\n          array(W_NATIVE_ADDRESS, _flashSwapToken),\r\n          flashSwapFee\r\n        )[0];\r\n      }\r\n\r\n      if (address(underlyingCollateral) != W_NATIVE_ADDRESS) {\r\n        // Approve to Uniswap router\r\n        justApprove(underlyingCollateral, address(UNISWAP_V2_ROUTER_02), underlyingCollateralSeized);\r\n\r\n        // Swap collateral tokens for W_NATIVE to be repaid via Uniswap router\r\n        UNISWAP_V2_ROUTER_02.swapTokensForExactTokens(\r\n          wethRequired,\r\n          underlyingCollateralSeized,\r\n          array(address(underlyingCollateral), W_NATIVE_ADDRESS),\r\n          address(this),\r\n          block.timestamp\r\n        );\r\n      }\r\n\r\n      // Repay flashloan\r\n      require(\r\n        wethRequired <= IERC20Upgradeable(W_NATIVE_ADDRESS).balanceOf(address(this)),\r\n        \"Not enough W_NATIVE exchanged from seized collateral to repay flashloan.\"\r\n      );\r\n      require(\r\n        IW_NATIVE(W_NATIVE_ADDRESS).transfer(msg.sender, wethRequired),\r\n        \"Failed to repay Uniswap flashloan with W_NATIVE exchanged from seized collateral.\"\r\n      );\r\n\r\n      // Return the profited token (underlying collateral if same as exchangeProfitTo; otherwise, W_NATIVE)\r\n      return address(underlyingCollateral);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev for security reasons only whitelisted redemption strategies may be used.\r\n   * Each whitelisted redemption strategy has to be checked to not be able to\r\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\r\n   */\r\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external onlyOwner {\r\n    redemptionStrategiesWhitelist[address(strategy)] = whitelisted;\r\n  }\r\n\r\n  /**\r\n   * @dev for security reasons only whitelisted redemption strategies may be used.\r\n   * Each whitelisted redemption strategy has to be checked to not be able to\r\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\r\n   */\r\n  function _whitelistRedemptionStrategies(\r\n    IRedemptionStrategy[] calldata strategies,\r\n    bool[] calldata whitelisted\r\n  ) external onlyOwner {\r\n    require(\r\n      strategies.length > 0 && strategies.length == whitelisted.length,\r\n      \"list of strategies empty or whitelist does not match its length\"\r\n    );\r\n\r\n    for (uint256 i = 0; i < strategies.length; i++) {\r\n      redemptionStrategiesWhitelist[address(strategies[i])] = whitelisted[i];\r\n    }\r\n  }\r\n\r\n  function setExpressRelay(address _expressRelay) external onlyOwner {\r\n    expressRelay = IExpressRelay(_expressRelay);\r\n  }\r\n\r\n  function setPoolLens(address _poolLens) external onlyOwner {\r\n    lens = PoolLens(_poolLens);\r\n  }\r\n\r\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external onlyOwner {\r\n    require(_healthFactorThreshold <= 1e18, \"Invalid Health Factor Threshold\");\r\n    healthFactorThreshold = _healthFactorThreshold;\r\n  }\r\n\r\n  /**\r\n   * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\r\n   * Public visibility because we have to call this function externally if called from a payable IonicLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\r\n   */\r\n  function redeemCustomCollateral(\r\n    IERC20Upgradeable underlyingCollateral,\r\n    uint256 underlyingCollateralSeized,\r\n    IRedemptionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\r\n\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  function convertCustomFunds(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IFundsConversionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\r\n\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.convert.selector, inputToken, inputAmount, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\r\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\r\n   */\r\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\r\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\r\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\r\n   */\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an array containing the parameters supplied.\r\n   */\r\n  function array(address a, address b) private pure returns (address[] memory) {\r\n    address[] memory arr = new address[](2);\r\n    arr[0] = a;\r\n    arr[1] = b;\r\n    return arr;\r\n  }\r\n}\r\n"
    },
    "contracts/IonicUniV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\nimport \"./liquidators/IRedemptionStrategy.sol\";\r\nimport \"./liquidators/IFundsConversionStrategy.sol\";\r\nimport \"./ILiquidator.sol\";\r\n\r\nimport \"./external/uniswap/IUniswapV3FlashCallback.sol\";\r\nimport \"./external/uniswap/IUniswapV3Pool.sol\";\r\nimport \"./external/pyth/IExpressRelay.sol\";\r\nimport \"./external/pyth/IExpressRelayFeeReceiver.sol\";\r\nimport { IUniswapV3Quoter } from \"./external/uniswap/quoter/interfaces/IUniswapV3Quoter.sol\";\r\nimport { IFlashLoanReceiver } from \"./ionic/IFlashLoanReceiver.sol\";\r\n\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\n\r\nimport \"./PoolLens.sol\";\r\n\r\n/**\r\n * @title IonicUniV3Liquidator\r\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\r\n * @notice IonicUniV3Liquidator liquidates unhealthy borrowers with flashloan support.\r\n */\r\ncontract IonicUniV3Liquidator is\r\n  OwnableUpgradeable,\r\n  ILiquidator,\r\n  IUniswapV3FlashCallback,\r\n  IExpressRelayFeeReceiver,\r\n  IFlashLoanReceiver\r\n{\r\n  using AddressUpgradeable for address payable;\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  event VaultReceivedETH(address sender, uint256 amount, bytes permissionKey);\r\n  /**\r\n   * @dev Cached liquidator profit exchange source.\r\n   * ERC20 token address or the zero address for NATIVE.\r\n   * For use in `safeLiquidateToTokensWithFlashLoan` after it is set by `postFlashLoanTokens`.\r\n   */\r\n  address private _liquidatorProfitExchangeSource;\r\n\r\n  /**\r\n   * @dev Cached flash swap amount.\r\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\r\n   */\r\n  uint256 private _flashSwapAmount;\r\n\r\n  /**\r\n   * @dev Cached flash swap token.\r\n   * For use in `repayTokenFlashLoan` after it is set by `safeLiquidateToTokensWithFlashLoan`.\r\n   */\r\n  address private _flashSwapToken;\r\n\r\n  address public W_NATIVE_ADDRESS;\r\n  mapping(address => bool) public redemptionStrategiesWhitelist;\r\n  IUniswapV3Quoter public quoter;\r\n\r\n  /**\r\n   * @dev Addres of Pyth Express Relay for preventing value leakage in liquidations.\r\n   */\r\n  IExpressRelay public expressRelay;\r\n  /**\r\n   * @dev Pool Lens.\r\n   */\r\n  PoolLens public lens;\r\n  /**\r\n   * @dev Health Factor below which PER permissioning is bypassed.\r\n   */\r\n  uint256 public healthFactorThreshold;\r\n\r\n  modifier onlyLowHF(address borrower, ICErc20 cToken) {\r\n    uint256 currentHealthFactor = lens.getHealthFactor(borrower, cToken.comptroller());\r\n    require(currentHealthFactor < healthFactorThreshold, \"HF not low enough, reserving for PYTH\");\r\n    _;\r\n  }\r\n\r\n  function initialize(address _wtoken, address _quoter) external initializer {\r\n    __Ownable_init();\r\n    W_NATIVE_ADDRESS = _wtoken;\r\n    quoter = IUniswapV3Quoter(_quoter);\r\n  }\r\n\r\n  /**\r\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\r\n   * @param borrower The borrower's Ethereum address.\r\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\r\n   * @param cErc20 The borrowed cErc20 to repay.\r\n   * @param cTokenCollateral The cToken collateral to be liquidated.\r\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\r\n   */\r\n  function _safeLiquidate(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) internal returns (uint256) {\r\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\r\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\r\n    IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\r\n    underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\r\n    underlying.approve(address(cErc20), repayAmount);\r\n    require(cErc20.liquidateBorrow(borrower, repayAmount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\r\n\r\n    // Redeem seized cTokens for underlying asset\r\n    uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\r\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n    uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\r\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n\r\n    return transferSeizedFunds(address(cTokenCollateral.underlying()), minOutputAmount);\r\n  }\r\n\r\n  function safeLiquidate(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) external onlyLowHF(borrower, cTokenCollateral) returns (uint256) {\r\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\r\n  }\r\n\r\n  function safeLiquidatePyth(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    uint256 minOutputAmount\r\n  ) external returns (uint256) {\r\n    require(expressRelay.isPermissioned(address(this), abi.encode(borrower)), \"invalid liquidation\");\r\n    return _safeLiquidate(borrower, repayAmount, cErc20, cTokenCollateral, minOutputAmount);\r\n  }\r\n\r\n  function safeLiquidateWithAggregator(\r\n    address borrower,\r\n    uint256 repayAmount,\r\n    ICErc20 cErc20,\r\n    ICErc20 cTokenCollateral,\r\n    address aggregatorTarget,\r\n    bytes memory aggregatorData\r\n  ) external {\r\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\r\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\r\n    cErc20.flash(\r\n      repayAmount,\r\n      abi.encode(borrower, cErc20, cTokenCollateral, aggregatorTarget, aggregatorData, msg.sender)\r\n    );\r\n  }\r\n\r\n  function receiveFlashLoan(address _underlyingBorrow, uint256 amount, bytes calldata data) external {\r\n    (\r\n      address borrower,\r\n      ICErc20 cErc20,\r\n      ICErc20 cTokenCollateral,\r\n      address aggregatorTarget,\r\n      bytes memory aggregatorData,\r\n      address liquidator\r\n    ) = abi.decode(data, (address, ICErc20, ICErc20, address, bytes, address));\r\n    IERC20Upgradeable underlyingBorrow = IERC20Upgradeable(_underlyingBorrow);\r\n    underlyingBorrow.approve(address(cErc20), amount);\r\n    require(cErc20.liquidateBorrow(borrower, amount, address(cTokenCollateral)) == 0, \"Liquidation failed.\");\r\n\r\n    // Redeem seized cTokens for underlying asset\r\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cTokenCollateral.underlying());\r\n    {\r\n      uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\r\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n      uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\r\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n      uint256 underlyingCollateralRedeemed = underlyingCollateral.balanceOf(address(this));\r\n\r\n      // Call the aggregator\r\n      underlyingCollateral.approve(aggregatorTarget, underlyingCollateralRedeemed);\r\n      (bool success, ) = aggregatorTarget.call(aggregatorData);\r\n      require(success, \"Aggregator call failed\");\r\n    }\r\n\r\n    // receive profits\r\n    {\r\n      uint256 receivedAmount = underlyingBorrow.balanceOf(address(this));\r\n      require(receivedAmount >= amount, \"Not received enough collateral after swap.\");\r\n      uint256 profitBorrow = receivedAmount - amount;\r\n      if (profitBorrow > 0) {\r\n        underlyingBorrow.safeTransfer(liquidator, profitBorrow);\r\n      }\r\n\r\n      uint256 profitCollateral = underlyingCollateral.balanceOf(address(this));\r\n      if (profitCollateral > 0) {\r\n        underlyingCollateral.safeTransfer(liquidator, profitCollateral);\r\n      }\r\n    }\r\n\r\n    // pay back flashloan\r\n    underlyingBorrow.approve(address(cErc20), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers seized funds to the sender.\r\n   * @param erc20Contract The address of the token to transfer.\r\n   * @param minOutputAmount The minimum amount to transfer.\r\n   */\r\n  function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\r\n    IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\r\n    uint256 seizedOutputAmount = token.balanceOf(address(this));\r\n    require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\r\n    if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\r\n\r\n    return seizedOutputAmount;\r\n  }\r\n\r\n  function safeLiquidateToTokensWithFlashLoan(\r\n    LiquidateToTokensWithFlashSwapVars calldata vars\r\n  ) external onlyLowHF(vars.borrower, vars.cTokenCollateral) returns (uint256) {\r\n    // Input validation\r\n    require(vars.repayAmount > 0, \"Repay amount must be greater than 0.\");\r\n\r\n    // we want to calculate the needed flashSwapAmount on-chain to\r\n    // avoid errors due to changing market conditions\r\n    // between the time of calculating and including the tx in a block\r\n    uint256 fundingAmount = vars.repayAmount;\r\n    IERC20Upgradeable fundingToken;\r\n    if (vars.debtFundingStrategies.length > 0) {\r\n      require(\r\n        vars.debtFundingStrategies.length == vars.debtFundingStrategiesData.length,\r\n        \"Funding IFundsConversionStrategy contract array and strategy data bytes array must be the same length.\"\r\n      );\r\n      // estimate the initial (flash-swapped token) input from the expected output (debt token)\r\n      for (uint256 i = 0; i < vars.debtFundingStrategies.length; i++) {\r\n        bytes memory strategyData = vars.debtFundingStrategiesData[i];\r\n        IFundsConversionStrategy fcs = vars.debtFundingStrategies[i];\r\n        (fundingToken, fundingAmount) = fcs.estimateInputAmount(fundingAmount, strategyData);\r\n      }\r\n    } else {\r\n      fundingToken = IERC20Upgradeable(ICErc20(address(vars.cErc20)).underlying());\r\n    }\r\n\r\n    // the last outputs from estimateInputAmount are the ones to be flash-swapped\r\n    _flashSwapAmount = fundingAmount;\r\n    _flashSwapToken = address(fundingToken);\r\n\r\n    IUniswapV3Pool flashSwapPool = IUniswapV3Pool(vars.flashSwapContract);\r\n    bool token0IsFlashSwapFundingToken = flashSwapPool.token0() == address(fundingToken);\r\n    flashSwapPool.flash(\r\n      address(this),\r\n      token0IsFlashSwapFundingToken ? fundingAmount : 0,\r\n      !token0IsFlashSwapFundingToken ? fundingAmount : 0,\r\n      msg.data\r\n    );\r\n\r\n    return transferSeizedFunds(_liquidatorProfitExchangeSource, vars.minProfitAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Receives NATIVE from liquidations and flashloans.\r\n   * Requires that `msg.sender` is W_NATIVE, a CToken, or a Uniswap V2 Router, or another contract.\r\n   */\r\n  receive() external payable {\r\n    require(payable(msg.sender).isContract(), \"Sender is not a contract.\");\r\n  }\r\n\r\n  /**\r\n   * @notice receiveAuctionProceedings function - receives native token from the express relay\r\n   * You can use permission key to distribute the received funds to users who got liquidated, LPs, etc...\r\n   */\r\n  function receiveAuctionProceedings(bytes calldata permissionKey) external payable {\r\n    emit VaultReceivedETH(msg.sender, msg.value, permissionKey);\r\n  }\r\n\r\n  function withdrawAll() external onlyOwner {\r\n    uint256 balance = address(this).balance;\r\n    require(balance > 0, \"No Ether left to withdraw\");\r\n\r\n    // Transfer all Ether to the owner\r\n    (bool sent, ) = msg.sender.call{ value: balance }(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n  }\r\n\r\n  /**\r\n   * @dev Callback function for Uniswap flashloans.\r\n   */\r\n\r\n  function supV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external {\r\n    uniswapV3FlashCallback(fee0, fee1, data);\r\n  }\r\n\r\n  function algebraFlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) external {\r\n    uniswapV3FlashCallback(fee0, fee1, data);\r\n  }\r\n\r\n  function uniswapV3FlashCallback(uint256 fee0, uint256 fee1, bytes calldata data) public {\r\n    // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\r\n    // Decode params\r\n    LiquidateToTokensWithFlashSwapVars memory vars = abi.decode(data[4:], (LiquidateToTokensWithFlashSwapVars));\r\n\r\n    // Post token flashloan\r\n    // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\r\n    _liquidatorProfitExchangeSource = postFlashLoanTokens(vars, fee0, fee1);\r\n  }\r\n\r\n  /**\r\n   * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\r\n   */\r\n  function postFlashLoanTokens(\r\n    LiquidateToTokensWithFlashSwapVars memory vars,\r\n    uint256 fee0,\r\n    uint256 fee1\r\n  ) private returns (address) {\r\n    IERC20Upgradeable debtRepaymentToken = IERC20Upgradeable(_flashSwapToken);\r\n    uint256 debtRepaymentAmount = _flashSwapAmount;\r\n\r\n    if (vars.debtFundingStrategies.length > 0) {\r\n      // loop backwards to convert the initial (flash-swapped token) input to the final expected output (debt token)\r\n      for (uint256 i = vars.debtFundingStrategies.length; i > 0; i--) {\r\n        (debtRepaymentToken, debtRepaymentAmount) = convertCustomFunds(\r\n          debtRepaymentToken,\r\n          debtRepaymentAmount,\r\n          vars.debtFundingStrategies[i - 1],\r\n          vars.debtFundingStrategiesData[i - 1]\r\n        );\r\n      }\r\n    }\r\n\r\n    // Approve the debt repayment transfer, liquidate and redeem the seized collateral\r\n    {\r\n      address underlyingBorrow = vars.cErc20.underlying();\r\n      require(\r\n        address(debtRepaymentToken) == underlyingBorrow,\r\n        \"the debt repayment funds should be converted to the underlying debt token\"\r\n      );\r\n      require(debtRepaymentAmount >= vars.repayAmount, \"debt repayment amount not enough\");\r\n      // Approve repayAmount to cErc20\r\n      IERC20Upgradeable(underlyingBorrow).approve(address(vars.cErc20), vars.repayAmount);\r\n\r\n      // Liquidate borrow\r\n      require(\r\n        vars.cErc20.liquidateBorrow(vars.borrower, vars.repayAmount, address(vars.cTokenCollateral)) == 0,\r\n        \"Liquidation failed.\"\r\n      );\r\n\r\n      // Redeem seized cTokens for underlying asset\r\n      uint256 seizedCTokenAmount = vars.cTokenCollateral.balanceOf(address(this));\r\n      require(seizedCTokenAmount > 0, \"No cTokens seized.\");\r\n      uint256 redeemResult = vars.cTokenCollateral.redeem(seizedCTokenAmount);\r\n      require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\r\n    }\r\n\r\n    // Repay flashloan\r\n    return repayTokenFlashLoan(vars.cTokenCollateral, vars.redemptionStrategies, vars.strategyData, fee0, fee1);\r\n  }\r\n\r\n  /**\r\n   * @dev Repays token flashloans.\r\n   */\r\n  function repayTokenFlashLoan(\r\n    ICErc20 cTokenCollateral,\r\n    IRedemptionStrategy[] memory redemptionStrategies,\r\n    bytes[] memory strategyData,\r\n    uint256 fee0,\r\n    uint256 fee1\r\n  ) private returns (address) {\r\n    IUniswapV3Pool pool = IUniswapV3Pool(msg.sender);\r\n    uint256 flashSwapReturnAmount = _flashSwapAmount;\r\n    if (IUniswapV3Pool(msg.sender).token0() == _flashSwapToken) {\r\n      flashSwapReturnAmount += fee0;\r\n    } else if (IUniswapV3Pool(msg.sender).token1() == _flashSwapToken) {\r\n      flashSwapReturnAmount += fee1;\r\n    } else {\r\n      revert(\"wrong pool or _flashSwapToken\");\r\n    }\r\n\r\n    // Swap cTokenCollateral for cErc20 via Uniswap\r\n    // Check underlying collateral seized\r\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\r\n    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\r\n\r\n    // Redeem custom collateral if liquidation strategy is set\r\n    if (redemptionStrategies.length > 0) {\r\n      require(\r\n        redemptionStrategies.length == strategyData.length,\r\n        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\r\n      );\r\n      for (uint256 i = 0; i < redemptionStrategies.length; i++)\r\n        (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\r\n          underlyingCollateral,\r\n          underlyingCollateralSeized,\r\n          redemptionStrategies[i],\r\n          strategyData[i]\r\n        );\r\n    }\r\n\r\n    // Check if we can repay directly one of the sides with collateral\r\n    if (address(underlyingCollateral) == pool.token0() || address(underlyingCollateral) == pool.token1()) {\r\n      // Repay flashloan directly with collateral\r\n      uint256 collateralRequired;\r\n      if (address(underlyingCollateral) == _flashSwapToken) {\r\n        // repay the borrowed asset directly\r\n        collateralRequired = flashSwapReturnAmount;\r\n\r\n        // Repay flashloan\r\n        IERC20Upgradeable(_flashSwapToken).transfer(address(pool), flashSwapReturnAmount);\r\n      } else {\r\n        // TODO swap within the same pool and then repay the FL to the pool\r\n        bool zeroForOne = address(underlyingCollateral) == pool.token0();\r\n\r\n        {\r\n          collateralRequired = quoter.quoteExactOutputSingle(\r\n            zeroForOne ? pool.token0() : pool.token1(),\r\n            zeroForOne ? pool.token1() : pool.token0(),\r\n            pool.fee(),\r\n            _flashSwapAmount,\r\n            0 // sqrtPriceLimitX96\r\n          );\r\n        }\r\n        require(\r\n          collateralRequired <= underlyingCollateralSeized,\r\n          \"Token flashloan return amount greater than seized collateral.\"\r\n        );\r\n\r\n        // Repay flashloan\r\n        pool.swap(\r\n          address(pool),\r\n          zeroForOne,\r\n          int256(collateralRequired),\r\n          0, // sqrtPriceLimitX96\r\n          \"\"\r\n        );\r\n      }\r\n\r\n      return address(underlyingCollateral);\r\n    } else {\r\n      revert(\"the redemptions strategy did not swap to the flash swapped pool assets\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev for security reasons only whitelisted redemption strategies may be used.\r\n   * Each whitelisted redemption strategy has to be checked to not be able to\r\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\r\n   */\r\n  function _whitelistRedemptionStrategy(IRedemptionStrategy strategy, bool whitelisted) external onlyOwner {\r\n    redemptionStrategiesWhitelist[address(strategy)] = whitelisted;\r\n  }\r\n\r\n  /**\r\n   * @dev for security reasons only whitelisted redemption strategies may be used.\r\n   * Each whitelisted redemption strategy has to be checked to not be able to\r\n   * call `selfdestruct` with the `delegatecall` call in `redeemCustomCollateral`\r\n   */\r\n  function _whitelistRedemptionStrategies(\r\n    IRedemptionStrategy[] calldata strategies,\r\n    bool[] calldata whitelisted\r\n  ) external onlyOwner {\r\n    require(\r\n      strategies.length > 0 && strategies.length == whitelisted.length,\r\n      \"list of strategies empty or whitelist does not match its length\"\r\n    );\r\n\r\n    for (uint256 i = 0; i < strategies.length; i++) {\r\n      redemptionStrategiesWhitelist[address(strategies[i])] = whitelisted[i];\r\n    }\r\n  }\r\n\r\n  function setExpressRelay(address _expressRelay) external onlyOwner {\r\n    expressRelay = IExpressRelay(_expressRelay);\r\n  }\r\n\r\n  function setPoolLens(address _poolLens) external onlyOwner {\r\n    lens = PoolLens(_poolLens);\r\n  }\r\n\r\n  function setHealthFactorThreshold(uint256 _healthFactorThreshold) external onlyOwner {\r\n    require(_healthFactorThreshold <= 1e18, \"Invalid Health Factor Threshold\");\r\n    healthFactorThreshold = _healthFactorThreshold;\r\n  }\r\n\r\n  /**\r\n   * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\r\n   * Public visibility because we have to call this function externally if called from a payable IonicLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\r\n   */\r\n  function redeemCustomCollateral(\r\n    IERC20Upgradeable underlyingCollateral,\r\n    uint256 underlyingCollateralSeized,\r\n    IRedemptionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\r\n\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  function convertCustomFunds(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IFundsConversionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    require(redemptionStrategiesWhitelist[address(strategy)], \"only whitelisted redemption strategies can be used\");\r\n\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.convert.selector, inputToken, inputAmount, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\r\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\r\n   */\r\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\r\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\r\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/contracts/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\r\n   */\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/liquidators/CurveSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\nimport \"../external/curve/ICurvePool.sol\";\r\nimport { IERC4626 } from \"../compound/IERC4626.sol\";\r\n\r\nimport \"./IRedemptionStrategy.sol\";\r\n\r\nimport \"../oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol\";\r\nimport \"../oracles/default/CurveLpTokenPriceOracleNoRegistry.sol\";\r\n\r\n/**\r\n * @title CurveSwapLiquidator\r\n * @notice Swaps seized token collateral via Curve as a step in a liquidation.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract CurveSwapLiquidator is IRedemptionStrategy {\r\n  /**\r\n   * @notice Redeems custom collateral `token` for an underlying token.\r\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\r\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\r\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\r\n   * @return outputToken The underlying ERC20 token outputted.\r\n   * @return outputAmount The quantity of underlying tokens outputted.\r\n   */\r\n  function redeem(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    bytes memory strategyData\r\n  ) external override returns (IERC20Upgradeable, uint256) {\r\n    return _convert(inputToken, inputAmount, strategyData);\r\n  }\r\n\r\n  function _convert(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    bytes memory strategyData\r\n  ) internal returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\r\n    (\r\n      CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle,\r\n      address outputTokenAddress,\r\n      address _unwrappedInput,\r\n      address _unwrappedOutput\r\n    ) = abi.decode(strategyData, (CurveV2LpTokenPriceOracleNoRegistry, address, address, address));\r\n\r\n    if (_unwrappedOutput != address(0)) {\r\n      outputToken = IERC20Upgradeable(_unwrappedOutput);\r\n    } else {\r\n      outputToken = IERC20Upgradeable(outputTokenAddress);\r\n    }\r\n\r\n    if (_unwrappedInput != address(0)) {\r\n      inputToken.approve(address(inputToken), inputAmount);\r\n      inputAmount = IERC4626(address(inputToken)).redeem(inputAmount, address(this), address(this));\r\n      inputToken = IERC20Upgradeable(_unwrappedInput);\r\n    }\r\n\r\n    address inputTokenAddress = address(inputToken);\r\n\r\n    ICurvePool curvePool;\r\n    int128 i;\r\n    int128 j;\r\n    if (address(curveV2Oracle) != address(0)) {\r\n      (curvePool, i, j) = curveV2Oracle.getPoolForSwap(inputTokenAddress, address(outputToken));\r\n    }\r\n    require(address(curvePool) != address(0), \"!curve pool\");\r\n\r\n    inputToken.approve(address(curvePool), inputAmount);\r\n    outputAmount = curvePool.exchange(i, j, inputAmount, 0);\r\n\r\n    if (_unwrappedOutput != address(0)) {\r\n      IERC20Upgradeable(_unwrappedOutput).approve(address(outputTokenAddress), outputAmount);\r\n      IERC4626(outputTokenAddress).deposit(outputAmount, address(this));\r\n      outputToken = IERC20Upgradeable(outputTokenAddress);\r\n    }\r\n\r\n    outputAmount = outputToken.balanceOf(address(this));\r\n    return (outputToken, outputAmount);\r\n  }\r\n\r\n  function name() public pure virtual returns (string memory) {\r\n    return \"CurveSwapLiquidator\";\r\n  }\r\n}\r\n"
    },
    "contracts/liquidators/CurveSwapLiquidatorFunder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./CurveSwapLiquidator.sol\";\r\nimport \"./IFundsConversionStrategy.sol\";\r\n\r\nimport { IERC20MetadataUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\r\n\r\ncontract CurveSwapLiquidatorFunder is CurveSwapLiquidator, IFundsConversionStrategy {\r\n  function convert(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    bytes memory strategyData\r\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\r\n    return _convert(inputToken, inputAmount, strategyData);\r\n  }\r\n\r\n  function estimateInputAmount(\r\n    uint256 outputAmount,\r\n    bytes memory strategyData\r\n  ) external view returns (IERC20Upgradeable, uint256) {\r\n    ICurvePool curvePool;\r\n    int128 i;\r\n    int128 j;\r\n    {\r\n      (\r\n        CurveLpTokenPriceOracleNoRegistry curveV1Oracle,\r\n        CurveV2LpTokenPriceOracleNoRegistry curveV2Oracle,\r\n        address inputTokenAddress,\r\n        address outputTokenAddress,\r\n\r\n      ) = abi.decode(\r\n          strategyData,\r\n          (CurveLpTokenPriceOracleNoRegistry, CurveV2LpTokenPriceOracleNoRegistry, address, address, address)\r\n        );\r\n\r\n      if (address(curveV2Oracle) != address(0)) {\r\n        (curvePool, i, j) = curveV2Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\r\n      }\r\n      if (address(curvePool) == address(0)) {\r\n        (curvePool, i, j) = curveV1Oracle.getPoolForSwap(inputTokenAddress, outputTokenAddress);\r\n      }\r\n    }\r\n    require(address(curvePool) != address(0), \"!curve pool\");\r\n\r\n    IERC20MetadataUpgradeable inputMetadataToken = IERC20MetadataUpgradeable(curvePool.coins(uint256(int256(i))));\r\n    uint256 inputAmountGuesstimate = guesstimateInputAmount(curvePool, i, j, inputMetadataToken, outputAmount);\r\n    uint256 inputAmount = binSearch(\r\n      curvePool,\r\n      i,\r\n      j,\r\n      (70 * inputAmountGuesstimate) / 100,\r\n      (130 * inputAmountGuesstimate) / 100,\r\n      outputAmount\r\n    );\r\n\r\n    return (inputMetadataToken, inputAmount);\r\n  }\r\n\r\n  function guesstimateInputAmount(\r\n    ICurvePool curvePool,\r\n    int128 i,\r\n    int128 j,\r\n    IERC20MetadataUpgradeable inputMetadataToken,\r\n    uint256 outputAmount\r\n  ) internal view returns (uint256) {\r\n    uint256 oneInputToken = 10 ** inputMetadataToken.decimals();\r\n    uint256 outputTokensForOneInputToken = curvePool.get_dy(i, j, oneInputToken);\r\n    // inputAmount / outputAmount = oneInputToken / outputTokensForOneInputToken\r\n    uint256 inputAmount = (outputAmount * oneInputToken) / outputTokensForOneInputToken;\r\n    return inputAmount;\r\n  }\r\n\r\n  function binSearch(\r\n    ICurvePool curvePool,\r\n    int128 i,\r\n    int128 j,\r\n    uint256 low,\r\n    uint256 high,\r\n    uint256 value\r\n  ) internal view returns (uint256) {\r\n    if (low >= high) return low;\r\n\r\n    uint256 mid = (low + high) / 2;\r\n    uint256 outputAmount = curvePool.get_dy(i, j, mid);\r\n    if (outputAmount == 0) revert(\"output amount 0\");\r\n    // output can be up to 10% in excess\r\n    if (outputAmount >= value && outputAmount <= (11 * value) / 10) return mid;\r\n    else if (outputAmount > value) {\r\n      return binSearch(curvePool, i, j, low, mid, value);\r\n    } else {\r\n      return binSearch(curvePool, i, j, mid, high, value);\r\n    }\r\n  }\r\n\r\n  function name() public pure override(CurveSwapLiquidator, IRedemptionStrategy) returns (string memory) {\r\n    return \"CurveSwapLiquidatorFunder\";\r\n  }\r\n}\r\n"
    },
    "contracts/liquidators/IFundsConversionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IRedemptionStrategy.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ninterface IFundsConversionStrategy is IRedemptionStrategy {\r\n  function convert(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    bytes memory strategyData\r\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\r\n\r\n  function estimateInputAmount(\r\n    uint256 outputAmount,\r\n    bytes memory strategyData\r\n  ) external view returns (IERC20Upgradeable inputToken, uint256 inputAmount);\r\n}\r\n"
    },
    "contracts/liquidators/IRedemptionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\n/**\r\n * @title IRedemptionStrategy\r\n * @notice Redeems seized wrapped token collateral for an underlying token for use as a step in a liquidation.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ninterface IRedemptionStrategy {\r\n  /**\r\n   * @notice Redeems custom collateral `token` for an underlying token.\r\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\r\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\r\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\r\n   * @return outputToken The underlying ERC20 token outputted.\r\n   * @return outputAmount The quantity of underlying tokens outputted.\r\n   */\r\n  function redeem(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    bytes memory strategyData\r\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\r\n\r\n  function name() external view returns (string memory);\r\n}\r\n"
    },
    "contracts/liquidators/registry/ILiquidatorsRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { IRedemptionStrategy } from \"../../liquidators/IRedemptionStrategy.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\n\r\ninterface ILiquidatorsRegistryStorage {\r\n  function redemptionStrategiesByName(string memory name) external view returns (IRedemptionStrategy);\r\n\r\n  function redemptionStrategiesByTokens(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IRedemptionStrategy);\r\n\r\n  function defaultOutputToken(IERC20Upgradeable inputToken) external view returns (IERC20Upgradeable);\r\n\r\n  function owner() external view returns (address);\r\n\r\n  function uniswapV3Fees(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) external view returns (uint24);\r\n\r\n  function customUniV3Router(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (address);\r\n}\r\n\r\ninterface ILiquidatorsRegistryExtension {\r\n  function getInputTokensByOutputToken(IERC20Upgradeable outputToken) external view returns (address[] memory);\r\n\r\n  function getRedemptionStrategies(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData);\r\n\r\n  function getRedemptionStrategy(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IRedemptionStrategy strategy, bytes memory strategyData);\r\n\r\n  function getAllRedemptionStrategies() external view returns (address[] memory);\r\n\r\n  function getSlippage(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (uint256 slippage);\r\n\r\n  function swap(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IERC20Upgradeable outputToken\r\n  ) external returns (uint256);\r\n\r\n  function amountOutAndSlippageOfSwap(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IERC20Upgradeable outputToken\r\n  ) external returns (uint256 outputAmount, uint256 slippage);\r\n}\r\n\r\ninterface ILiquidatorsRegistrySecondExtension {\r\n  function getAllPairsStrategies()\r\n    external\r\n    view\r\n    returns (\r\n      IRedemptionStrategy[] memory strategies,\r\n      IERC20Upgradeable[] memory inputTokens,\r\n      IERC20Upgradeable[] memory outputTokens\r\n    );\r\n\r\n  function pairsStrategiesMatch(\r\n    IRedemptionStrategy[] calldata configStrategies,\r\n    IERC20Upgradeable[] calldata configInputTokens,\r\n    IERC20Upgradeable[] calldata configOutputTokens\r\n  ) external view returns (bool);\r\n\r\n  function uniswapPairsFeesMatch(\r\n    IERC20Upgradeable[] calldata configInputTokens,\r\n    IERC20Upgradeable[] calldata configOutputTokens,\r\n    uint256[] calldata configFees\r\n  ) external view returns (bool);\r\n\r\n  function uniswapPairsRoutersMatch(\r\n    IERC20Upgradeable[] calldata configInputTokens,\r\n    IERC20Upgradeable[] calldata configOutputTokens,\r\n    address[] calldata configRouters\r\n  ) external view returns (bool);\r\n\r\n  function _setRedemptionStrategy(\r\n    IRedemptionStrategy strategy,\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external;\r\n\r\n  function _setRedemptionStrategies(\r\n    IRedemptionStrategy[] calldata strategies,\r\n    IERC20Upgradeable[] calldata inputTokens,\r\n    IERC20Upgradeable[] calldata outputTokens\r\n  ) external;\r\n\r\n  function _resetRedemptionStrategies(\r\n    IRedemptionStrategy[] calldata strategies,\r\n    IERC20Upgradeable[] calldata inputTokens,\r\n    IERC20Upgradeable[] calldata outputTokens\r\n  ) external;\r\n\r\n  function _removeRedemptionStrategy(IRedemptionStrategy strategyToRemove) external;\r\n\r\n  function _setDefaultOutputToken(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) external;\r\n\r\n  function _setUniswapV3Fees(\r\n    IERC20Upgradeable[] calldata inputTokens,\r\n    IERC20Upgradeable[] calldata outputTokens,\r\n    uint24[] calldata fees\r\n  ) external;\r\n\r\n  function _setUniswapV3Routers(\r\n    IERC20Upgradeable[] calldata inputTokens,\r\n    IERC20Upgradeable[] calldata outputTokens,\r\n    address[] calldata routers\r\n  ) external;\r\n\r\n  function _setSlippages(\r\n    IERC20Upgradeable[] calldata inputTokens,\r\n    IERC20Upgradeable[] calldata outputTokens,\r\n    uint256[] calldata slippages\r\n  ) external;\r\n\r\n  function optimalSwapPath(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (IERC20Upgradeable[] memory);\r\n\r\n  function _setOptimalSwapPath(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken,\r\n    IERC20Upgradeable[] calldata optimalPath\r\n  ) external;\r\n\r\n  function wrappedToUnwrapped4626(address wrapped) external view returns (address);\r\n\r\n  function _setWrappedToUnwrapped4626(address wrapped, address unwrapped) external;\r\n\r\n  function aeroCLTickSpacings(address inputToken, address outputToken) external view returns (int24);\r\n\r\n  function _setAeroCLTickSpacings(address inputToken, address outputToken, int24 tickSpacing) external;\r\n\r\n  function aeroV2IsStable(address inputToken, address outputToken) external view returns (bool);\r\n\r\n  function _setAeroV2IsStable(address inputToken, address outputToken, bool isStable) external;\r\n}\r\n\r\ninterface ILiquidatorsRegistry is\r\n  ILiquidatorsRegistryExtension,\r\n  ILiquidatorsRegistrySecondExtension,\r\n  ILiquidatorsRegistryStorage\r\n{}\r\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../../ionic/DiamondExtension.sol\";\r\nimport \"./LiquidatorsRegistryStorage.sol\";\r\nimport \"./LiquidatorsRegistryExtension.sol\";\r\n\r\ncontract LiquidatorsRegistry is LiquidatorsRegistryStorage, DiamondBase {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  constructor(AddressesProvider _ap) SafeOwnable() {\r\n    ap = _ap;\r\n  }\r\n\r\n  /**\r\n   * @dev register a logic extension\r\n   * @param extensionToAdd the extension whose functions are to be added\r\n   * @param extensionToReplace the extension whose functions are to be removed/replaced\r\n   */\r\n  function _registerExtension(DiamondExtension extensionToAdd, DiamondExtension extensionToReplace)\r\n    public\r\n    override\r\n    onlyOwner\r\n  {\r\n    LibDiamond.registerExtension(extensionToAdd, extensionToReplace);\r\n  }\r\n\r\n  function asExtension() public view returns (LiquidatorsRegistryExtension) {\r\n    return LiquidatorsRegistryExtension(address(this));\r\n  }\r\n}\r\n"
    },
    "contracts/liquidators/registry/LiquidatorsRegistryExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./ILiquidatorsRegistry.sol\";\r\nimport \"./LiquidatorsRegistryStorage.sol\";\r\n\r\nimport \"../IRedemptionStrategy.sol\";\r\nimport \"../../ionic/DiamondExtension.sol\";\r\nimport { MasterPriceOracle } from \"../../oracles/MasterPriceOracle.sol\";\r\n\r\nimport { IRouter_Aerodrome as IAerodromeV2Router } from \"../../external/aerodrome/IAerodromeRouter.sol\";\r\nimport { IRouter_Velodrome as IVelodromeV2Router } from \"../../external/velodrome/IVelodromeRouter.sol\";\r\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\ncontract LiquidatorsRegistryExtension is LiquidatorsRegistryStorage, DiamondExtension, ILiquidatorsRegistryExtension {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  error NoRedemptionPath();\r\n  error OutputTokenMismatch();\r\n\r\n  event SlippageUpdated(\r\n    IERC20Upgradeable indexed from,\r\n    IERC20Upgradeable indexed to,\r\n    uint256 prevValue,\r\n    uint256 newValue\r\n  );\r\n\r\n  // @notice maximum slippage in swaps, in bps\r\n  uint256 public constant MAX_SLIPPAGE = 900; // 9%\r\n\r\n  function _getExtensionFunctions() external pure override returns (bytes4[] memory) {\r\n    uint8 fnsCount = 7;\r\n    bytes4[] memory functionSelectors = new bytes4[](fnsCount);\r\n    functionSelectors[--fnsCount] = this.getRedemptionStrategies.selector;\r\n    functionSelectors[--fnsCount] = this.getRedemptionStrategy.selector;\r\n    functionSelectors[--fnsCount] = this.getInputTokensByOutputToken.selector;\r\n    functionSelectors[--fnsCount] = this.swap.selector;\r\n    functionSelectors[--fnsCount] = this.getAllRedemptionStrategies.selector;\r\n    functionSelectors[--fnsCount] = this.amountOutAndSlippageOfSwap.selector;\r\n    functionSelectors[--fnsCount] = this.getSlippage.selector;\r\n    require(fnsCount == 0, \"use the correct array length\");\r\n    return functionSelectors;\r\n  }\r\n\r\n  function getSlippage(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) external view returns (uint256 slippage) {\r\n    slippage = conversionSlippage[inputToken][outputToken];\r\n    // TODO slippage == 0 should be allowed\r\n    if (slippage == 0) return MAX_SLIPPAGE;\r\n  }\r\n\r\n  function getAllRedemptionStrategies() public view returns (address[] memory) {\r\n    return redemptionStrategies.values();\r\n  }\r\n\r\n  function amountOutAndSlippageOfSwap(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IERC20Upgradeable outputToken\r\n  ) external returns (uint256 outputAmount, uint256 slippage) {\r\n    if (inputAmount == 0) return (0, 0);\r\n\r\n    outputAmount = swap(inputToken, inputAmount, outputToken);\r\n    if (outputAmount == 0) return (0, 0);\r\n\r\n    MasterPriceOracle mpo = MasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\r\n    uint256 inputTokenPrice = mpo.price(address(inputToken));\r\n    uint256 outputTokenPrice = mpo.price(address(outputToken));\r\n\r\n    uint256 inputTokensValue = inputAmount * toScaledPrice(inputTokenPrice, inputToken);\r\n    uint256 outputTokensValue = outputAmount * toScaledPrice(outputTokenPrice, outputToken);\r\n\r\n    if (outputTokensValue < inputTokensValue) {\r\n      slippage = ((inputTokensValue - outputTokensValue) * 10000) / inputTokensValue;\r\n    }\r\n    // min slippage should be non-zero\r\n    // just in case of rounding errors\r\n    slippage += 1;\r\n\r\n    // cache the slippage\r\n    uint256 prevValue = conversionSlippage[inputToken][outputToken];\r\n    if (prevValue == 0 || block.timestamp - conversionSlippageUpdated[inputToken][outputToken] > 5000) {\r\n      emit SlippageUpdated(inputToken, outputToken, prevValue, slippage);\r\n\r\n      conversionSlippage[inputToken][outputToken] = slippage;\r\n      conversionSlippageUpdated[inputToken][outputToken] = block.timestamp;\r\n    }\r\n  }\r\n\r\n  /// @dev returns price scaled to 1e36 - decimals\r\n  function toScaledPrice(uint256 unscaledPrice, IERC20Upgradeable token) internal view returns (uint256) {\r\n    uint256 tokenDecimals = uint256(ERC20Upgradeable(address(token)).decimals());\r\n    return\r\n      tokenDecimals <= 18\r\n        ? uint256(unscaledPrice) * (10 ** (18 - tokenDecimals))\r\n        : uint256(unscaledPrice) / (10 ** (tokenDecimals - 18));\r\n  }\r\n\r\n  function swap(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IERC20Upgradeable outputToken\r\n  ) public returns (uint256 outputAmount) {\r\n    inputToken.safeTransferFrom(msg.sender, address(this), inputAmount);\r\n    outputAmount = convertAllTo(inputToken, outputToken);\r\n    outputToken.safeTransfer(msg.sender, outputAmount);\r\n  }\r\n\r\n  function convertAllTo(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) private returns (uint256) {\r\n    uint256 inputAmount = inputToken.balanceOf(address(this));\r\n    (IRedemptionStrategy[] memory redemptionStrategies, bytes[] memory strategiesData) = getRedemptionStrategies(\r\n      inputToken,\r\n      outputToken\r\n    );\r\n\r\n    if (redemptionStrategies.length == 0) revert NoRedemptionPath();\r\n\r\n    IERC20Upgradeable swapInputToken = inputToken;\r\n    uint256 swapInputAmount = inputAmount;\r\n    for (uint256 i = 0; i < redemptionStrategies.length; i++) {\r\n      IRedemptionStrategy redemptionStrategy = redemptionStrategies[i];\r\n      bytes memory strategyData = strategiesData[i];\r\n      (IERC20Upgradeable swapOutputToken, uint256 swapOutputAmount) = convertCustomFunds(\r\n        swapInputToken,\r\n        swapInputAmount,\r\n        redemptionStrategy,\r\n        strategyData\r\n      );\r\n      swapInputAmount = swapOutputAmount;\r\n      swapInputToken = swapOutputToken;\r\n    }\r\n\r\n    if (swapInputToken != outputToken) revert OutputTokenMismatch();\r\n    return outputToken.balanceOf(address(this));\r\n  }\r\n\r\n  function convertCustomFunds(\r\n    IERC20Upgradeable inputToken,\r\n    uint256 inputAmount,\r\n    IRedemptionStrategy strategy,\r\n    bytes memory strategyData\r\n  ) private returns (IERC20Upgradeable, uint256) {\r\n    bytes memory returndata = _functionDelegateCall(\r\n      address(strategy),\r\n      abi.encodeWithSelector(strategy.redeem.selector, inputToken, inputAmount, strategyData)\r\n    );\r\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\r\n  }\r\n\r\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\r\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getInputTokensByOutputToken(IERC20Upgradeable outputToken) external view returns (address[] memory) {\r\n    return inputTokensByOutputToken[outputToken].values();\r\n  }\r\n\r\n  function getRedemptionStrategies(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) public view returns (IRedemptionStrategy[] memory strategies, bytes[] memory strategiesData) {\r\n    IERC20Upgradeable tokenToRedeem = inputToken;\r\n    IERC20Upgradeable targetOutputToken = outputToken;\r\n    IRedemptionStrategy[] memory strategiesTemp = new IRedemptionStrategy[](10);\r\n    bytes[] memory strategiesDataTemp = new bytes[](10);\r\n    IERC20Upgradeable[] memory tokenPath = new IERC20Upgradeable[](10);\r\n    IERC20Upgradeable[] memory optimalPath = new IERC20Upgradeable[](0);\r\n    uint256 optimalPathIterator = 0;\r\n\r\n    uint256 k = 0;\r\n    while (tokenToRedeem != targetOutputToken) {\r\n      IERC20Upgradeable nextRedeemedToken;\r\n      IRedemptionStrategy directStrategy = redemptionStrategiesByTokens[tokenToRedeem][targetOutputToken];\r\n      if (address(directStrategy) != address(0)) {\r\n        nextRedeemedToken = targetOutputToken;\r\n      } else {\r\n        // check if an optimal path is preconfigured\r\n        if (optimalPath.length == 0 && _optimalSwapPath[tokenToRedeem][targetOutputToken].length != 0) {\r\n          optimalPath = _optimalSwapPath[tokenToRedeem][targetOutputToken];\r\n        }\r\n        if (optimalPath.length != 0 && optimalPathIterator < optimalPath.length) {\r\n          nextRedeemedToken = optimalPath[optimalPathIterator++];\r\n        } else {\r\n          // else if no optimal path is available, use the default\r\n          nextRedeemedToken = defaultOutputToken[tokenToRedeem];\r\n        }\r\n      }\r\n\r\n      // check if going in an endless loop\r\n      for (uint256 i = 0; i < tokenPath.length; i++) {\r\n        if (nextRedeemedToken == tokenPath[i]) break;\r\n      }\r\n\r\n      (IRedemptionStrategy strategy, bytes memory strategyData) = getRedemptionStrategy(\r\n        tokenToRedeem,\r\n        nextRedeemedToken\r\n      );\r\n      if (address(strategy) == address(0)) break;\r\n\r\n      strategiesTemp[k] = strategy;\r\n      strategiesDataTemp[k] = strategyData;\r\n      tokenPath[k] = nextRedeemedToken;\r\n      tokenToRedeem = nextRedeemedToken;\r\n\r\n      k++;\r\n      if (k == 10) break;\r\n    }\r\n\r\n    strategies = new IRedemptionStrategy[](k);\r\n    strategiesData = new bytes[](k);\r\n\r\n    for (uint8 i = 0; i < k; i++) {\r\n      strategies[i] = strategiesTemp[i];\r\n      strategiesData[i] = strategiesDataTemp[i];\r\n    }\r\n  }\r\n\r\n  function getRedemptionStrategy(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) public view returns (IRedemptionStrategy strategy, bytes memory strategyData) {\r\n    strategy = redemptionStrategiesByTokens[inputToken][outputToken];\r\n\r\n    if (isStrategy(strategy, \"UniswapV2LiquidatorFunder\") || isStrategy(strategy, \"KimUniV2Liquidator\")) {\r\n      strategyData = uniswapV2LiquidatorData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"UniswapV3LiquidatorFunder\")) {\r\n      strategyData = uniswapV3LiquidatorFunderData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"AlgebraSwapLiquidator\")) {\r\n      strategyData = algebraSwapLiquidatorData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"AerodromeV2Liquidator\")) {\r\n      strategyData = aerodromeV2LiquidatorData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"AerodromeCLLiquidator\")) {\r\n      strategyData = aerodromeCLLiquidatorData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"CurveSwapLiquidator\")) {\r\n      strategyData = curveSwapLiquidatorData(inputToken, outputToken);\r\n    } else if (isStrategy(strategy, \"VelodromeV2Liquidator\")) {\r\n      strategyData = velodromeV2LiquidatorData(inputToken, outputToken);\r\n    } else {\r\n      revert(\"no strategy data\");\r\n    }\r\n  }\r\n\r\n  function isStrategy(IRedemptionStrategy strategy, string memory name) internal view returns (bool) {\r\n    return address(strategy) != address(0) && address(strategy) == address(redemptionStrategiesByName[name]);\r\n  }\r\n\r\n  function pickPreferredToken(address[] memory tokens, address strategyOutputToken) internal view returns (address) {\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i] == strategyOutputToken) return strategyOutputToken;\r\n    }\r\n    address wnative = ap.getAddress(\"wtoken\");\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i] == wnative) return wnative;\r\n    }\r\n    address stableToken = ap.getAddress(\"stableToken\");\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i] == stableToken) return stableToken;\r\n    }\r\n    address wbtc = ap.getAddress(\"wBTCToken\");\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i] == wbtc) return wbtc;\r\n    }\r\n    return tokens[0];\r\n  }\r\n\r\n  function getUniswapV3Router(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (address) {\r\n    address customRouter = customUniV3Router[inputToken][outputToken];\r\n    if (customRouter == address(0)) {\r\n      customRouter = customUniV3Router[outputToken][inputToken];\r\n    }\r\n\r\n    if (customRouter != address(0)) {\r\n      return customRouter;\r\n    } else {\r\n      // get asset specific router or default\r\n      return ap.getAddress(\"UNISWAP_V3_ROUTER\");\r\n    }\r\n  }\r\n\r\n  function getUniswapV2Router(IERC20Upgradeable inputToken) internal view returns (address) {\r\n    // get asset specific router or default\r\n    return ap.getAddress(\"IUniswapV2Router02\");\r\n  }\r\n\r\n  function getAerodromeV2Router(IERC20Upgradeable inputToken) internal view returns (address) {\r\n    // get asset specific router or default\r\n    return ap.getAddress(\"AERODROME_V2_ROUTER\");\r\n  }\r\n\r\n  function getAerodromeCLRouter(IERC20Upgradeable inputToken) internal view returns (address) {\r\n    // get asset specific router or default\r\n    return ap.getAddress(\"AERODROME_CL_ROUTER\");\r\n  }\r\n\r\n  function uniswapV3LiquidatorFunderData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    uint24 fee = uniswapV3Fees[inputToken][outputToken];\r\n    if (fee == 0) fee = uniswapV3Fees[outputToken][inputToken];\r\n    if (fee == 0) fee = 500;\r\n\r\n    address router = getUniswapV3Router(inputToken, outputToken);\r\n    strategyData = abi.encode(inputToken, outputToken, fee, router, ap.getAddress(\"Quoter\"));\r\n  }\r\n\r\n  function getWrappedToUnwrapped4626(IERC20Upgradeable inputToken) internal view returns (address) {\r\n    return _wrappedToUnwrapped4626[address(inputToken)];\r\n  }\r\n\r\n  function getAeroCLTickSpacing(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (int24) {\r\n    int24 tickSpacing = _aeroCLTickSpacings[address(inputToken)][address(outputToken)];\r\n    if (tickSpacing == 0) {\r\n      tickSpacing = 1;\r\n    }\r\n    return tickSpacing;\r\n  }\r\n\r\n  function aeroV2IsStable(IERC20Upgradeable inputToken, IERC20Upgradeable outputToken) internal view returns (bool) {\r\n    return _aeroV2IsStable[address(inputToken)][address(outputToken)];\r\n  }\r\n\r\n  function uniswapV2LiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    IERC20Upgradeable[] memory swapPath = new IERC20Upgradeable[](2);\r\n    swapPath[0] = inputToken;\r\n    swapPath[1] = outputToken;\r\n    strategyData = abi.encode(getUniswapV2Router(inputToken), swapPath);\r\n  }\r\n\r\n  function aerodromeV2LiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    IAerodromeV2Router.Route[] memory swapPath = new IAerodromeV2Router.Route[](1);\r\n    swapPath[0] = IAerodromeV2Router.Route({\r\n      from: address(inputToken),\r\n      to: address(outputToken),\r\n      stable: aeroV2IsStable(inputToken, outputToken),\r\n      factory: ap.getAddress(\"AERODROME_V2_FACTORY\")\r\n    });\r\n    strategyData = abi.encode(getAerodromeV2Router(inputToken), swapPath);\r\n  }\r\n\r\n  function aerodromeCLLiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    strategyData = abi.encode(\r\n      inputToken,\r\n      outputToken,\r\n      getAerodromeCLRouter(inputToken),\r\n      getWrappedToUnwrapped4626(inputToken),\r\n      getWrappedToUnwrapped4626(outputToken),\r\n      getAeroCLTickSpacing(inputToken, outputToken)\r\n    );\r\n  }\r\n\r\n  function algebraSwapLiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    strategyData = abi.encode(outputToken, ap.getAddress(\"ALGEBRA_SWAP_ROUTER\"));\r\n  }\r\n\r\n  function curveSwapLiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    strategyData = abi.encode(\r\n      ap.getAddress(\"CURVE_V2_ORACLE_NO_REGISTRY\"),\r\n      outputToken,\r\n      getWrappedToUnwrapped4626(inputToken),\r\n      getWrappedToUnwrapped4626(outputToken)\r\n    );\r\n  }\r\n\r\n  function velodromeV2LiquidatorData(\r\n    IERC20Upgradeable inputToken,\r\n    IERC20Upgradeable outputToken\r\n  ) internal view returns (bytes memory strategyData) {\r\n    IVelodromeV2Router.Route[] memory swapPath = new IVelodromeV2Router.Route[](1);\r\n    swapPath[0] = IVelodromeV2Router.Route({\r\n      from: address(inputToken),\r\n      to: address(outputToken),\r\n      stable: aeroV2IsStable(inputToken, outputToken)\r\n    });\r\n    strategyData = abi.encode(getAerodromeV2Router(inputToken), swapPath);\r\n  }\r\n}"
    },
    "contracts/liquidators/registry/LiquidatorsRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../IRedemptionStrategy.sol\";\r\nimport { SafeOwnable } from \"../../ionic/SafeOwnable.sol\";\r\nimport { AddressesProvider } from \"../../ionic/AddressesProvider.sol\";\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nabstract contract LiquidatorsRegistryStorage is SafeOwnable {\r\n  AddressesProvider public ap;\r\n\r\n  EnumerableSet.AddressSet internal redemptionStrategies;\r\n  mapping(string => IRedemptionStrategy) public redemptionStrategiesByName;\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => IRedemptionStrategy)) public redemptionStrategiesByTokens;\r\n  mapping(IERC20Upgradeable => IERC20Upgradeable) public defaultOutputToken;\r\n  mapping(IERC20Upgradeable => EnumerableSet.AddressSet) internal inputTokensByOutputToken;\r\n  EnumerableSet.AddressSet internal outputTokensSet;\r\n\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) internal conversionSlippage;\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint256)) internal conversionSlippageUpdated;\r\n\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => uint24)) public uniswapV3Fees;\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => address)) public customUniV3Router;\r\n\r\n  mapping(IERC20Upgradeable => mapping(IERC20Upgradeable => IERC20Upgradeable[])) internal _optimalSwapPath;\r\n  mapping(address => address) internal _wrappedToUnwrapped4626;\r\n  mapping(address => mapping(address => int24)) internal _aeroCLTickSpacings;\r\n  mapping(address => mapping(address => bool)) internal _aeroV2IsStable;\r\n}"
    },
    "contracts/oracles/1337/MockPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title MockPriceOracle\r\n * @notice Returns mocked prices from a Chainlink-like oracle. Used for local dev only\r\n * @dev Implements `PriceOracle`.\r\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\r\n */\r\ncontract MockPriceOracle is BasePriceOracle {\r\n  /**\r\n   * @notice The maximum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\r\n   */\r\n  uint256 public maxSecondsBeforePriceIsStale;\r\n\r\n  /**\r\n   * @dev Constructor to set `maxSecondsBeforePriceIsStale` as well as all Chainlink price feeds.\r\n   */\r\n  constructor(uint256 _maxSecondsBeforePriceIsStale) {\r\n    // Set maxSecondsBeforePriceIsStale\r\n    maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a boolean indicating if a price feed exists for the underlying asset.\r\n   */\r\n\r\n  function hasPriceFeed(address underlying) external pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function returning the price in ETH of `underlying`.\r\n   */\r\n\r\n  function random() private view returns (uint256) {\r\n    uint256 r = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 99;\r\n    r = r + 1;\r\n    return r;\r\n  }\r\n\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Return 1e18 for WETH\r\n    if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\r\n\r\n    int256 tokenEthPrice = 1;\r\n    uint256 r = random();\r\n\r\n    return ((uint256(tokenEthPrice) * 1e18) / r) / 1e18;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    return 1e18;\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/1337/MockRevertPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title MockRevertPriceOracle\r\n * @notice Mocks a failing price oracle. Used for testing purposes only\r\n * @author Jourdan Dunkley <dunkley.jourdan@gmail.com> (https://github.com/jourdanDunkley)\r\n */\r\ncontract MockRevertPriceOracle is BasePriceOracle {\r\n  constructor() {}\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    revert(\"MockPriceOracle: price function is failing.\");\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    revert(\"MockPriceOracle: getUnderlyingPrice function is failing.\");\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../compound/CTokenInterfaces.sol\";\r\n\r\n/**\r\n * @title BasePriceOracle\r\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\r\n * @dev Implements the `PriceOracle` interface.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ninterface BasePriceOracle {\r\n  /**\r\n   * @notice Get the price of an underlying asset.\r\n   * @param underlying The underlying asset to get the price of.\r\n   * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\r\n   * Zero means the price is unavailable.\r\n   */\r\n  function price(address underlying) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the underlying price of a cToken asset\r\n   * @param cToken The cToken to get the underlying price of\r\n   * @return The underlying asset price mantissa (scaled by 1e18).\r\n   *  Zero means the price is unavailable.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/oracles/default/AerodromePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ninterface BasePrices {\r\n  function getManyRatesWithConnectors(\r\n    uint8 src_len,\r\n    address[] memory connectors\r\n  ) external view returns (uint256[] memory rates);\r\n}\r\n\r\ncontract AerodromePriceOracle is BasePriceOracle {\r\n  BasePrices immutable prices;\r\n  address constant WETH = 0x4200000000000000000000000000000000000006;\r\n\r\n  constructor(address _prices) {\r\n    prices = BasePrices(_prices);\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   * @param underlying The underlying token address for which to get the price.\r\n   * @return Price denominated in ETH (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying));\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   */\r\n  function _price(address token) internal view returns (uint256) {\r\n    address[] memory connectors = new address[](2);\r\n    connectors[0] = token;\r\n    connectors[1] = WETH;\r\n    return prices.getManyRatesWithConnectors(1, connectors)[0];\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/API3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { IProxy } from \"../../external/api3/IProxy.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title API3PriceOracle\r\n * @notice Returns prices from Api3.\r\n * @dev Implements `PriceOracle`.\r\n * @author Carlo Mazzaferro <carlo@ionic.money> (https://github.com/carlomazzaferro)\r\n */\r\ncontract API3PriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\r\n  /**\r\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\r\n   */\r\n  mapping(address => IProxy) public proxies;\r\n\r\n  /**\r\n   * @notice Chainlink NATIVE/USD price feed contracts.\r\n   */\r\n  address public NATIVE_TOKEN_USD_PRICE_FEED;\r\n\r\n  /**\r\n   * @notice The USD Token of the chain\r\n   */\r\n  address public USD_TOKEN;\r\n\r\n  /**\r\n   * @dev Constructor to set wtoken address and native token USD price feed address\r\n   * @param _usdToken The Wrapped native asset address\r\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\r\n   */\r\n  function initialize(address _usdToken, address nativeTokenUsd) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    USD_TOKEN = _usdToken;\r\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor to set wtoken address and native token USD price feed address\r\n   * @param _usdToken The Wrapped native asset address\r\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\r\n   */\r\n  function reinitialize(address _usdToken, address nativeTokenUsd) public onlyOwnerOrAdmin {\r\n    USD_TOKEN = _usdToken;\r\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\r\n   */\r\n  function setPriceFeeds(address[] memory underlyings, address[] memory feeds) external onlyOwner {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == feeds.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/feed\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      // Set feed and base currency\r\n      proxies[underlying] = IProxy(feeds[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning the price in of `underlying`.\r\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    IProxy proxy = proxies[underlying];\r\n    require(address(proxy) != address(0), \"No API3 price feed found for this underlying ERC20 token.\");\r\n\r\n    uint256 nativeTokenUsdPrice;\r\n\r\n    if (NATIVE_TOKEN_USD_PRICE_FEED == address(0)) {\r\n      // get the USDX/USD price from the MPO\r\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\r\n      nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals\r\n    } else {\r\n      (int224 nativeTokenUsdPrice224, ) = IProxy(NATIVE_TOKEN_USD_PRICE_FEED).read();\r\n      if (nativeTokenUsdPrice224 <= 0) {\r\n        revert(\"API3PriceOracle: native token price <= 0\");\r\n      }\r\n      nativeTokenUsdPrice = uint256(uint224(nativeTokenUsdPrice224));\r\n    }\r\n    (int224 tokenUsdPrice, ) = proxy.read();\r\n\r\n    if (tokenUsdPrice <= 0) {\r\n      revert(\"API3PriceOracle: token price <= 0\");\r\n    }\r\n\r\n    return (uint256(uint224(tokenUsdPrice)) * 1e18) / nativeTokenUsdPrice;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in of `underlying` either in USD or the native token (implements `BasePriceOracle`).\r\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/ChainlinkPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title ChainlinkPriceOracleV2\r\n * @notice Returns prices from Chainlink.\r\n * @dev Implements `PriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract ChainlinkPriceOracleV2 is SafeOwnableUpgradeable, BasePriceOracle {\r\n  /**\r\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\r\n   */\r\n  mapping(address => AggregatorV3Interface) public priceFeeds;\r\n\r\n  /**\r\n   * @notice Maps ERC20 token addresses to enums indicating the base currency of the feed.\r\n   */\r\n  mapping(address => FeedBaseCurrency) public feedBaseCurrencies;\r\n\r\n  /**\r\n   * @notice Enum indicating the base currency of a Chainlink price feed.\r\n   * @dev ETH is interchangeable with the nativeToken of the current chain.\r\n   */\r\n  enum FeedBaseCurrency {\r\n    ETH,\r\n    USD\r\n  }\r\n\r\n  /**\r\n   * @notice Chainlink NATIVE/USD price feed contracts.\r\n   */\r\n  address public NATIVE_TOKEN_USD_PRICE_FEED;\r\n\r\n  /**\r\n   * @notice The USD Token of the chain\r\n   */\r\n  address public USD_TOKEN;\r\n\r\n  /**\r\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\r\n   * @param _usdToken The Wrapped native asset address\r\n   * @param nativeTokenUsd Will this oracle return prices denominated in USD or in the native token.\r\n   */\r\n  function initialize(address _usdToken, address nativeTokenUsd) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    USD_TOKEN = _usdToken;\r\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\r\n   * @param baseCurrency The currency in which `feeds` are based.\r\n   */\r\n  function setPriceFeeds(\r\n    address[] memory underlyings,\r\n    address[] memory feeds,\r\n    FeedBaseCurrency baseCurrency\r\n  ) external onlyOwner {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == feeds.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/feed\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      // Set feed and base currency\r\n      priceFeeds[underlying] = AggregatorV3Interface(feeds[i]);\r\n      feedBaseCurrencies[underlying] = baseCurrency;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning the price in of `underlying`.\r\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Get token/ETH price from Chainlink\r\n    AggregatorV3Interface feed = priceFeeds[underlying];\r\n    require(address(feed) != address(0), \"No Chainlink price feed found for this underlying ERC20 token.\");\r\n    FeedBaseCurrency baseCurrency = feedBaseCurrencies[underlying];\r\n\r\n    if (baseCurrency == FeedBaseCurrency.ETH) {\r\n      (, int256 tokenEthPrice, , , ) = feed.latestRoundData();\r\n      return tokenEthPrice >= 0 ? (uint256(tokenEthPrice) * 1e18) / (10 ** uint256(feed.decimals())) : 0;\r\n    } else if (baseCurrency == FeedBaseCurrency.USD) {\r\n      int256 nativeTokenUsdPrice;\r\n      uint8 usdPriceDecimals;\r\n\r\n      if (NATIVE_TOKEN_USD_PRICE_FEED == address(0)) {\r\n        uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\r\n        nativeTokenUsdPrice = int256(1e36 / usdNativeTokenPrice); // 18 decimals\r\n        usdPriceDecimals = 18;\r\n      } else {\r\n        (, nativeTokenUsdPrice, , , ) = AggregatorV3Interface(NATIVE_TOKEN_USD_PRICE_FEED).latestRoundData();\r\n        if (nativeTokenUsdPrice <= 0) return 0;\r\n        usdPriceDecimals = AggregatorV3Interface(NATIVE_TOKEN_USD_PRICE_FEED).decimals();\r\n      }\r\n      (, int256 tokenUsdPrice, , , ) = feed.latestRoundData();\r\n\r\n      return\r\n        tokenUsdPrice >= 0\r\n          ? ((uint256(tokenUsdPrice) * 1e18 * (10 ** uint256(usdPriceDecimals))) / (10 ** uint256(feed.decimals()))) /\r\n            uint256(nativeTokenUsdPrice)\r\n          : 0;\r\n    } else {\r\n      revert(\"unknown base currency\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in of `underlying` either in USD or the native token (implements `BasePriceOracle`).\r\n   * @dev If the oracle got constructed with `nativeTokenUsd` = TRUE this will return a price denominated in USD otherwise in the native token\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/ConcentratedLiquidityBasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport { BasePriceOracle } from \"../../oracles/BasePriceOracle.sol\";\r\nimport { ICErc20 } from \"../../compound/CTokenInterfaces.sol\";\r\n\r\nimport \"../../external/uniswap/FullMath.sol\";\r\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title ConcentratedLiquidityBasePriceOracle\r\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\r\n * @notice ConcentratedLiquidityBasePriceOracle is an abstract price oracle for concentrated liquidty (UniV3-like) pairs.\r\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\r\n */\r\nabstract contract ConcentratedLiquidityBasePriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\r\n  /**\r\n   * @notice Maps ERC20 token addresses to asset configs.\r\n   */\r\n  mapping(address => AssetConfig) public poolFeeds;\r\n\r\n  /**\r\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\r\n   */\r\n  bool public canAdminOverwrite;\r\n\r\n  struct AssetConfig {\r\n    address poolAddress;\r\n    uint256 twapWindow;\r\n    address baseToken;\r\n  }\r\n\r\n  address public WTOKEN;\r\n  address[] public SUPPORTED_BASE_TOKENS;\r\n\r\n  function initialize(address _wtoken, address[] memory _supportedBaseTokens) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    WTOKEN = _wtoken;\r\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param assetConfig The asset configuration which includes pool address and twap window.\r\n   */\r\n  function setPoolFeeds(address[] memory underlyings, AssetConfig[] memory assetConfig) external onlyOwner {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == assetConfig.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/config\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      // Set asset config for underlying\r\n      require(\r\n        assetConfig[i].baseToken == WTOKEN || _isBaseTokenSupported(assetConfig[i].baseToken),\r\n        \"Base token must be supported\"\r\n      );\r\n      poolFeeds[underlying] = assetConfig[i];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the token price price for an underlying token address.\r\n   * @param underlying The underlying token address for which to get the price (set to zero address for WTOKEN)\r\n   * @return Price denominated in NATIVE (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in NATIVE of the token underlying `cToken`.\r\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10 ** uint256(EIP20Interface(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fetches the price for a token from Uniswap v3\r\n   */\r\n  function _price(address token) internal view virtual returns (uint256);\r\n\r\n  function getPriceX96FromSqrtPriceX96(\r\n    address token0,\r\n    address priceToken,\r\n    uint160 sqrtPriceX96\r\n  ) public pure returns (uint256 price_) {\r\n    price_ = FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, uint256(2 ** (96 * 2)) / 1e18);\r\n    if (token0 != priceToken) price_ = 1e36 / price_;\r\n  }\r\n\r\n  function _isBaseTokenSupported(address token) internal view returns (bool) {\r\n    for (uint256 i = 0; i < SUPPORTED_BASE_TOKENS.length; i++) {\r\n      if (SUPPORTED_BASE_TOKENS[i] == token) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function _setSupportedBaseTokens(address[] memory _supportedBaseTokens) external onlyOwner {\r\n    SUPPORTED_BASE_TOKENS = _supportedBaseTokens;\r\n  }\r\n\r\n  function getSupportedBaseTokens() external view returns (address[] memory) {\r\n    return SUPPORTED_BASE_TOKENS;\r\n  }\r\n\r\n  function scalePrices(address baseToken, address token, uint256 tokenPrice) internal view returns (uint256) {\r\n    uint256 baseTokenDecimals;\r\n    uint256 tokenPriceScaled;\r\n\r\n    if (baseToken == address(0) || baseToken == WTOKEN) {\r\n      baseTokenDecimals = 18;\r\n    } else {\r\n      baseTokenDecimals = uint256(ERC20Upgradeable(baseToken).decimals());\r\n    }\r\n\r\n    uint256 baseNativePrice = BasePriceOracle(msg.sender).price(baseToken);\r\n\r\n    // scale tokenPrice by 1e18\r\n    uint256 tokenDecimals = uint256(ERC20Upgradeable(token).decimals());\r\n    if (baseTokenDecimals > tokenDecimals) {\r\n      tokenPriceScaled = tokenPrice / (10 ** (baseTokenDecimals - tokenDecimals));\r\n    } else if (baseTokenDecimals < tokenDecimals) {\r\n      tokenPriceScaled = tokenPrice * (10 ** (tokenDecimals - baseTokenDecimals));\r\n    } else {\r\n      tokenPriceScaled = tokenPrice;\r\n    }\r\n    return (tokenPriceScaled * baseNativePrice) / 1e18;\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/CurveLpTokenPriceOracleNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\r\n\r\nimport \"../../external/curve/ICurvePool.sol\";\r\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title CurveLpTokenPriceOracleNoRegistry\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve LP tokens (using the sender as a root oracle).\r\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\r\n */\r\ncontract CurveLpTokenPriceOracleNoRegistry is SafeOwnableUpgradeable, BasePriceOracle {\r\n  /**\r\n   * @dev Maps Curve LP token addresses to underlying token addresses.\r\n   */\r\n  mapping(address => address[]) public underlyingTokens;\r\n\r\n  /**\r\n   * @dev Maps Curve LP token addresses to pool addresses.\r\n   */\r\n  mapping(address => address) public poolOf;\r\n\r\n  address[] public lpTokens;\r\n\r\n  /**\r\n   * @dev Initializes an array of LP tokens and pools if desired.\r\n   * @param _lpTokens Array of LP token addresses.\r\n   * @param _pools Array of pool addresses.\r\n   * @param _poolUnderlyings The underlying token addresses of a pool\r\n   */\r\n  function initialize(\r\n    address[] memory _lpTokens,\r\n    address[] memory _pools,\r\n    address[][] memory _poolUnderlyings\r\n  ) public initializer {\r\n    require(\r\n      _lpTokens.length == _pools.length && _lpTokens.length == _poolUnderlyings.length,\r\n      \"No LP tokens supplied or array lengths not equal.\"\r\n    );\r\n\r\n    __SafeOwnable_init(msg.sender);\r\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\r\n      poolOf[_lpTokens[i]] = _pools[i];\r\n      underlyingTokens[_lpTokens[i]] = _poolUnderlyings[i];\r\n    }\r\n  }\r\n\r\n  function getAllLPTokens() public view returns (address[] memory) {\r\n    return lpTokens;\r\n  }\r\n\r\n  function getPoolForSwap(address inputToken, address outputToken)\r\n    public\r\n    view\r\n    returns (\r\n      ICurvePool,\r\n      int128,\r\n      int128\r\n    )\r\n  {\r\n    for (uint256 i = 0; i < lpTokens.length; i++) {\r\n      ICurvePool pool = ICurvePool(poolOf[lpTokens[i]]);\r\n      int128 inputIndex = -1;\r\n      int128 outputIndex = -1;\r\n      int128 j = 0;\r\n      while (true) {\r\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\r\n          if (coin == inputToken) inputIndex = j;\r\n          else if (coin == outputToken) outputIndex = j;\r\n          j++;\r\n        } catch {\r\n          break;\r\n        }\r\n\r\n        if (outputIndex > -1 && inputIndex > -1) {\r\n          return (pool, inputIndex, outputIndex);\r\n        }\r\n      }\r\n    }\r\n\r\n    return (ICurvePool(address(0)), 0, 0);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the LP token price price for an underlying token address.\r\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\r\n   * @return Price denominated in ETH (scaled by 1e18).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\r\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\r\n   * @param lpToken The LP token contract address for price retrieval.\r\n   */\r\n  function _price(address lpToken) internal view returns (uint256) {\r\n    address pool = poolOf[lpToken];\r\n    require(pool != address(0), \"LP token is not registered.\");\r\n    address[] memory tokens = underlyingTokens[lpToken];\r\n    uint256 minPx = type(uint256).max;\r\n    uint256 n = tokens.length;\r\n\r\n    for (uint256 i = 0; i < n; i++) {\r\n      address ulToken = tokens[i];\r\n      uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\r\n      if (tokenPx < minPx) minPx = tokenPx;\r\n    }\r\n\r\n    require(minPx != type(uint256).max, \"No minimum underlying token price found.\");\r\n    return (minPx * ICurvePool(pool).get_virtual_price()) / 1e18; // Use min underlying token prices\r\n  }\r\n\r\n  /**\r\n   * @dev Register the pool given LP token address and set the pool info.\r\n   * @param _lpToken LP token to find the corresponding pool.\r\n   * @param _pool Pool address.\r\n   * @param _underlyings Underlying addresses.\r\n   */\r\n  function registerPool(\r\n    address _lpToken,\r\n    address _pool,\r\n    address[] memory _underlyings\r\n  ) external onlyOwner {\r\n    poolOf[_lpToken] = _pool;\r\n    underlyingTokens[_lpToken] = _underlyings;\r\n\r\n    bool skip = false;\r\n    for (uint256 j = 0; j < lpTokens.length; j++) {\r\n      if (lpTokens[j] == _lpToken) {\r\n        skip = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!skip) lpTokens.push(_lpToken);\r\n  }\r\n\r\n  /**\r\n   * @dev getter for the underlying tokens\r\n   * @param lpToken the LP token address.\r\n   * @return _underlyings Underlying addresses.\r\n   */\r\n  function getUnderlyingTokens(address lpToken) public view returns (address[] memory) {\r\n    return underlyingTokens[lpToken];\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/CurveV2LpTokenPriceOracleNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\r\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\r\n\r\nimport \"../../external/curve/ICurveV2Pool.sol\";\r\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title CurveLpTokenPriceOracle\r\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\r\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve V2 LP tokens (using the sender as a root oracle).\r\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\r\n */\r\ncontract CurveV2LpTokenPriceOracleNoRegistry is SafeOwnableUpgradeable, BasePriceOracle {\r\n  address public usdToken;\r\n  MasterPriceOracle public masterPriceOracle;\r\n  /**\r\n   * @dev Maps Curve LP token addresses to pool addresses.\r\n   */\r\n  mapping(address => address) public poolOf;\r\n\r\n  address[] public lpTokens;\r\n\r\n  /**\r\n   * @dev Initializes an array of LP tokens and pools if desired.\r\n   * @param _lpTokens Array of LP token addresses.\r\n   * @param _pools Array of pool addresses.\r\n   */\r\n  function initialize(address[] memory _lpTokens, address[] memory _pools) public initializer {\r\n    require(_lpTokens.length == _pools.length, \"No LP tokens supplied or array lengths not equal.\");\r\n    __SafeOwnable_init(msg.sender);\r\n\r\n    for (uint256 i = 0; i < _pools.length; i++) {\r\n      poolOf[_lpTokens[i]] = _pools[i];\r\n    }\r\n  }\r\n\r\n  function getAllLPTokens() public view returns (address[] memory) {\r\n    return lpTokens;\r\n  }\r\n\r\n  function getPoolForSwap(address inputToken, address outputToken)\r\n    public\r\n    view\r\n    returns (\r\n      ICurvePool,\r\n      int128,\r\n      int128\r\n    )\r\n  {\r\n    for (uint256 i = 0; i < lpTokens.length; i++) {\r\n      ICurvePool pool = ICurvePool(poolOf[lpTokens[i]]);\r\n      int128 inputIndex = -1;\r\n      int128 outputIndex = -1;\r\n      int128 j = 0;\r\n      while (true) {\r\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\r\n          if (coin == inputToken) inputIndex = j;\r\n          else if (coin == outputToken) outputIndex = j;\r\n          j++;\r\n        } catch {\r\n          break;\r\n        }\r\n\r\n        if (outputIndex > -1 && inputIndex > -1) {\r\n          return (pool, inputIndex, outputIndex);\r\n        }\r\n      }\r\n    }\r\n\r\n    return (ICurvePool(address(0)), int128(0), int128(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Get the LP token price price for an underlying token address.\r\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\r\n   * @return Price denominated in ETH (scaled by 1e18).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fetches the fair LP token price from Curve, with 18 decimals of precision.\r\n   * @param lpToken The LP token contract address for price retrieval.\r\n   */\r\n  function _price(address lpToken) internal view returns (uint256) {\r\n    address pool = poolOf[lpToken];\r\n    require(address(pool) != address(0), \"LP token is not registered.\");\r\n\r\n    address baseToken = ICurvePool(pool).coins(0);\r\n    uint256 lpPrice = ICurveV2Pool(pool).lp_price();\r\n    uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\r\n    return (lpPrice * baseTokenPrice) / 10**18;\r\n  }\r\n\r\n  /**\r\n   * @dev Register the pool given LP token address and set the pool info.\r\n   * @param _lpToken LP token to find the corresponding pool.\r\n   * @param _pool Pool address.\r\n   */\r\n  function registerPool(address _lpToken, address _pool) external onlyOwner {\r\n    address pool = poolOf[_lpToken];\r\n    require(pool == address(0), \"This LP token is already registered.\");\r\n    poolOf[_lpToken] = _pool;\r\n\r\n    bool skip = false;\r\n    for (uint256 j = 0; j < lpTokens.length; j++) {\r\n      if (lpTokens[j] == _lpToken) {\r\n        skip = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!skip) lpTokens.push(_lpToken);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/CurveV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { EIP20Interface } from \"../../compound/EIP20Interface.sol\";\r\n\r\nimport \"../../external/curve/ICurveV2Pool.sol\";\r\n\r\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title CurveLpTokenPriceOracle\r\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\r\n * @notice CurveLpTokenPriceOracleNoRegistry is a price oracle for Curve V2 LP tokens (using the sender as a root oracle).\r\n * @dev Implements the `PriceOracle` interface used by Midas pools (and Compound v2).\r\n */\r\ncontract CurveV2PriceOracle is SafeOwnableUpgradeable, BasePriceOracle {\r\n  /**\r\n   * @dev Maps Curve LP token addresses to pool addresses.\r\n   */\r\n  mapping(address => address) public poolFor;\r\n\r\n  address[] public tokens;\r\n\r\n  /**\r\n   * @dev Initializes an array of tokens and pools if desired.\r\n   * @param _tokens Array of token addresses.\r\n   * @param _pools Array of pool addresses.\r\n   */\r\n  function initialize(address[] memory _tokens, address[] memory _pools) public initializer {\r\n    require(_tokens.length == _pools.length, \"No LP tokens supplied or array lengths not equal.\");\r\n    __SafeOwnable_init(msg.sender);\r\n\r\n    for (uint256 i = 0; i < _pools.length; i++) {\r\n      try ICurvePool(_pools[i]).coins(2) returns (address) {\r\n        revert(\"!only two token pools\");\r\n      } catch {\r\n        // ignore error\r\n      }\r\n\r\n      poolFor[_tokens[i]] = _pools[i];\r\n    }\r\n  }\r\n\r\n  function getAllSupportedTokens() public view returns (address[] memory) {\r\n    return tokens;\r\n  }\r\n\r\n  function getPoolForSwap(address inputToken, address outputToken)\r\n    public\r\n    view\r\n    returns (\r\n      ICurvePool,\r\n      int128,\r\n      int128\r\n    )\r\n  {\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      ICurvePool pool = ICurvePool(poolFor[tokens[i]]);\r\n      int128 inputIndex = -1;\r\n      int128 outputIndex = -1;\r\n      int128 j = 0;\r\n      while (true) {\r\n        try pool.coins(uint256(uint128(j))) returns (address coin) {\r\n          if (coin == inputToken) inputIndex = j;\r\n          else if (coin == outputToken) outputIndex = j;\r\n          j++;\r\n        } catch {\r\n          break;\r\n        }\r\n\r\n        if (outputIndex > -1 && inputIndex > -1) {\r\n          return (pool, inputIndex, outputIndex);\r\n        }\r\n      }\r\n    }\r\n\r\n    return (ICurvePool(address(0)), int128(0), int128(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Get the LP token price price for an underlying token address.\r\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\r\n   * @return Price denominated in ETH (scaled by 1e18).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10**uint256(EIP20Interface(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fetches the fair LP token price from Curve, with 18 decimals of precision.\r\n   * @param token The LP token contract address for price retrieval.\r\n   */\r\n  function _price(address token) internal view returns (uint256) {\r\n    address pool = poolFor[token];\r\n    require(address(pool) != address(0), \"Token is not registered.\");\r\n\r\n    address baseToken;\r\n    // Returns always coin(1) / coin(0)  [ e.g. USDC (1) / eUSDC (1) ]\r\n    uint256 exchangeRate = ICurveV2Pool(pool).price_oracle();\r\n\r\n    if (ICurvePool(pool).coins(0) == token) {\r\n      baseToken = ICurvePool(pool).coins(1);\r\n      // USDC / ETH\r\n      uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\r\n      // USDC / ETH * eUSDC / USDC = eUSDC / ETH\r\n      return (baseTokenPrice * 10**18) / exchangeRate;\r\n    } else {\r\n      // if coin(1) is eUSDC, exchangeRate is USDC / eUSDC\r\n      baseToken = ICurvePool(pool).coins(0);\r\n      // USDC / ETH\r\n      uint256 baseTokenPrice = BasePriceOracle(msg.sender).price(baseToken);\r\n      // (USDC / ETH) *  (1 / (USDC / eUSDC)) = eUSDC / ETH\r\n      return (baseTokenPrice * exchangeRate) / 10**18;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Register the pool given token address and set the pool info.\r\n   * @param _token token to find the corresponding pool.\r\n   * @param _pool Pool address.\r\n   */\r\n  function registerPool(address _token, address _pool) external onlyOwner {\r\n    try ICurvePool(_pool).coins(2) returns (address) {\r\n      revert(\"!only two token pools\");\r\n    } catch {\r\n      // ignore error\r\n    }\r\n\r\n    address pool = poolFor[_token];\r\n    require(pool == address(0), \"This LP token is already registered.\");\r\n    poolFor[_token] = _pool;\r\n\r\n    bool skip = false;\r\n    for (uint256 j = 0; j < tokens.length; j++) {\r\n      if (tokens[j] == _token) {\r\n        skip = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!skip) tokens.push(_token);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/DiaPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { IPriceOracle } from \"../../external/compound/IPriceOracle.sol\";\r\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\r\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\r\n\r\ninterface DIAOracleV2 {\r\n  function getValue(string memory key) external view returns (uint128, uint128);\r\n}\r\n\r\n/**\r\n * @title DiaPriceOracle\r\n * @notice Returns prices from DIA.\r\n * @dev Implements `PriceOracle`.\r\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\r\n */\r\ncontract DiaPriceOracle is BasePriceOracle {\r\n  struct DiaOracle {\r\n    DIAOracleV2 feed;\r\n    string key;\r\n  }\r\n\r\n  /**\r\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\r\n   */\r\n  mapping(address => DiaOracle) public priceFeeds;\r\n\r\n  /**\r\n   * @dev The administrator of this `MasterPriceOracle`.\r\n   */\r\n  address public admin;\r\n\r\n  /**\r\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\r\n   */\r\n  bool public immutable CAN_ADMIN_OVERWRITE;\r\n\r\n  /**\r\n   * @dev The Wrapped native asset address.\r\n   */\r\n  address public immutable WTOKEN;\r\n\r\n  /**\r\n   * @notice DIA NATIVE/USD price feed contracts.\r\n   */\r\n  DIAOracleV2 public immutable NATIVE_TOKEN_USD_PRICE_FEED;\r\n  string public NATIVE_TOKEN_USD_KEY;\r\n\r\n  /**\r\n   * @notice MasterPriceOracle for backup for USD price.\r\n   */\r\n  MasterPriceOracle public immutable MASTER_PRICE_ORACLE;\r\n  address public immutable USD_TOKEN; // token to use as USD price (i.e. USDC)\r\n\r\n  /**\r\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\r\n   */\r\n  constructor(\r\n    address _admin,\r\n    bool canAdminOverwrite,\r\n    address wtoken,\r\n    DIAOracleV2 nativeTokenUsd,\r\n    string memory nativeTokenUsdKey,\r\n    MasterPriceOracle masterPriceOracle,\r\n    address usdToken\r\n  ) {\r\n    admin = _admin;\r\n    CAN_ADMIN_OVERWRITE = canAdminOverwrite;\r\n    WTOKEN = wtoken;\r\n    NATIVE_TOKEN_USD_PRICE_FEED = nativeTokenUsd;\r\n    NATIVE_TOKEN_USD_KEY = nativeTokenUsdKey;\r\n    MASTER_PRICE_ORACLE = masterPriceOracle;\r\n    USD_TOKEN = usdToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin and emits an event.\r\n   */\r\n  function changeAdmin(address newAdmin) external onlyAdmin {\r\n    address oldAdmin = admin;\r\n    admin = newAdmin;\r\n    emit NewAdmin(oldAdmin, newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Event emitted when `admin` is changed.\r\n   */\r\n  event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Modifier that checks if `msg.sender == admin`.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"Sender is not the admin.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param feeds The DIA price feed contract addresses for each of `underlyings`.\r\n   * @param keys The keys for each of `underlyings`, in the format \"ETH/USD\" for example\r\n   */\r\n  function setPriceFeeds(\r\n    address[] memory underlyings,\r\n    DIAOracleV2[] memory feeds,\r\n    string[] memory keys\r\n  ) external onlyAdmin {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == feeds.length && underlyings.length == keys.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/feed\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n\r\n      // Check for existing oracle if !canAdminOverwrite\r\n      if (!CAN_ADMIN_OVERWRITE)\r\n        require(\r\n          address(priceFeeds[underlying].feed) == address(0),\r\n          \"Admin cannot overwrite existing assignments of price feeds to underlying tokens.\"\r\n        );\r\n\r\n      // Set feed and base currency\r\n      priceFeeds[underlying] = DiaOracle({ feed: feeds[i], key: keys[i] });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function returning the price in ETH of `underlying`.\r\n   * Assumes price feeds are 8 decimals!\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Return 1e18 for WTOKEN\r\n    if (underlying == WTOKEN || underlying == address(0)) return 1e18;\r\n\r\n    // Get token/Native price from Oracle\r\n    DiaOracle memory feed = priceFeeds[underlying];\r\n    require(address(feed.feed) != address(0), \"No oracle price feed found for this underlying ERC20 token.\");\r\n\r\n    if (address(NATIVE_TOKEN_USD_PRICE_FEED) == address(0)) {\r\n      // Get price from MasterPriceOracle\r\n      uint256 usdNativeTokenPrice = MASTER_PRICE_ORACLE.price(USD_TOKEN);\r\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals\r\n      (uint128 tokenUsdPrice, ) = feed.feed.getValue(feed.key); // 8 decimals\r\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e28) / uint256(nativeTokenUsdPrice) : 0;\r\n    } else {\r\n      (uint128 nativeTokenUsdPrice, ) = NATIVE_TOKEN_USD_PRICE_FEED.getValue(NATIVE_TOKEN_USD_KEY);\r\n      if (nativeTokenUsdPrice <= 0) return 0;\r\n      (uint128 tokenUsdPrice, ) = feed.feed.getValue(feed.key); // 8 decimals\r\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    // Get price\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    // Format and return price\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/ERC4626Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { IERC4626 } from \"../../compound/IERC4626.sol\";\r\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\ncontract ERC4626Oracle is SafeOwnableUpgradeable, BasePriceOracle {\r\n  function initialize() public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n  }\r\n\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10 ** uint256(ERC20Upgradeable(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\r\n   */\r\n  function _price(address underlying) internal view virtual returns (uint256) {\r\n    IERC4626 vault = IERC4626(underlying);\r\n    address asset = vault.asset();\r\n    uint256 redeemAmount = vault.previewRedeem(10 ** vault.decimals());\r\n    uint256 underlyingPrice = BasePriceOracle(msg.sender).price(asset);\r\n    return (redeemAmount * underlyingPrice) / 10 ** ERC20Upgradeable(asset).decimals();\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/FixedNativePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title FixedEthPriceOracle\r\n * @notice Returns fixed prices of 1 denominated in the chain's native token for all tokens (expected to be used under a `MasterPriceOracle`).\r\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract FixedNativePriceOracle is BasePriceOracle {\r\n  /**\r\n   * @dev Returns the price in native token of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return 1e18;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in native token of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in native token of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    return 1e18;\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/FixedTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title FixedTokenPriceOracle\r\n * @notice Returns token prices using the prices for another token.\r\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract FixedTokenPriceOracle is BasePriceOracle {\r\n  /**\r\n   * @dev The token to base prices on.\r\n   */\r\n  address public immutable baseToken;\r\n\r\n  /**\r\n   * @dev Sets the token to base prices on.\r\n   */\r\n  constructor(address _baseToken) {\r\n    baseToken = _baseToken;\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   * @param underlying The underlying token address for which to get the price.\r\n   * @return Price denominated in ETH (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10 ** uint256(ERC20Upgradeable(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   */\r\n  function _price(address token) internal view returns (uint256) {\r\n    return BasePriceOracle(msg.sender).price(baseToken);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/PreferredPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport \"../MasterPriceOracle.sol\";\r\nimport \"../default/ChainlinkPriceOracleV2.sol\";\r\n\r\n/**\r\n * @title PreferredPriceOracle\r\n * @notice Returns prices from MasterPriceOracle, ChainlinkPriceOracleV2, or prices from a tertiary oracle (in order of preference).\r\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract PreferredPriceOracle is BasePriceOracle {\r\n  /**\r\n   * @dev The primary `MasterPriceOracle`.\r\n   */\r\n  MasterPriceOracle public masterOracle;\r\n\r\n  /**\r\n   * @dev The secondary `ChainlinkPriceOracleV2`.\r\n   */\r\n  ChainlinkPriceOracleV2 public chainlinkOracleV2;\r\n\r\n  /**\r\n   * @dev The tertiary `PriceOracle`.\r\n   */\r\n  BasePriceOracle public tertiaryOracle;\r\n\r\n  /**\r\n   * @dev The Wrapped native asset address.\r\n   */\r\n  address public wtoken;\r\n\r\n  /**\r\n   * @dev Constructor to set the primary `MasterPriceOracle`, the secondary `ChainlinkPriceOracleV2`, and the tertiary `PriceOracle`.\r\n   */\r\n  constructor(\r\n    MasterPriceOracle _masterOracle,\r\n    ChainlinkPriceOracleV2 _chainlinkOracleV2,\r\n    BasePriceOracle _tertiaryOracle,\r\n    address _wtoken\r\n  ) {\r\n    require(address(_masterOracle) != address(0), \"MasterPriceOracle not set.\");\r\n    require(address(_chainlinkOracleV2) != address(0), \"ChainlinkPriceOracleV2 not set.\");\r\n    require(address(_tertiaryOracle) != address(0), \"Tertiary price oracle not set.\");\r\n    masterOracle = _masterOracle;\r\n    chainlinkOracleV2 = _chainlinkOracleV2;\r\n    tertiaryOracle = _tertiaryOracle;\r\n    wtoken = _wtoken;\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   * @param underlying The underlying token address for which to get the price.\r\n   * @return Price denominated in ETH (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    // Return 1e18 for wtoken\r\n    if (underlying == wtoken) return 1e18;\r\n\r\n    // Try to get MasterPriceOracle price\r\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.price(underlying);\r\n\r\n    // Try to get ChainlinkPriceOracleV2 price\r\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0)) return chainlinkOracleV2.price(underlying);\r\n\r\n    // Otherwise, get price from tertiary oracle\r\n    return BasePriceOracle(address(tertiaryOracle)).price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying ERC20 token address\r\n    address underlying = cToken.underlying();\r\n\r\n    // Return 1e18 for wtoken\r\n    if (underlying == wtoken) return 1e18;\r\n\r\n    // Try to get MasterPriceOracle price\r\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.getUnderlyingPrice(cToken);\r\n\r\n    // Try to get ChainlinkPriceOracleV2 price\r\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0))\r\n      return chainlinkOracleV2.getUnderlyingPrice(cToken);\r\n\r\n    // Otherwise, get price from tertiary oracle\r\n    return tertiaryOracle.getUnderlyingPrice(cToken);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/PythPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\r\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\r\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\r\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title PythPriceOracle\r\n * @notice Returns prices from Pyth.\r\n * @dev Implements `PriceOracle`.\r\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\r\n */\r\ncontract PythPriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\r\n  /**\r\n   * @notice Maps ERC20 token addresses to Pyth price IDs.\r\n   */\r\n  mapping(address => bytes32) public priceFeedIds;\r\n\r\n  /**\r\n   * @notice DIA NATIVE/USD price feed contracts.\r\n   */\r\n  bytes32 public NATIVE_TOKEN_USD_FEED;\r\n\r\n  /**\r\n   * @notice MasterPriceOracle for backup for USD price.\r\n   */\r\n  address public USD_TOKEN; // token to use as USD price (i.e. USDC)\r\n\r\n  /**\r\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\r\n   */\r\n\r\n  IPyth public PYTH;\r\n\r\n  function initialize(address pythAddress, bytes32 nativeTokenUsdFeed, address usdToken) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\r\n    USD_TOKEN = usdToken;\r\n    PYTH = IPyth(pythAddress);\r\n  }\r\n\r\n  function reinitialize(address pythAddress, bytes32 nativeTokenUsdFeed, address usdToken) public onlyOwnerOrAdmin {\r\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\r\n    USD_TOKEN = usdToken;\r\n    PYTH = IPyth(pythAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param feedIds The Pyth Network feed IDs`.\r\n   */\r\n  function setPriceFeeds(address[] memory underlyings, bytes32[] memory feedIds) external onlyOwner {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == feedIds.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/feed\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      // Set feed and base currency\r\n      priceFeedIds[underlying] = feedIds[i];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function returning the price in ETH of `underlying`.\r\n   * Assumes price feeds are 8 decimals (TODO: doublecheck)\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Get token/native price from Oracle\r\n    bytes32 feed = priceFeedIds[underlying];\r\n    require(feed != \"\", \"No oracle price feed found for this underlying ERC20 token.\");\r\n\r\n    if (NATIVE_TOKEN_USD_FEED == \"\") {\r\n      // Get price from MasterPriceOracle\r\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\r\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals -- TODO: doublecheck\r\n      PythStructs.Price memory tokenUsdPrice = PYTH.getPriceUnsafe(feed); // 8 decimals ---  TODO: doublecheck\r\n      return\r\n        tokenUsdPrice.price >= 0 ? (uint256(uint64(tokenUsdPrice.price)) * 1e28) / uint256(nativeTokenUsdPrice) : 0;\r\n    } else {\r\n      uint128 nativeTokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(NATIVE_TOKEN_USD_FEED).price));\r\n      if (nativeTokenUsdPrice <= 0) return 0;\r\n      uint128 tokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(feed).price));\r\n      return tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    // Get price\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    // Format and return price\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/PythPriceOracleDmBTC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { MasterPriceOracle } from \"../MasterPriceOracle.sol\";\r\nimport { BasePriceOracle, ICErc20 } from \"../BasePriceOracle.sol\";\r\nimport { IPyth } from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\r\nimport { PythStructs } from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\r\nimport { SafeOwnableUpgradeable } from \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title PythPriceOracle\r\n * @notice Returns prices from Pyth.\r\n * @dev Implements `PriceOracle`.\r\n * @author Rahul Sethuram <rahul@midascapital.xyz> (https://github.com/rhlsthrm)\r\n */\r\ncontract PythPriceOracleDmBTC is BasePriceOracle, SafeOwnableUpgradeable {\r\n  /**\r\n   * @notice Maps ERC20 token addresses to Pyth price IDs.\r\n   */\r\n  mapping(address => bytes32) public priceFeedIds;\r\n\r\n  /**\r\n   * @notice DIA NATIVE/USD price feed contracts.\r\n   */\r\n  bytes32 public NATIVE_TOKEN_USD_FEED;\r\n\r\n  /**\r\n   * @notice MasterPriceOracle for backup for USD price.\r\n   */\r\n  address public USD_TOKEN; // token to use as USD price (i.e. USDC)\r\n\r\n  /**\r\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\r\n   */\r\n\r\n  IPyth public PYTH;\r\n\r\n  address public DMBTC;\r\n\r\n  function initialize(\r\n    address pythAddress,\r\n    bytes32 nativeTokenUsdFeed,\r\n    address usdToken,\r\n    address dmBTC\r\n  ) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\r\n    USD_TOKEN = usdToken;\r\n    PYTH = IPyth(pythAddress);\r\n    DMBTC = dmBTC;\r\n  }\r\n\r\n  function reinitialize(\r\n    address pythAddress,\r\n    bytes32 nativeTokenUsdFeed,\r\n    address usdToken,\r\n    address dmBTC\r\n  ) public onlyOwnerOrAdmin {\r\n    NATIVE_TOKEN_USD_FEED = nativeTokenUsdFeed;\r\n    USD_TOKEN = usdToken;\r\n    PYTH = IPyth(pythAddress);\r\n    DMBTC = dmBTC;\r\n  }\r\n\r\n  /**\r\n   * @dev Admin-only function to set price feeds.\r\n   * @param underlyings Underlying token addresses for which to set price feeds.\r\n   * @param feedIds The Pyth Network feed IDs`.\r\n   */\r\n  function setPriceFeeds(address[] memory underlyings, bytes32[] memory feedIds) external onlyOwner {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == feedIds.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // For each token/feed\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      // Set feed and base currency\r\n      priceFeedIds[underlying] = feedIds[i];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function returning the price in ETH of `underlying`.\r\n   * Assumes price feeds are 8 decimals (TODO: doublecheck)\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Get token/native price from Oracle\r\n    bytes32 feed = priceFeedIds[underlying];\r\n    require(feed != \"\", \"No oracle price feed found for this underlying ERC20 token.\");\r\n    uint256 normalizedPrice;\r\n    if (NATIVE_TOKEN_USD_FEED == \"\") {\r\n      // Get price from MasterPriceOracle\r\n      uint256 usdNativeTokenPrice = BasePriceOracle(msg.sender).price(USD_TOKEN);\r\n      uint256 nativeTokenUsdPrice = 1e36 / usdNativeTokenPrice; // 18 decimals -- TODO: doublecheck\r\n      PythStructs.Price memory tokenUsdPrice = PYTH.getPriceUnsafe(feed); // 8 decimals ---  TODO: doublecheck\r\n      normalizedPrice = tokenUsdPrice.price >= 0\r\n        ? (uint256(uint64(tokenUsdPrice.price)) * 1e28) / uint256(nativeTokenUsdPrice)\r\n        : 0;\r\n    } else {\r\n      uint128 nativeTokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(NATIVE_TOKEN_USD_FEED).price));\r\n      if (nativeTokenUsdPrice <= 0) return 0;\r\n      uint128 tokenUsdPrice = uint128(uint64(PYTH.getPriceUnsafe(feed).price));\r\n      normalizedPrice = tokenUsdPrice >= 0 ? (uint256(tokenUsdPrice) * 1e18) / uint256(nativeTokenUsdPrice) : 0;\r\n    }\r\n    if (underlying == DMBTC) {\r\n      return normalizedPrice / 100000;\r\n    }\r\n    return normalizedPrice;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    // Get price\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    // Format and return price\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/redstone/IRedstoneOracle.sol\";\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title RedstoneAdapterPriceOracle\r\n * @notice Returns prices from Redstone.\r\n * @dev Implements `BasePriceOracle`.\r\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\r\n */\r\ncontract RedstoneAdapterPriceOracle is BasePriceOracle {\r\n  /**\r\n   * @notice The Redstone oracle contract\r\n   */\r\n  IRedstoneOracle public REDSTONE_ORACLE;\r\n\r\n  /**\r\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\r\n   * @param redstoneOracle The Redstone oracle contract address\r\n   */\r\n  constructor(address redstoneOracle) {\r\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning the price in of `underlying`.\r\n   * @dev will return a price denominated in the native token\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\r\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\r\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in of `underlying` either in the\r\n   * native token (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\r\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracleWeETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/redstone/IRedstoneOracle.sol\";\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title RedstoneAdapterPriceOracle\r\n * @notice Returns prices from Redstone.\r\n * @dev Implements `BasePriceOracle`.\r\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\r\n */\r\ncontract RedstoneAdapterPriceOracleWeETH is BasePriceOracle {\r\n  /**\r\n   * @notice The Redstone oracle contract\r\n   */\r\n  IRedstoneOracle public REDSTONE_ORACLE;\r\n\r\n  /**\r\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\r\n   * @param redstoneOracle The Redstone oracle contract address\r\n   */\r\n  constructor(address redstoneOracle) {\r\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning the price in of `underlying`.\r\n   * @dev will return a price denominated in the native token\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // special case for wrsETH\r\n    // if input is wrsETH, we need to get the price of rsETH\r\n    if (underlying == 0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A) {\r\n      underlying = 0x028227c4dd1e5419d11Bb6fa6e661920c519D4F5;\r\n    }\r\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\r\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\r\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in of `underlying` either in the\r\n   * native token (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\r\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/RedstoneAdapterPriceOracleWrsETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/redstone/IRedstoneOracle.sol\";\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title RedstoneAdapterPriceOracle\r\n * @notice Returns prices from Redstone.\r\n * @dev Implements `BasePriceOracle`.\r\n * @author Veliko Minkov <v.minkov@dcvx.io> (https://github.com/vminkov)\r\n */\r\ncontract RedstoneAdapterPriceOracleWrsETH is BasePriceOracle {\r\n  /**\r\n   * @notice The Redstone oracle contract\r\n   */\r\n  IRedstoneOracle public REDSTONE_ORACLE;\r\n\r\n  /**\r\n   * @dev Constructor to set admin, wtoken address and native token USD price feed address\r\n   * @param redstoneOracle The Redstone oracle contract address\r\n   */\r\n  constructor(address redstoneOracle) {\r\n    REDSTONE_ORACLE = IRedstoneOracle(redstoneOracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning the price in of `underlying`.\r\n   * @dev will return a price denominated in the native token\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // special case for wrsETH\r\n    // if input is wrsETH, we need to get the price of rsETH\r\n    if (underlying == 0xe7903B1F75C534Dd8159b313d92cDCfbC62cB3Cd) {\r\n      underlying = 0x4186BFC76E2E237523CBC30FD220FE055156b41F;\r\n    }\r\n    uint256 priceInUsd = REDSTONE_ORACLE.priceOf(underlying);\r\n    uint256 priceOfNativeInUsd = REDSTONE_ORACLE.priceOfETH();\r\n    return (priceInUsd * 1e18) / priceOfNativeInUsd;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in of `underlying` either in the\r\n   * native token (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in WNATIVE of the token underlying `cToken`.\r\n   * @dev Implements the `BasePriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in WNATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying token address\r\n    address underlying = cToken.underlying();\r\n\r\n    uint256 oraclePrice = _price(underlying);\r\n\r\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n    return\r\n      underlyingDecimals <= 18\r\n        ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n        : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"../../ionic/SafeOwnableUpgradeable.sol\";\r\n\r\ncontract SimplePriceOracle is BasePriceOracle, SafeOwnableUpgradeable {\r\n  mapping(address => uint256) prices;\r\n  event PricePosted(\r\n    address asset,\r\n    uint256 previousPriceMantissa,\r\n    uint256 requestedPriceMantissa,\r\n    uint256 newPriceMantissa\r\n  );\r\n\r\n  function initialize() public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n  }\r\n\r\n  function getUnderlyingPrice(ICErc20 cToken) public view override returns (uint256) {\r\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\r\n      return 1e18;\r\n    } else {\r\n      address underlying = ICErc20(address(cToken)).underlying();\r\n      uint256 oraclePrice = prices[underlying];\r\n\r\n      uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\r\n      return\r\n        underlyingDecimals <= 18\r\n          ? uint256(oraclePrice) * (10 ** (18 - underlyingDecimals))\r\n          : uint256(oraclePrice) / (10 ** (underlyingDecimals - 18));\r\n    }\r\n  }\r\n\r\n  function setUnderlyingPrice(ICErc20 cToken, uint256 underlyingPriceMantissa) public onlyOwner {\r\n    address asset = ICErc20(address(cToken)).underlying();\r\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\r\n    prices[asset] = underlyingPriceMantissa;\r\n  }\r\n\r\n  function setDirectPrice(address asset, uint256 _price) public onlyOwner {\r\n    emit PricePosted(asset, prices[asset], _price, _price);\r\n    prices[asset] = _price;\r\n  }\r\n\r\n  function price(address underlying) external view returns (uint256) {\r\n    return prices[address(underlying)];\r\n  }\r\n\r\n  // v1 price oracle interface for use as backing of proxy\r\n  function assetPrices(address asset) external view returns (uint256) {\r\n    return prices[asset];\r\n  }\r\n\r\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\r\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapLikeLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title UniswapLpTokenPriceOracle\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\r\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\r\n */\r\nabstract contract UniswapLikeLpTokenPriceOracle is BasePriceOracle {\r\n  /**\r\n   * @dev wtoken contract address.\r\n   */\r\n  address public immutable wtoken;\r\n\r\n  /**\r\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\r\n   */\r\n  constructor(address _wtoken) {\r\n    wtoken = _wtoken;\r\n  }\r\n\r\n  function _price(address token) internal view virtual returns (uint256);\r\n\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying) * 1e18) / (10 ** uint256(ERC20Upgradeable(underlying).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Fast square root function.\r\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\r\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n   */\r\n  function sqrt(uint256 x) internal pure returns (uint256) {\r\n    if (x == 0) return 0;\r\n    uint256 xx = x;\r\n    uint256 r = 1;\r\n\r\n    if (xx >= 0x100000000000000000000000000000000) {\r\n      xx >>= 128;\r\n      r <<= 64;\r\n    }\r\n    if (xx >= 0x10000000000000000) {\r\n      xx >>= 64;\r\n      r <<= 32;\r\n    }\r\n    if (xx >= 0x100000000) {\r\n      xx >>= 32;\r\n      r <<= 16;\r\n    }\r\n    if (xx >= 0x10000) {\r\n      xx >>= 16;\r\n      r <<= 8;\r\n    }\r\n    if (xx >= 0x100) {\r\n      xx >>= 8;\r\n      r <<= 4;\r\n    }\r\n    if (xx >= 0x10) {\r\n      xx >>= 4;\r\n      r <<= 2;\r\n    }\r\n    if (xx >= 0x8) {\r\n      r <<= 1;\r\n    }\r\n\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1;\r\n    r = (r + x / r) >> 1; // Seven iterations should be enough\r\n    uint256 r1 = x / r;\r\n    return (r < r1 ? r : r1);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport { UniswapLikeLpTokenPriceOracle } from \"./UniswapLikeLpTokenPriceOracle.sol\";\r\n\r\n/**\r\n * @title UniswapLpTokenPriceOracle\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\r\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\r\n */\r\ncontract UniswapLpTokenPriceOracle is UniswapLikeLpTokenPriceOracle {\r\n  /**\r\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\r\n   */\r\n  constructor(address _wtoken) UniswapLikeLpTokenPriceOracle(_wtoken) {}\r\n\r\n  function _price(address token) internal view virtual override returns (uint256) {\r\n    IUniswapV2Pair pair = IUniswapV2Pair(token);\r\n    uint256 totalSupply = pair.totalSupply();\r\n    if (totalSupply == 0) return 0;\r\n    (uint256 r0, uint256 r1, ) = pair.getReserves();\r\n\r\n    r0 = r0 * 10 ** (18 - uint256(ERC20Upgradeable(pair.token0()).decimals()));\r\n    r1 = r1 * 10 ** (18 - uint256(ERC20Upgradeable(pair.token1()).decimals()));\r\n\r\n    address token0 = pair.token0();\r\n    address token1 = pair.token1();\r\n\r\n    // Get fair price of non-WETH token (underlying the pair) in terms of ETH\r\n    uint256 token0FairPrice = token0 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token0);\r\n    uint256 token1FairPrice = token1 == wtoken ? 1e18 : BasePriceOracle(msg.sender).price(token1);\r\n\r\n    // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\r\n    uint256 sqrtK = (sqrt(r0 * r1) * (2 ** 112)) / totalSupply;\r\n    return (((sqrtK * 2 * sqrt(token0FairPrice)) / (2 ** 56)) * sqrt(token1FairPrice)) / (2 ** 56);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../BasePriceOracle.sol\";\r\nimport \"./UniswapTwapPriceOracleV2Root.sol\";\r\n\r\n/**\r\n * @title UniswapTwapPriceOracleV2\r\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\r\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract UniswapTwapPriceOracleV2 is Initializable, BasePriceOracle {\r\n  /**\r\n   * @dev wtoken token contract address.\r\n   */\r\n  address public wtoken;\r\n\r\n  /**\r\n   * @dev UniswapTwapPriceOracleV2Root contract address.\r\n   */\r\n  UniswapTwapPriceOracleV2Root public rootOracle;\r\n\r\n  /**\r\n   * @dev UniswapV2Factory contract address.\r\n   */\r\n  address public uniswapV2Factory;\r\n\r\n  /**\r\n   * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\r\n   */\r\n  address public baseToken;\r\n\r\n  /**\r\n   * @dev Initalize that sets the UniswapTwapPriceOracleV2Root, UniswapV2Factory, and base token.\r\n   * @param _rootOracle Sets `UniswapTwapPriceOracleV2Root`\r\n   * @param _uniswapV2Factory Sets `UniswapV2Factory`\r\n   * @param _baseToken The token on which to base TWAPs (its price must be available via `msg.sender`).\r\n   * @param _wtoken The Wrapped native asset address\r\n   */\r\n  function initialize(\r\n    address _rootOracle,\r\n    address _uniswapV2Factory,\r\n    address _baseToken,\r\n    address _wtoken\r\n  ) external initializer {\r\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\r\n    require(_uniswapV2Factory != address(0), \"UniswapV2Factory not defined.\");\r\n    rootOracle = UniswapTwapPriceOracleV2Root(_rootOracle);\r\n    uniswapV2Factory = _uniswapV2Factory;\r\n    wtoken = _wtoken;\r\n    baseToken = _baseToken == address(0) ? address(wtoken) : _baseToken;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying ERC20 token address\r\n    address underlying = cToken.underlying();\r\n\r\n    // Get price, format, and return\r\n    uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\r\n    return (_price(underlying) * 1e18) / baseUnit;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function returning the price in ETH of `underlying`.\r\n   */\r\n  function _price(address underlying) internal view returns (uint256) {\r\n    // Return 1e18 for wtoken\r\n    if (underlying == wtoken) return 1e18;\r\n\r\n    // Return root oracle ERC20/ETH TWAP\r\n    uint256 twap = rootOracle.price(underlying, baseToken, uniswapV2Factory);\r\n    return\r\n      baseToken == address(wtoken)\r\n        ? twap\r\n        : (twap * BasePriceOracle(msg.sender).price(baseToken)) /\r\n          (10 ** uint256(ERC20Upgradeable(baseToken).decimals()));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/ClonesUpgradeable.sol\";\r\n\r\nimport \"./UniswapTwapPriceOracleV2.sol\";\r\n\r\n/**\r\n * @title UniswapTwapPriceOracleV2Factory\r\n * @notice Deploys and catalogs UniswapTwapPriceOracleV2 contracts.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract UniswapTwapPriceOracleV2Factory {\r\n  /**\r\n   * @dev WETH token contract address.\r\n   */\r\n  address public immutable wtoken;\r\n\r\n  /**\r\n   * @dev `UniswapTwapPriceOracleV2Root` contract address.\r\n   */\r\n  address public immutable rootOracle;\r\n\r\n  /**\r\n   * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\r\n   */\r\n  address public immutable logic;\r\n\r\n  /**\r\n   * @notice Maps `UniswapV2Factory` contracts to base tokens to `UniswapTwapPriceOracleV2` contract addresses.\r\n   */\r\n  mapping(address => mapping(address => UniswapTwapPriceOracleV2)) public oracles;\r\n\r\n  /**\r\n   * @dev Constructor that sets the `UniswapTwapPriceOracleV2Root` and `UniswapTwapPriceOracleV2` implementation contract.\r\n   */\r\n  constructor(address _rootOracle, address _logic, address _wtoken) {\r\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\r\n    require(_logic != address(0), \"UniswapTwapPriceOracleV2 implementation/logic contract not defined.\");\r\n    rootOracle = _rootOracle;\r\n    logic = _logic;\r\n    wtoken = _wtoken;\r\n  }\r\n\r\n  /**\r\n   * @notice Deploys a `UniswapTwapPriceOracleV2`.\r\n   * @param uniswapV2Factory The `UniswapV2Factory` contract of the pairs for which this oracle will be used.\r\n   * @param baseToken The base token of the pairs for which this oracle will be used.\r\n   */\r\n  function deploy(address uniswapV2Factory, address baseToken) external returns (address) {\r\n    // Input validation\r\n    if (baseToken == address(0)) baseToken = address(wtoken);\r\n\r\n    // Return existing oracle if present\r\n    address currentOracle = address(oracles[uniswapV2Factory][baseToken]);\r\n    if (currentOracle != address(0)) return currentOracle;\r\n\r\n    // Deploy oracle\r\n    bytes32 salt = keccak256(abi.encodePacked(uniswapV2Factory, baseToken));\r\n    address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\r\n    UniswapTwapPriceOracleV2(oracle).initialize(rootOracle, uniswapV2Factory, baseToken, wtoken);\r\n\r\n    // Set oracle in state\r\n    oracles[uniswapV2Factory][baseToken] = UniswapTwapPriceOracleV2(oracle);\r\n\r\n    // Return oracle address\r\n    return oracle;\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Root.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\r\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\r\n\r\n/**\r\n * @title UniswapTwapPriceOracleV2Root\r\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract UniswapTwapPriceOracleV2Root {\r\n  /**\r\n   * @dev wtoken token contract address.\r\n   */\r\n  address public immutable wtoken;\r\n\r\n  /**\r\n   * @dev Minimum TWAP interval.\r\n   */\r\n  uint256 public constant MIN_TWAP_TIME = 15 minutes;\r\n\r\n  /**\r\n   * @dev Constructor to set wtoken address\r\n   */\r\n  constructor(address _wtoken) {\r\n    wtoken = _wtoken;\r\n  }\r\n\r\n  /**\r\n   * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\r\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\r\n   * @param pair The pair to query for price0.\r\n   */\r\n  function price0TWAP(address pair) internal view returns (uint256) {\r\n    uint256 length = observationCount[pair];\r\n    require(length > 0, \"No length-1 TWAP observation.\");\r\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\r\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\r\n      require(length > 1, \"No length-2 TWAP observation.\");\r\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\r\n    }\r\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\r\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\r\n    uint256 currPx0Cumu = currentPx0Cumu(pair);\r\n    unchecked {\r\n      return (currPx0Cumu - lastObservation.price0Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\r\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\r\n   * @param pair The pair to query for price1.\r\n   */\r\n  function price1TWAP(address pair) internal view returns (uint256) {\r\n    uint256 length = observationCount[pair];\r\n    require(length > 0, \"No length-1 TWAP observation.\");\r\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\r\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\r\n      require(length > 1, \"No length-2 TWAP observation.\");\r\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\r\n    }\r\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\r\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\r\n    uint256 currPx1Cumu = currentPx1Cumu(pair);\r\n    unchecked {\r\n      return (currPx1Cumu - lastObservation.price1Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Return the current price0 cumulative value on Uniswap.\r\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\r\n   * @param pair The uniswap pair to query for price0 cumulative value.\r\n   */\r\n  function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) {\r\n    uint32 currTime = uint32(block.timestamp);\r\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\r\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    if (lastTime != block.timestamp) {\r\n      unchecked {\r\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\r\n        px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Return the current price1 cumulative value on Uniswap.\r\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\r\n   * @param pair The uniswap pair to query for price1 cumulative value.\r\n   */\r\n  function currentPx1Cumu(address pair) internal view returns (uint256 px1Cumu) {\r\n    uint32 currTime = uint32(block.timestamp);\r\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\r\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    if (lastTime != currTime) {\r\n      unchecked {\r\n        uint32 timeElapsed = currTime - lastTime; // overflow is desired\r\n        px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\r\n   */\r\n  function price(address underlying, address baseToken, address factory) external view returns (uint256) {\r\n    // Return ERC20/ETH TWAP\r\n    address pair = IUniswapV2Factory(factory).getPair(underlying, baseToken);\r\n    uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\r\n    return (((underlying < baseToken ? price0TWAP(pair) : price1TWAP(pair)) / (2 ** 56)) * baseUnit) / (2 ** 56); // Scaled by 1e18, not 2 ** 112\r\n  }\r\n\r\n  /**\r\n   * @dev Struct for cumulative price observations.\r\n   */\r\n  struct Observation {\r\n    uint32 timestamp;\r\n    uint256 price0Cumulative;\r\n    uint256 price1Cumulative;\r\n  }\r\n\r\n  /**\r\n   * @dev Length after which observations roll over to index 0.\r\n   */\r\n  uint8 public constant OBSERVATION_BUFFER = 4;\r\n\r\n  /**\r\n   * @dev Total observation count for each pair.\r\n   */\r\n  mapping(address => uint256) public observationCount;\r\n\r\n  /**\r\n   * @dev Array of cumulative price observations for each pair.\r\n   */\r\n  mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\r\n\r\n  /// @notice Get pairs for token combinations.\r\n  function pairsFor(\r\n    address[] calldata tokenA,\r\n    address[] calldata tokenB,\r\n    address factory\r\n  ) external view returns (address[] memory) {\r\n    require(\r\n      tokenA.length > 0 && tokenA.length == tokenB.length,\r\n      \"Token array lengths must be equal and greater than 0.\"\r\n    );\r\n    address[] memory pairs = new address[](tokenA.length);\r\n    for (uint256 i = 0; i < tokenA.length; i++) pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\r\n    return pairs;\r\n  }\r\n\r\n  /// @notice Check which of multiple pairs are workable/updatable.\r\n  function workable(\r\n    address[] calldata pairs,\r\n    address[] calldata baseTokens,\r\n    uint256[] calldata minPeriods,\r\n    uint256[] calldata deviationThresholds\r\n  ) external view returns (bool[] memory) {\r\n    require(\r\n      pairs.length > 0 &&\r\n        pairs.length == baseTokens.length &&\r\n        pairs.length == minPeriods.length &&\r\n        pairs.length == deviationThresholds.length,\r\n      \"Array lengths must be equal and greater than 0.\"\r\n    );\r\n    bool[] memory answers = new bool[](pairs.length);\r\n    for (uint256 i = 0; i < pairs.length; i++)\r\n      answers[i] = _workable(pairs[i], baseTokens[i], minPeriods[i], deviationThresholds[i]);\r\n    return answers;\r\n  }\r\n\r\n  /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\r\n  function _workable(\r\n    address pair,\r\n    address baseToken,\r\n    uint256 minPeriod,\r\n    uint256 deviationThreshold\r\n  ) internal view returns (bool) {\r\n    // Workable if:\r\n    // 1) We have no observations\r\n    // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied\r\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\r\n    if (observationCount[pair] <= 0) return true;\r\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    return\r\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\r\n      (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\r\n      lastTime != observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp &&\r\n      _deviation(pair, baseToken) >= deviationThreshold;\r\n  }\r\n\r\n  /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\r\n  function _deviation(address pair, address baseToken) internal view returns (uint256) {\r\n    // Get token base unit\r\n    address token0 = IUniswapV2Pair(pair).token0();\r\n    bool useToken0Price = token0 != baseToken;\r\n    address underlying = useToken0Price ? token0 : IUniswapV2Pair(pair).token1();\r\n    uint256 baseUnit = 10 ** uint256(ERC20Upgradeable(underlying).decimals());\r\n\r\n    // Get TWAP price\r\n    uint256 twapPrice = (((useToken0Price ? price0TWAP(pair) : price1TWAP(pair)) / (2 ** 56)) * baseUnit) / (2 ** 56); // Scaled by 1e18, not 2 ** 112\r\n\r\n    // Get spot price\r\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\r\n    uint256 spotPrice = useToken0Price ? (reserve1 * baseUnit) / reserve0 : (reserve0 * baseUnit) / reserve1;\r\n\r\n    // Get ratio and return deviation\r\n    uint256 ratio = (spotPrice * 1e18) / twapPrice;\r\n    return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\r\n  }\r\n\r\n  /// @dev Internal function to check if a pair is updatable at all.\r\n  function _updateable(address pair) internal view returns (bool) {\r\n    // Updateable if:\r\n    // 1) We have no observations\r\n    // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\r\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\r\n    return\r\n      observationCount[pair] <= 0 ||\r\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\r\n      MIN_TWAP_TIME;\r\n  }\r\n\r\n  /// @notice Update one pair.\r\n  function update(address pair) external {\r\n    require(_update(pair), \"Failed to update pair.\");\r\n  }\r\n\r\n  /// @notice Update multiple pairs at once.\r\n  function update(address[] calldata pairs) external {\r\n    bool worked = false;\r\n    for (uint256 i = 0; i < pairs.length; i++) if (_update(pairs[i])) worked = true;\r\n    require(worked, \"No pairs can be updated (yet).\");\r\n  }\r\n\r\n  /// @dev Internal function to update a single pair.\r\n  function _update(address pair) internal returns (bool) {\r\n    // Check if workable\r\n    if (!_updateable(pair)) return false;\r\n\r\n    // Get cumulative price(s)\r\n    uint256 price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n    uint256 price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n    // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\r\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\r\n    observations[pair][observationCount[pair] % OBSERVATION_BUFFER] = Observation(\r\n      lastTime,\r\n      price0Cumulative,\r\n      price1Cumulative\r\n    );\r\n    observationCount[pair]++;\r\n    return true;\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/UniswapV3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport { BasePriceOracle } from \"../BasePriceOracle.sol\";\r\nimport { ERC20Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\nimport { ConcentratedLiquidityBasePriceOracle } from \"./ConcentratedLiquidityBasePriceOracle.sol\";\r\n\r\nimport \"../../external/uniswap/TickMath.sol\";\r\nimport \"../../external/uniswap/FullMath.sol\";\r\nimport \"../../external/uniswap/IUniswapV3Pool.sol\";\r\n\r\n/**\r\n * @title UniswapV3PriceOracle\r\n * @author Carlo Mazzaferro <carlo@midascapital.xyz> (https://github.com/carlomazzaferro)\r\n * @notice UniswapV3PriceOracle is a price oracle for Uniswap V3 pairs.\r\n * @dev Implements the `PriceOracle` interface used by Ionic pools (and Compound v2).\r\n */\r\ncontract UniswapV3PriceOracle is ConcentratedLiquidityBasePriceOracle {\r\n  /**\r\n   * @dev Fetches the price for a token from Algebra pools.\r\n   */\r\n\r\n  function _price(address token) internal view override returns (uint256) {\r\n    uint32[] memory secondsAgos = new uint32[](2);\r\n    uint256 twapWindow = poolFeeds[token].twapWindow;\r\n    address baseToken = poolFeeds[token].baseToken;\r\n\r\n    secondsAgos[0] = uint32(twapWindow);\r\n    secondsAgos[1] = 0;\r\n\r\n    IUniswapV3Pool pool = IUniswapV3Pool(poolFeeds[token].poolAddress);\r\n    (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);\r\n\r\n    int24 tick = int24((tickCumulatives[1] - tickCumulatives[0]) / int56(int256(twapWindow)));\r\n    uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\r\n\r\n    uint256 tokenPrice = getPriceX96FromSqrtPriceX96(pool.token0(), token, sqrtPriceX96);\r\n    return scalePrices(baseToken, token, tokenPrice);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/VelodromePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ninterface Prices {\r\n  function getRateToEth(address srcToken, bool useSrcWrappers) external view returns (uint256 weightedRate);\r\n}\r\n\r\ncontract VelodromePriceOracle is BasePriceOracle {\r\n  Prices immutable prices;\r\n\r\n  constructor(address _prices) {\r\n    prices = Prices(_prices);\r\n  }\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   * @param underlying The underlying token address for which to get the price.\r\n   * @return Price denominated in ETH (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying));\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   */\r\n  function _price(address token) internal view returns (uint256) {\r\n    return prices.getRateToEth(token, false);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/default/VelodromePriceOracleFraxtal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../BasePriceOracle.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ninterface Prices_Fraxtal {\r\n  function getRate(address srcToken, address dstToken, bool useSrcWrappers) external view returns (uint256 weightedRate);\r\n}\r\n\r\ncontract VelodromePriceOracleFraxtal is BasePriceOracle {\r\n  Prices_Fraxtal immutable prices;\r\n\r\n  constructor(address _prices) {\r\n    prices = Prices_Fraxtal(_prices);\r\n  }\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   * @param underlying The underlying token address for which to get the price.\r\n   * @return Price denominated in ETH (scaled by 1e18)\r\n   */\r\n  function price(address underlying) external view override returns (uint256) {\r\n    return _price(underlying);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    address underlying = cToken.underlying();\r\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\r\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\r\n    return (_price(underlying));\r\n  }\r\n\r\n  /**\r\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\r\n   */\r\n  function _price(address token) internal view returns (uint256) {\r\n    return prices.getRate(token, 0xFC00000000000000000000000000000000000006, false);\r\n  }\r\n}\r\n"
    },
    "contracts/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\n\r\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\r\n\r\nimport { BasePriceOracle } from \"./BasePriceOracle.sol\";\r\n\r\n/**\r\n * @title MasterPriceOracle\r\n * @notice Use a combination of price oracles.\r\n * @dev Implements `PriceOracle`.\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n */\r\ncontract MasterPriceOracle is Initializable, BasePriceOracle {\r\n  /**\r\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\r\n   */\r\n  mapping(address => BasePriceOracle) public oracles;\r\n\r\n  /**\r\n   * @dev Default/fallback `PriceOracle`.\r\n   */\r\n  BasePriceOracle public defaultOracle;\r\n\r\n  /**\r\n   * @dev The administrator of this `MasterPriceOracle`.\r\n   */\r\n  address public admin;\r\n\r\n  /**\r\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\r\n   */\r\n  bool internal noAdminOverwrite;\r\n\r\n  /**\r\n   * @dev The Wrapped native asset address.\r\n   */\r\n  address public wtoken;\r\n\r\n  /**\r\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\r\n   */\r\n  mapping(address => BasePriceOracle) public fallbackOracles;\r\n\r\n  /**\r\n   * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\r\n   */\r\n  function canAdminOverwrite() external view returns (bool) {\r\n    return !noAdminOverwrite;\r\n  }\r\n\r\n  /**\r\n   * @dev Event emitted when `admin` is changed.\r\n   */\r\n  event NewAdmin(address oldAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Event emitted when the default oracle is changed.\r\n   */\r\n  event NewDefaultOracle(address oldOracle, address newOracle);\r\n\r\n  /**\r\n   * @dev Event emitted when an underlying token's oracle is changed.\r\n   */\r\n  event NewOracle(address underlying, address oldOracle, address newOracle);\r\n\r\n  /**\r\n   * @dev  Initialize state variables.\r\n   * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\r\n   * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\r\n   * @param _defaultOracle The default `PriceOracle` contract to use.\r\n   * @param _admin The admin who can assign oracles to underlying tokens.\r\n   * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\r\n   * @param _wtoken The Wrapped native asset address\r\n   */\r\n  function initialize(\r\n    address[] memory underlyings,\r\n    BasePriceOracle[] memory _oracles,\r\n    BasePriceOracle _defaultOracle,\r\n    address _admin,\r\n    bool _canAdminOverwrite,\r\n    address _wtoken\r\n  ) external initializer {\r\n    // Input validation\r\n    require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\r\n\r\n    // Initialize state variables\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      BasePriceOracle newOracle = _oracles[i];\r\n      oracles[underlying] = newOracle;\r\n      emit NewOracle(underlying, address(0), address(newOracle));\r\n    }\r\n\r\n    defaultOracle = _defaultOracle;\r\n    admin = _admin;\r\n    noAdminOverwrite = !_canAdminOverwrite;\r\n    wtoken = _wtoken;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `_oracles` for `underlyings`.\r\n   */\r\n  function add(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == _oracles.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // Assign oracles to underlying tokens\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      address oldOracle = address(oracles[underlying]);\r\n      if (noAdminOverwrite)\r\n        require(\r\n          oldOracle == address(0),\r\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\r\n        );\r\n      BasePriceOracle newOracle = _oracles[i];\r\n      oracles[underlying] = newOracle;\r\n      emit NewOracle(underlying, oldOracle, address(newOracle));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `_oracles` for `underlyings`.\r\n   */\r\n  function addFallbacks(address[] calldata underlyings, BasePriceOracle[] calldata _oracles) external onlyAdmin {\r\n    // Input validation\r\n    require(\r\n      underlyings.length > 0 && underlyings.length == _oracles.length,\r\n      \"Lengths of both arrays must be equal and greater than 0.\"\r\n    );\r\n\r\n    // Assign oracles to underlying tokens\r\n    for (uint256 i = 0; i < underlyings.length; i++) {\r\n      address underlying = underlyings[i];\r\n      address oldOracle = address(fallbackOracles[underlying]);\r\n      if (noAdminOverwrite)\r\n        require(\r\n          oldOracle == address(0),\r\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\r\n        );\r\n      BasePriceOracle newOracle = _oracles[i];\r\n      fallbackOracles[underlying] = newOracle;\r\n      emit NewOracle(underlying, oldOracle, address(newOracle));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the default price oracle\r\n   */\r\n  function setDefaultOracle(BasePriceOracle newOracle) external onlyAdmin {\r\n    BasePriceOracle oldOracle = defaultOracle;\r\n    defaultOracle = newOracle;\r\n    emit NewDefaultOracle(address(oldOracle), address(newOracle));\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin and emits an event.\r\n   */\r\n  function changeAdmin(address newAdmin) external onlyAdmin {\r\n    address oldAdmin = admin;\r\n    admin = newAdmin;\r\n    emit NewAdmin(oldAdmin, newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier that checks if `msg.sender == admin`.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin, \"Sender is not the admin.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the price in ETH of the token underlying `cToken`.\r\n   * @dev Implements the `PriceOracle` interface for Ionic pools (and Compound v2).\r\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\r\n   */\r\n  function getUnderlyingPrice(ICErc20 cToken) external view override returns (uint256) {\r\n    // Get underlying ERC20 token address\r\n    address underlying = address(ICErc20(address(cToken)).underlying());\r\n\r\n    if (underlying == wtoken) return 1e18;\r\n\r\n    BasePriceOracle oracle = oracles[underlying];\r\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\r\n\r\n    if (address(oracle) != address(0)) {\r\n      try oracle.getUnderlyingPrice(cToken) returns (uint256 underlyingPrice) {\r\n        if (underlyingPrice == 0) {\r\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\r\n        } else {\r\n          return underlyingPrice;\r\n        }\r\n      } catch {\r\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\r\n      }\r\n    } else {\r\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.getUnderlyingPrice(cToken);\r\n    }\r\n    revert(\"Price oracle not found for this underlying token address.\");\r\n  }\r\n\r\n  /**\r\n   * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\r\n   */\r\n  function price(address underlying) public view override returns (uint256) {\r\n    // Return 1e18 for WETH\r\n    if (underlying == wtoken) return 1e18;\r\n\r\n    // Get underlying price from assigned oracle\r\n    BasePriceOracle oracle = oracles[underlying];\r\n    BasePriceOracle fallbackOracle = fallbackOracles[underlying];\r\n\r\n    if (address(oracle) != address(0)) {\r\n      try oracle.price(underlying) returns (uint256 underlyingPrice) {\r\n        if (underlyingPrice == 0) {\r\n          if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\r\n        } else {\r\n          return underlyingPrice;\r\n        }\r\n      } catch {\r\n        if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\r\n      }\r\n    } else {\r\n      if (address(fallbackOracle) != address(0)) return fallbackOracle.price(underlying);\r\n    }\r\n    revert(\"Price oracle not found for this underlying token address.\");\r\n  }\r\n}\r\n"
    },
    "contracts/PoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/utils/Create2Upgradeable.sol\";\r\n\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\r\nimport { Unitroller } from \"./compound/Unitroller.sol\";\r\nimport \"./ionic/SafeOwnableUpgradeable.sol\";\r\nimport \"./ionic/DiamondExtension.sol\";\r\n\r\n/**\r\n * @title PoolDirectory\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice PoolDirectory is a directory for Ionic interest rate pools.\r\n */\r\ncontract PoolDirectory is SafeOwnableUpgradeable {\r\n  /**\r\n   * @dev Initializes a deployer whitelist if desired.\r\n   * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\r\n   * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\r\n   */\r\n  function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\r\n    __SafeOwnable_init(msg.sender);\r\n    enforceDeployerWhitelist = _enforceDeployerWhitelist;\r\n    for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Struct for a Ionic interest rate pool.\r\n   */\r\n  struct Pool {\r\n    string name;\r\n    address creator;\r\n    address comptroller;\r\n    uint256 blockPosted;\r\n    uint256 timestampPosted;\r\n  }\r\n\r\n  /**\r\n   * @dev Array of Ionic interest rate pools.\r\n   */\r\n  Pool[] public pools;\r\n\r\n  /**\r\n   * @dev Maps Ethereum accounts to arrays of Ionic pool indexes.\r\n   */\r\n  mapping(address => uint256[]) private _poolsByAccount;\r\n\r\n  /**\r\n   * @dev Maps Ionic pool Comptroller addresses to bools indicating if they have been registered via the directory.\r\n   */\r\n  mapping(address => bool) public poolExists;\r\n\r\n  /**\r\n   * @dev Emitted when a new Ionic pool is added to the directory.\r\n   */\r\n  event PoolRegistered(uint256 index, Pool pool);\r\n\r\n  /**\r\n   * @dev Booleans indicating if the deployer whitelist is enforced.\r\n   */\r\n  bool public enforceDeployerWhitelist;\r\n\r\n  /**\r\n   * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\r\n   */\r\n  mapping(address => bool) public deployerWhitelist;\r\n\r\n  /**\r\n   * @dev Controls if the deployer whitelist is to be enforced.\r\n   * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\r\n   */\r\n  function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\r\n    enforceDeployerWhitelist = enforce;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds/removes Ethereum accounts to the deployer whitelist.\r\n   * @param deployers Array of Ethereum accounts to be whitelisted.\r\n   * @param status Whether to add or remove the accounts.\r\n   */\r\n  function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\r\n    require(deployers.length > 0, \"No deployers supplied.\");\r\n    for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new Ionic pool to the directory (without checking msg.sender).\r\n   * @param name The name of the pool.\r\n   * @param comptroller The pool's Comptroller proxy contract address.\r\n   * @return The index of the registered Ionic pool.\r\n   */\r\n  function _registerPool(string memory name, address comptroller) internal returns (uint256) {\r\n    require(!poolExists[comptroller], \"Pool already exists in the directory.\");\r\n    require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \"Sender is not on deployer whitelist.\");\r\n    require(bytes(name).length <= 100, \"No pool name supplied.\");\r\n    Pool memory pool = Pool(name, msg.sender, comptroller, block.number, block.timestamp);\r\n    pools.push(pool);\r\n    _poolsByAccount[msg.sender].push(pools.length - 1);\r\n    poolExists[comptroller] = true;\r\n    emit PoolRegistered(pools.length - 1, pool);\r\n    return pools.length - 1;\r\n  }\r\n\r\n  function _deprecatePool(address comptroller) external onlyOwner {\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      if (pools[i].comptroller == comptroller) {\r\n        _deprecatePool(i);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _deprecatePool(uint256 index) public onlyOwner {\r\n    Pool storage ionicPool = pools[index];\r\n\r\n    require(ionicPool.comptroller != address(0), \"pool already deprecated\");\r\n\r\n    // swap with the last pool of the creator and delete\r\n    uint256[] storage creatorPools = _poolsByAccount[ionicPool.creator];\r\n    for (uint256 i = 0; i < creatorPools.length; i++) {\r\n      if (creatorPools[i] == index) {\r\n        creatorPools[i] = creatorPools[creatorPools.length - 1];\r\n        creatorPools.pop();\r\n        break;\r\n      }\r\n    }\r\n\r\n    // leave it to true to deny the re-registering of the same pool\r\n    poolExists[ionicPool.comptroller] = true;\r\n\r\n    // nullify the storage\r\n    ionicPool.comptroller = address(0);\r\n    ionicPool.creator = address(0);\r\n    ionicPool.name = \"\";\r\n    ionicPool.blockPosted = 0;\r\n    ionicPool.timestampPosted = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Deploys a new Ionic pool and adds to the directory.\r\n   * @param name The name of the pool.\r\n   * @param implementation The Comptroller implementation contract address.\r\n   * @param constructorData Encoded construction data for `Unitroller constructor()`\r\n   * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\r\n   * @param closeFactor The pool's close factor (scaled by 1e18).\r\n   * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\r\n   * @param priceOracle The pool's PriceOracle contract address.\r\n   * @return Index of the registered Ionic pool and the Unitroller proxy address.\r\n   */\r\n  function deployPool(\r\n    string memory name,\r\n    address implementation,\r\n    bytes calldata constructorData,\r\n    bool enforceWhitelist,\r\n    uint256 closeFactor,\r\n    uint256 liquidationIncentive,\r\n    address priceOracle\r\n  ) external returns (uint256, address) {\r\n    // Input validation\r\n    require(implementation != address(0), \"No Comptroller implementation contract address specified.\");\r\n    require(priceOracle != address(0), \"No PriceOracle contract address specified.\");\r\n\r\n    // Deploy Unitroller using msg.sender, name, and block.number as a salt\r\n    bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode, constructorData);\r\n    address proxy = Create2Upgradeable.deploy(\r\n      0,\r\n      keccak256(abi.encodePacked(msg.sender, name, ++poolsCounter)),\r\n      unitrollerCreationCode\r\n    );\r\n\r\n    // Setup the pool\r\n    IonicComptroller comptrollerProxy = IonicComptroller(proxy);\r\n    // Set up the extensions\r\n    comptrollerProxy._upgrade();\r\n\r\n    // Set pool parameters\r\n    require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \"Failed to set pool close factor.\");\r\n    require(\r\n      comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0,\r\n      \"Failed to set pool liquidation incentive.\"\r\n    );\r\n    require(comptrollerProxy._setPriceOracle(BasePriceOracle(priceOracle)) == 0, \"Failed to set pool price oracle.\");\r\n\r\n    // Whitelist\r\n    if (enforceWhitelist)\r\n      require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \"Failed to enforce supplier/borrower whitelist.\");\r\n\r\n    // Make msg.sender the admin\r\n    require(comptrollerProxy._setPendingAdmin(msg.sender) == 0, \"Failed to set pending admin on Unitroller.\");\r\n\r\n    // Register the pool with this PoolDirectory\r\n    return (_registerPool(name, proxy), proxy);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns `ids` and directory information of all non-deprecated Ionic pools.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getActivePools() public view returns (uint256[] memory, Pool[] memory) {\r\n    uint256 count = 0;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      if (pools[i].comptroller != address(0)) count++;\r\n    }\r\n\r\n    Pool[] memory activePools = new Pool[](count);\r\n    uint256[] memory poolIds = new uint256[](count);\r\n\r\n    uint256 index = 0;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      if (pools[i].comptroller != address(0)) {\r\n        poolIds[index] = i;\r\n        activePools[index] = pools[i];\r\n        index++;\r\n      }\r\n    }\r\n\r\n    return (poolIds, activePools);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all Ionic pools' data.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getAllPools() public view returns (Pool[] memory) {\r\n    uint256 count = 0;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      if (pools[i].comptroller != address(0)) count++;\r\n    }\r\n\r\n    Pool[] memory result = new Pool[](count);\r\n\r\n    uint256 index = 0;\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      if (pools[i].comptroller != address(0)) {\r\n        result[index++] = pools[i];\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all public Ionic pool indexes and data.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getPublicPools() external view returns (uint256[] memory, Pool[] memory) {\r\n    uint256 arrayLength = 0;\r\n\r\n    (, Pool[] memory activePools) = getActivePools();\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\r\n        if (enforceWhitelist) continue;\r\n      } catch {}\r\n\r\n      arrayLength++;\r\n    }\r\n\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    Pool[] memory publicPools = new Pool[](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      try IonicComptroller(activePools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\r\n        if (enforceWhitelist) continue;\r\n      } catch {}\r\n\r\n      indexes[index] = i;\r\n      publicPools[index] = activePools[i];\r\n      index++;\r\n    }\r\n\r\n    return (indexes, publicPools);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all public Ionic pool indexes and data.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getPoolsOfUser(address user) external view returns (uint256[] memory, Pool[] memory) {\r\n    uint256 arrayLength = 0;\r\n\r\n    (, Pool[] memory activePools) = getActivePools();\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\r\n        if (!isUsing) continue;\r\n      } catch {}\r\n\r\n      arrayLength++;\r\n    }\r\n\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    Pool[] memory poolsOfUser = new Pool[](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      try IonicComptroller(activePools[i].comptroller).isUserOfPool(user) returns (bool isUsing) {\r\n        if (!isUsing) continue;\r\n      } catch {}\r\n\r\n      indexes[index] = i;\r\n      poolsOfUser[index] = activePools[i];\r\n      index++;\r\n    }\r\n\r\n    return (indexes, poolsOfUser);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of Ionic pool indexes and data created by `account`.\r\n   */\r\n  function getPoolsByAccount(address account) external view returns (uint256[] memory, Pool[] memory) {\r\n    uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\r\n    Pool[] memory accountPools = new Pool[](_poolsByAccount[account].length);\r\n    (, Pool[] memory activePools) = getActivePools();\r\n\r\n    for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\r\n      indexes[i] = _poolsByAccount[account][i];\r\n      accountPools[i] = activePools[_poolsByAccount[account][i]];\r\n    }\r\n\r\n    return (indexes, accountPools);\r\n  }\r\n\r\n  /**\r\n   * @notice Modify existing Ionic pool name.\r\n   */\r\n  function setPoolName(uint256 index, string calldata name) external {\r\n    IonicComptroller _comptroller = IonicComptroller(pools[index].comptroller);\r\n    require(\r\n      (msg.sender == _comptroller.admin() && _comptroller.adminHasRights()) || msg.sender == owner(),\r\n      \"!permission\"\r\n    );\r\n    pools[index].name = name;\r\n  }\r\n\r\n  /**\r\n   * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\r\n   */\r\n  mapping(address => bool) public adminWhitelist;\r\n\r\n  /**\r\n   * @dev used as salt for the creation of new pools\r\n   */\r\n  uint256 public poolsCounter;\r\n\r\n  /**\r\n   * @dev Event emitted when the admin whitelist is updated.\r\n   */\r\n  event AdminWhitelistUpdated(address[] admins, bool status);\r\n\r\n  /**\r\n   * @dev Adds/removes Ethereum accounts to the admin whitelist.\r\n   * @param admins Array of Ethereum accounts to be whitelisted.\r\n   * @param status Whether to add or remove the accounts.\r\n   */\r\n  function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\r\n    require(admins.length > 0, \"No admins supplied.\");\r\n    for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\r\n    emit AdminWhitelistUpdated(admins, status);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all Ionic pool indexes and data with whitelisted admins.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getPublicPoolsByVerification(bool whitelistedAdmin) external view returns (uint256[] memory, Pool[] memory) {\r\n    uint256 arrayLength = 0;\r\n\r\n    (, Pool[] memory activePools) = getActivePools();\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\r\n\r\n      try comptroller.admin() returns (address admin) {\r\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\r\n      } catch {}\r\n\r\n      arrayLength++;\r\n    }\r\n\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    Pool[] memory publicPools = new Pool[](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\r\n\r\n      try comptroller.admin() returns (address admin) {\r\n        if (whitelistedAdmin != adminWhitelist[admin]) continue;\r\n      } catch {}\r\n\r\n      indexes[index] = i;\r\n      publicPools[index] = activePools[i];\r\n      index++;\r\n    }\r\n\r\n    return (indexes, publicPools);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all verified Ionic pool indexes and data for which the account is whitelisted\r\n   * @param account who is whitelisted in the returned verified whitelist-enabled pools.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getVerifiedPoolsOfWhitelistedAccount(\r\n    address account\r\n  ) external view returns (uint256[] memory, Pool[] memory) {\r\n    uint256 arrayLength = 0;\r\n    (, Pool[] memory activePools) = getActivePools();\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\r\n\r\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\r\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\r\n      } catch {}\r\n\r\n      arrayLength++;\r\n    }\r\n\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    Pool[] memory accountWhitelistedPools = new Pool[](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(activePools[i].comptroller);\r\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\r\n        if (!enforceWhitelist || !comptroller.whitelist(account)) continue;\r\n      } catch {}\r\n\r\n      indexes[index] = i;\r\n      accountWhitelistedPools[index] = activePools[i];\r\n      index++;\r\n    }\r\n\r\n    return (indexes, accountWhitelistedPools);\r\n  }\r\n}\r\n"
    },
    "contracts/PoolLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { BasePriceOracle } from \"./oracles/BasePriceOracle.sol\";\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\n\r\nimport { PoolDirectory } from \"./PoolDirectory.sol\";\r\nimport { MasterPriceOracle } from \"./oracles/MasterPriceOracle.sol\";\r\n\r\n/**\r\n * @title PoolLens\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice PoolLens returns data on Ionic interest rate pools in mass for viewing by dApps, bots, etc.\r\n */\r\ncontract PoolLens is Initializable {\r\n  error ComptrollerError(uint256 errCode);\r\n\r\n  /**\r\n   * @notice Initialize the `PoolDirectory` contract object.\r\n   * @param _directory The PoolDirectory\r\n   * @param _name Name for the nativeToken\r\n   * @param _symbol Symbol for the nativeToken\r\n   * @param _hardcodedAddresses Underlying token addresses for a token like maker which are DSToken and/or use bytes32 for `symbol`\r\n   * @param _hardcodedNames Harcoded name for these tokens\r\n   * @param _hardcodedSymbols Harcoded symbol for these tokens\r\n   * @param _uniswapLPTokenNames Harcoded names for underlying uniswap LpToken\r\n   * @param _uniswapLPTokenSymbols Harcoded symbols for underlying uniswap LpToken\r\n   * @param _uniswapLPTokenDisplayNames Harcoded display names for underlying uniswap LpToken\r\n   */\r\n  function initialize(\r\n    PoolDirectory _directory,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    address[] memory _hardcodedAddresses,\r\n    string[] memory _hardcodedNames,\r\n    string[] memory _hardcodedSymbols,\r\n    string[] memory _uniswapLPTokenNames,\r\n    string[] memory _uniswapLPTokenSymbols,\r\n    string[] memory _uniswapLPTokenDisplayNames\r\n  ) public initializer {\r\n    require(address(_directory) != address(0), \"PoolDirectory instance cannot be the zero address.\");\r\n    require(\r\n      _hardcodedAddresses.length == _hardcodedNames.length && _hardcodedAddresses.length == _hardcodedSymbols.length,\r\n      \"Hardcoded addresses lengths not equal.\"\r\n    );\r\n    require(\r\n      _uniswapLPTokenNames.length == _uniswapLPTokenSymbols.length &&\r\n        _uniswapLPTokenNames.length == _uniswapLPTokenDisplayNames.length,\r\n      \"Uniswap LP token names lengths not equal.\"\r\n    );\r\n\r\n    directory = _directory;\r\n    name = _name;\r\n    symbol = _symbol;\r\n    for (uint256 i = 0; i < _hardcodedAddresses.length; i++) {\r\n      hardcoded[_hardcodedAddresses[i]] = TokenData({ name: _hardcodedNames[i], symbol: _hardcodedSymbols[i] });\r\n    }\r\n\r\n    for (uint256 i = 0; i < _uniswapLPTokenNames.length; i++) {\r\n      uniswapData.push(\r\n        UniswapData({\r\n          name: _uniswapLPTokenNames[i],\r\n          symbol: _uniswapLPTokenSymbols[i],\r\n          displayName: _uniswapLPTokenDisplayNames[i]\r\n        })\r\n      );\r\n    }\r\n  }\r\n\r\n  string public name;\r\n  string public symbol;\r\n\r\n  struct TokenData {\r\n    string name;\r\n    string symbol;\r\n  }\r\n  mapping(address => TokenData) hardcoded;\r\n\r\n  struct UniswapData {\r\n    string name; // ie \"Uniswap V2\" or \"SushiSwap LP Token\"\r\n    string symbol; // ie \"UNI-V2\" or \"SLP\"\r\n    string displayName; // ie \"SushiSwap\" or \"Uniswap\"\r\n  }\r\n  UniswapData[] uniswapData;\r\n\r\n  /**\r\n   * @notice `PoolDirectory` contract object.\r\n   */\r\n  PoolDirectory public directory;\r\n\r\n  /**\r\n   * @dev Struct for Ionic pool summary data.\r\n   */\r\n  struct IonicPoolData {\r\n    uint256 totalSupply;\r\n    uint256 totalBorrow;\r\n    address[] underlyingTokens;\r\n    string[] underlyingSymbols;\r\n    bool whitelistedAdmin;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all public Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPublicPoolsWithData()\r\n    external\r\n    returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory)\r\n  {\r\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory publicPools) = directory.getPublicPools();\r\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\r\n    return (indexes, publicPools, data, errored);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of all whitelisted public Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPublicPoolsByVerificationWithData(\r\n    bool whitelistedAdmin\r\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\r\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory publicPools) = directory.getPublicPoolsByVerification(\r\n      whitelistedAdmin\r\n    );\r\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\r\n    return (indexes, publicPools, data, errored);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of the indexes of Ionic pools created by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPoolsByAccountWithData(\r\n    address account\r\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\r\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory accountPools) = directory.getPoolsByAccount(account);\r\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\r\n    return (indexes, accountPools, data, errored);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of the indexes of Ionic pools used by `user`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPoolsOIonicrWithData(\r\n    address user\r\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\r\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory userPools) = directory.getPoolsOfUser(user);\r\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(userPools);\r\n    return (indexes, userPools, data, errored);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function returning arrays of requested Ionic pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPoolsData(PoolDirectory.Pool[] memory pools) internal returns (IonicPoolData[] memory, bool[] memory) {\r\n    IonicPoolData[] memory data = new IonicPoolData[](pools.length);\r\n    bool[] memory errored = new bool[](pools.length);\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      try this.getPoolSummary(IonicComptroller(pools[i].comptroller)) returns (\r\n        uint256 _totalSupply,\r\n        uint256 _totalBorrow,\r\n        address[] memory _underlyingTokens,\r\n        string[] memory _underlyingSymbols,\r\n        bool _whitelistedAdmin\r\n      ) {\r\n        data[i] = IonicPoolData(_totalSupply, _totalBorrow, _underlyingTokens, _underlyingSymbols, _whitelistedAdmin);\r\n      } catch {\r\n        errored[i] = true;\r\n      }\r\n    }\r\n\r\n    return (data, errored);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns total supply balance (in ETH), total borrow balance (in ETH), underlying token addresses, and underlying token symbols of a Ionic pool.\r\n   */\r\n  function getPoolSummary(\r\n    IonicComptroller comptroller\r\n  ) external returns (uint256, uint256, address[] memory, string[] memory, bool) {\r\n    uint256 totalBorrow = 0;\r\n    uint256 totalSupply = 0;\r\n    ICErc20[] memory cTokens = comptroller.getAllMarkets();\r\n    address[] memory underlyingTokens = new address[](cTokens.length);\r\n    string[] memory underlyingSymbols = new string[](cTokens.length);\r\n    BasePriceOracle oracle = comptroller.oracle();\r\n\r\n    for (uint256 i = 0; i < cTokens.length; i++) {\r\n      ICErc20 cToken = cTokens[i];\r\n      (bool isListed, ) = comptroller.markets(address(cToken));\r\n      if (!isListed) continue;\r\n      cToken.accrueInterest();\r\n      uint256 assetTotalBorrow = cToken.totalBorrowsCurrent();\r\n      uint256 assetTotalSupply = cToken.getCash() +\r\n        assetTotalBorrow -\r\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalIonicFees());\r\n      uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\r\n      totalBorrow = totalBorrow + (assetTotalBorrow * underlyingPrice) / 1e18;\r\n      totalSupply = totalSupply + (assetTotalSupply * underlyingPrice) / 1e18;\r\n\r\n      underlyingTokens[i] = ICErc20(address(cToken)).underlying();\r\n      (, underlyingSymbols[i]) = getTokenNameAndSymbol(underlyingTokens[i]);\r\n    }\r\n\r\n    bool whitelistedAdmin = directory.adminWhitelist(comptroller.admin());\r\n    return (totalSupply, totalBorrow, underlyingTokens, underlyingSymbols, whitelistedAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Struct for a Ionic pool asset.\r\n   */\r\n  struct PoolAsset {\r\n    address cToken;\r\n    address underlyingToken;\r\n    string underlyingName;\r\n    string underlyingSymbol;\r\n    uint256 underlyingDecimals;\r\n    uint256 underlyingBalance;\r\n    uint256 supplyRatePerBlock;\r\n    uint256 borrowRatePerBlock;\r\n    uint256 totalSupply;\r\n    uint256 totalBorrow;\r\n    uint256 supplyBalance;\r\n    uint256 borrowBalance;\r\n    uint256 liquidity;\r\n    bool membership;\r\n    uint256 exchangeRate; // Price of cTokens in terms of underlying tokens\r\n    uint256 underlyingPrice; // Price of underlying tokens in ETH (scaled by 1e18)\r\n    address oracle;\r\n    uint256 collateralFactor;\r\n    uint256 reserveFactor;\r\n    uint256 adminFee;\r\n    uint256 ionicFee;\r\n    bool borrowGuardianPaused;\r\n    bool mintGuardianPaused;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns data on the specified assets of the specified Ionic pool.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   * @param comptroller The Comptroller proxy contract address of the Ionic pool.\r\n   * @param cTokens The cToken contract addresses of the assets to query.\r\n   * @param user The user for which to get account data.\r\n   * @return An array of Ionic pool assets.\r\n   */\r\n  function getPoolAssetsWithData(\r\n    IonicComptroller comptroller,\r\n    ICErc20[] memory cTokens,\r\n    address user\r\n  ) internal returns (PoolAsset[] memory) {\r\n    uint256 arrayLength = 0;\r\n\r\n    for (uint256 i = 0; i < cTokens.length; i++) {\r\n      (bool isListed, ) = comptroller.markets(address(cTokens[i]));\r\n      if (isListed) arrayLength++;\r\n    }\r\n\r\n    PoolAsset[] memory detailedAssets = new PoolAsset[](arrayLength);\r\n    uint256 index = 0;\r\n    BasePriceOracle oracle = BasePriceOracle(address(comptroller.oracle()));\r\n\r\n    for (uint256 i = 0; i < cTokens.length; i++) {\r\n      // Check if market is listed and get collateral factor\r\n      (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokens[i]));\r\n      if (!isListed) continue;\r\n\r\n      // Start adding data to PoolAsset\r\n      PoolAsset memory asset;\r\n      ICErc20 cToken = cTokens[i];\r\n      asset.cToken = address(cToken);\r\n\r\n      cToken.accrueInterest();\r\n\r\n      // Get underlying asset data\r\n      asset.underlyingToken = ICErc20(address(cToken)).underlying();\r\n      ERC20Upgradeable underlying = ERC20Upgradeable(asset.underlyingToken);\r\n      (asset.underlyingName, asset.underlyingSymbol) = getTokenNameAndSymbol(asset.underlyingToken);\r\n      asset.underlyingDecimals = underlying.decimals();\r\n      asset.underlyingBalance = underlying.balanceOf(user);\r\n\r\n      // Get cToken data\r\n      asset.supplyRatePerBlock = cToken.supplyRatePerBlock();\r\n      asset.borrowRatePerBlock = cToken.borrowRatePerBlock();\r\n      asset.liquidity = cToken.getCash();\r\n      asset.totalBorrow = cToken.totalBorrowsCurrent();\r\n      asset.totalSupply =\r\n        asset.liquidity +\r\n        asset.totalBorrow -\r\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalIonicFees());\r\n      asset.supplyBalance = cToken.balanceOfUnderlying(user);\r\n      asset.borrowBalance = cToken.borrowBalanceCurrent(user);\r\n      asset.membership = comptroller.checkMembership(user, cToken);\r\n      asset.exchangeRate = cToken.exchangeRateCurrent(); // We would use exchangeRateCurrent but we already accrue interest above\r\n      asset.underlyingPrice = oracle.price(asset.underlyingToken);\r\n\r\n      // Get oracle for this cToken\r\n      asset.oracle = address(oracle);\r\n\r\n      try MasterPriceOracle(asset.oracle).oracles(asset.underlyingToken) returns (BasePriceOracle _oracle) {\r\n        asset.oracle = address(_oracle);\r\n      } catch {}\r\n\r\n      // More cToken data\r\n      asset.collateralFactor = collateralFactorMantissa;\r\n      asset.reserveFactor = cToken.reserveFactorMantissa();\r\n      asset.adminFee = cToken.adminFeeMantissa();\r\n      asset.ionicFee = cToken.ionicFeeMantissa();\r\n      asset.borrowGuardianPaused = comptroller.borrowGuardianPaused(address(cToken));\r\n      asset.mintGuardianPaused = comptroller.mintGuardianPaused(address(cToken));\r\n\r\n      // Add to assets array and increment index\r\n      detailedAssets[index] = asset;\r\n      index++;\r\n    }\r\n\r\n    return (detailedAssets);\r\n  }\r\n\r\n  function getBorrowCapsPerCollateral(\r\n    ICErc20 borrowedAsset,\r\n    IonicComptroller comptroller\r\n  )\r\n    internal\r\n    view\r\n    returns (\r\n      address[] memory collateral,\r\n      uint256[] memory borrowCapsAgainstCollateral,\r\n      bool[] memory borrowingBlacklistedAgainstCollateral\r\n    )\r\n  {\r\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\r\n\r\n    collateral = new address[](poolMarkets.length);\r\n    borrowCapsAgainstCollateral = new uint256[](poolMarkets.length);\r\n    borrowingBlacklistedAgainstCollateral = new bool[](poolMarkets.length);\r\n\r\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\r\n      address collateralAddress = address(poolMarkets[i]);\r\n      if (collateralAddress != address(borrowedAsset)) {\r\n        collateral[i] = collateralAddress;\r\n        borrowCapsAgainstCollateral[i] = comptroller.borrowCapForCollateral(address(borrowedAsset), collateralAddress);\r\n        borrowingBlacklistedAgainstCollateral[i] = comptroller.borrowingAgainstCollateralBlacklist(\r\n          address(borrowedAsset),\r\n          collateralAddress\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the `name` and `symbol` of `token`.\r\n   * Supports Uniswap V2 and SushiSwap LP tokens as well as MKR.\r\n   * @param token An ERC20 token contract object.\r\n   * @return The `name` and `symbol`.\r\n   */\r\n  function getTokenNameAndSymbol(address token) internal view returns (string memory, string memory) {\r\n    // i.e. MKR is a DSToken and uses bytes32\r\n    if (bytes(hardcoded[token].symbol).length != 0) {\r\n      return (hardcoded[token].name, hardcoded[token].symbol);\r\n    }\r\n\r\n    // Get name and symbol from token contract\r\n    ERC20Upgradeable tokenContract = ERC20Upgradeable(token);\r\n    string memory _name = tokenContract.name();\r\n    string memory _symbol = tokenContract.symbol();\r\n\r\n    return (_name, _symbol);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the assets of the specified Ionic pool.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   * @param comptroller The Comptroller proxy contract of the Ionic pool.\r\n   * @return An array of Ionic pool assets.\r\n   */\r\n  function getPoolAssetsWithData(IonicComptroller comptroller) external returns (PoolAsset[] memory) {\r\n    return getPoolAssetsWithData(comptroller, comptroller.getAllMarkets(), msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Struct for a Ionic pool user.\r\n   */\r\n  struct IonicPoolUser {\r\n    address account;\r\n    uint256 totalBorrow;\r\n    uint256 totalCollateral;\r\n    uint256 health;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of PoolAsset for a specific user\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getPoolAssetsByUser(IonicComptroller comptroller, address user) public returns (PoolAsset[] memory) {\r\n    PoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(user), user);\r\n    return assets;\r\n  }\r\n\r\n  /**\r\n   * @notice returns the total supply cap for each asset in the pool\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getSupplyCapsForPool(IonicComptroller comptroller) public view returns (address[] memory, uint256[] memory) {\r\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\r\n\r\n    address[] memory assets = new address[](poolMarkets.length);\r\n    uint256[] memory supplyCapsPerAsset = new uint256[](poolMarkets.length);\r\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\r\n      assets[i] = address(poolMarkets[i]);\r\n      supplyCapsPerAsset[i] = comptroller.effectiveSupplyCaps(assets[i]);\r\n    }\r\n\r\n    return (assets, supplyCapsPerAsset);\r\n  }\r\n\r\n  /**\r\n   * @notice returns the total supply cap for each asset in the pool and the total non-whitelist supplied assets\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getSupplyCapsDataForPool(\r\n    IonicComptroller comptroller\r\n  ) public view returns (address[] memory, uint256[] memory, uint256[] memory) {\r\n    ICErc20[] memory poolMarkets = comptroller.getAllMarkets();\r\n\r\n    address[] memory assets = new address[](poolMarkets.length);\r\n    uint256[] memory supplyCapsPerAsset = new uint256[](poolMarkets.length);\r\n    uint256[] memory nonWhitelistedTotalSupply = new uint256[](poolMarkets.length);\r\n    for (uint256 i = 0; i < poolMarkets.length; i++) {\r\n      assets[i] = address(poolMarkets[i]);\r\n      supplyCapsPerAsset[i] = comptroller.effectiveSupplyCaps(assets[i]);\r\n      uint256 assetTotalSupplied = poolMarkets[i].getTotalUnderlyingSupplied();\r\n      uint256 whitelistedSuppliersSupply = comptroller.getWhitelistedSuppliersSupply(assets[i]);\r\n      if (whitelistedSuppliersSupply >= assetTotalSupplied) nonWhitelistedTotalSupply[i] = 0;\r\n      else nonWhitelistedTotalSupply[i] = assetTotalSupplied - whitelistedSuppliersSupply;\r\n    }\r\n\r\n    return (assets, supplyCapsPerAsset, nonWhitelistedTotalSupply);\r\n  }\r\n\r\n  /**\r\n   * @notice returns the total borrow cap and the per collateral borrowing cap/blacklist for the asset\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getBorrowCapsForAsset(\r\n    ICErc20 asset\r\n  )\r\n    public\r\n    view\r\n    returns (\r\n      address[] memory collateral,\r\n      uint256[] memory borrowCapsPerCollateral,\r\n      bool[] memory collateralBlacklisted,\r\n      uint256 totalBorrowCap\r\n    )\r\n  {\r\n    IonicComptroller comptroller = IonicComptroller(asset.comptroller());\r\n    (collateral, borrowCapsPerCollateral, collateralBlacklisted) = getBorrowCapsPerCollateral(asset, comptroller);\r\n    totalBorrowCap = comptroller.effectiveBorrowCaps(address(asset));\r\n  }\r\n\r\n  /**\r\n   * @notice returns the total borrow cap, the per collateral borrowing cap/blacklist for the asset and the total non-whitelist borrows\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getBorrowCapsDataForAsset(\r\n    ICErc20 asset\r\n  )\r\n    public\r\n    view\r\n    returns (\r\n      address[] memory collateral,\r\n      uint256[] memory borrowCapsPerCollateral,\r\n      bool[] memory collateralBlacklisted,\r\n      uint256 totalBorrowCap,\r\n      uint256 nonWhitelistedTotalBorrows\r\n    )\r\n  {\r\n    IonicComptroller comptroller = IonicComptroller(asset.comptroller());\r\n    (collateral, borrowCapsPerCollateral, collateralBlacklisted) = getBorrowCapsPerCollateral(asset, comptroller);\r\n    totalBorrowCap = comptroller.effectiveBorrowCaps(address(asset));\r\n    uint256 totalBorrows = asset.totalBorrowsCurrent();\r\n    uint256 whitelistedBorrowersBorrows = comptroller.getWhitelistedBorrowersBorrows(address(asset));\r\n    if (whitelistedBorrowersBorrows >= totalBorrows) nonWhitelistedTotalBorrows = 0;\r\n    else nonWhitelistedTotalBorrows = totalBorrows - whitelistedBorrowersBorrows;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of Ionic pool indexes and data with a whitelist containing `account`.\r\n   * Note that the whitelist does not have to be enforced.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getWhitelistedPoolsByAccount(\r\n    address account\r\n  ) public view returns (uint256[] memory, PoolDirectory.Pool[] memory) {\r\n    (, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\r\n    uint256 arrayLength = 0;\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n\r\n      if (comptroller.whitelist(account)) arrayLength++;\r\n    }\r\n\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    PoolDirectory.Pool[] memory accountPools = new PoolDirectory.Pool[](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n\r\n      if (comptroller.whitelist(account)) {\r\n        indexes[index] = i;\r\n        accountPools[index] = pools[i];\r\n        index++;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return (indexes, accountPools);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of the indexes of Ionic pools with a whitelist containing `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getWhitelistedPoolsByAccountWithData(\r\n    address account\r\n  ) external returns (uint256[] memory, PoolDirectory.Pool[] memory, IonicPoolData[] memory, bool[] memory) {\r\n    (uint256[] memory indexes, PoolDirectory.Pool[] memory accountPools) = getWhitelistedPoolsByAccount(account);\r\n    (IonicPoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\r\n    return (indexes, accountPools, data, errored);\r\n  }\r\n\r\n  function getHealthFactor(address user, IonicComptroller pool) external view returns (uint256) {\r\n    return getHealthFactorHypothetical(pool, user, address(0), 0, 0, 0);\r\n  }\r\n\r\n  function getHealthFactorHypothetical(\r\n    IonicComptroller pool,\r\n    address account,\r\n    address cTokenModify,\r\n    uint256 redeemTokens,\r\n    uint256 borrowAmount,\r\n    uint256 repayAmount\r\n  ) public view returns (uint256) {\r\n    (uint256 err, uint256 collateralValue, uint256 liquidity, uint256 shortfall) = pool.getHypotheticalAccountLiquidity(\r\n      account,\r\n      cTokenModify,\r\n      redeemTokens,\r\n      borrowAmount,\r\n      repayAmount\r\n    );\r\n\r\n    if (err != 0) revert ComptrollerError(err);\r\n\r\n    if (shortfall > 0) {\r\n      // HF < 1.0\r\n      return (collateralValue * 1e18) / (collateralValue + shortfall);\r\n    } else {\r\n      // HF >= 1.0\r\n      if (collateralValue <= liquidity) return type(uint256).max;\r\n      else return (collateralValue * 1e18) / (collateralValue - liquidity);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/PoolLensSecondary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\r\n\r\nimport { IonicComptroller } from \"./compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"./compound/CTokenInterfaces.sol\";\r\nimport { IUniswapV2Pair } from \"./external/uniswap/IUniswapV2Pair.sol\";\r\n\r\nimport { PoolDirectory } from \"./PoolDirectory.sol\";\r\n\r\ninterface IRewardsDistributor_PLS {\r\n  function rewardToken() external view returns (address);\r\n\r\n  function compSupplySpeeds(address) external view returns (uint256);\r\n\r\n  function compBorrowSpeeds(address) external view returns (uint256);\r\n\r\n  function compAccrued(address) external view returns (uint256);\r\n\r\n  function flywheelPreSupplierAction(address cToken, address supplier) external;\r\n\r\n  function flywheelPreBorrowerAction(address cToken, address borrower) external;\r\n\r\n  function getAllMarkets() external view returns (ICErc20[] memory);\r\n}\r\n\r\n/**\r\n * @title PoolLensSecondary\r\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\r\n * @notice PoolLensSecondary returns data on Ionic interest rate pools in mass for viewing by dApps, bots, etc.\r\n */\r\ncontract PoolLensSecondary is Initializable {\r\n  /**\r\n   * @notice Constructor to set the `PoolDirectory` contract object.\r\n   */\r\n  function initialize(PoolDirectory _directory) public initializer {\r\n    require(address(_directory) != address(0), \"PoolDirectory instance cannot be the zero address.\");\r\n    directory = _directory;\r\n  }\r\n\r\n  /**\r\n   * @notice `PoolDirectory` contract object.\r\n   */\r\n  PoolDirectory public directory;\r\n\r\n  /**\r\n   * @notice Struct for ownership over a CToken.\r\n   */\r\n  struct CTokenOwnership {\r\n    address cToken;\r\n    address admin;\r\n    bool adminHasRights;\r\n    bool ionicAdminHasRights;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the admin, admin rights, Ionic admin (constant), Ionic admin rights, and an array of cTokens with differing properties.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\r\n   */\r\n  function getPoolOwnership(\r\n    IonicComptroller comptroller\r\n  ) external view returns (address, bool, bool, CTokenOwnership[] memory) {\r\n    // Get pool ownership\r\n    address comptrollerAdmin = comptroller.admin();\r\n    bool comptrollerAdminHasRights = comptroller.adminHasRights();\r\n    bool comptrollerIonicAdminHasRights = comptroller.ionicAdminHasRights();\r\n\r\n    // Get cToken ownership\r\n    ICErc20[] memory cTokens = comptroller.getAllMarkets();\r\n    uint256 arrayLength = 0;\r\n\r\n    for (uint256 i = 0; i < cTokens.length; i++) {\r\n      ICErc20 cToken = cTokens[i];\r\n      (bool isListed, ) = comptroller.markets(address(cToken));\r\n      if (!isListed) continue;\r\n\r\n      address cTokenAdmin;\r\n      try cToken.admin() returns (address _cTokenAdmin) {\r\n        cTokenAdmin = _cTokenAdmin;\r\n      } catch {\r\n        continue;\r\n      }\r\n      bool cTokenAdminHasRights = cToken.adminHasRights();\r\n      bool cTokenIonicAdminHasRights = cToken.ionicAdminHasRights();\r\n\r\n      // If outlier, push to array\r\n      if (\r\n        cTokenAdmin != comptrollerAdmin ||\r\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\r\n        cTokenIonicAdminHasRights != comptrollerIonicAdminHasRights\r\n      ) arrayLength++;\r\n    }\r\n\r\n    CTokenOwnership[] memory outliers = new CTokenOwnership[](arrayLength);\r\n    uint256 arrayIndex = 0;\r\n\r\n    for (uint256 i = 0; i < cTokens.length; i++) {\r\n      ICErc20 cToken = cTokens[i];\r\n      (bool isListed, ) = comptroller.markets(address(cToken));\r\n      if (!isListed) continue;\r\n\r\n      address cTokenAdmin;\r\n      try cToken.admin() returns (address _cTokenAdmin) {\r\n        cTokenAdmin = _cTokenAdmin;\r\n      } catch {\r\n        continue;\r\n      }\r\n      bool cTokenAdminHasRights = cToken.adminHasRights();\r\n      bool cTokenIonicAdminHasRights = cToken.ionicAdminHasRights();\r\n\r\n      // If outlier, push to array and increment array index\r\n      if (\r\n        cTokenAdmin != comptrollerAdmin ||\r\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\r\n        cTokenIonicAdminHasRights != comptrollerIonicAdminHasRights\r\n      ) {\r\n        outliers[arrayIndex] = CTokenOwnership(\r\n          address(cToken),\r\n          cTokenAdmin,\r\n          cTokenAdminHasRights,\r\n          cTokenIonicAdminHasRights\r\n        );\r\n        arrayIndex++;\r\n      }\r\n    }\r\n\r\n    return (comptrollerAdmin, comptrollerAdminHasRights, comptrollerIonicAdminHasRights, outliers);\r\n  }\r\n\r\n  /**\r\n   * @notice Determine the maximum redeem amount of a cToken.\r\n   * @param cTokenModify The market to hypothetically redeem in.\r\n   * @param account The account to determine liquidity for.\r\n   * @return Maximum redeem amount.\r\n   */\r\n  function getMaxRedeem(address account, ICErc20 cTokenModify) external returns (uint256) {\r\n    return getMaxRedeemOrBorrow(account, cTokenModify, false);\r\n  }\r\n\r\n  /**\r\n   * @notice Determine the maximum borrow amount of a cToken.\r\n   * @param cTokenModify The market to hypothetically borrow in.\r\n   * @param account The account to determine liquidity for.\r\n   * @return Maximum borrow amount.\r\n   */\r\n  function getMaxBorrow(address account, ICErc20 cTokenModify) external returns (uint256) {\r\n    return getMaxRedeemOrBorrow(account, cTokenModify, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to determine the maximum borrow/redeem amount of a cToken.\r\n   * @param cTokenModify The market to hypothetically borrow/redeem in.\r\n   * @param account The account to determine liquidity for.\r\n   * @return Maximum borrow/redeem amount.\r\n   */\r\n  function getMaxRedeemOrBorrow(address account, ICErc20 cTokenModify, bool isBorrow) internal returns (uint256) {\r\n    IonicComptroller comptroller = IonicComptroller(cTokenModify.comptroller());\r\n    return comptroller.getMaxRedeemOrBorrow(account, cTokenModify, isBorrow);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\r\n   * @param comptroller The Ionic pool Comptroller to check.\r\n   */\r\n  function getRewardSpeedsByPool(\r\n    IonicComptroller comptroller\r\n  ) public view returns (ICErc20[] memory, address[] memory, address[] memory, uint256[][] memory, uint256[][] memory) {\r\n    ICErc20[] memory allMarkets = comptroller.getAllMarkets();\r\n    address[] memory distributors;\r\n\r\n    try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\r\n      distributors = _distributors;\r\n    } catch {\r\n      distributors = new address[](0);\r\n    }\r\n\r\n    address[] memory rewardTokens = new address[](distributors.length);\r\n    uint256[][] memory supplySpeeds = new uint256[][](allMarkets.length);\r\n    uint256[][] memory borrowSpeeds = new uint256[][](allMarkets.length);\r\n\r\n    // Get reward tokens for each distributor\r\n    for (uint256 i = 0; i < distributors.length; i++) {\r\n      rewardTokens[i] = IRewardsDistributor_PLS(distributors[i]).rewardToken();\r\n    }\r\n\r\n    // Get reward speeds for each market for each distributor\r\n    for (uint256 i = 0; i < allMarkets.length; i++) {\r\n      address cToken = address(allMarkets[i]);\r\n      supplySpeeds[i] = new uint256[](distributors.length);\r\n      borrowSpeeds[i] = new uint256[](distributors.length);\r\n\r\n      for (uint256 j = 0; j < distributors.length; j++) {\r\n        IRewardsDistributor_PLS distributor = IRewardsDistributor_PLS(distributors[j]);\r\n        supplySpeeds[i][j] = distributor.compSupplySpeeds(cToken);\r\n        borrowSpeeds[i][j] = distributor.compBorrowSpeeds(cToken);\r\n      }\r\n    }\r\n\r\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\r\n  }\r\n\r\n  /**\r\n   * @notice For each `Comptroller`, returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\r\n   * @param comptrollers The Ionic pool Comptrollers to check.\r\n   */\r\n  function getRewardSpeedsByPools(\r\n    IonicComptroller[] memory comptrollers\r\n  )\r\n    external\r\n    view\r\n    returns (ICErc20[][] memory, address[][] memory, address[][] memory, uint256[][][] memory, uint256[][][] memory)\r\n  {\r\n    ICErc20[][] memory allMarkets = new ICErc20[][](comptrollers.length);\r\n    address[][] memory distributors = new address[][](comptrollers.length);\r\n    address[][] memory rewardTokens = new address[][](comptrollers.length);\r\n    uint256[][][] memory supplySpeeds = new uint256[][][](comptrollers.length);\r\n    uint256[][][] memory borrowSpeeds = new uint256[][][](comptrollers.length);\r\n    for (uint256 i = 0; i < comptrollers.length; i++)\r\n      (allMarkets[i], distributors[i], rewardTokens[i], supplySpeeds[i], borrowSpeeds[i]) = getRewardSpeedsByPool(\r\n        comptrollers[i]\r\n      );\r\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns unaccrued rewards by `holder` from `cToken` on `distributor`.\r\n   * @param holder The address to check.\r\n   * @param distributor The RewardsDistributor to check.\r\n   * @param cToken The CToken to check.\r\n   * @return Unaccrued (unclaimed) supply-side rewards and unaccrued (unclaimed) borrow-side rewards.\r\n   */\r\n  function getUnaccruedRewards(\r\n    address holder,\r\n    IRewardsDistributor_PLS distributor,\r\n    ICErc20 cToken\r\n  ) internal returns (uint256, uint256) {\r\n    // Get unaccrued supply rewards\r\n    uint256 compAccruedPrior = distributor.compAccrued(holder);\r\n    distributor.flywheelPreSupplierAction(address(cToken), holder);\r\n    uint256 supplyRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\r\n\r\n    // Get unaccrued borrow rewards\r\n    compAccruedPrior = distributor.compAccrued(holder);\r\n    distributor.flywheelPreBorrowerAction(address(cToken), holder);\r\n    uint256 borrowRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\r\n\r\n    // Return both\r\n    return (supplyRewardsUnaccrued, borrowRewardsUnaccrued);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns all unclaimed rewards accrued by the `holder` on `distributors`.\r\n   * @param holder The address to check.\r\n   * @param distributors The `RewardsDistributor` contracts to check.\r\n   * @return For each of `distributors`: total quantity of unclaimed rewards, array of cTokens, array of unaccrued (unclaimed) supply-side and borrow-side rewards per cToken, and quantity of funds available in the distributor.\r\n   */\r\n  function getUnclaimedRewardsByDistributors(\r\n    address holder,\r\n    IRewardsDistributor_PLS[] memory distributors\r\n  ) external returns (address[] memory, uint256[] memory, ICErc20[][] memory, uint256[2][][] memory, uint256[] memory) {\r\n    address[] memory rewardTokens = new address[](distributors.length);\r\n    uint256[] memory compUnclaimedTotal = new uint256[](distributors.length);\r\n    ICErc20[][] memory allMarkets = new ICErc20[][](distributors.length);\r\n    uint256[2][][] memory rewardsUnaccrued = new uint256[2][][](distributors.length);\r\n    uint256[] memory distributorFunds = new uint256[](distributors.length);\r\n\r\n    for (uint256 i = 0; i < distributors.length; i++) {\r\n      IRewardsDistributor_PLS distributor = distributors[i];\r\n      rewardTokens[i] = distributor.rewardToken();\r\n      allMarkets[i] = distributor.getAllMarkets();\r\n      rewardsUnaccrued[i] = new uint256[2][](allMarkets[i].length);\r\n      for (uint256 j = 0; j < allMarkets[i].length; j++)\r\n        (rewardsUnaccrued[i][j][0], rewardsUnaccrued[i][j][1]) = getUnaccruedRewards(\r\n          holder,\r\n          distributor,\r\n          allMarkets[i][j]\r\n        );\r\n      compUnclaimedTotal[i] = distributor.compAccrued(holder);\r\n      distributorFunds[i] = IERC20Upgradeable(rewardTokens[i]).balanceOf(address(distributor));\r\n    }\r\n\r\n    return (rewardTokens, compUnclaimedTotal, allMarkets, rewardsUnaccrued, distributorFunds);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns arrays of indexes, `Comptroller` proxy contracts, and `RewardsDistributor` contracts for Ionic pools supplied to by `account`.\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getRewardsDistributorsBySupplier(\r\n    address supplier\r\n  ) external view returns (uint256[] memory, IonicComptroller[] memory, address[][] memory) {\r\n    // Get array length\r\n    (, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\r\n    uint256 arrayLength = 0;\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      try IonicComptroller(pools[i].comptroller).suppliers(supplier) returns (bool isSupplier) {\r\n        if (isSupplier) arrayLength++;\r\n      } catch {}\r\n    }\r\n\r\n    // Build array\r\n    uint256[] memory indexes = new uint256[](arrayLength);\r\n    IonicComptroller[] memory comptrollers = new IonicComptroller[](arrayLength);\r\n    address[][] memory distributors = new address[][](arrayLength);\r\n    uint256 index = 0;\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n\r\n      try comptroller.suppliers(supplier) returns (bool isSupplier) {\r\n        if (isSupplier) {\r\n          indexes[index] = i;\r\n          comptrollers[index] = comptroller;\r\n\r\n          try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\r\n            distributors[index] = _distributors;\r\n          } catch {}\r\n\r\n          index++;\r\n        }\r\n      } catch {}\r\n    }\r\n\r\n    // Return distributors\r\n    return (indexes, comptrollers, distributors);\r\n  }\r\n\r\n  /**\r\n   * @notice The returned list of flywheels contains address(0) for flywheels for which the user has no rewards to claim\r\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\r\n   */\r\n  function getFlywheelsToClaim(\r\n    address user\r\n  ) external view returns (uint256[] memory, IonicComptroller[] memory, address[][] memory) {\r\n    (uint256[] memory poolIds, PoolDirectory.Pool[] memory pools) = directory.getActivePools();\r\n\r\n    IonicComptroller[] memory comptrollers = new IonicComptroller[](pools.length);\r\n    address[][] memory distributors = new address[][](pools.length);\r\n\r\n    for (uint256 i = 0; i < pools.length; i++) {\r\n      IonicComptroller comptroller = IonicComptroller(pools[i].comptroller);\r\n      try comptroller.getRewardsDistributors() returns (address[] memory _distributors) {\r\n        comptrollers[i] = comptroller;\r\n        distributors[i] = flywheelsWithRewardsForPoolUser(user, _distributors);\r\n      } catch {}\r\n    }\r\n\r\n    return (poolIds, comptrollers, distributors);\r\n  }\r\n\r\n  function flywheelsWithRewardsForPoolUser(\r\n    address user,\r\n    address[] memory _distributors\r\n  ) internal view returns (address[] memory) {\r\n    address[] memory distributors = new address[](_distributors.length);\r\n    for (uint256 j = 0; j < _distributors.length; j++) {\r\n      if (IRewardsDistributor_PLS(_distributors[j]).compAccrued(user) > 0) {\r\n        distributors[j] = _distributors[j];\r\n      }\r\n    }\r\n\r\n    return distributors;\r\n  }\r\n}\r\n"
    },
    "contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n/// @title Multicall interface\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\ninterface IMulticall {\r\n  /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\r\n  /// @dev The `msg.value` should not be trusted for any method callable from multicall.\r\n  /// @param data The encoded function data for each of the calls to make to this contract\r\n  /// @return results The results from each of the calls passed in via data\r\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n}\r\n"
    },
    "contracts/utils/IW_NATIVE.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.8.0;\r\n\r\ninterface IW_NATIVE {\r\n  function deposit() external payable;\r\n\r\n  function withdraw(uint256 amount) external;\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  function balanceOf(address) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\nimport \"./IMulticall.sol\";\r\n\r\n/// @title Multicall\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall is IMulticall {\r\n  /// @inheritdoc IMulticall\r\n  function multicall(bytes[] calldata data) public payable virtual override returns (bytes[] memory results) {\r\n    results = new bytes[](data.length);\r\n    for (uint256 i = 0; i < data.length; i++) {\r\n      (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n      if (!success) {\r\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n        if (result.length < 68) revert();\r\n        assembly {\r\n          result := add(result, 0x04)\r\n        }\r\n        revert(abi.decode(result, (string)));\r\n      }\r\n\r\n      results[i] = result;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/veION/BribeRewards.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport { IBribeRewards } from \"./interfaces/IBribeRewards.sol\";\r\nimport { IVoter } from \"./interfaces/IVoter.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { IonicTimeLibrary } from \"./libraries/IonicTimeLibrary.sol\";\r\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\r\n\r\n/**\r\n * @title BribeRewards Contract\r\n * @notice This contract allows veION to benefit from bribes when voting for various markets\r\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n */\r\ncontract BribeRewards is IBribeRewards, ReentrancyGuardUpgradeable, Ownable2StepUpgradeable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           State Variables                                 ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /// @notice Duration of the reward period in seconds\r\n  uint256 public constant DURATION = 7 days;\r\n  /// @notice Address of the voter contract\r\n  address public voter;\r\n  /// @notice Address of the veION contract\r\n  address public ve;\r\n  /// @notice List of reward tokens\r\n  address[] public rewards;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                                Mappings                                   ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /// @notice Mapping to check if an address is a reward token\r\n  mapping(address => bool) public isReward;\r\n  /// @notice Total supply of LP tokens for each reward token\r\n  mapping(address => uint256) public totalSupply;\r\n  /// @notice Balance of LP tokens for each tokenId and reward token\r\n  mapping(uint256 => mapping(address => uint256)) public balanceOf;\r\n  /// @notice Rewards per epoch for each reward token\r\n  mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\r\n  /// @notice Last earned timestamp for each reward token and tokenId\r\n  mapping(address => mapping(uint256 => uint256)) public lastEarn;\r\n  /// @notice A record of balance checkpoints for each account, by index\r\n  mapping(uint256 => mapping(address => mapping(uint256 => Checkpoint))) public checkpoints;\r\n  /// @notice The number of checkpoints for each account\r\n  mapping(uint256 => mapping(address => uint256)) public numCheckpoints;\r\n  /// @notice A record of balance checkpoints for each token, by index\r\n  mapping(uint256 => mapping(address => SupplyCheckpoint)) public supplyCheckpoints;\r\n  /// @notice The number of supply checkpoints for each token\r\n  mapping(address => uint256) public supplyNumCheckpoints;\r\n  /// @notice Historical prices for each reward token and epoch\r\n  mapping(address => mapping(uint256 => uint256)) public historicalPrices;\r\n\r\n  /**\r\n   * @notice Modifier to restrict access to only the voter contract\r\n   * @dev Ensures that the caller is the voter contract\r\n   */\r\n  modifier onlyVoter() {\r\n    require(msg.sender == voter, \"Caller is not the voter\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes the BribeRewards contract with the voter and veION addresses\r\n   * @dev This function is called only once during contract deployment\r\n   * @param _voter The address of the voter contract\r\n   * @param _ve The address of the veION contract\r\n   */\r\n  function initialize(address _voter, address _ve) public initializer {\r\n    __ReentrancyGuard_init();\r\n    __Ownable2Step_init();\r\n    voter = _voter;\r\n    ve = _ve;\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           External Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function deposit(address lpToken, uint256 amount, uint256 tokenId) external onlyVoter {\r\n    address sender = msg.sender;\r\n\r\n    totalSupply[lpToken] += amount;\r\n    balanceOf[tokenId][lpToken] += amount;\r\n\r\n    _writeCheckpoint(tokenId, lpToken, balanceOf[tokenId][lpToken]);\r\n    _writeSupplyCheckpoint(lpToken);\r\n\r\n    emit Deposit(sender, tokenId, amount);\r\n  }\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function withdraw(address lpToken, uint256 amount, uint256 tokenId) external onlyVoter {\r\n    address sender = msg.sender;\r\n\r\n    totalSupply[lpToken] -= amount;\r\n    balanceOf[tokenId][lpToken] -= amount;\r\n\r\n    _writeCheckpoint(tokenId, lpToken, balanceOf[tokenId][lpToken]);\r\n    _writeSupplyCheckpoint(lpToken);\r\n\r\n    emit Withdraw(sender, tokenId, amount);\r\n  }\r\n\r\n  /**\r\n   * @inheritdoc IBribeRewards\r\n   * @notice This function can accept any token, regardless of its whitelisting status.\r\n   * @dev If we were to check the whitelisting status, it could prevent tokens that were initially whitelisted and later de-whitelisted from having their rewards claimed, leading to unclaimable rewards.\r\n   */\r\n  function getReward(uint256 tokenId, address[] memory tokens) external nonReentrant onlyVoter {\r\n    address sender = msg.sender;\r\n    if (ERC721Upgradeable(ve).ownerOf(tokenId) != sender && sender != voter) revert Unauthorized();\r\n\r\n    address _owner = ERC721Upgradeable(ve).ownerOf(tokenId);\r\n    _getReward(_owner, tokenId, tokens);\r\n  }\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function notifyRewardAmount(address token, uint256 amount) external override nonReentrant {\r\n    address sender = msg.sender;\r\n\r\n    if (!isReward[token]) {\r\n      if (!IVoter(voter).isWhitelistedToken(token)) revert TokenNotWhitelisted();\r\n      isReward[token] = true;\r\n      rewards.push(token);\r\n    }\r\n\r\n    _notifyRewardAmount(sender, token, amount);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Internal Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @dev used with all getReward implementations\r\n  function _getReward(address recipient, uint256 tokenId, address[] memory tokens) internal {\r\n    // check if token whitelisted\r\n    uint256 _length = tokens.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      uint256 _reward = earned(tokens[i], tokenId);\r\n      lastEarn[tokens[i]][tokenId] = block.timestamp;\r\n      if (_reward > 0) IERC20(tokens[i]).safeTransfer(recipient, _reward);\r\n\r\n      emit RewardsClaimed(recipient, tokens[i], _reward);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Writes a new checkpoint for a token's balance\r\n   * @param tokenId The ID of the veION token\r\n   * @param lpToken The LP token address\r\n   * @param balance The balance to record\r\n   */\r\n  function _writeCheckpoint(uint256 tokenId, address lpToken, uint256 balance) internal {\r\n    uint256 _nCheckPoints = numCheckpoints[tokenId][lpToken];\r\n    uint256 _timestamp = block.timestamp;\r\n\r\n    if (\r\n      _nCheckPoints > 0 &&\r\n      IonicTimeLibrary.epochStart(checkpoints[tokenId][lpToken][_nCheckPoints - 1].timestamp) ==\r\n      IonicTimeLibrary.epochStart(_timestamp)\r\n    ) {\r\n      checkpoints[tokenId][lpToken][_nCheckPoints - 1] = Checkpoint(_timestamp, balance);\r\n    } else {\r\n      checkpoints[tokenId][lpToken][_nCheckPoints] = Checkpoint(_timestamp, balance);\r\n      numCheckpoints[tokenId][lpToken] = _nCheckPoints + 1;\r\n    }\r\n  }\r\n\r\n  /// @notice Writes a new checkpoint for total supply\r\n  /// @param lpToken The LP token address\r\n  function _writeSupplyCheckpoint(address lpToken) internal {\r\n    uint256 _nCheckPoints = supplyNumCheckpoints[lpToken];\r\n    uint256 _timestamp = block.timestamp;\r\n\r\n    if (\r\n      _nCheckPoints > 0 &&\r\n      IonicTimeLibrary.epochStart(supplyCheckpoints[_nCheckPoints - 1][lpToken].timestamp) ==\r\n      IonicTimeLibrary.epochStart(_timestamp)\r\n    ) {\r\n      supplyCheckpoints[_nCheckPoints - 1][lpToken] = SupplyCheckpoint(_timestamp, totalSupply[lpToken]);\r\n    } else {\r\n      supplyCheckpoints[_nCheckPoints][lpToken] = SupplyCheckpoint(_timestamp, totalSupply[lpToken]);\r\n      supplyNumCheckpoints[lpToken] = _nCheckPoints + 1;\r\n    }\r\n  }\r\n\r\n  /// @dev used within all notifyRewardAmount implementations\r\n  function _notifyRewardAmount(address sender, address token, uint256 amount) internal {\r\n    if (amount == 0) revert AmountCannotBeZero();\r\n    IERC20(token).safeTransferFrom(sender, address(this), amount);\r\n\r\n    uint256 epochStart = IonicTimeLibrary.epochStart(block.timestamp);\r\n    tokenRewardsPerEpoch[token][epochStart] += amount;\r\n\r\n    emit RewardNotification(sender, token, epochStart, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the ETH value of a token amount at a specific epoch\r\n   * @param amount The amount of tokens\r\n   * @param lpToken The LP token address\r\n   * @param epochTimestamp The timestamp of the epoch\r\n   * @return The ETH value of the tokens\r\n   */\r\n  function _getTokenEthValueAt(\r\n    uint256 amount,\r\n    address lpToken,\r\n    uint256 epochTimestamp\r\n  ) internal view returns (uint256) {\r\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\r\n    uint256 historicalPrice = IVoter(voter).getHistoricalPrice(lpToken, epochTimestamp);\r\n    if (historicalPrice == 0) revert HistoricalPriceNotSet(lpToken, epochStart);\r\n    uint256 ethValue = (amount * historicalPrice) / 1e18;\r\n    return ethValue;\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Pure/View Functions                             ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @notice Returns the total number of reward tokens\r\n  /// @return The length of the rewards array\r\n  function rewardsListLength() external view returns (uint256) {\r\n    return rewards.length;\r\n  }\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function earned(address token, uint256 tokenId) public view returns (uint256) {\r\n    EarnedVars memory vars;\r\n    vars.totalReward = 0;\r\n    address[] memory lpTokens = getAllLpRewardTokens();\r\n    uint256 lpTokensLength = lpTokens.length;\r\n    for (uint256 j = 0; j < lpTokensLength; j++) {\r\n      address lpToken = lpTokens[j];\r\n\r\n      if (numCheckpoints[tokenId][lpToken] == 0) {\r\n        continue;\r\n      }\r\n\r\n      vars.currTs = IonicTimeLibrary.epochStart(lastEarn[token][tokenId]);\r\n      vars.index = getPriorBalanceIndex(tokenId, lpToken, vars.currTs);\r\n      Checkpoint memory cp0 = checkpoints[tokenId][lpToken][vars.index];\r\n\r\n      vars.currTs = Math.max(vars.currTs, IonicTimeLibrary.epochStart(cp0.timestamp));\r\n      vars.numEpochs = (IonicTimeLibrary.epochStart(block.timestamp) - vars.currTs) / DURATION;\r\n\r\n      if (vars.numEpochs > 0) {\r\n        for (uint256 i = 0; i < vars.numEpochs; i++) {\r\n          vars.index = getPriorBalanceIndex(tokenId, lpToken, vars.currTs + DURATION - 1);\r\n          cp0 = checkpoints[tokenId][lpToken][vars.index];\r\n          vars.epochBalanceValue = _getTokenEthValueAt(cp0.balanceOf, lpToken, vars.currTs);\r\n\r\n          vars.supplyValue = 0;\r\n          for (uint256 k = 0; k < lpTokensLength; k++) {\r\n            address currentLpToken = lpTokens[k];\r\n            uint256 supplyAmount = Math.max(\r\n              supplyCheckpoints[getPriorSupplyIndex(vars.currTs + DURATION - 1, currentLpToken)][currentLpToken].supply,\r\n              1\r\n            );\r\n            vars.supplyValue += _getTokenEthValueAt(supplyAmount, currentLpToken, vars.currTs);\r\n          }\r\n          if (vars.supplyValue > 0) {\r\n            vars.totalReward += (vars.epochBalanceValue * tokenRewardsPerEpoch[token][vars.currTs]) / vars.supplyValue;\r\n          }\r\n          vars.currTs += DURATION;\r\n        }\r\n      }\r\n    }\r\n\r\n    return vars.totalReward;\r\n  }\r\n\r\n  /// @notice Gets all LP tokens that can receive rewards\r\n  /// @return Array of LP token addresses\r\n  function getAllLpRewardTokens() public view returns (address[] memory) {\r\n    return IVoter(voter).getAllLpRewardTokens();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets historical prices for LP tokens at specific epochs\r\n   * @param epochTimestamp The timestamp of the epoch\r\n   * @param lpToken The LP token address\r\n   * @param price The price to set\r\n   */\r\n  function setHistoricalPrices(uint256 epochTimestamp, address lpToken, uint256 price) external onlyOwner {\r\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\r\n    historicalPrices[lpToken][epochStart] = price;\r\n    emit HistoricalPriceSet(epochTimestamp, lpToken, price);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets a specific checkpoint for a token\r\n   * @param tokenId The ID of the veION token\r\n   * @param lpToken The LP token address\r\n   * @param index The index of the checkpoint to retrieve\r\n   * @return The checkpoint data\r\n   */\r\n  function getCheckpoint(uint256 tokenId, address lpToken, uint256 index) external view returns (Checkpoint memory) {\r\n    return checkpoints[tokenId][lpToken][index];\r\n  }\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function getPriorBalanceIndex(uint256 tokenId, address lpToken, uint256 timestamp) public view returns (uint256) {\r\n    uint256 nCheckpoints = numCheckpoints[tokenId][lpToken];\r\n    if (nCheckpoints == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // First check most recent balance\r\n    if (checkpoints[tokenId][lpToken][nCheckpoints - 1].timestamp <= timestamp) {\r\n      return (nCheckpoints - 1);\r\n    }\r\n\r\n    // Next check implicit zero balance\r\n    if (checkpoints[tokenId][lpToken][0].timestamp > timestamp) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 lower = 0;\r\n    uint256 upper = nCheckpoints - 1;\r\n    while (upper > lower) {\r\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n      Checkpoint memory cp = checkpoints[tokenId][lpToken][center];\r\n      if (cp.timestamp == timestamp) {\r\n        return center;\r\n      } else if (cp.timestamp < timestamp) {\r\n        lower = center;\r\n      } else {\r\n        upper = center - 1;\r\n      }\r\n    }\r\n    return lower;\r\n  }\r\n\r\n  /// @inheritdoc IBribeRewards\r\n  function getPriorSupplyIndex(uint256 timestamp, address lpToken) public view returns (uint256) {\r\n    uint256 nCheckpoints = supplyNumCheckpoints[lpToken];\r\n    if (nCheckpoints == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // First check most recent balance\r\n    if (supplyCheckpoints[nCheckpoints - 1][lpToken].timestamp <= timestamp) {\r\n      return (nCheckpoints - 1);\r\n    }\r\n\r\n    // Next check implicit zero balance\r\n    if (supplyCheckpoints[0][lpToken].timestamp > timestamp) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 lower = 0;\r\n    uint256 upper = nCheckpoints - 1;\r\n    while (upper > lower) {\r\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n      SupplyCheckpoint memory cp = supplyCheckpoints[center][lpToken];\r\n      if (cp.timestamp == timestamp) {\r\n        return center;\r\n      } else if (cp.timestamp < timestamp) {\r\n        lower = center;\r\n      } else {\r\n        upper = center - 1;\r\n      }\r\n    }\r\n    return lower;\r\n  }\r\n}\r\n"
    },
    "contracts/veION/interfaces/IBribeRewards.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\ninterface IBribeRewards {\r\n  /// @notice A checkpoint for marking balance\r\n  struct Checkpoint {\r\n    uint256 timestamp;\r\n    uint256 balanceOf;\r\n  }\r\n\r\n  /// @notice A checkpoint for marking supply\r\n  struct SupplyCheckpoint {\r\n    uint256 timestamp;\r\n    uint256 supply;\r\n  }\r\n\r\n  struct EarnedVars {\r\n    uint256 totalReward;\r\n    uint256 reward;\r\n    uint256 supplyValue;\r\n    uint256 epochBalanceValue;\r\n    uint256 currTs;\r\n    uint256 index;\r\n    uint256 numEpochs;\r\n    uint256 overallBalance;\r\n    uint256 overallSupply;\r\n    uint256 historicalPrice;\r\n  }\r\n\r\n  error InvalidReward();\r\n  error Unauthorized();\r\n  error InvalidGauge();\r\n  error InvalidEscrowToken();\r\n  error SingleTokenExpected();\r\n  error InvalidVotingEscrow();\r\n  error TokenNotWhitelisted();\r\n  error AmountCannotBeZero();\r\n  error HistoricalPriceNotSet(address lpToken, uint256 epochStart);\r\n\r\n  event Deposit(address indexed user, uint256 indexed tokenId, uint256 amount);\r\n  event Withdraw(address indexed user, uint256 indexed tokenId, uint256 amount);\r\n  event RewardNotification(address indexed user, address indexed rewardToken, uint256 indexed epoch, uint256 amount);\r\n  event RewardsClaimed(address indexed user, address indexed rewardToken, uint256 amount);\r\n  event HistoricalPriceSet(uint256 indexed epochTimestamp, address indexed lpToken, uint256 price);\r\n\r\n  /// @notice Deposit an amount into the bribe rewards contract for a specific veNFT\r\n  /// @dev Can only be called internally by authorized entities.\r\n  /// @param lpToken  Address of the liquidity pool token\r\n  /// @param amount   Amount to be deposited for the veNFT\r\n  /// @param tokenId  Unique identifier of the veNFT\r\n  function deposit(address lpToken, uint256 amount, uint256 tokenId) external;\r\n\r\n  /// @notice Withdraw an amount from the bribe rewards contract for a specific veNFT\r\n  /// @dev Can only be called internally by authorized entities.\r\n  /// @param lpToken  Address of the liquidity pool token\r\n  /// @param amount   Amount to be withdrawn for the veNFT\r\n  /// @param tokenId  Unique identifier of the veNFT\r\n  function withdraw(address lpToken, uint256 amount, uint256 tokenId) external;\r\n\r\n  /// @notice Claim the rewards earned by a veNFT holder\r\n  /// @param tokenId  Unique identifier of the veNFT\r\n  /// @param tokens   Array of tokens to claim rewards for\r\n  function getReward(uint256 tokenId, address[] memory tokens) external;\r\n\r\n  /// @notice Notify the contract about new rewards for stakers\r\n  /// @param token    Address of the reward token\r\n  /// @param amount   Amount of the reward token to be added\r\n  function notifyRewardAmount(address token, uint256 amount) external;\r\n\r\n  /// @notice Get the prior balance index for a veNFT at a specific timestamp\r\n  /// @dev Timestamp must be in the past or present.\r\n  /// @param tokenId      The veNFT token ID to check\r\n  /// @param lpToken      Address of the liquidity pool token\r\n  /// @param timestamp    The timestamp to get the balance at\r\n  /// @return The balance index at the given timestamp\r\n  function getPriorBalanceIndex(uint256 tokenId, address lpToken, uint256 timestamp) external view returns (uint256);\r\n\r\n  /// @notice Get the prior supply index at a specific timestamp\r\n  /// @dev Timestamp must be in the past or present.\r\n  /// @param timestamp The timestamp to get the supply index at\r\n  /// @return The supply index at the given timestamp\r\n  function getPriorSupplyIndex(uint256 timestamp, address lpToken) external view returns (uint256);\r\n\r\n  /// @notice Calculate the rewards earned for a specific token and veNFT\r\n  /// @param token Address of the reward token\r\n  /// @param tokenId Unique identifier of the veNFT\r\n  /// @return Amount of the reward token earned\r\n  function earned(address token, uint256 tokenId) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IveION.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"../stake/IStakeStrategy.sol\";\r\nimport \"./IveIONCore.sol\";\r\nimport \"./IveIONFirstExtension.sol\";\r\nimport \"./IveIONSecondExtension.sol\";\r\n\r\n/// @title IveION Interface\r\n/// @notice Interface for veION contract\r\ninterface IveION is IveIONStructsEnumsErrorsEvents, IveIONCore, IveIONFirstExtension, IveIONSecondExtension {\r\n  // Constants\r\n  function PRECISION() external view returns (uint256);\r\n\r\n  // State Variables\r\n  function s_tokenId() external view returns (uint256);\r\n  function s_limitedBoost() external view returns (uint256);\r\n  function s_limitedBoostActive() external view returns (bool);\r\n  function s_veAERO() external view returns (address);\r\n  function s_aeroVoting() external view returns (address);\r\n  function s_ionicPool() external view returns (address);\r\n  function s_voter() external view returns (address);\r\n  function s_aeroVoterBoost() external view returns (uint256);\r\n  function s_minimumLockDuration() external view returns (uint256);\r\n  function s_maxEarlyWithdrawFee() external view returns (uint256);\r\n  function ap() external view returns (address);\r\n  function implementation() external view returns (address);\r\n\r\n  // Mappings\r\n  function s_minimumLockAmount(LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_whitelistedToken(address token) external view returns (bool);\r\n  function s_lpType(address token) external view returns (LpTokenType);\r\n  function s_canSplit(address user) external view returns (bool);\r\n  function s_locked(uint256 tokenId, LpTokenType lpTokenType) external view returns (LockedBalance memory);\r\n  function s_userPointEpoch(uint256 tokenId, LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_userPointHistory(\r\n    uint256 tokenId,\r\n    LpTokenType lpTokenType,\r\n    uint256 epoch\r\n  ) external view returns (UserPoint memory);\r\n  function s_voted(uint256 tokenId) external view returns (bool);\r\n  function s_supply(LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_permanentLockBalance(LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_stakeStrategy(LpTokenType lpTokenType) external view returns (address);\r\n  function s_underlyingStake(uint256 tokenId, address token) external view returns (uint256);\r\n  function s_protocolFees(LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_distributedFees(LpTokenType lpTokenType) external view returns (uint256);\r\n  function s_delegations(\r\n    uint256 delegatorTokenId,\r\n    uint256 delegateeTokenId,\r\n    LpTokenType lpTokenType\r\n  ) external view returns (uint256);\r\n  function s_userCumulativeAssetValues(address user, address token) external view returns (uint256);\r\n  function s_delegatorsBlocked(uint256 tokenId, address token) external view returns (bool);\r\n\r\n  // Openzeppelin functions\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n  function ownerOf(uint256 tokenId) external returns (address);\r\n  function owner() external returns (address);\r\n  function balanceOf(address owner) external returns (uint256);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IveIONCore.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"../stake/IStakeStrategy.sol\";\r\n\r\n/// @title IveION Interface\r\n/// @notice Interface for veION contract\r\ninterface IveIONCore {\r\n  /**\r\n   * @notice Creates a new lock for multiple tokens and assigns it to a specified address\r\n   * @param _tokenAddress Array of token addresses to lock\r\n   * @param _tokenAmount Array of token amounts to lock\r\n   * @param _duration Array of lock durations\r\n   * @param _stakeUnderlying Array of booleans indicating whether to stake underlying tokens\r\n   * @param _to Address to assign the lock to\r\n   * @return The ID of the newly created veNFT\r\n   */\r\n  function createLockFor(\r\n    address[] memory _tokenAddress,\r\n    uint256[] memory _tokenAmount,\r\n    uint256[] memory _duration,\r\n    bool[] memory _stakeUnderlying,\r\n    address _to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Creates a new lock for multiple tokens\r\n   * @param _tokenAddress Array of token addresses to lock\r\n   * @param _tokenAmount Array of token amounts to lock\r\n   * @param _duration Array of lock durations\r\n   * @param _stakeUnderlying Array of booleans indicating whether to stake underlying tokens\r\n   * @return The ID of the newly created veNFT\r\n   */\r\n  function createLock(\r\n    address[] calldata _tokenAddress,\r\n    uint256[] calldata _tokenAmount,\r\n    uint256[] calldata _duration,\r\n    bool[] memory _stakeUnderlying\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @notice Increases the amount of tokens locked for a specific veNFT\r\n   * @param _tokenAddress Address of the token to increase lock amount for\r\n   * @param _tokenId ID of the veNFT\r\n   * @param _tokenAmount Amount of tokens to add to the lock\r\n   * @param _stakeUnderlying Whether to stake the underlying tokens\r\n   */\r\n  function increaseAmount(\r\n    address _tokenAddress,\r\n    uint256 _tokenId,\r\n    uint256 _tokenAmount,\r\n    bool _stakeUnderlying\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Locks additional asset type for an existing veNFT\r\n   * @param _tokenAddress Address of the new token to lock\r\n   * @param _tokenAmount Amount of tokens to lock\r\n   * @param _tokenId ID of the veNFT\r\n   * @param _duration Duration of the lock\r\n   * @param _stakeUnderlying Whether to stake the underlying tokens\r\n   */\r\n  function lockAdditionalAsset(\r\n    address _tokenAddress,\r\n    uint256 _tokenAmount,\r\n    uint256 _tokenId,\r\n    uint256 _duration,\r\n    bool _stakeUnderlying\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Increases the lock duration for a specific token in a veNFT\r\n   * @param _tokenAddress Address of the token\r\n   * @param _tokenId ID of the veNFT\r\n   * @param _lockDuration New lock duration to extend to\r\n   */\r\n  function increaseUnlockTime(address _tokenAddress, uint256 _tokenId, uint256 _lockDuration) external;\r\n\r\n  /**\r\n   * @notice Delegates voting power from one veNFT to another.\r\n   * @param fromTokenId The ID of the veNFT from which voting power is delegated.\r\n   * @param toTokenId The ID of the veNFT to which voting power is delegated.\r\n   * @param lpToken The address of the LP token associated with the delegation.\r\n   * @param amount The amount of voting power to delegate.\r\n   */\r\n  function delegate(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) external;\r\n\r\n  /**\r\n   * @notice Removes delegatees from a specific veNFT\r\n   * @param fromTokenId ID of the veNFT from which delegatees are removed\r\n   * @param toTokenIds Array of veNFT IDs that are delegatees to be removed\r\n   * @param lpToken Address of the LP token associated with the delegation\r\n   * @param amounts Array of amounts of voting power to remove from each delegatee\r\n   */\r\n  function removeDelegatees(\r\n    uint256 fromTokenId,\r\n    uint256[] memory toTokenIds,\r\n    address lpToken,\r\n    uint256[] memory amounts\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Removes delegators from a specific veNFT\r\n   * @param fromTokenIds Array of veNFT IDs that are delegators to be removed\r\n   * @param toTokenId ID of the veNFT from which delegators are removed\r\n   * @param lpToken Address of the LP token associated with the delegation\r\n   * @param amounts Array of amounts of voting power to remove from each delegator\r\n   */\r\n  function removeDelegators(\r\n    uint256[] memory fromTokenIds,\r\n    uint256 toTokenId,\r\n    address lpToken,\r\n    uint256[] memory amounts\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Locks a token permanently.\r\n   * @param _tokenAddress The address of the token to lock.\r\n   * @param _tokenId The ID of the token to lock.\r\n   */\r\n  function lockPermanent(address _tokenAddress, uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Unlocks a permanently locked token.\r\n   * @param _tokenAddress The address of the token to unlock.\r\n   * @param _tokenId The ID of the token to unlock.\r\n   */\r\n  function unlockPermanent(address _tokenAddress, uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Updates voting status for a veNFT\r\n   * @param _tokenId ID of the veNFT\r\n   * @param _voting Voting status\r\n   */\r\n  function voting(uint256 _tokenId, bool _voting) external;\r\n\r\n  /**\r\n   * @notice Sets the implementation addresses for the veION contract extensions.\r\n   * @dev This function can only be called by authorized entities.\r\n   * @param _veIONFirstExtension The address of the first extension contract.\r\n   * @param _veIONSecondExtension The address of the second extension contract.\r\n   */\r\n  function setExtensions(address _veIONFirstExtension, address _veIONSecondExtension) external;\r\n}\r\n\r\n/// @title IAeroVotingEscrow Interface\r\n/// @notice Interface for Aero Voting Escrow contract\r\ninterface IAeroVotingEscrow {\r\n  /**\r\n   * @notice Returns the balance of the specified owner.\r\n   * @param _owner The address of the owner.\r\n   * @return The balance of the owner.\r\n   */\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Retrieves the token ID at a specific index for a given owner.\r\n   * @param _owner The address of the owner.\r\n   * @param _index The index of the token ID in the owner's list.\r\n   * @return The token ID at the specified index.\r\n   */\r\n  function ownerToNFTokenIdList(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @title IAeroVoter Interface\r\n/// @notice Interface for Aero Voter contract\r\ninterface IAeroVoter {\r\n  /**\r\n   * @notice Returns the list of pools voted for by a specific token ID.\r\n   * @param tokenId The ID of the token.\r\n   * @return An array of addresses representing the pools voted for.\r\n   */\r\n  function poolVote(uint256 tokenId) external view returns (address[] memory);\r\n\r\n  /**\r\n   * @notice Retrieves the weight of a specific pool.\r\n   * @param pool The address of the pool.\r\n   * @return The weight of the pool.\r\n   */\r\n  function weights(address pool) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the number of votes a specific token ID has for a given pool.\r\n   * @param tokenId The ID of the token.\r\n   * @param pool The address of the pool.\r\n   * @return The number of votes for the pool.\r\n   */\r\n  function votes(uint256 tokenId, address pool) external view returns (uint256);\r\n}\r\n\r\ninterface IAddressesProvider {\r\n  function getAddress(string calldata id) external view returns (address);\r\n}\r\n\r\ninterface IMasterPriceOracle {\r\n  function price(address underlying) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IveIONFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"../stake/IStakeStrategy.sol\";\r\nimport { IveIONStructsEnumsErrorsEvents } from \"./IveIONStructsEnumsErrorsEvents.sol\";\r\n\r\n/// @title IveION Interface First Extensions\r\n/// @notice Interface for veION contract\r\ninterface IveIONFirstExtension is IveIONStructsEnumsErrorsEvents {\r\n  /**\r\n   * @notice Withdraws tokens associated with a specific token ID.\r\n   * @param _tokenAddress The address of the token to withdraw.\r\n   * @param _tokenId The ID of the token to withdraw.\r\n   */\r\n  function withdraw(address _tokenAddress, uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Merges two token IDs into one.\r\n   * @param _from The ID of the token to merge from.\r\n   * @param _to The ID of the token to merge into.\r\n   */\r\n  function merge(uint256 _from, uint256 _to) external;\r\n\r\n  /**\r\n   * @notice Splits a token into two separate tokens.\r\n   * @param _tokenAddress The address of the token to split.\r\n   * @param _from The ID of the token to split.\r\n   * @param _splitAmount The amount to split from the original token.\r\n   * @return _tokenId1 The ID of the first resulting token.\r\n   * @return _tokenId2 The ID of the second resulting token.\r\n   */\r\n  function split(\r\n    address _tokenAddress,\r\n    uint256 _from,\r\n    uint256 _splitAmount\r\n  ) external returns (uint256 _tokenId1, uint256 _tokenId2);\r\n\r\n  /**\r\n   * @notice Claims emissions for a specific token.\r\n   * @param _tokenAddress The address of the token for which to claim emissions.\r\n   */\r\n  function claimEmissions(address _tokenAddress) external;\r\n\r\n  /**\r\n   * @notice Allows or blocks delegators for a specific token ID.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _tokenAddress The address of the token.\r\n   * @param _blocked Boolean indicating if delegators are blocked.\r\n   */\r\n  function allowDelegators(uint256 _tokenId, address _tokenAddress, bool _blocked) external;\r\n\r\n  /**\r\n   * @notice Retrieves the balance of a specific NFT.\r\n   * @param _tokenId The ID of the NFT.\r\n   * @return _assets An array of asset addresses.\r\n   * @return _balances An array of balances for each asset.\r\n   * @return _boosts An array of boost values for each asset.\r\n   */\r\n  function balanceOfNFT(\r\n    uint256 _tokenId\r\n  ) external view returns (address[] memory _assets, uint256[] memory _balances, uint256[] memory _boosts);\r\n\r\n  /**\r\n   * @notice Retrieves the total ETH value of tokens owned by a specific address.\r\n   * @param _owner The address of the owner.\r\n   * @return totalValue The total ETH value of the tokens.\r\n   */\r\n  function getTotalEthValueOfTokens(address _owner) external view returns (uint256 totalValue);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IveIONSecondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"../stake/IStakeStrategy.sol\";\r\nimport { IveIONStructsEnumsErrorsEvents } from \"./IveIONStructsEnumsErrorsEvents.sol\";\r\n\r\n/// @title IveION Interface Second Extension\r\n/// @notice Interface for veION contract\r\ninterface IveIONSecondExtension is IveIONStructsEnumsErrorsEvents {\r\n  /**\r\n   * @notice Whitelists or removes tokens from the whitelist.\r\n   * @param _tokens An array of token addresses to be whitelisted or removed.\r\n   * @param _isWhitelisted An array of booleans indicating the whitelist status for each token.\r\n   */\r\n  function whitelistTokens(address[] memory _tokens, bool[] memory _isWhitelisted) external;\r\n\r\n  /**\r\n   * @notice Withdraws protocol fees for a specific token to a recipient address.\r\n   * @param _tokenAddress The address of the token for which protocol fees are to be withdrawn.\r\n   * @param _recipient The address to which the protocol fees will be sent.\r\n   */\r\n  function withdrawProtocolFees(address _tokenAddress, address _recipient) external;\r\n\r\n  /**\r\n   * @notice Withdraws distributed fees for a specific token to a recipient address.\r\n   * @param _tokenAddress The address of the token for which distributed fees are to be withdrawn.\r\n   * @param _recipient The address to which the distributed fees will be sent.\r\n   */\r\n  function withdrawDistributedFees(address _tokenAddress, address _recipient) external;\r\n\r\n  /**\r\n   * @notice Toggles the ability to split tokens for a specific account.\r\n   * @param _account The address of the account.\r\n   * @param _isAllowed Boolean indicating if splitting is allowed.\r\n   */\r\n  function toggleSplit(address _account, bool _isAllowed) external;\r\n\r\n  /**\r\n   * @notice Toggles the limited boost feature.\r\n   * @param _isBoosted Boolean indicating if the boost is active.\r\n   */\r\n  function toggleLimitedBoost(bool _isBoosted) external;\r\n\r\n  /**\r\n   * @notice Sets the amount for a limited time boost.\r\n   * @param _boostAmount The amount of the boost.\r\n   */\r\n  function setLimitedTimeBoost(uint256 _boostAmount) external;\r\n\r\n  /**\r\n   * @notice Sets the address of the voter.\r\n   * @param _voter The address of the voter.\r\n   */\r\n  function setVoter(address _voter) external;\r\n\r\n  /**\r\n   * @notice Sets the minimum lock amount for a specific token.\r\n   * @param _tokenAddress The address of the token.\r\n   * @param _minimumAmount The minimum amount to lock.\r\n   */\r\n  function setMinimumLockAmount(address _tokenAddress, uint256 _minimumAmount) external;\r\n\r\n  /**\r\n   * @notice Sets the minimum lock duration.\r\n   * @param _minimumLockDuration The minimum duration for locking.\r\n   */\r\n  function setMinimumLockDuration(uint256 _minimumLockDuration) external;\r\n\r\n  /**\r\n   * @notice Sets the address of the Ionic Pool.\r\n   * @param _ionicPool The address of the Ionic Pool.\r\n   */\r\n  function setIonicPool(address _ionicPool) external;\r\n\r\n  /**\r\n   * @notice Sets the address of the Aero Voting contract.\r\n   * @param _aeroVoting The address of the Aero Voting contract.\r\n   */\r\n  function setAeroVoting(address _aeroVoting) external;\r\n\r\n  /**\r\n   * @notice Sets the boost amount for Aero Voter.\r\n   * @param _aeroVoterBoost The boost amount for Aero Voter.\r\n   */\r\n  function setAeroVoterBoost(uint256 _aeroVoterBoost) external;\r\n\r\n  /**\r\n   * @notice Sets the maximum early withdrawal fee.\r\n   * @param _maxEarlyWithdrawFee The maximum fee for early withdrawal.\r\n   */\r\n  function setMaxEarlyWithdrawFee(uint256 _maxEarlyWithdrawFee) external;\r\n\r\n  /**\r\n   * @notice Sets the LP token type for a specific token.\r\n   * @param _token The address of the token.\r\n   * @param _type The LP token type.\r\n   */\r\n  function setLpTokenType(address _token, LpTokenType _type) external;\r\n\r\n  /**\r\n   * @notice Sets the stake strategy for a specific LP token type.\r\n   * @param _lpType The LP token type.\r\n   * @param _strategy The stake strategy.\r\n   */\r\n  function setStakeStrategy(LpTokenType _lpType, IStakeStrategy _strategy) external;\r\n\r\n  /**\r\n   * @notice Sets the address of the veAERO contract.\r\n   * @param _veAERO The address of the veAERO contract.\r\n   */\r\n  function setVeAERO(address _veAERO) external;\r\n\r\n  /**\r\n   * @notice Retrieves the lock information for a specific user.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpType The LP token type.\r\n   * @return A LockedBalance struct containing lock details.\r\n   */\r\n  function getUserLock(uint256 _tokenId, LpTokenType _lpType) external view returns (LockedBalance memory);\r\n\r\n  /**\r\n   * @notice Retrieves the token IDs owned by a specific address.\r\n   * @param _owner The address of the owner.\r\n   * @return An array of token IDs owned by the address.\r\n   */\r\n  function getOwnedTokenIds(address _owner) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Retrieves the assets locked for a specific token ID.\r\n   * @param _tokenId The ID of the token.\r\n   * @return An array of addresses representing the locked assets.\r\n   */\r\n  function getAssetsLocked(uint256 _tokenId) external view returns (address[] memory);\r\n\r\n  /**\r\n   * @notice Retrieves the delegatees for a specific token ID and LP token type.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpType The LP token type.\r\n   * @return An array of delegatee IDs.\r\n   */\r\n  function getDelegatees(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Retrieves the delegators for a specific token ID and LP token type.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpType The LP token type.\r\n   * @return An array of delegator IDs.\r\n   */\r\n  function getDelegators(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Retrieves the user point for a specific token ID, LP token type, and epoch.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpType The LP token type.\r\n   * @param _epoch The epoch number.\r\n   * @return A UserPoint struct containing user point details.\r\n   */\r\n  function getUserPoint(uint256 _tokenId, LpTokenType _lpType, uint256 _epoch) external view returns (UserPoint memory);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IveIONStructsEnumsErrorsEvents.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\ninterface IveIONStructsEnumsErrorsEvents {\r\n  /**\r\n   * @notice Structure representing a locked balance\r\n   * @param tokenAddress Address of the token\r\n   * @param amount Amount of tokens locked\r\n   * @param delegateAmount Amount of tokens delegated\r\n   * @param start Start time of the lock\r\n   * @param end End time of the lock\r\n   * @param isPermanent Indicates if the lock is permanent\r\n   * @param boost Boost value for the lock\r\n   */\r\n  struct LockedBalance {\r\n    address tokenAddress;\r\n    uint256 amount;\r\n    uint256 delegateAmount;\r\n    uint256 start;\r\n    uint256 end;\r\n    bool isPermanent;\r\n    uint256 boost;\r\n  }\r\n\r\n  /**\r\n   * @notice Structure representing a delegation\r\n   * @param amount Amount of tokens delegated\r\n   * @param delegatee ID of the delegatee\r\n   */\r\n  struct Delegation {\r\n    uint256 amount;\r\n    uint256 delegatee;\r\n  }\r\n\r\n  /**\r\n   * @notice Structure representing a user point\r\n   * @param bias Bias value\r\n   * @param slope Slope value, representing -dweight / dt\r\n   * @param ts Timestamp of the point\r\n   * @param blk Block number of the point\r\n   * @param permanent Permanent value\r\n   * @param permanentDelegate Permanent delegate value\r\n   */\r\n  struct UserPoint {\r\n    uint256 bias;\r\n    uint256 slope;\r\n    uint256 ts;\r\n    uint256 blk;\r\n    uint256 permanent;\r\n    uint256 permanentDelegate;\r\n  }\r\n\r\n  /**\r\n   * @notice Structure representing a global point\r\n   * @param bias Bias value\r\n   * @param slope Slope value, representing -dweight / dt\r\n   * @param ts Timestamp of the point\r\n   * @param blk Block number of the point\r\n   * @param permanentLockBalance Permanent lock balance\r\n   */\r\n  struct GlobalPoint {\r\n    int128 bias;\r\n    int128 slope;\r\n    uint256 ts;\r\n    uint256 blk;\r\n    uint256 permanentLockBalance;\r\n  }\r\n\r\n  /**\r\n   * @notice Structure representing a checkpoint\r\n   * @param fromTimestamp Timestamp from which the checkpoint is valid\r\n   * @param owner Address of the owner\r\n   * @param delegatedBalance Balance that has been delegated\r\n   * @param delegatee ID of the delegatee\r\n   */\r\n  struct Checkpoint {\r\n    uint256 fromTimestamp;\r\n    address owner;\r\n    uint256 delegatedBalance;\r\n    uint256 delegatee;\r\n  }\r\n\r\n  /**\r\n   * @notice Enum representing deposit types\r\n   */\r\n  enum DepositType {\r\n    DEPOSIT_FOR_TYPE,\r\n    CREATE_LOCK_TYPE,\r\n    INCREASE_LOCK_AMOUNT,\r\n    INCREASE_UNLOCK_TIME,\r\n    LOCK_ADDITIONAL\r\n  }\r\n\r\n  /**\r\n   * @notice Enum representing LP token types\r\n   */\r\n  enum LpTokenType {\r\n    Mode_Velodrome_5050_ION_MODE,\r\n    Mode_Balancer_8020_ION_ETH,\r\n    Base_Aerodrome_5050_ION_wstETH,\r\n    Base_Balancer_8020_ION_ETH,\r\n    Optimism_Velodrome_5050_ION_OP,\r\n    Optimism_Balancer_8020_ION_ETH\r\n  }\r\n\r\n  error LockDurationNotInFuture();\r\n  error ZeroAmount();\r\n  error LockDurationTooLong();\r\n  error TokenNotWhitelisted();\r\n  error NotOwner();\r\n  error AlreadyVoted();\r\n  error PermanentLock();\r\n  error NoLockFound();\r\n  error LockExpired();\r\n  error SameNFT();\r\n  error SplitNotAllowed();\r\n  error AmountTooBig();\r\n  error NotPermanentLock();\r\n  error TokenHasDelegatees();\r\n  error TokenHasDelegators();\r\n  error NotVoter();\r\n  error MinimumNotMet();\r\n  error ArrayMismatch();\r\n  error LockDurationTooShort();\r\n  error DuplicateAsset();\r\n  error SplitTooSmall();\r\n  error NotEnoughRemainingAfterSplit();\r\n  error NoDelegationBetweenTokens(uint256 _tokenId1, uint256 _tokenId2);\r\n  error NoUnderlyingStake();\r\n  error NotAcceptingDelegators();\r\n  error BoostAmountMustBeGreaterThanZero();\r\n  error InvalidAddress();\r\n  error MinimumAmountMustBeGreaterThanZero();\r\n  error MinimumLockDurationMustBeGreaterThanZero();\r\n  error AeroBoostAmountMustBeGreaterThanZero();\r\n  error MaxEarlyWithdrawFeeMustBeGreaterThanZero();\r\n  error InvalidTokenAddress();\r\n  error InvalidStrategyAddress();\r\n  error InvalidVeAEROAddress();\r\n\r\n  event Deposit(\r\n    address indexed provider,\r\n    uint256 indexed tokenId,\r\n    DepositType indexed depositType,\r\n    uint256 value,\r\n    uint256 locktime,\r\n    uint256 ts\r\n  );\r\n  event Withdraw(address indexed provider, uint256 indexed tokenId, uint256 value, uint256 ts);\r\n  event Supply(uint256 prevSupply, uint256 supply);\r\n  event Delegated(uint256 indexed fromTokenId, uint256 indexed toTokenId, address lpToken, uint256 amount);\r\n  event DelegationRemoved(uint256 indexed fromTokenId, uint256 indexed toTokenId, address lpToken, uint256 amount);\r\n  event ProtocolFeesWithdrawn(address indexed tokenAddress, address indexed recipient, uint256 amount);\r\n  event DistributedFeesWithdrawn(address indexed tokenAddress, address indexed recipient, uint256 amount);\r\n  event SplitToggle(address indexed account, bool isAllowed);\r\n  event LimitedBoostToggled(bool isBoosted);\r\n  event LimitedTimeBoostSet(uint256 boostAmount);\r\n  event VoterSet(address indexed newVoter);\r\n  event AeroVotingSet(address indexed newAeroVoting);\r\n  event AeroVoterBoostSet(uint256 newAeroVoterBoost);\r\n  event TokensWhitelisted(address[] token, bool[] isWhitelisted);\r\n  event LpTokenTypeSet(address indexed token, LpTokenType lpTokenType);\r\n  event VeAEROSet(address indexed veAERO);\r\n  event StakeStrategySet(LpTokenType indexed lpTokenType, address indexed strategy);\r\n  event MinimumLockAmountSet(address indexed tokenAddress, uint256 minimumAmount);\r\n  event MinimumLockDurationSet(uint256 minimumDuration);\r\n  event IonicPoolSet(address indexed newIonicPool);\r\n  event SplitCompleted(\r\n    uint256 indexed fromTokenId,\r\n    uint256 indexed tokenId1,\r\n    uint256 indexed tokenId2,\r\n    uint256 splitAmount,\r\n    address tokenAddress\r\n  );\r\n  event MergeCompleted(\r\n    uint256 indexed fromTokenId,\r\n    uint256 indexed toTokenId,\r\n    address[] assetsLocked,\r\n    uint256 lengthOfAssets\r\n  );\r\n  event EmissionsClaimed(address indexed claimant, address indexed tokenAddress);\r\n  event MaxEarlyWithdrawFeeSet(uint256 maxEarlyWithdrawFee);\r\n  event PermanentLockCreated(address indexed tokenAddress, uint256 indexed tokenId, uint256 amount);\r\n  event PermanentLockRemoved(address indexed tokenAddress, uint256 indexed tokenId, uint256 amount);\r\n  event Voted(uint256 _tokenId, bool _voting);\r\n  event DelegatorsBlocked(uint256 indexed _tokenId, address indexed _lpToken, bool _blocked);\r\n  event Initialized(address indexed addressesProvider);\r\n  event ExtensionsSet(address indexed _firstExtension, address indexed _secondExtension);\r\n}\r\n"
    },
    "contracts/veION/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\n/**\r\n * @title IVoter\r\n * @notice Interface for the Voter contract, which manages voting and reward distribution.\r\n */\r\ninterface IVoter {\r\n  /// @notice Error thrown when a user has already voted or deposited.\r\n  error AlreadyVotedOrDeposited();\r\n\r\n  /// @notice Error thrown when an action is attempted outside the distribution window.\r\n  error DistributeWindow();\r\n\r\n  /// @notice Error thrown when a reward accumulator does not exist for a given pool.\r\n  error RewardAccumulatorDoesNotExist(address _pool);\r\n\r\n  /// @notice Error thrown when a reward accumulator is not alive.\r\n  error RewardAccumulatorNotAlive(address _rewardAccumulator);\r\n\r\n  /// @notice Error thrown when a market already exists.\r\n  error MarketAlreadyExists();\r\n\r\n  /// @notice Error thrown when the maximum voting number is too low.\r\n  error MaximumVotingNumberTooLow();\r\n\r\n  /// @notice Error thrown when array lengths do not match.\r\n  error MismatchedArrayLengths();\r\n\r\n  /// @notice Error thrown when there are non-zero votes.\r\n  error NonZeroVotes();\r\n\r\n  /// @notice Error thrown when the caller is not the owner.\r\n  error NotOwner();\r\n\r\n  /// @notice Error thrown when an action is attempted outside the distribution window.\r\n  error NotDistributeWindow();\r\n\r\n  /// @notice Error thrown when the caller is not the governor.\r\n  error NotGovernor();\r\n\r\n  /// @notice Error thrown when an NFT is not whitelisted.\r\n  error NotWhitelistedNFT();\r\n\r\n  /// @notice Error thrown when the same value is provided.\r\n  error SameValue();\r\n\r\n  /// @notice Error thrown when there are too many pools.\r\n  error TooManyPools();\r\n\r\n  /// @notice Error thrown when array lengths are unequal.\r\n  error UnequalLengths();\r\n\r\n  /// @notice Error thrown when an address is zero.\r\n  error ZeroAddress();\r\n\r\n  /// @notice Error thrown when the tokens array is empty.\r\n  error TokensArrayEmpty();\r\n\r\n  /// @notice Error thrown when the weight is zero.\r\n  error ZeroWeight();\r\n\r\n  /**\r\n   * @notice Struct to store vote details.\r\n   * @param marketVotes Array of market addresses voted for.\r\n   * @param marketVoteSides Array of market sides voted for.\r\n   * @param votes Array of vote weights.\r\n   * @param usedWeight Total weight used in voting.\r\n   */\r\n  struct VoteDetails {\r\n    address[] marketVotes;\r\n    MarketSide[] marketVoteSides;\r\n    uint256[] votes;\r\n    uint256 usedWeight;\r\n  }\r\n\r\n  /**\r\n   * @notice Struct to store market information.\r\n   * @param marketAddress Address of the market.\r\n   * @param side Side of the market (Supply or Borrow).\r\n   */\r\n  struct Market {\r\n    address marketAddress;\r\n    MarketSide side;\r\n  }\r\n\r\n  /**\r\n   * @notice Struct to store variables used in voting.\r\n   * @param totalWeight Total weight available for voting.\r\n   * @param usedWeight Weight used in voting.\r\n   * @param market Address of the market.\r\n   * @param marketSide Side of the market.\r\n   * @param rewardAccumulator Address of the reward accumulator.\r\n   * @param marketWeight Weight of the market.\r\n   * @param bribes Address of the bribes.\r\n   */\r\n  struct VoteVars {\r\n    uint256 totalWeight;\r\n    uint256 usedWeight;\r\n    address market;\r\n    MarketSide marketSide;\r\n    address rewardAccumulator;\r\n    uint256 marketWeight;\r\n    address bribes;\r\n  }\r\n\r\n  /**\r\n   * @notice Struct to store local variables used in voting.\r\n   * @param sender Address of the sender.\r\n   * @param timestamp Timestamp of the vote.\r\n   * @param votingLPs Array of voting LP addresses.\r\n   * @param votingLPBalances Array of voting LP balances.\r\n   * @param boosts Array of boosts.\r\n   */\r\n  struct VoteLocalVars {\r\n    address sender;\r\n    uint256 timestamp;\r\n    address[] votingLPs;\r\n    uint256[] votingLPBalances;\r\n    uint256[] boosts;\r\n  }\r\n\r\n  /**\r\n   * @notice Enum to represent the side of a market.\r\n   */\r\n  enum MarketSide {\r\n    Supply,\r\n    Borrow\r\n  }\r\n\r\n  /**\r\n   * @notice Event emitted when a vote is cast.\r\n   * @param voter Address of the voter.\r\n   * @param pool Address of the pool.\r\n   * @param tokenId ID of the token.\r\n   * @param weight Weight of the vote.\r\n   * @param totalWeight Total weight of the vote.\r\n   * @param timestamp Timestamp of the vote.\r\n   */\r\n  event Voted(\r\n    address indexed voter,\r\n    address indexed pool,\r\n    uint256 indexed tokenId,\r\n    uint256 weight,\r\n    uint256 totalWeight,\r\n    uint256 timestamp\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a vote is abstained.\r\n   * @param voter Address of the voter.\r\n   * @param pool Address of the pool.\r\n   * @param tokenId ID of the token.\r\n   * @param weight Weight of the vote.\r\n   * @param totalWeight Total weight of the vote.\r\n   * @param timestamp Timestamp of the vote.\r\n   */\r\n  event Abstained(\r\n    address indexed voter,\r\n    address indexed pool,\r\n    uint256 indexed tokenId,\r\n    uint256 weight,\r\n    uint256 totalWeight,\r\n    uint256 timestamp\r\n  );\r\n\r\n  /**\r\n   * @notice Event emitted when a reward is notified.\r\n   * @param sender Address of the sender.\r\n   * @param reward Address of the reward.\r\n   * @param amount Amount of the reward.\r\n   */\r\n  event NotifyReward(address indexed sender, address indexed reward, uint256 amount);\r\n\r\n  /**\r\n   * @notice Event emitted when a token is whitelisted.\r\n   * @param whitelister Address of the whitelister.\r\n   * @param token Address of the token.\r\n   * @param _bool Boolean indicating whitelist status.\r\n   */\r\n  event WhitelistToken(address indexed whitelister, address indexed token, bool indexed _bool);\r\n\r\n  /**\r\n   * @notice Event emitted when an NFT is whitelisted.\r\n   * @param whitelister Address of the whitelister.\r\n   * @param tokenId ID of the token.\r\n   * @param _bool Boolean indicating whitelist status.\r\n   */\r\n  event WhitelistNFT(address indexed whitelister, uint256 indexed tokenId, bool indexed _bool);\r\n\r\n  event LpTokensSet(address[] indexed lpTokens);\r\n  event MpoSet(address indexed mpo);\r\n  event GovernorSet(address indexed governor);\r\n  event MarketsAdded(Market[] markets);\r\n  event MarketRewardAccumulatorsSet(\r\n    address[] indexed markets,\r\n    MarketSide[] indexed marketSides,\r\n    address[] indexed rewardAccumulators\r\n  );\r\n  event BribesSet(address[] indexed rewardAccumulators, address[] indexed bribes);\r\n  event MaxVotingNumSet(uint256 indexed maxVotingNum);\r\n  event RewardAccumulatorAliveToggled(address indexed market, MarketSide indexed marketSide, bool isAlive);\r\n  event Initialized(address[] tokens, address mpo, address rewardToken, address ve, address governor);\r\n  event DistributionTimelockAliveToggled(bool isAlive);\r\n\r\n  /**\r\n   * @notice Get the weight of a market.\r\n   * @param market Address of the market.\r\n   * @param marketSide Side of the market.\r\n   * @param lpToken Address of the LP token.\r\n   * @return The weight of the market.\r\n   */\r\n  function weights(address market, MarketSide marketSide, address lpToken) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the votes for a token.\r\n   * @param tokenId ID of the token.\r\n   * @param market Address of the market.\r\n   * @param marketSide Side of the market.\r\n   * @param lpToken Address of the LP token.\r\n   * @return The votes for the token.\r\n   */\r\n  function votes(\r\n    uint256 tokenId,\r\n    address market,\r\n    MarketSide marketSide,\r\n    address lpToken\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the used weights for a token.\r\n   * @param tokenId ID of the token.\r\n   * @param lpToken Address of the LP token.\r\n   * @return The used weights for the token.\r\n   */\r\n  function usedWeights(uint256 tokenId, address lpToken) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the last voted timestamp for a token.\r\n   * @param tokenId ID of the token.\r\n   * @return The last voted timestamp for the token.\r\n   */\r\n  function lastVoted(uint256 tokenId) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Check if a token is whitelisted.\r\n   * @param token Address of the token.\r\n   * @return True if the token is whitelisted, false otherwise.\r\n   */\r\n  function isWhitelistedToken(address token) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Check if an NFT is whitelisted.\r\n   * @param tokenId ID of the token.\r\n   * @return True if the NFT is whitelisted, false otherwise.\r\n   */\r\n  function isWhitelistedNFT(uint256 tokenId) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get the address of the ve contract.\r\n   * @return The address of the ve contract.\r\n   */\r\n  function ve() external view returns (address);\r\n\r\n  /**\r\n   * @notice Get the address of the governor.\r\n   * @return The address of the governor.\r\n   */\r\n  function governor() external view returns (address);\r\n\r\n  /**\r\n   * @notice Update voting balances in voting rewards contracts.\r\n   * @param _tokenId ID of veNFT whose balance you wish to update.\r\n   */\r\n  function poke(uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Vote for pools. Votes distributed proportionally based on weights.\r\n   * @dev Can only vote or deposit into a managed NFT once per epoch.\r\n   *      Can only vote for gauges that have not been killed.\r\n   *      Throws if length of _poolVote and _weights do not match.\r\n   * @param _tokenId ID of veNFT you are voting with.\r\n   * @param _poolVote Array of pools you are voting for.\r\n   * @param _marketVoteSide Array of market vote sides you are voting for.\r\n   * @param _weights Weights of pools.\r\n   */\r\n  function vote(\r\n    uint256 _tokenId,\r\n    address[] calldata _poolVote,\r\n    MarketSide[] calldata _marketVoteSide,\r\n    uint256[] calldata _weights\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Reset voting state. Required if you wish to make changes to veNFT state.\r\n   * @dev Cannot reset in the same epoch that you voted in.\r\n   *      Can vote or deposit into a managed NFT again after reset.\r\n   * @param _tokenId ID of veNFT that you are resetting.\r\n   */\r\n  function reset(uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Distributes rewards to eligible markets.\r\n   */\r\n  function distributeRewards() external;\r\n\r\n  /**\r\n   * @notice Claim bribes for a given NFT.\r\n   * @dev Utility to help batch bribe claims.\r\n   * @param _bribes Array of BribeVotingReward contracts to collect from.\r\n   * @param _tokens Array of tokens that are used as bribes.\r\n   * @param _tokenId ID of veNFT that you wish to claim bribes for.\r\n   */\r\n  function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint256 _tokenId) external;\r\n\r\n  /**\r\n   * @notice Whitelist (or unwhitelist) token for use in bribes.\r\n   * @dev Throws if not called by governor.\r\n   * @param _token Address of the token.\r\n   * @param _bool Boolean indicating whitelist status.\r\n   */\r\n  function whitelistToken(address _token, bool _bool) external;\r\n\r\n  /**\r\n   * @notice Whitelist (or unwhitelist) token id for voting in last hour prior to epoch flip.\r\n   * @dev Throws if not called by governor.\r\n   *      Throws if already whitelisted.\r\n   * @param _tokenId ID of the token.\r\n   * @param _bool Boolean indicating whitelist status.\r\n   */\r\n  function whitelistNFT(uint256 _tokenId, bool _bool) external;\r\n\r\n  /**\r\n   * @notice Set the LP tokens.\r\n   * @param _lpTokens Array of LP token addresses.\r\n   */\r\n  function setLpTokens(address[] memory _lpTokens) external;\r\n\r\n  /**\r\n   * @notice Set the Master Price Oracle (MPO) address.\r\n   * @param _mpo Address of the Master Price Oracle.\r\n   */\r\n  function setMpo(address _mpo) external;\r\n\r\n  /**\r\n   * @notice Set a new governor.\r\n   * @param _governor Address of the new governor.\r\n   */\r\n  function setGovernor(address _governor) external;\r\n\r\n  /**\r\n   * @notice Add new markets.\r\n   * @param _markets Array of Market structs to be added.\r\n   */\r\n  function addMarkets(Market[] calldata _markets) external;\r\n\r\n  /**\r\n   * @notice Set reward accumulators for markets.\r\n   * @param _markets Array of market addresses.\r\n   * @param _marketSides Array of market sides.\r\n   * @param _rewardAccumulators Array of reward accumulator addresses.\r\n   */\r\n  function setMarketRewardAccumulators(\r\n    address[] calldata _markets,\r\n    MarketSide[] calldata _marketSides,\r\n    address[] calldata _rewardAccumulators\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Set bribes for reward accumulators.\r\n   * @param _rewardAccumulators Array of reward accumulator addresses.\r\n   * @param _bribes Array of bribe addresses.\r\n   */\r\n  function setBribes(address[] calldata _rewardAccumulators, address[] calldata _bribes) external;\r\n\r\n  /**\r\n   * @notice Set the maximum number of votes.\r\n   * @param _maxVotingNum Maximum number of votes allowed.\r\n   */\r\n  function setMaxVotingNum(uint256 _maxVotingNum) external;\r\n\r\n  /**\r\n   * @notice Toggle the alive status of a reward accumulator.\r\n   * @param _market Address of the market.\r\n   * @param _marketSide Side of the market.\r\n   * @param _isAlive Boolean indicating if the reward accumulator is alive.\r\n   */\r\n  function toggleRewardAccumulatorAlive(address _market, MarketSide _marketSide, bool _isAlive) external;\r\n\r\n  /**\r\n   * @notice Toggle the alive status of a timelock on distributing rewards.\r\n   * @param _isAlive Boolean indicating if the timelock is alive.\r\n   */\r\n  function toggleDistributionTimelockAlive(bool _isAlive) external;\r\n\r\n  /**\r\n   * @notice Get the start of the epoch for a given timestamp.\r\n   * @param _timestamp The timestamp to calculate the epoch start for.\r\n   * @return The start of the epoch.\r\n   */\r\n  function epochStart(uint256 _timestamp) external pure returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the next epoch for a given timestamp.\r\n   * @param _timestamp The timestamp to calculate the next epoch for.\r\n   * @return The next epoch.\r\n   */\r\n  function epochNext(uint256 _timestamp) external pure returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the start of the voting period for a given timestamp.\r\n   * @param _timestamp The timestamp to calculate the voting start for.\r\n   * @return The start of the voting period.\r\n   */\r\n  function epochVoteStart(uint256 _timestamp) external pure returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the end of the voting period for a given timestamp.\r\n   * @param _timestamp The timestamp to calculate the voting end for.\r\n   * @return The end of the voting period.\r\n   */\r\n  function epochVoteEnd(uint256 _timestamp) external pure returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the number of markets.\r\n   * @return The number of markets.\r\n   */\r\n  function marketsLength() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get all LP reward tokens.\r\n   * @return An array of addresses representing all LP reward tokens.\r\n   */\r\n  function getAllLpRewardTokens() external view returns (address[] memory);\r\n\r\n  /**\r\n   * @notice Get vote details for a specific token ID and LP asset.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpAsset The address of the LP asset.\r\n   * @return A struct containing vote details.\r\n   */\r\n  function getVoteDetails(uint256 _tokenId, address _lpAsset) external view returns (VoteDetails memory);\r\n\r\n  function getHistoricalPrice(address _lpToken, uint256 _epochTimestamp) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/veION/libraries/BalanceLogicLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"../interfaces/IveIONStructsEnumsErrorsEvents.sol\";\r\n\r\nlibrary BalanceLogicLibrary {\r\n  uint256 internal constant _WEEK = 1 weeks;\r\n\r\n  /// @notice Calculates the voting power for a given NFT at a specific time.\r\n  /// @dev This function is compatible with the ERC20 `balanceOf` interface for Aragon.\r\n  ///      It retrieves the last user point before a specified timestamp and computes the voting power at that time.\r\n  /// @param s_userPointEpoch Mapping of user point epochs for all tokens.\r\n  /// @param s_userPointHistory Mapping of user point history for all tokens.\r\n  /// @param _lpType The type of LP token associated with the NFT.\r\n  /// @param _tokenId The ID of the NFT for which to calculate voting power.\r\n  /// @param _t The epoch time at which to calculate the voting power.\r\n  /// @param _isPermanent A boolean indicating if the lock is permanent.\r\n  /// @return The calculated voting power of the user at the specified time.\r\n  function balanceOfNFTAt(\r\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => uint256)) storage s_userPointEpoch,\r\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => IveIONStructsEnumsErrorsEvents.UserPoint[1000000000]))\r\n      storage s_userPointHistory,\r\n    IveIONStructsEnumsErrorsEvents.LpTokenType _lpType,\r\n    uint256 _tokenId,\r\n    uint256 _t,\r\n    bool _isPermanent\r\n  ) internal view returns (uint256) {\r\n    uint256 _epoch = getPastUserPointIndex(s_userPointEpoch, s_userPointHistory, _lpType, _tokenId, _t);\r\n    // epoch 0 is an empty point\r\n    if (_epoch == 0) return 0;\r\n    IveIONStructsEnumsErrorsEvents.UserPoint memory lastPoint = s_userPointHistory[_tokenId][_lpType][_epoch];\r\n    if (_isPermanent) {\r\n      return lastPoint.permanent + lastPoint.permanentDelegate;\r\n    } else {\r\n      uint256 reduction = lastPoint.slope * (_t - lastPoint.ts);\r\n      if (reduction > lastPoint.bias) {\r\n        lastPoint.bias = 0;\r\n      } else {\r\n        lastPoint.bias -= reduction;\r\n      }\r\n      return lastPoint.bias;\r\n    }\r\n  }\r\n\r\n  /// @notice Binary search to get the user point index for a token id at or prior to a given timestamp\r\n  /// @dev If a user point does not exist prior to the timestamp, this will return 0.\r\n  /// @param s_userPointEpoch State of all user point epochs\r\n  /// @param s_userPointHistory State of all user point history\r\n  /// @param _tokenId .\r\n  /// @param _timestamp .\r\n  /// @return User point index\r\n  function getPastUserPointIndex(\r\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => uint256)) storage s_userPointEpoch,\r\n    mapping(uint256 => mapping(IveIONStructsEnumsErrorsEvents.LpTokenType => IveIONStructsEnumsErrorsEvents.UserPoint[1000000000]))\r\n      storage s_userPointHistory,\r\n    IveIONStructsEnumsErrorsEvents.LpTokenType _lpType,\r\n    uint256 _tokenId,\r\n    uint256 _timestamp\r\n  ) internal view returns (uint256) {\r\n    uint256 _userEpoch = s_userPointEpoch[_tokenId][_lpType];\r\n    if (_userEpoch == 0) return 0;\r\n    // First check most recent balance\r\n    if (s_userPointHistory[_tokenId][_lpType][_userEpoch].ts <= _timestamp) return (_userEpoch);\r\n    // Next check implicit zero balance\r\n    if (s_userPointHistory[_tokenId][_lpType][1].ts > _timestamp) return 0;\r\n    uint256 lower = 0;\r\n    uint256 upper = _userEpoch;\r\n    while (upper > lower) {\r\n      uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n      IveIONStructsEnumsErrorsEvents.UserPoint storage userPoint = s_userPointHistory[_tokenId][_lpType][center];\r\n      if (userPoint.ts == _timestamp) {\r\n        return center;\r\n      } else if (userPoint.ts < _timestamp) {\r\n        lower = center;\r\n      } else {\r\n        upper = center - 1;\r\n      }\r\n    }\r\n    return lower;\r\n  }\r\n}\r\n"
    },
    "contracts/veION/libraries/IonicTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nlibrary IonicTimeLibrary {\r\n  uint256 internal constant _WEEK = 7 days;\r\n\r\n  /// @dev Returns start of epoch based on current timestamp\r\n  function epochStart(uint256 timestamp) internal pure returns (uint256) {\r\n    unchecked {\r\n      return timestamp - (timestamp % _WEEK);\r\n    }\r\n  }\r\n\r\n  /// @dev Returns start of next epoch / end of current epoch\r\n  function epochNext(uint256 timestamp) internal pure returns (uint256) {\r\n    unchecked {\r\n      return timestamp - (timestamp % _WEEK) + _WEEK;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns start of voting window\r\n  function epochVoteStart(uint256 timestamp) internal pure returns (uint256) {\r\n    unchecked {\r\n      return timestamp - (timestamp % _WEEK) + 1 hours;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns end of voting window / beginning of unrestricted voting window\r\n  function epochVoteEnd(uint256 timestamp) internal pure returns (uint256) {\r\n    unchecked {\r\n      return timestamp - (timestamp % _WEEK) + _WEEK - 12 hours;\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/veION/stake/IStakeStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\n/**\r\n * @title IStakeStrategy\r\n * @notice Interface for the VeloIonModeStakingModeReward contract.\r\n */\r\ninterface IStakeStrategy {\r\n  /// @notice Emitted when the contract is initialized\r\n  event Initialized(\r\n    address indexed escrow,\r\n    address indexed stakingToken,\r\n    address indexed stakingContract,\r\n    address stakingWalletImplementation\r\n  );\r\n\r\n  /// @notice Emitted when tokens are staked\r\n  event Staked(address indexed from, uint256 amount, address indexed veloWallet);\r\n\r\n  /// @notice Emitted when rewards are claimed\r\n  event Claimed(address indexed from, address indexed veloWallet);\r\n\r\n  /// @notice Emitted when tokens are withdrawn\r\n  event Withdrawn(address indexed owner, address indexed withdrawTo, uint256 amount);\r\n\r\n  /// @notice Emitted when staking wallet is transferred\r\n  event StakingWalletTransferred(address indexed from, address indexed to, uint256 amount);\r\n\r\n  /// @notice Emitted when escrow is set\r\n  event EscrowSet(address indexed newEscrow);\r\n\r\n  /// @notice Emitted when staking token is set\r\n  event StakingTokenSet(address indexed newStakingToken);\r\n\r\n  /// @notice Emitted when staking contract is set\r\n  event StakingContractSet(address indexed newStakingContract);\r\n\r\n  /// @notice Emitted when upgradeable beacon is set\r\n  event UpgradeableBeaconSet(address indexed newBeacon);\r\n\r\n  /**\r\n   * @notice Stakes a specified amount of tokens from a given address.\r\n   * @param _from The address from which tokens will be staked.\r\n   * @param _amount The amount of tokens to stake.\r\n   * @param _data Additional data that might be needed for staking.\r\n   */\r\n  function stake(address _from, uint256 _amount, bytes memory _data) external;\r\n\r\n  /**\r\n   * @notice Claims rewards for a given address.\r\n   * @param _from The address for which to claim rewards.\r\n   */\r\n  function claim(address _from) external;\r\n\r\n  /**\r\n   * @notice Withdraws a specified amount of tokens for a given address.\r\n   * @param _owner The address from which tokens will be withdrawn.\r\n   * @param _amount The amount of tokens to withdraw.\r\n   */\r\n  function withdraw(address _owner, address _withdrawTo, uint256 _amount) external;\r\n\r\n  /**\r\n   * @notice Returns the current reward rate for the staking strategy.\r\n   * @return The reward rate as a uint256.\r\n   */\r\n  function rewardRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the period finish time for the staking strategy.\r\n   * @return The period finish time as a uint256.\r\n   */\r\n  function periodFinish() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the balance of a specific address.\r\n   * @param account The address to query the balance of.\r\n   * @return The balance as a uint256.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the total supply of staked tokens.\r\n   * @return The total supply as a uint256.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the address of the reward token for the staking strategy.\r\n   * @return The address of the reward token.\r\n   */\r\n  function rewardToken() external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the address of the staking contract.\r\n   * @return The address of the staking contract.\r\n   */\r\n  function stakingContract() external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the address of the staking token.\r\n   * @return The address of the staking token.\r\n   */\r\n  function stakingToken() external view returns (address);\r\n\r\n  /**\r\n   * @notice Returns the staking wallet address for a specific user.\r\n   * @param user The address of the user.\r\n   * @return The address of the user's staking wallet.\r\n   */\r\n  function userStakingWallet(address user) external view returns (address);\r\n\r\n  /**\r\n   * @notice Transfers the staking wallet from one user to another.\r\n   * @param from The current owner of the staking wallet.\r\n   * @param to The new owner of the staking wallet.\r\n   */\r\n  function transferStakingWallet(address from, address to, uint256 _amount) external;\r\n\r\n  /**\r\n   * @notice Sets the escrow address.\r\n   * @param _escrow The address of the new escrow.\r\n   */\r\n  function setEscrow(address _escrow) external;\r\n\r\n  /**\r\n   * @notice Sets the staking token address.\r\n   * @param _stakingToken The address of the new staking token.\r\n   */\r\n  function setStakingToken(address _stakingToken) external;\r\n\r\n  /**\r\n   * @notice Sets the staking contract address.\r\n   * @param _stakingContract The address of the new staking contract.\r\n   */\r\n  function setStakingContract(address _stakingContract) external;\r\n\r\n  /**\r\n   * @notice Sets the address of the  beacon.\r\n   * @param _beacon The address of the new beacon contract.\r\n   */\r\n  function setUpgradeableBeacon(address _beacon) external;\r\n}\r\n"
    },
    "contracts/veION/veION.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { IveIONCore, IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IVoter } from \"./interfaces/IVoter.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { veIONStorage } from \"./veIONStorage.sol\";\r\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\r\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\r\n\r\n/**\r\n * @title veION Contract\r\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\r\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n */\r\ncontract veION is Ownable2StepUpgradeable, ERC721Upgradeable, ReentrancyGuardUpgradeable, veIONStorage, IveIONCore {\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using SafeERC20 for IERC20;\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes the veION contract with the given AddressesProvider.\r\n   * @dev This function is called only once during the contract deployment.\r\n   * It initializes the Ownable, ERC721, and ReentrancyGuard modules.\r\n   * @param _ap The AddressesProvider contract used for address management.\r\n   */\r\n  function initialize(IAddressesProvider _ap) public initializer {\r\n    __Ownable2Step_init();\r\n    __ERC721_init(\"veION\", \"veION\");\r\n    __ReentrancyGuard_init();\r\n    ap = _ap;\r\n    emit Initialized(address(_ap));\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           External Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function createLockFor(\r\n    address[] calldata _tokenAddress,\r\n    uint256[] calldata _tokenAmount,\r\n    uint256[] calldata _duration,\r\n    bool[] memory _stakeUnderlying,\r\n    address _to\r\n  ) external override nonReentrant returns (uint256) {\r\n    return _createLock(_tokenAddress, _tokenAmount, _duration, _stakeUnderlying, _to);\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function createLock(\r\n    address[] calldata _tokenAddress,\r\n    uint256[] calldata _tokenAmount,\r\n    uint256[] calldata _duration,\r\n    bool[] memory _stakeUnderlying\r\n  ) external override nonReentrant returns (uint256) {\r\n    return _createLock(_tokenAddress, _tokenAmount, _duration, _stakeUnderlying, _msgSender());\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function increaseAmount(\r\n    address _tokenAddress,\r\n    uint256 _tokenId,\r\n    uint256 _tokenAmount,\r\n    bool _stakeUnderlying\r\n  ) external nonReentrant {\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\r\n\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (_tokenAmount == 0) revert ZeroAmount();\r\n    if (oldLocked.amount == 0) revert NoLockFound();\r\n    if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent) revert LockExpired();\r\n\r\n    if (oldLocked.isPermanent) s_permanentLockBalance[_lpType] += _tokenAmount;\r\n\r\n    _depositFor(\r\n      _tokenAddress,\r\n      _tokenId,\r\n      _tokenAmount,\r\n      0,\r\n      _stakeUnderlying,\r\n      oldLocked,\r\n      DepositType.INCREASE_LOCK_AMOUNT,\r\n      _lpType,\r\n      _msgSender()\r\n    );\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function lockAdditionalAsset(\r\n    address _tokenAddress,\r\n    uint256 _tokenAmount,\r\n    uint256 _tokenId,\r\n    uint256 _duration,\r\n    bool _stakeUnderlying\r\n  ) external nonReentrant {\r\n    LpTokenType lpType = s_lpType[_tokenAddress];\r\n    LockedBalance storage lockedBalance = s_locked[_tokenId][lpType];\r\n    uint256 unlockTime = ((block.timestamp + _duration) / _WEEK) * _WEEK;\r\n\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (_tokenAmount == 0) revert ZeroAmount();\r\n    if (s_voted[_tokenId]) revert AlreadyVoted();\r\n    if (!s_assetsLocked[_tokenId].add(_tokenAddress)) revert DuplicateAsset();\r\n    if (_tokenAmount < s_minimumLockAmount[lpType]) revert MinimumNotMet();\r\n    if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\r\n    if (_duration < s_minimumLockDuration) revert LockDurationTooShort();\r\n\r\n    if (lockedBalance.isPermanent) s_permanentLockBalance[lpType] += _tokenAmount;\r\n\r\n    _depositFor(\r\n      _tokenAddress,\r\n      _tokenId,\r\n      _tokenAmount,\r\n      unlockTime,\r\n      _stakeUnderlying,\r\n      lockedBalance,\r\n      DepositType.LOCK_ADDITIONAL,\r\n      lpType,\r\n      _msgSender()\r\n    );\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function increaseUnlockTime(address _tokenAddress, uint256 _tokenId, uint256 _lockDuration) external nonReentrant {\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\r\n    uint256 unlockTime = ((block.timestamp + _lockDuration) / _WEEK) * _WEEK; // Locktime is rounded down to weeks\r\n\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (oldLocked.isPermanent) revert PermanentLock();\r\n    if (oldLocked.end <= block.timestamp) revert LockExpired();\r\n    if (oldLocked.amount <= 0) revert NoLockFound();\r\n    if (unlockTime <= oldLocked.end) revert LockDurationNotInFuture();\r\n    if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\r\n\r\n    _depositFor(\r\n      _tokenAddress,\r\n      _tokenId,\r\n      0,\r\n      unlockTime,\r\n      false,\r\n      oldLocked,\r\n      DepositType.INCREASE_UNLOCK_TIME,\r\n      _lpType,\r\n      _msgSender()\r\n    );\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function delegate(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) external nonReentrant {\r\n    LpTokenType lpType = s_lpType[lpToken];\r\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\r\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\r\n\r\n    if (ownerOf(fromTokenId) != _msgSender()) revert NotOwner();\r\n    if (amount > fromLocked.amount) revert AmountTooBig();\r\n    if (!fromLocked.isPermanent) revert NotPermanentLock();\r\n    if (!toLocked.isPermanent) revert NotPermanentLock();\r\n    if (s_delegatorsBlocked[toTokenId][lpToken]) revert NotAcceptingDelegators();\r\n\r\n    fromLocked.amount -= amount;\r\n    toLocked.delegateAmount += amount;\r\n\r\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\r\n      s_delegatees[fromTokenId][lpType].add(toTokenId);\r\n      s_delegators[toTokenId][lpType].add(fromTokenId);\r\n    }\r\n\r\n    s_delegations[fromTokenId][toTokenId][lpType] += amount;\r\n\r\n    s_locked[fromTokenId][lpType] = fromLocked;\r\n    s_locked[toTokenId][lpType] = toLocked;\r\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\r\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\r\n\r\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\r\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\r\n\r\n    emit Delegated(fromTokenId, toTokenId, lpToken, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a delegation between two veNFTs.\r\n   * @param fromTokenId ID of the veNFT from which delegation is being removed.\r\n   * @param toTokenId ID of the veNFT to which delegation is being removed.\r\n   * @param lpToken Address of the LP token associated with the delegation.\r\n   * @param amount Amount of delegation to remove.\r\n   */\r\n  function _removeDelegation(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) internal {\r\n    LpTokenType lpType = s_lpType[lpToken];\r\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\r\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\r\n\r\n    if (ownerOf(fromTokenId) != _msgSender() && ownerOf(toTokenId) != _msgSender()) revert NotOwner();\r\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) revert NoDelegationBetweenTokens(fromTokenId, toTokenId);\r\n\r\n    amount = amount > s_delegations[fromTokenId][toTokenId][lpType]\r\n      ? s_delegations[fromTokenId][toTokenId][lpType]\r\n      : amount;\r\n\r\n    toLocked.delegateAmount -= amount;\r\n    fromLocked.amount += amount;\r\n\r\n    s_delegations[fromTokenId][toTokenId][lpType] -= amount;\r\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\r\n      s_delegatees[fromTokenId][lpType].remove(toTokenId);\r\n      s_delegators[toTokenId][lpType].remove(fromTokenId);\r\n    }\r\n\r\n    s_locked[toTokenId][lpType] = toLocked;\r\n    s_locked[fromTokenId][lpType] = fromLocked;\r\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\r\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\r\n\r\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\r\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\r\n\r\n    emit DelegationRemoved(fromTokenId, toTokenId, lpToken, amount);\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function removeDelegatees(\r\n    uint256 fromTokenId,\r\n    uint256[] memory toTokenIds,\r\n    address lpToken,\r\n    uint256[] memory amounts\r\n  ) public nonReentrant {\r\n    if (toTokenIds.length != amounts.length) revert ArrayMismatch();\r\n    uint256 toTokenIdsLength = toTokenIds.length;\r\n    for (uint256 i = 0; i < toTokenIdsLength; i++) {\r\n      _removeDelegation(fromTokenId, toTokenIds[i], lpToken, amounts[i]);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function removeDelegators(\r\n    uint256[] memory fromTokenIds,\r\n    uint256 toTokenId,\r\n    address lpToken,\r\n    uint256[] memory amounts\r\n  ) external nonReentrant {\r\n    if (fromTokenIds.length != amounts.length) revert ArrayMismatch();\r\n    uint256 fromTokenIdsLength = fromTokenIds.length;\r\n    for (uint256 i = 0; i < fromTokenIdsLength; i++) {\r\n      _removeDelegation(fromTokenIds[i], toTokenId, lpToken, amounts[i]);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function lockPermanent(address _tokenAddress, uint256 _tokenId) external nonReentrant {\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory _newLocked = s_locked[_tokenId][_lpType];\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (_newLocked.isPermanent) revert PermanentLock();\r\n    if (_newLocked.end <= block.timestamp) revert LockExpired();\r\n    if (_newLocked.amount <= 0) revert NoLockFound();\r\n\r\n    s_permanentLockBalance[_lpType] += _newLocked.amount;\r\n    _newLocked.end = 0;\r\n    _newLocked.isPermanent = true;\r\n    _newLocked.boost = _calculateBoost(_MAXTIME);\r\n\r\n    s_locked[_tokenId][_lpType] = _newLocked;\r\n    _checkpoint(_tokenId, _newLocked, _lpType);\r\n\r\n    emit PermanentLockCreated(_tokenAddress, _tokenId, _newLocked.amount);\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function unlockPermanent(address _tokenAddress, uint256 _tokenId) external nonReentrant {\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory _newLocked = s_locked[_tokenId][_lpType];\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (!_newLocked.isPermanent) revert NotPermanentLock();\r\n    if (s_delegatees[_tokenId][_lpType].length() != 0) revert TokenHasDelegatees();\r\n    if (s_delegators[_tokenId][_lpType].length() != 0) revert TokenHasDelegators();\r\n\r\n    s_permanentLockBalance[_lpType] -= _newLocked.amount;\r\n    _newLocked.end = ((block.timestamp + _MAXTIME) / _WEEK) * _WEEK;\r\n    _newLocked.isPermanent = false;\r\n\r\n    s_locked[_tokenId][_lpType] = _newLocked;\r\n    _checkpoint(_tokenId, _newLocked, _lpType);\r\n\r\n    emit PermanentLockRemoved(_tokenAddress, _tokenId, _newLocked.amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Overrides the _burn function from ERC721 to include additional logic for bridging.\r\n   * @param tokenId Token ID to burn.\r\n   */\r\n  function _burn(uint256 tokenId) internal override {\r\n    super._burn(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice Hook that is called before any token transfer. This includes minting\r\n   * and burning. It updates the ownership mappings and handles delegation and\r\n   * staking logic when transferring tokens between addresses.\r\n   *\r\n   * @param from The address which previously owned the token.\r\n   * @param to The address that will receive the token.\r\n   * @param tokenId The ID of the token being transferred.\r\n   */\r\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {\r\n    super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n    if (from != address(0)) s_ownerToTokenIds[from].remove(tokenId);\r\n    if (to != address(0)) s_ownerToTokenIds[to].add(tokenId);\r\n\r\n    if (from != address(0) && to != address(0)) {\r\n      address[] memory assetsLocked = s_assetsLocked[tokenId].values();\r\n      uint256 assetsLockedLength = assetsLocked.length;\r\n      for (uint256 i = 0; i < assetsLockedLength; i++) {\r\n        address asset = assetsLocked[i];\r\n        LpTokenType _lpType = s_lpType[asset];\r\n\r\n        uint256[] memory delegatees = s_delegatees[tokenId][_lpType].values();\r\n        uint256[] memory amounts = new uint256[](delegatees.length);\r\n        uint256 delegateesLength = delegatees.length;\r\n        for (uint256 j = 0; j < delegateesLength; j++) {\r\n          amounts[j] = type(uint256).max;\r\n        }\r\n\r\n        if (delegateesLength != 0) {\r\n          removeDelegatees(tokenId, delegatees, asset, amounts);\r\n        }\r\n\r\n        uint256 amountStaked = s_underlyingStake[tokenId][asset];\r\n        if (amountStaked != 0) {\r\n          IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\r\n          _stakeStrategy.transferStakingWallet(from, to, amountStaked);\r\n        }\r\n\r\n        LockedBalance memory lock = s_locked[tokenId][_lpType];\r\n        s_userCumulativeAssetValues[from][asset] -= lock.amount;\r\n        s_userCumulativeAssetValues[to][asset] += lock.amount;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function voting(uint256 _tokenId, bool _voting) external {\r\n    if (_msgSender() != s_voter) revert NotVoter();\r\n    s_voted[_tokenId] = _voting;\r\n    emit Voted(_tokenId, _voting);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Internal Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  struct DepositVars {\r\n    uint256 supplyBefore;\r\n    uint256 totalLockTime;\r\n    LockedBalance newLocked;\r\n    address from;\r\n  }\r\n\r\n  /**\r\n   * @notice Deposits tokens for a specific veNFT, updating its locked balance and boost.\r\n   * @dev This function handles the deposit logic for veNFTs, including updating the locked balance,\r\n   *      calculating the boost based on the lock duration, and transferring tokens.\r\n   * @param _tokenAddress The address of the token to deposit.\r\n   * @param _tokenId The ID of the veNFT to deposit tokens for.\r\n   * @param _tokenAmount The amount of tokens to deposit.\r\n   * @param _unlockTime The time at which the lock will expire.\r\n   * @param _stakeUnderlying A boolean indicating whether to stake the underlying tokens.\r\n   * @param _oldLocked The previous locked balance of the veNFT.\r\n   * @param _depositType The type of deposit being made.\r\n   * @param _lpType The LP token type associated with the deposit.\r\n   * @param _to The address to which the veNFT is assigned.\r\n   */\r\n  function _depositFor(\r\n    address _tokenAddress,\r\n    uint256 _tokenId,\r\n    uint256 _tokenAmount,\r\n    uint256 _unlockTime,\r\n    bool _stakeUnderlying,\r\n    LockedBalance memory _oldLocked,\r\n    DepositType _depositType,\r\n    LpTokenType _lpType,\r\n    address _to\r\n  ) internal {\r\n    if (!s_whitelistedToken[_tokenAddress]) revert TokenNotWhitelisted();\r\n\r\n    DepositVars memory vars;\r\n    vars.supplyBefore = s_supply[_lpType];\r\n    s_supply[_lpType] = vars.supplyBefore + _tokenAmount;\r\n\r\n    (\r\n      vars.newLocked.tokenAddress,\r\n      vars.newLocked.amount,\r\n      vars.newLocked.start,\r\n      vars.newLocked.end,\r\n      vars.newLocked.isPermanent,\r\n      vars.newLocked.boost\r\n    ) = (\r\n      _oldLocked.tokenAddress,\r\n      _oldLocked.amount,\r\n      _oldLocked.start,\r\n      _oldLocked.end,\r\n      _oldLocked.isPermanent,\r\n      _oldLocked.boost\r\n    );\r\n\r\n    vars.newLocked.tokenAddress = _tokenAddress;\r\n    vars.newLocked.amount += _tokenAmount;\r\n    if (_unlockTime != 0) {\r\n      if (vars.newLocked.start == 0) vars.newLocked.start = block.timestamp;\r\n      vars.newLocked.end = _unlockTime;\r\n      vars.totalLockTime = vars.newLocked.end - vars.newLocked.start;\r\n      vars.newLocked.boost = _calculateBoost(vars.totalLockTime);\r\n    }\r\n    s_locked[_tokenId][_lpType] = vars.newLocked;\r\n\r\n    _checkpoint(_tokenId, vars.newLocked, _lpType);\r\n\r\n    vars.from = _msgSender();\r\n    if (_tokenAmount != 0) {\r\n      s_userCumulativeAssetValues[ownerOf(_tokenId)][_tokenAddress] += _tokenAmount;\r\n      IERC20(_tokenAddress).safeTransferFrom(vars.from, address(this), _tokenAmount);\r\n      (IStakeStrategy _stakeStrategy, bytes memory _stakeData) = _getStakeStrategy(_lpType);\r\n      if (address(_stakeStrategy) != address(0) && _stakeUnderlying) {\r\n        _handleTokenStake(_to, _tokenId, _tokenAddress, _tokenAmount, _stakeStrategy, _stakeData);\r\n      }\r\n    }\r\n\r\n    emit Deposit(_to, _tokenId, _depositType, _tokenAmount, vars.newLocked.end, block.timestamp);\r\n    emit Supply(vars.supplyBefore, s_supply[_lpType]);\r\n  }\r\n\r\n  /**\r\n   * @notice Handles the staking of tokens using a specified staking strategy.\r\n   * @param _to The address to which the stake is attributed.\r\n   * @param _tokenId The ID of the token being staked.\r\n   * @param _tokenAddress The address of the token being staked.\r\n   * @param _tokenAmount The amount of tokens to stake.\r\n   * @param _stakeStrategy The staking strategy to use.\r\n   * @param _stakeData Additional data required for staking.\r\n   */\r\n  function _handleTokenStake(\r\n    address _to,\r\n    uint256 _tokenId,\r\n    address _tokenAddress,\r\n    uint256 _tokenAmount,\r\n    IStakeStrategy _stakeStrategy,\r\n    bytes memory _stakeData\r\n  ) internal {\r\n    IERC20(_tokenAddress).approve(address(_stakeStrategy), _tokenAmount);\r\n    _stakeStrategy.stake(_to, _tokenAmount, _stakeData);\r\n    s_underlyingStake[_tokenId][_tokenAddress] += _tokenAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Updates the user point history and epoch for a given token and LP token type.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _newLocked The new locked balance information.\r\n   * @param _lpType The LP token type.\r\n   */\r\n  function _checkpoint(uint256 _tokenId, LockedBalance memory _newLocked, LpTokenType _lpType) internal {\r\n    UserPoint memory uNew;\r\n    uNew.permanent = _newLocked.isPermanent ? _newLocked.amount : 0;\r\n    uNew.permanentDelegate = _newLocked.isPermanent ? _newLocked.delegateAmount : 0;\r\n\r\n    if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\r\n      uNew.slope = _newLocked.amount / _MAXTIME;\r\n      uNew.bias = uNew.slope * (_newLocked.end - block.timestamp);\r\n    }\r\n\r\n    uNew.ts = block.timestamp;\r\n    uNew.blk = block.number;\r\n    uint256 userEpoch = s_userPointEpoch[_tokenId][_lpType];\r\n    if (userEpoch != 0 && s_userPointHistory[_tokenId][_lpType][userEpoch].ts == block.timestamp) {\r\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\r\n    } else {\r\n      s_userPointEpoch[_tokenId][_lpType] = ++userEpoch;\r\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a lock for multiple tokens with specified durations and staking options.\r\n   * @param _tokenAddress Array of token addresses to lock.\r\n   * @param _tokenAmount Array of token amounts to lock.\r\n   * @param _duration Array of durations for each lock.\r\n   * @param _stakeUnderlying Array of booleans indicating whether to stake the underlying tokens.\r\n   * @param _to The address to which the lock is attributed.\r\n   * @return The ID of the newly created lock.\r\n   */\r\n  function _createLock(\r\n    address[] memory _tokenAddress,\r\n    uint256[] memory _tokenAmount,\r\n    uint256[] memory _duration,\r\n    bool[] memory _stakeUnderlying,\r\n    address _to\r\n  ) internal returns (uint256) {\r\n    uint256 _tokenId = ++s_tokenId;\r\n    uint256 _length = _tokenAddress.length;\r\n    _safeMint(_to, _tokenId);\r\n\r\n    if (\r\n      _tokenAddress.length != _tokenAmount.length ||\r\n      _tokenAmount.length != _duration.length ||\r\n      _duration.length != _stakeUnderlying.length\r\n    ) {\r\n      revert ArrayMismatch();\r\n    }\r\n\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      LpTokenType _lpType = s_lpType[_tokenAddress[i]];\r\n      uint256 unlockTime = ((block.timestamp + _duration[i]) / _WEEK) * _WEEK;\r\n\r\n      if (!s_assetsLocked[_tokenId].add(_tokenAddress[i])) revert DuplicateAsset();\r\n      if (_tokenAmount[i] == 0) revert ZeroAmount();\r\n      if (_duration[i] < s_minimumLockDuration) revert LockDurationTooShort();\r\n      if (unlockTime > block.timestamp + _MAXTIME) revert LockDurationTooLong();\r\n      if (_tokenAmount[i] < s_minimumLockAmount[_lpType]) revert MinimumNotMet();\r\n\r\n      _depositFor(\r\n        _tokenAddress[i],\r\n        _tokenId,\r\n        _tokenAmount[i],\r\n        unlockTime,\r\n        _stakeUnderlying[i],\r\n        s_locked[_tokenId][_lpType],\r\n        DepositType.CREATE_LOCK_TYPE,\r\n        _lpType,\r\n        _to\r\n      );\r\n    }\r\n    return _tokenId;\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the boost for a given lock duration.\r\n   * @param _duration The duration of the lock.\r\n   * @return The calculated boost value.\r\n   */\r\n  function _calculateBoost(uint256 _duration) internal view returns (uint256) {\r\n    uint256 minDuration = s_minimumLockDuration;\r\n    uint256 maxDuration = _MAXTIME;\r\n    uint256 minBoost = 1e18;\r\n    uint256 maxBoost = 2e18;\r\n\r\n    if (_duration <= minDuration) {\r\n      return minBoost;\r\n    } else if (_duration >= maxDuration) {\r\n      return maxBoost;\r\n    } else {\r\n      return minBoost + ((_duration - minDuration) * (maxBoost - minBoost)) / (maxDuration - minDuration);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the staking strategy and data for a given LP token type.\r\n   * @param _lpType The LP token type.\r\n   * @return _stakeStrategy The staking strategy for the LP token type.\r\n   * @return _stakeData The staking data for the LP token type.\r\n   */\r\n  function _getStakeStrategy(\r\n    LpTokenType _lpType\r\n  ) internal view returns (IStakeStrategy _stakeStrategy, bytes memory _stakeData) {\r\n    IStakeStrategy strategy = s_stakeStrategy[_lpType];\r\n    return (strategy, \"\");\r\n  }\r\n\r\n  /// @inheritdoc IveIONCore\r\n  function setExtensions(address _veIONFirstExtension, address _veIONSecondExtension) external onlyOwner {\r\n    require(_veIONFirstExtension != address(0), \"Invalid First Extension Address\");\r\n    require(_veIONSecondExtension != address(0), \"Invalid Second Extension Address\");\r\n    require(_veIONFirstExtension != _veIONSecondExtension, \"Submitted Identical Addresses\");\r\n    veIONFirstExtension = _veIONFirstExtension;\r\n    veIONSecondExtension = _veIONSecondExtension;\r\n    emit ExtensionsSet(_veIONFirstExtension, _veIONSecondExtension);\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n   * function in the contract matches the call data.\r\n   */\r\n  fallback() external {\r\n    address impl = veIONFirstExtension;\r\n    require(impl != address(0), \"Implementation not set\");\r\n\r\n    assembly {\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n      let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\r\n\r\n      returndatacopy(0, 0, returndatasize())\r\n      switch result\r\n      case 0 {\r\n        revert(0, returndatasize())\r\n      }\r\n      default {\r\n        return(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/veION/veIONFirstExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IVoter } from \"./interfaces/IVoter.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { veIONStorage } from \"./veIONStorage.sol\";\r\nimport { BalanceLogicLibrary } from \"./libraries/BalanceLogicLibrary.sol\";\r\nimport { IveIONFirstExtension } from \"./interfaces/IveIONFirstExtension.sol\";\r\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\r\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\r\n\r\n/**\r\n * @title veION Contract First Extensions\r\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\r\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n */\r\ncontract veIONFirstExtension is\r\n  Ownable2StepUpgradeable,\r\n  ERC721Upgradeable,\r\n  ReentrancyGuardUpgradeable,\r\n  veIONStorage,\r\n  IveIONFirstExtension\r\n{\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using SafeERC20 for IERC20;\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           External Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function withdraw(address _tokenAddress, uint256 _tokenId) external nonReentrant {\r\n    address sender = _msgSender();\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory oldLocked = s_locked[_tokenId][_lpType];\r\n\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    if (s_voted[_tokenId]) revert AlreadyVoted();\r\n    if (oldLocked.isPermanent) revert PermanentLock();\r\n    if (!s_whitelistedToken[_tokenAddress]) revert TokenNotWhitelisted();\r\n    if (oldLocked.amount == 0 || !s_assetsLocked[_tokenId].contains(_tokenAddress)) revert NoLockFound();\r\n\r\n    uint256 value = oldLocked.amount;\r\n    s_userCumulativeAssetValues[sender][_tokenAddress] -= value;\r\n    uint256 fee = 0;\r\n\r\n    if (block.timestamp < oldLocked.end) {\r\n      uint256 daysLocked = ((oldLocked.end - oldLocked.start) * 1e18) / 1 days;\r\n      uint256 daysLeft = ((oldLocked.end - block.timestamp) * 1e18) / 1 days;\r\n      uint256 timeFactor = (daysLeft * 1e18) / daysLocked;\r\n      uint256 veLPLocked = s_supply[_lpType];\r\n      uint256 LPInCirculation = IERC20(_tokenAddress).totalSupply();\r\n      uint256 ratioFactor = 1e18 - (veLPLocked * 1e18) / LPInCirculation;\r\n      fee = (timeFactor * ratioFactor * oldLocked.boost) / 1e36;\r\n      if (fee > s_maxEarlyWithdrawFee) fee = s_maxEarlyWithdrawFee;\r\n      fee = (value * fee) / 1e18;\r\n      value -= fee;\r\n\r\n      uint256 feeToDistribute = (fee * 75) / 100;\r\n      uint256 feeToProtocol = fee - feeToDistribute;\r\n      s_protocolFees[_lpType] += feeToProtocol;\r\n      s_distributedFees[_lpType] += feeToDistribute;\r\n    }\r\n\r\n    s_locked[_tokenId][_lpType] = LockedBalance(address(0), 0, 0, 0, 0, false, 0);\r\n    s_assetsLocked[_tokenId].remove(_tokenAddress);\r\n    uint256 supplyBefore = s_supply[_lpType];\r\n\r\n    uint256 amountStaked = s_underlyingStake[_tokenId][_tokenAddress];\r\n    if (amountStaked != 0) {\r\n      (IStakeStrategy _stakeStrategy, ) = _getStakeStrategy(_lpType);\r\n      if (address(_stakeStrategy) != address(0)) {\r\n        _handleTokenWithdrawStake(sender, address(this), _tokenId, _tokenAddress, amountStaked, _stakeStrategy);\r\n      }\r\n    }\r\n\r\n    s_supply[_lpType] = supplyBefore - oldLocked.amount;\r\n    _checkpoint(_tokenId, LockedBalance(address(0), 0, 0, 0, 0, false, 0), _lpType);\r\n\r\n    // Check if all LP types for this token have zero balance\r\n    bool shouldBurn = true;\r\n    address[] memory lockedAssets = s_assetsLocked[_tokenId].values();\r\n    uint256 lockedAssetsLength = lockedAssets.length;\r\n    for (uint256 i = 0; i < lockedAssetsLength; i++) {\r\n      LpTokenType assetLpType = s_lpType[lockedAssets[i]];\r\n      if (s_locked[_tokenId][assetLpType].amount > 0) {\r\n        shouldBurn = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (shouldBurn) _burn(_tokenId);\r\n\r\n    IERC20(_tokenAddress).safeTransfer(sender, value);\r\n    emit Withdraw(sender, _tokenId, value, block.timestamp);\r\n    emit Supply(supplyBefore, supplyBefore - oldLocked.amount);\r\n  }\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function merge(uint256 _from, uint256 _to) external nonReentrant {\r\n    if (_from == _to) revert SameNFT();\r\n    if (s_voted[_from] || s_voted[_to]) revert AlreadyVoted();\r\n    if (ownerOf(_from) != _msgSender()) revert NotOwner();\r\n    if (ownerOf(_to) != _msgSender()) revert NotOwner();\r\n\r\n    address[] memory assetsLocked = s_assetsLocked[_from].values();\r\n    uint256 assetsLockedLength = assetsLocked.length;\r\n    for (uint256 i = 0; i < assetsLockedLength; i++) {\r\n      address asset = assetsLocked[i];\r\n      LpTokenType lpType = s_lpType[asset];\r\n\r\n      LockedBalance memory oldLockedTo = s_locked[_to][lpType];\r\n      LockedBalance memory oldLockedFrom = s_locked[_from][lpType];\r\n\r\n      if (oldLockedTo.end != 0 && oldLockedTo.end <= block.timestamp) revert LockExpired();\r\n      if (oldLockedFrom.end != 0 && oldLockedFrom.end <= block.timestamp) revert LockExpired();\r\n      if (oldLockedFrom.isPermanent) revert PermanentLock();\r\n      if (oldLockedTo.isPermanent) revert PermanentLock();\r\n\r\n      LockedBalance memory newLockedTo;\r\n\r\n      newLockedTo.tokenAddress = asset;\r\n      newLockedTo.amount = oldLockedTo.amount + oldLockedFrom.amount;\r\n      newLockedTo.start = oldLockedTo.start < oldLockedFrom.start && oldLockedTo.start != 0\r\n        ? oldLockedTo.start\r\n        : oldLockedFrom.start;\r\n      newLockedTo.end = oldLockedTo.end > oldLockedFrom.end ? oldLockedTo.end : oldLockedFrom.end;\r\n      newLockedTo.boost = _calculateBoost(newLockedTo.end - newLockedTo.start);\r\n\r\n      s_locked[_from][lpType] = LockedBalance(address(0), 0, 0, 0, 0, false, 0);\r\n      _checkpoint(_from, LockedBalance(address(0), 0, 0, 0, 0, false, 0), lpType);\r\n      s_locked[_to][lpType] = newLockedTo;\r\n      _checkpoint(_to, newLockedTo, lpType);\r\n\r\n      s_assetsLocked[_from].remove(asset);\r\n      if (!s_assetsLocked[_to].contains(asset)) {\r\n        s_assetsLocked[_to].add(asset);\r\n      }\r\n\r\n      if (s_underlyingStake[_from][asset] != 0) {\r\n        s_underlyingStake[_to][asset] += s_underlyingStake[_from][asset];\r\n        s_underlyingStake[_from][asset] = 0;\r\n      }\r\n    }\r\n    _burn(_from);\r\n    emit MergeCompleted(_from, _to, assetsLocked, assetsLocked.length);\r\n  }\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function split(\r\n    address _tokenAddress,\r\n    uint256 _from,\r\n    uint256 _splitAmount\r\n  ) external nonReentrant returns (uint256 _tokenId1, uint256 _tokenId2) {\r\n    address ownerFrom = _ownerOf(_from);\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    LockedBalance memory oldLocked = s_locked[_from][_lpType];\r\n    uint256 minimumLockAmount = s_minimumLockAmount[_lpType];\r\n\r\n    if (s_voted[_from]) revert AlreadyVoted();\r\n    if (!s_canSplit[ownerFrom] && !s_canSplit[address(0)]) revert SplitNotAllowed();\r\n    if (ownerFrom != _msgSender()) revert NotOwner();\r\n    if (oldLocked.end <= block.timestamp && !oldLocked.isPermanent) revert LockExpired();\r\n    if (_splitAmount >= oldLocked.amount) revert AmountTooBig();\r\n    if (_splitAmount < minimumLockAmount) revert SplitTooSmall();\r\n    if (oldLocked.amount - _splitAmount < minimumLockAmount) revert NotEnoughRemainingAfterSplit();\r\n\r\n    LockedBalance memory oldLockedTemp = oldLocked;\r\n\r\n    oldLocked.amount -= _splitAmount;\r\n    s_locked[_from][_lpType] = oldLocked;\r\n    _checkpoint(_from, oldLocked, _lpType);\r\n\r\n    LockedBalance memory splitLocked = oldLockedTemp;\r\n    splitLocked.amount = _splitAmount;\r\n    _tokenId2 = _createSplitVE(ownerFrom, splitLocked, _lpType, _tokenAddress);\r\n    _tokenId1 = _from;\r\n\r\n    if (s_underlyingStake[_from][_tokenAddress] != 0) {\r\n      s_underlyingStake[_from][_tokenAddress] -= _splitAmount;\r\n      s_underlyingStake[_tokenId2][_tokenAddress] = _splitAmount;\r\n    }\r\n\r\n    emit SplitCompleted(_from, _tokenId1, _tokenId2, _splitAmount, _tokenAddress);\r\n  }\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function claimEmissions(address _tokenAddress) external nonReentrant {\r\n    LpTokenType _lpType = s_lpType[_tokenAddress];\r\n    IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\r\n    if (_stakeStrategy.userStakingWallet(_msgSender()) == address(0)) revert NoUnderlyingStake();\r\n    _stakeStrategy.claim(_msgSender());\r\n    emit EmissionsClaimed(_msgSender(), _tokenAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Overrides the _burn function from ERC721 to include additional logic for bridging.\r\n   * @param tokenId Token ID to burn.\r\n   */\r\n  function _burn(uint256 tokenId) internal override {\r\n    super._burn(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice Hook that is called before any token transfer. This includes minting\r\n   * and burning. It updates the ownership mappings and handles delegation and\r\n   * staking logic when transferring tokens between addresses.\r\n   *\r\n   * @param from The address which previously owned the token.\r\n   * @param to The address that will receive the token.\r\n   * @param tokenId The ID of the token being transferred.\r\n   */\r\n  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {\r\n    super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n    if (from != address(0)) s_ownerToTokenIds[from].remove(tokenId);\r\n    if (to != address(0)) s_ownerToTokenIds[to].add(tokenId);\r\n\r\n    if (from != address(0) && to != address(0)) {\r\n      address[] memory assetsLocked = s_assetsLocked[tokenId].values();\r\n      uint256 assetsLockedLength = assetsLocked.length;\r\n      for (uint256 i = 0; i < assetsLockedLength; i++) {\r\n        address asset = assetsLocked[i];\r\n        LpTokenType _lpType = s_lpType[asset];\r\n\r\n        uint256[] memory delegatees = s_delegatees[tokenId][_lpType].values();\r\n        uint256[] memory amounts = new uint256[](delegatees.length);\r\n        uint256 delegateesLength = delegatees.length;\r\n        for (uint256 j = 0; j < delegateesLength; j++) {\r\n          amounts[j] = type(uint256).max;\r\n        }\r\n\r\n        if (delegateesLength != 0) {\r\n          removeDelegatees(tokenId, delegatees, asset, amounts);\r\n        }\r\n\r\n        uint256 amountStaked = s_underlyingStake[tokenId][asset];\r\n        if (amountStaked != 0) {\r\n          IStakeStrategy _stakeStrategy = s_stakeStrategy[_lpType];\r\n          _stakeStrategy.transferStakingWallet(from, to, amountStaked);\r\n        }\r\n\r\n        LockedBalance memory lock = s_locked[tokenId][_lpType];\r\n        s_userCumulativeAssetValues[from][asset] -= lock.amount;\r\n        s_userCumulativeAssetValues[to][asset] += lock.amount;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a delegation between two veNFTs.\r\n   * @param fromTokenId ID of the veNFT from which delegation is being removed.\r\n   * @param toTokenId ID of the veNFT to which delegation is being removed.\r\n   * @param lpToken Address of the LP token associated with the delegation.\r\n   * @param amount Amount of delegation to remove.\r\n   */\r\n  function _removeDelegation(uint256 fromTokenId, uint256 toTokenId, address lpToken, uint256 amount) internal {\r\n    LpTokenType lpType = s_lpType[lpToken];\r\n    LockedBalance memory fromLocked = s_locked[fromTokenId][lpType];\r\n    LockedBalance memory toLocked = s_locked[toTokenId][lpType];\r\n\r\n    if (ownerOf(fromTokenId) != _msgSender() && ownerOf(toTokenId) != _msgSender()) revert NotOwner();\r\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) revert NoDelegationBetweenTokens(fromTokenId, toTokenId);\r\n\r\n    amount = amount > s_delegations[fromTokenId][toTokenId][lpType]\r\n      ? s_delegations[fromTokenId][toTokenId][lpType]\r\n      : amount;\r\n\r\n    toLocked.delegateAmount -= amount;\r\n    fromLocked.amount += amount;\r\n\r\n    s_delegations[fromTokenId][toTokenId][lpType] -= amount;\r\n    if (s_delegations[fromTokenId][toTokenId][lpType] == 0) {\r\n      s_delegatees[fromTokenId][lpType].remove(toTokenId);\r\n      s_delegators[toTokenId][lpType].remove(fromTokenId);\r\n    }\r\n\r\n    s_locked[toTokenId][lpType] = toLocked;\r\n    s_locked[fromTokenId][lpType] = fromLocked;\r\n    _checkpoint(toTokenId, s_locked[toTokenId][lpType], lpType);\r\n    _checkpoint(fromTokenId, s_locked[fromTokenId][lpType], lpType);\r\n\r\n    if (s_voted[toTokenId]) IVoter(s_voter).poke(toTokenId);\r\n    if (s_voted[fromTokenId]) IVoter(s_voter).poke(fromTokenId);\r\n\r\n    emit DelegationRemoved(fromTokenId, toTokenId, lpToken, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Removes delegatees from a specific veNFT\r\n   * @param fromTokenId ID of the veNFT from which delegatees are removed\r\n   * @param toTokenIds Array of veNFT IDs that are delegatees to be removed\r\n   * @param lpToken Address of the LP token associated with the delegation\r\n   * @param amounts Array of amounts of voting power to remove from each delegatee\r\n   */\r\n  function removeDelegatees(\r\n    uint256 fromTokenId,\r\n    uint256[] memory toTokenIds,\r\n    address lpToken,\r\n    uint256[] memory amounts\r\n  ) public nonReentrant {\r\n    if (toTokenIds.length != amounts.length) revert ArrayMismatch();\r\n    uint256 toTokenIdsLength = toTokenIds.length;\r\n    for (uint256 i = 0; i < toTokenIdsLength; i++) {\r\n      _removeDelegation(fromTokenId, toTokenIds[i], lpToken, amounts[i]);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function allowDelegators(uint256 _tokenId, address _tokenAddress, bool _blocked) external nonReentrant {\r\n    if (ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    s_delegatorsBlocked[_tokenId][_tokenAddress] = _blocked;\r\n    emit DelegatorsBlocked(_tokenId, _tokenAddress, _blocked);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Internal Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /**\r\n   * @notice Handles the withdrawal of staked tokens using a specified staking strategy.\r\n   * @param _owner The address of the owner of the stake.\r\n   * @param _withdrawTo The address to which the withdrawn tokens are sent.\r\n   * @param _tokenId The ID of the token being withdrawn.\r\n   * @param _tokenAddress The address of the token being withdrawn.\r\n   * @param _tokenAmount The amount of tokens to withdraw.\r\n   * @param _stakeStrategy The staking strategy to use for withdrawal.\r\n   */\r\n  function _handleTokenWithdrawStake(\r\n    address _owner,\r\n    address _withdrawTo,\r\n    uint256 _tokenId,\r\n    address _tokenAddress,\r\n    uint256 _tokenAmount,\r\n    IStakeStrategy _stakeStrategy\r\n  ) internal {\r\n    _stakeStrategy.claim(_owner);\r\n    _stakeStrategy.withdraw(_owner, _withdrawTo, _tokenAmount);\r\n    s_underlyingStake[_tokenId][_tokenAddress] -= _tokenAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Updates the user point history and epoch for a given token and LP token type.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _newLocked The new locked balance information.\r\n   * @param _lpType The LP token type.\r\n   */\r\n  function _checkpoint(uint256 _tokenId, LockedBalance memory _newLocked, LpTokenType _lpType) internal {\r\n    UserPoint memory uNew;\r\n    uNew.permanent = _newLocked.isPermanent ? _newLocked.amount : 0;\r\n    uNew.permanentDelegate = _newLocked.isPermanent ? _newLocked.delegateAmount : 0;\r\n\r\n    if (_newLocked.end > block.timestamp && _newLocked.amount > 0) {\r\n      uNew.slope = _newLocked.amount / _MAXTIME;\r\n      uNew.bias = uNew.slope * (_newLocked.end - block.timestamp);\r\n    }\r\n\r\n    uNew.ts = block.timestamp;\r\n    uNew.blk = block.number;\r\n    uint256 userEpoch = s_userPointEpoch[_tokenId][_lpType];\r\n    if (userEpoch != 0 && s_userPointHistory[_tokenId][_lpType][userEpoch].ts == block.timestamp) {\r\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\r\n    } else {\r\n      s_userPointEpoch[_tokenId][_lpType] = ++userEpoch;\r\n      s_userPointHistory[_tokenId][_lpType][userEpoch] = uNew;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the boost for a given lock duration.\r\n   * @param _duration The duration of the lock.\r\n   * @return The calculated boost value.\r\n   */\r\n  function _calculateBoost(uint256 _duration) internal view returns (uint256) {\r\n    uint256 minDuration = s_minimumLockDuration;\r\n    uint256 maxDuration = _MAXTIME;\r\n    uint256 minBoost = 1e18;\r\n    uint256 maxBoost = 2e18;\r\n\r\n    if (_duration <= minDuration) {\r\n      return minBoost;\r\n    } else if (_duration >= maxDuration) {\r\n      return maxBoost;\r\n    } else {\r\n      return minBoost + ((_duration - minDuration) * (maxBoost - minBoost)) / (maxDuration - minDuration);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a new split veNFT with specified locked balance and LP token type.\r\n   * @param _to The address to which the new veNFT is attributed.\r\n   * @param _newLocked The locked balance information for the new veNFT.\r\n   * @param _lpType The LP token type.\r\n   * @param _tokenAddress The address of the token being locked.\r\n   * @return _tokenId The ID of the newly created veNFT.\r\n   */\r\n  function _createSplitVE(\r\n    address _to,\r\n    LockedBalance memory _newLocked,\r\n    LpTokenType _lpType,\r\n    address _tokenAddress\r\n  ) private returns (uint256 _tokenId) {\r\n    _tokenId = ++s_tokenId;\r\n    _safeMint(_to, _tokenId);\r\n    s_locked[_tokenId][_lpType] = _newLocked;\r\n    s_assetsLocked[_tokenId].add(_tokenAddress);\r\n    _checkpoint(_tokenId, _newLocked, _lpType);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the staking strategy and data for a given LP token type.\r\n   * @param _lpType The LP token type.\r\n   * @return _stakeStrategy The staking strategy for the LP token type.\r\n   * @return _stakeData The staking data for the LP token type.\r\n   */\r\n  function _getStakeStrategy(\r\n    LpTokenType _lpType\r\n  ) internal view returns (IStakeStrategy _stakeStrategy, bytes memory _stakeData) {\r\n    IStakeStrategy strategy = s_stakeStrategy[_lpType];\r\n    return (strategy, \"\");\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the total boost for a given token ID and LP token type.\r\n   * @param _tokenId The ID of the token.\r\n   * @param _lpType The LP token type.\r\n   * @return The total boost value.\r\n   */\r\n  function _getTotalBoost(uint256 _tokenId, LpTokenType _lpType) internal view returns (uint256) {\r\n    uint256 totalBoost = s_locked[_tokenId][_lpType].boost;\r\n    if (s_limitedBoostActive) totalBoost += s_limitedBoost;\r\n    if (s_veAERO == address(0)) return totalBoost;\r\n\r\n    address _owner = ownerOf(_tokenId);\r\n    IAeroVoter aeroVoter = IAeroVoter(s_aeroVoting);\r\n    IAeroVotingEscrow veAERO = IAeroVotingEscrow(s_veAERO);\r\n    uint256 _balance = veAERO.balanceOf(_owner);\r\n    for (uint256 i = 0; i < _balance; i++) {\r\n      uint256 veAeroTokenId = veAERO.ownerToNFTokenIdList(_owner, i);\r\n      uint256 weightToVoteRatio = (aeroVoter.votes(veAeroTokenId, s_ionicPool) * 1e18) / aeroVoter.weights(s_ionicPool);\r\n      totalBoost += (s_aeroVoterBoost * weightToVoteRatio) / 1e18;\r\n    }\r\n\r\n    return totalBoost;\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the ETH price of a given token.\r\n   * @dev Uses the MasterPriceOracle to fetch the price.\r\n   * @param _token The address of the token for which the ETH price is requested.\r\n   * @return The ETH price of the specified token.\r\n   */\r\n  function _getEthPrice(address _token) internal view returns (uint256) {\r\n    IMasterPriceOracle mpo = IMasterPriceOracle(ap.getAddress(\"MasterPriceOracle\"));\r\n    return mpo.price(_token);\r\n  }\r\n\r\n  // // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // // ║                           View Functions                                  ║\r\n  // // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function balanceOfNFT(\r\n    uint256 _tokenId\r\n  ) public view returns (address[] memory _assets, uint256[] memory _balances, uint256[] memory _boosts) {\r\n    address[] memory assetsLocked = s_assetsLocked[_tokenId].values();\r\n\r\n    _assets = new address[](assetsLocked.length);\r\n    _balances = new uint256[](assetsLocked.length);\r\n    _boosts = new uint256[](assetsLocked.length);\r\n    uint256 assetsLockedLength = assetsLocked.length;\r\n    for (uint256 i = 0; i < assetsLockedLength; i++) {\r\n      address asset = assetsLocked[i];\r\n      LpTokenType lpType = s_lpType[asset];\r\n      LockedBalance memory lockedBalance = s_locked[_tokenId][lpType];\r\n      _boosts[i] = _getTotalBoost(_tokenId, lpType);\r\n      _assets[i] = asset;\r\n      _balances[i] = BalanceLogicLibrary.balanceOfNFTAt(\r\n        s_userPointEpoch,\r\n        s_userPointHistory,\r\n        lpType,\r\n        _tokenId,\r\n        block.timestamp,\r\n        lockedBalance.isPermanent\r\n      );\r\n    }\r\n\r\n    return (_assets, _balances, _boosts);\r\n  }\r\n\r\n  /// @inheritdoc IveIONFirstExtension\r\n  function getTotalEthValueOfTokens(address _owner) external view returns (uint256 totalValue) {\r\n    IVoter voter = IVoter(s_voter);\r\n    address[] memory lpTokens = voter.getAllLpRewardTokens();\r\n    uint256 lpTokensLength = lpTokens.length;\r\n    for (uint256 i = 0; i < lpTokensLength; i++) {\r\n      uint256 ethValue = (s_userCumulativeAssetValues[_owner][lpTokens[i]] * _getEthPrice(lpTokens[i])) / PRECISION;\r\n      totalValue += ethValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n   * function in the contract matches the call data.\r\n   */\r\n  fallback() external {\r\n    address impl = veIONSecondExtension;\r\n    require(impl != address(0), \"Implementation not set\");\r\n\r\n    assembly {\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n      let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\r\n\r\n      returndatacopy(0, 0, returndatasize())\r\n      switch result\r\n      case 0 {\r\n        revert(0, returndatasize())\r\n      }\r\n      default {\r\n        return(0, returndatasize())\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/veION/veIONSecondExtension.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { IMasterPriceOracle, IAeroVotingEscrow, IAeroVoter } from \"./interfaces/IveIONCore.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IVoter } from \"./interfaces/IVoter.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { veIONStorage } from \"./veIONStorage.sol\";\r\nimport { BalanceLogicLibrary } from \"./libraries/BalanceLogicLibrary.sol\";\r\nimport { IveIONSecondExtension } from \"./interfaces/IveIONSecondExtension.sol\";\r\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\r\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\r\n\r\n/**\r\n * @title veION Contract Second Extension\r\n * @notice This contract manages the veION framework, enabling the staking and management LP tokens for voting power.\r\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n */\r\ncontract veIONSecondExtension is\r\n  Ownable2StepUpgradeable,\r\n  ERC721Upgradeable,\r\n  ReentrancyGuardUpgradeable,\r\n  veIONStorage,\r\n  IveIONSecondExtension\r\n{\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using SafeERC20 for IERC20;\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function whitelistTokens(address[] memory _tokens, bool[] memory _isWhitelisted) external onlyOwner {\r\n    require(_tokens.length == _isWhitelisted.length, \"Unequal Arrays\");\r\n    for (uint256 i; i < _tokens.length; i++) s_whitelistedToken[_tokens[i]] = _isWhitelisted[i];\r\n    emit TokensWhitelisted(_tokens, _isWhitelisted);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function withdrawProtocolFees(address _tokenAddress, address _recipient) external onlyOwner {\r\n    LpTokenType lpType = s_lpType[_tokenAddress];\r\n    uint256 protocolFees = s_protocolFees[lpType];\r\n    require(protocolFees > 0, \"No protocol fees available\");\r\n    s_protocolFees[lpType] = 0;\r\n    IERC20(_tokenAddress).safeTransfer(_recipient, protocolFees);\r\n    emit ProtocolFeesWithdrawn(_tokenAddress, _recipient, protocolFees);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function withdrawDistributedFees(address _tokenAddress, address _recipient) external onlyOwner {\r\n    LpTokenType lpType = s_lpType[_tokenAddress];\r\n    uint256 distributedFees = s_distributedFees[lpType];\r\n    require(distributedFees > 0, \"No distributed fees available\");\r\n    s_distributedFees[lpType] = 0;\r\n    IERC20(_tokenAddress).safeTransfer(_recipient, distributedFees);\r\n    emit DistributedFeesWithdrawn(_tokenAddress, _recipient, distributedFees);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Setter Functions                                ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function toggleSplit(address _account, bool _isAllowed) external onlyOwner {\r\n    s_canSplit[_account] = _isAllowed;\r\n    emit SplitToggle(_account, _isAllowed);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function toggleLimitedBoost(bool _isBoosted) external onlyOwner {\r\n    s_limitedBoostActive = _isBoosted;\r\n    emit LimitedBoostToggled(_isBoosted);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setLimitedTimeBoost(uint256 _boostAmount) external onlyOwner {\r\n    if (_boostAmount <= 0) revert BoostAmountMustBeGreaterThanZero();\r\n    s_limitedBoost = _boostAmount;\r\n    emit LimitedTimeBoostSet(_boostAmount);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setVoter(address _voter) external onlyOwner {\r\n    if (address(_voter) == address(0)) revert InvalidAddress();\r\n    s_voter = _voter;\r\n    emit VoterSet(_voter);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setMinimumLockAmount(address _tokenAddress, uint256 _minimumAmount) external onlyOwner {\r\n    if (_minimumAmount <= 0) revert MinimumAmountMustBeGreaterThanZero();\r\n    LpTokenType lpType = s_lpType[_tokenAddress];\r\n    s_minimumLockAmount[lpType] = _minimumAmount;\r\n    emit MinimumLockAmountSet(_tokenAddress, _minimumAmount);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setMinimumLockDuration(uint256 _minimumLockDuration) external onlyOwner {\r\n    if (_minimumLockDuration <= 0) revert MinimumLockDurationMustBeGreaterThanZero();\r\n    s_minimumLockDuration = _minimumLockDuration;\r\n    emit MinimumLockDurationSet(_minimumLockDuration);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setIonicPool(address _ionicPool) external onlyOwner {\r\n    if (address(_ionicPool) == address(0)) revert InvalidAddress();\r\n    s_ionicPool = _ionicPool;\r\n    emit IonicPoolSet(_ionicPool);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setAeroVoting(address _aeroVoting) external onlyOwner {\r\n    if (address(_aeroVoting) == address(0)) revert InvalidAddress();\r\n    s_aeroVoting = _aeroVoting;\r\n    emit AeroVotingSet(_aeroVoting);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setAeroVoterBoost(uint256 _aeroVoterBoost) external onlyOwner {\r\n    if (_aeroVoterBoost <= 0) revert AeroBoostAmountMustBeGreaterThanZero();\r\n    s_aeroVoterBoost = _aeroVoterBoost;\r\n    emit AeroVoterBoostSet(_aeroVoterBoost);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setMaxEarlyWithdrawFee(uint256 _maxEarlyWithdrawFee) external onlyOwner {\r\n    if (_maxEarlyWithdrawFee <= 0) revert MaxEarlyWithdrawFeeMustBeGreaterThanZero();\r\n    s_maxEarlyWithdrawFee = _maxEarlyWithdrawFee;\r\n    emit MaxEarlyWithdrawFeeSet(_maxEarlyWithdrawFee);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setLpTokenType(address _token, LpTokenType _type) external onlyOwner {\r\n    if (_token == address(0)) revert InvalidTokenAddress();\r\n    s_lpType[_token] = _type;\r\n    emit LpTokenTypeSet(_token, _type);\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setStakeStrategy(LpTokenType _lpType, IStakeStrategy _strategy) external onlyOwner {\r\n    if (address(_strategy) == address(0)) revert InvalidStrategyAddress();\r\n    s_stakeStrategy[_lpType] = IStakeStrategy(_strategy);\r\n    emit StakeStrategySet(_lpType, address(_strategy));\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function setVeAERO(address _veAERO) external onlyOwner {\r\n    if (_veAERO == address(0)) revert InvalidVeAEROAddress();\r\n    s_veAERO = _veAERO;\r\n    emit VeAEROSet(_veAERO);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           View Functions                                  ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getUserLock(uint256 _tokenId, LpTokenType _lpType) external view returns (LockedBalance memory) {\r\n    return s_locked[_tokenId][_lpType];\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getOwnedTokenIds(address _owner) external view returns (uint256[] memory) {\r\n    return s_ownerToTokenIds[_owner].values();\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getAssetsLocked(uint256 _tokenId) external view returns (address[] memory) {\r\n    return s_assetsLocked[_tokenId].values();\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getDelegatees(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory) {\r\n    return s_delegatees[_tokenId][_lpType].values();\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getDelegators(uint256 _tokenId, LpTokenType _lpType) external view returns (uint256[] memory) {\r\n    return s_delegators[_tokenId][_lpType].values();\r\n  }\r\n\r\n  /// @inheritdoc IveIONSecondExtension\r\n  function getUserPoint(\r\n    uint256 _tokenId,\r\n    LpTokenType _lpType,\r\n    uint256 _epoch\r\n  ) external view returns (UserPoint memory) {\r\n    return s_userPointHistory[_tokenId][_lpType][_epoch];\r\n  }\r\n}\r\n"
    },
    "contracts/veION/veIONStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { IAddressesProvider } from \"./interfaces/IveIONCore.sol\";\r\nimport { IStakeStrategy } from \"./stake/IStakeStrategy.sol\";\r\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport { IveIONStructsEnumsErrorsEvents } from \"./interfaces/IveIONStructsEnumsErrorsEvents.sol\";\r\n\r\nabstract contract veIONStorage is IveIONStructsEnumsErrorsEvents {\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                                Constants                                  ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /// @notice Represents the duration of one week in seconds.\r\n  uint256 internal constant _WEEK = 1 weeks;\r\n  /// @notice Represents the maximum lock time in seconds (2 years).\r\n  uint256 internal constant _MAXTIME = 2 * 365 * 86400;\r\n  /// @notice Precision used for calculations, set to 1e18.\r\n  uint256 public constant PRECISION = 1e18;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                             State Variables                               ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /// @notice The current token ID counter.\r\n  uint256 public s_tokenId;\r\n  /// @notice The amount of limited boost available.\r\n  uint256 public s_limitedBoost;\r\n  /// @notice Indicates whether the limited boost is active.\r\n  bool public s_limitedBoostActive;\r\n  /// @notice Address of the veAERO contract.\r\n  address public s_veAERO;\r\n  /// @notice Address of the AeroVoting contract.\r\n  address public s_aeroVoting;\r\n  /// @notice Address of the Ionic Pool.\r\n  address public s_ionicPool;\r\n  /// @notice Address of the voter contract.\r\n  address public s_voter;\r\n  /// @notice The boost amount for AeroVoter.\r\n  uint256 public s_aeroVoterBoost;\r\n  /// @notice The minimum duration for locking.\r\n  uint256 public s_minimumLockDuration;\r\n  /// @notice The maximum fee for early withdrawal.\r\n  uint256 public s_maxEarlyWithdrawFee;\r\n  /// @notice The AddressesProvider contract used for address management.\r\n  IAddressesProvider public ap;\r\n  /// @notice The address of the logic contract for the veION first extension.\r\n  address public veIONFirstExtension;\r\n  /// @notice The address of the logic contract for the veION second extension.\r\n  address public veIONSecondExtension;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                                Mappings                                   ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /// @dev Maps LP token types to their minimum lock amounts.\r\n  mapping(LpTokenType => uint256) public s_minimumLockAmount;\r\n  /// @dev Maps token addresses to their whitelist status.\r\n  mapping(address => bool) public s_whitelistedToken;\r\n  /// @dev Maps token addresses to their corresponding LP token types.\r\n  mapping(address => LpTokenType) public s_lpType;\r\n  /// @dev Maps user addresses to their ability to split.\r\n  mapping(address => bool) public s_canSplit;\r\n  /// @dev Maps token IDs and LP token types to their locked balances.\r\n  mapping(uint256 => mapping(LpTokenType => LockedBalance)) public s_locked;\r\n  /// @dev Maps token IDs and LP token types to user epochs.\r\n  mapping(uint256 => mapping(LpTokenType => uint256)) public s_userPointEpoch;\r\n  /// @dev Maps token IDs and LP token types to user point history.\r\n  mapping(uint256 => mapping(LpTokenType => UserPoint[1000000000])) public s_userPointHistory;\r\n  /// @dev Maps token IDs to sets of locked asset addresses.\r\n  mapping(uint256 => EnumerableSet.AddressSet) internal s_assetsLocked;\r\n  /// @dev Maps token IDs to their voting status.\r\n  mapping(uint256 => bool) public s_voted;\r\n  /// @dev Maps LP token types to their total supply.\r\n  mapping(LpTokenType => uint256) public s_supply;\r\n  /// @dev Maps LP token types to their permanent lock balances.\r\n  mapping(LpTokenType => uint256) public s_permanentLockBalance;\r\n  /// @dev Maps LP token types to their underlying stake strategies.\r\n  mapping(LpTokenType => IStakeStrategy) public s_stakeStrategy;\r\n  /// @dev Maps token IDs and LP token addresses to their underlying stake amounts.\r\n  mapping(uint256 => mapping(address => uint256)) public s_underlyingStake;\r\n  /// @dev Maps LP token types to their protocol fees.\r\n  mapping(LpTokenType => uint256) public s_protocolFees;\r\n  /// @dev Maps LP token types to their distributed fees.\r\n  mapping(LpTokenType => uint256) public s_distributedFees;\r\n  /// @dev Maps delegators, delegatees, and LP token types to delegation amounts.\r\n  mapping(uint256 => mapping(uint256 => mapping(LpTokenType => uint256))) public s_delegations;\r\n  /// @dev Maps token IDs and LP token types to sets of delegatees.\r\n  mapping(uint256 => mapping(LpTokenType => EnumerableSet.UintSet)) internal s_delegatees;\r\n  /// @dev Maps token IDs and LP token types to sets of delegators.\r\n  mapping(uint256 => mapping(LpTokenType => EnumerableSet.UintSet)) internal s_delegators;\r\n  /// @dev Maps owner addresses to sets of token IDs they own.\r\n  mapping(address => EnumerableSet.UintSet) internal s_ownerToTokenIds;\r\n  /// @dev Maps user addresses and token addresses to cumulative asset values.\r\n  mapping(address => mapping(address => uint256)) public s_userCumulativeAssetValues;\r\n  /// @dev Maps token Id and lp onto delegator permissioning.\r\n  mapping(uint256 => mapping(address => bool)) public s_delegatorsBlocked;\r\n\r\n  uint256[50] private __gap;\r\n}\r\n"
    },
    "contracts/veION/Voter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport { IVoter } from \"./interfaces/IVoter.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IonicTimeLibrary } from \"./libraries/IonicTimeLibrary.sol\";\r\nimport { IveION } from \"./interfaces/IveION.sol\";\r\nimport { IBribeRewards } from \"./interfaces/IBribeRewards.sol\";\r\nimport { IonicComptroller } from \"../compound/ComptrollerInterface.sol\";\r\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\r\nimport { MasterPriceOracle } from \"../oracles/MasterPriceOracle.sol\";\r\nimport { ERC721Upgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\";\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\";\r\n\r\n/**\r\n * @title Voter Contract\r\n * @notice This contract allows veION holders to vote for various markets\r\n * @author Jourdan Dunkley <jourdan@ionic.money> (https://github.com/jourdanDunkley)\r\n */\r\ncontract Voter is IVoter, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           State Variables                                 ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  ///@notice The ve token that governs these contracts\r\n  address public ve;\r\n  ///@notice Base token of ve contract\r\n  address internal rewardToken;\r\n  ///@notice Standard OZ IGovernor using ve for vote weights\r\n  address public governor;\r\n  ///@notice Master Price Oracle instance\r\n  MasterPriceOracle public mpo;\r\n  ///@notice List of LP tokens\r\n  address[] public lpTokens;\r\n  ///@notice Total Voting Weights for each address\r\n  mapping(address => uint256) public totalWeight;\r\n  ///@notice Maximum number of markets one voter can vote for at once\r\n  uint256 public maxVotingNum;\r\n  ///@notice Minimum value for maxVotingNum\r\n  uint256 internal constant MIN_MAXVOTINGNUM = 10;\r\n  ///@notice All markets viable for incentives\r\n  Market[] public markets;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                                Mappings                                   ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  ///@notice Mapping from Reward Accumulator to Bribes Voting Reward\r\n  mapping(address => address) public rewardAccumulatorToBribe;\r\n  ///@notice Mapping from Market to Market Side to LP Asset to weights\r\n  mapping(address => mapping(MarketSide => mapping(address => uint256))) public weights;\r\n  ///@notice Mapping from NFT to Pool to LP Asset to Votes\r\n  mapping(uint256 => mapping(address => mapping(MarketSide => mapping(address => uint256)))) public votes;\r\n  ///@notice Mapping from NFT to Pool to LP Asset to Base Weights\r\n  mapping(uint256 => mapping(address => mapping(MarketSide => mapping(address => uint256)))) public baseWeights;\r\n  ///@notice Mapping from NFT to List of markets voted for by NFT\r\n  mapping(uint256 => mapping(address => address[])) public marketVote;\r\n  ///@notice Mapping from NFT to List of market vote sides voted for by NFT\r\n  mapping(uint256 => mapping(address => MarketSide[])) public marketVoteSide;\r\n  ///@notice Mapping from NFT to Total voting weight of NFT\r\n  mapping(uint256 => mapping(address => uint256)) public usedWeights;\r\n  ///@notice Mapping from NFT to Timestamp of last vote (ensures single vote per epoch)\r\n  mapping(uint256 => uint256) public lastVoted;\r\n  ///@notice Mapping from Token to Whitelisted status\r\n  mapping(address => bool) public isWhitelistedToken;\r\n  ///@notice Mapping from TokenId to Whitelisted status\r\n  mapping(uint256 => bool) public isWhitelistedNFT;\r\n  ///@notice Mapping from Reward Accumulator to Liveness status\r\n  mapping(address => bool) public isAlive;\r\n  ///@notice Mapping from Market to Market Side to Reward Accumulator\r\n  mapping(address => mapping(MarketSide => address)) public marketToRewardAccumulators;\r\n\r\n  bool distributionTimelockAlive;\r\n\r\n  /// @notice Historical prices for each reward token and epoch\r\n  mapping(address => mapping(uint256 => uint256)) public historicalPrices;\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                               Modifiers                                   ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n  /**\r\n   * @notice Modifier to ensure that the function is called only in a new epoch since the last vote.\r\n   * @dev Reverts if the current epoch start time is less than or equal to the last voted timestamp for the given token ID.\r\n   *      Also reverts if the current time is within the vote distribution window.\r\n   * @param _tokenId The ID of the veNFT to check the last voted timestamp.\r\n   */\r\n  modifier onlyNewEpoch(uint256 _tokenId) {\r\n    if (IonicTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert AlreadyVotedOrDeposited();\r\n    if (block.timestamp <= IonicTimeLibrary.epochVoteStart(block.timestamp)) revert DistributeWindow();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier to ensure that the function is called only by the governance address.\r\n   * @dev Reverts if the caller is not the current governor.\r\n   */\r\n  modifier onlyGovernance() {\r\n    if (msg.sender != governor) revert NotGovernor();\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    _disableInitializers(); // Locks the implementation contract from being initialized\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes the Voter contract with the specified parameters.\r\n   * @dev Requires initialization with at least one reward token.\r\n   * @param _tokens An array of token addresses to be whitelisted.\r\n   * @param _mpo The MasterPriceOracle contract address.\r\n   * @param _rewardToken The address of the reward token.\r\n   * @param _ve The address of the veION contract.\r\n   * @custom:reverts TokensArrayEmpty if the _tokens array is empty.\r\n   */\r\n  function initialize(\r\n    address[] calldata _tokens,\r\n    MasterPriceOracle _mpo,\r\n    address _rewardToken,\r\n    address _ve\r\n  ) external initializer {\r\n    __Ownable2Step_init();\r\n    __ReentrancyGuard_init();\r\n    uint256 _length = _tokens.length;\r\n    if (_length == 0) revert TokensArrayEmpty();\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      _whitelistToken(_tokens[i], true);\r\n    }\r\n    mpo = _mpo;\r\n    rewardToken = _rewardToken;\r\n    ve = _ve;\r\n    governor = msg.sender;\r\n\r\n    emit Initialized(_tokens, address(_mpo), _rewardToken, _ve, governor);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           External Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IVoter\r\n  function vote(\r\n    uint256 _tokenId,\r\n    address[] calldata _marketVote,\r\n    MarketSide[] calldata _marketVoteSide,\r\n    uint256[] calldata _weights\r\n  ) external nonReentrant onlyNewEpoch(_tokenId) {\r\n    VoteLocalVars memory vars;\r\n    vars.sender = msg.sender;\r\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != vars.sender) revert NotOwner();\r\n    if (\r\n      _marketVote.length != _marketVoteSide.length ||\r\n      _marketVoteSide.length != _weights.length ||\r\n      _weights.length != _marketVote.length\r\n    ) revert UnequalLengths();\r\n    if (_marketVote.length > maxVotingNum) revert TooManyPools();\r\n    vars.timestamp = block.timestamp;\r\n    if ((vars.timestamp > IonicTimeLibrary.epochVoteEnd(vars.timestamp)) && !isWhitelistedNFT[_tokenId])\r\n      revert NotWhitelistedNFT();\r\n    uint256 totalVoteWeight = 0;\r\n\r\n    for (uint256 i = 0; i < _marketVote.length; i++) {\r\n      totalVoteWeight += _weights[i];\r\n    }\r\n    for (uint256 i = 0; i < lpTokens.length; i++) {\r\n      _reset(_tokenId, lpTokens[i]);\r\n    }\r\n\r\n    lastVoted[_tokenId] = vars.timestamp;\r\n    (vars.votingLPs, vars.votingLPBalances, vars.boosts) = IveION(ve).balanceOfNFT(_tokenId);\r\n    for (uint256 j = 0; j < vars.votingLPs.length; j++) {\r\n      _vote(\r\n        _tokenId,\r\n        vars.votingLPs[j],\r\n        (vars.votingLPBalances[j] * vars.boosts[j]) / 1e18,\r\n        _marketVote,\r\n        _marketVoteSide,\r\n        _weights,\r\n        totalVoteWeight\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function poke(uint256 _tokenId) external nonReentrant {\r\n    if (block.timestamp <= IonicTimeLibrary.epochVoteStart(block.timestamp)) revert DistributeWindow();\r\n    (address[] memory _votingLPs, uint256[] memory _votingLPBalances, uint256[] memory _boosts) = IveION(ve)\r\n      .balanceOfNFT(_tokenId);\r\n\r\n    for (uint256 i = 0; i < _votingLPs.length; i++) {\r\n      uint256 effectiveBalance = (_votingLPBalances[i] * _boosts[i]) / 1e18;\r\n      _poke(_tokenId, lpTokens[i], effectiveBalance);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function reset(uint256 _tokenId) public nonReentrant onlyNewEpoch(_tokenId) {\r\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != msg.sender) revert NotOwner();\r\n    for (uint256 i = 0; i < lpTokens.length; i++) {\r\n      _reset(_tokenId, lpTokens[i]);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint256 _tokenId) external nonReentrant {\r\n    if (_bribes.length != _tokens.length) revert UnequalLengths();\r\n    if (ERC721Upgradeable(ve).ownerOf(_tokenId) != _msgSender()) revert NotOwner();\r\n    uint256 _length = _bribes.length;\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      IBribeRewards(_bribes[i]).getReward(_tokenId, _tokens[i]);\r\n    }\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Admin External Functions                        ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IVoter\r\n  function distributeRewards() external onlyGovernance {\r\n    if (distributionTimelockAlive && block.timestamp <= IonicTimeLibrary.epochVoteEnd(block.timestamp))\r\n      revert NotDistributeWindow();\r\n    uint256 _reward = IERC20(rewardToken).balanceOf(address(this));\r\n    uint256 _totalLPValueETH = _calculateTotalLPValue();\r\n    for (uint256 i = 0; i < markets.length; i++) {\r\n      uint256 _marketWeightETH = _calculateMarketLPValue(markets[i].marketAddress, markets[i].side);\r\n      if (_marketWeightETH > 0) {\r\n        IERC20(rewardToken).safeTransfer(\r\n          marketToRewardAccumulators[markets[i].marketAddress][markets[i].side],\r\n          (_reward * _marketWeightETH) / _totalLPValueETH\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function whitelistToken(address _token, bool _bool) external onlyGovernance {\r\n    _whitelistToken(_token, _bool);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function whitelistNFT(uint256 _tokenId, bool _bool) external onlyGovernance {\r\n    address _sender = msg.sender;\r\n    isWhitelistedNFT[_tokenId] = _bool;\r\n    emit WhitelistNFT(_sender, _tokenId, _bool);\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Internal Functions                              ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /**\r\n   * @notice Internal function to handle voting logic for a given token ID and voting asset.\r\n   * @param _tokenId The ID of the token used for voting.\r\n   * @param _votingAsset The address of the asset being used for voting.\r\n   * @param _votingAssetBalance The balance of the voting asset.\r\n   * @param _marketVote An array of market addresses to vote for.\r\n   * @param _marketVoteSide An array of market sides corresponding to the markets.\r\n   * @param _weights An array of weights for each market.\r\n   * @param totalVoteWeight The total weight of the vote.\r\n   */\r\n  function _vote(\r\n    uint256 _tokenId,\r\n    address _votingAsset,\r\n    uint256 _votingAssetBalance,\r\n    address[] memory _marketVote,\r\n    MarketSide[] memory _marketVoteSide,\r\n    uint256[] memory _weights,\r\n    uint256 totalVoteWeight\r\n  ) internal {\r\n    VoteVars memory vars;\r\n    uint256 marketVoteLength = _marketVote.length;\r\n    for (uint256 i = 0; i < marketVoteLength; i++) {\r\n      vars.market = _marketVote[i];\r\n      vars.marketSide = _marketVoteSide[i];\r\n      vars.rewardAccumulator = marketToRewardAccumulators[vars.market][vars.marketSide];\r\n      vars.bribes = rewardAccumulatorToBribe[vars.rewardAccumulator];\r\n      if (_weights[i] == 0) revert ZeroWeight();\r\n      if (vars.rewardAccumulator == address(0)) revert RewardAccumulatorDoesNotExist(vars.market);\r\n      if (!isAlive[vars.rewardAccumulator]) revert RewardAccumulatorNotAlive(vars.rewardAccumulator);\r\n\r\n      vars.marketWeight = (_weights[i] * _votingAssetBalance) / totalVoteWeight;\r\n      if (votes[_tokenId][vars.market][vars.marketSide][_votingAsset] != 0) revert NonZeroVotes();\r\n\r\n      marketVote[_tokenId][_votingAsset].push(vars.market);\r\n      marketVoteSide[_tokenId][_votingAsset].push(vars.marketSide);\r\n\r\n      weights[vars.market][vars.marketSide][_votingAsset] += vars.marketWeight;\r\n      votes[_tokenId][vars.market][vars.marketSide][_votingAsset] += vars.marketWeight;\r\n      baseWeights[_tokenId][vars.market][vars.marketSide][_votingAsset] = _weights[i];\r\n      IBribeRewards(vars.bribes).deposit(_votingAsset, uint256(vars.marketWeight), _tokenId);\r\n      vars.usedWeight += vars.marketWeight;\r\n      vars.totalWeight += vars.marketWeight;\r\n      emit Voted(\r\n        msg.sender,\r\n        vars.market,\r\n        _tokenId,\r\n        vars.marketWeight,\r\n        weights[vars.market][vars.marketSide][_votingAsset],\r\n        block.timestamp\r\n      );\r\n    }\r\n    IveION(ve).voting(_tokenId, true);\r\n    totalWeight[_votingAsset] += uint256(vars.totalWeight);\r\n    usedWeights[_tokenId][_votingAsset] = uint256(vars.usedWeight);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to update voting balances for a given token ID and voting asset.\r\n   * @param _tokenId The ID of the token whose voting balance is being updated.\r\n   * @param _votingAsset The address of the asset being used for voting.\r\n   * @param _votingAssetBalance The balance of the voting asset.\r\n   */\r\n  function _poke(uint256 _tokenId, address _votingAsset, uint256 _votingAssetBalance) internal {\r\n    address[] memory _marketVote = marketVote[_tokenId][_votingAsset];\r\n    MarketSide[] memory _marketVoteSide = marketVoteSide[_tokenId][_votingAsset];\r\n    uint256 _marketCnt = _marketVote.length;\r\n    uint256[] memory _weights = new uint256[](_marketCnt);\r\n    uint256 totalVoteWeight = 0;\r\n\r\n    for (uint256 i = 0; i < _marketCnt; i++) {\r\n      _weights[i] = baseWeights[_tokenId][_marketVote[i]][_marketVoteSide[i]][_votingAsset];\r\n    }\r\n\r\n    for (uint256 i = 0; i < _marketVote.length; i++) {\r\n      totalVoteWeight += _weights[i];\r\n    }\r\n\r\n    _reset(_tokenId, _votingAsset);\r\n    _vote(_tokenId, _votingAsset, _votingAssetBalance, _marketVote, _marketVoteSide, _weights, totalVoteWeight);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to reset voting state for a given token ID and voting asset.\r\n   * @param _tokenId The ID of the token whose voting state is being reset.\r\n   * @param _votingAsset The address of the asset being used for voting.\r\n   */\r\n  function _reset(uint256 _tokenId, address _votingAsset) internal {\r\n    address[] storage _marketVote = marketVote[_tokenId][_votingAsset];\r\n    MarketSide[] storage _marketVoteSide = marketVoteSide[_tokenId][_votingAsset];\r\n    uint256 _marketVoteCnt = _marketVote.length;\r\n\r\n    for (uint256 i = 0; i < _marketVoteCnt; i++) {\r\n      address _market = _marketVote[i];\r\n      MarketSide _marketSide = _marketVoteSide[i];\r\n\r\n      uint256 _votes = votes[_tokenId][_market][_marketSide][_votingAsset];\r\n      if (_votes != 0) {\r\n        weights[_market][_marketSide][_votingAsset] -= _votes;\r\n        delete votes[_tokenId][_market][_marketSide][_votingAsset];\r\n        IBribeRewards(rewardAccumulatorToBribe[marketToRewardAccumulators[_market][_marketSide]]).withdraw(\r\n          _votingAsset,\r\n          uint256(_votes),\r\n          _tokenId\r\n        );\r\n        totalWeight[_votingAsset] -= _votes;\r\n        emit Abstained(\r\n          msg.sender,\r\n          _market,\r\n          _tokenId,\r\n          _votes,\r\n          weights[_market][_marketSide][_votingAsset],\r\n          block.timestamp\r\n        );\r\n      }\r\n    }\r\n    usedWeights[_tokenId][_votingAsset] = 0;\r\n    delete marketVote[_tokenId][_votingAsset];\r\n    delete marketVoteSide[_tokenId][_votingAsset];\r\n    IveION(ve).voting(_tokenId, false);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to whitelist or unwhitelist a token for use in bribes.\r\n   * @param _token The address of the token to be whitelisted or unwhitelisted.\r\n   * @param _bool Boolean indicating whether to whitelist (true) or unwhitelist (false) the token.\r\n   */\r\n  function _whitelistToken(address _token, bool _bool) internal {\r\n    isWhitelistedToken[_token] = _bool;\r\n    emit WhitelistToken(msg.sender, _token, _bool);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to calculate the ETH value of a given amount of LP tokens.\r\n   * @param amount The amount of LP tokens.\r\n   * @param lpToken The address of the LP token.\r\n   * @return The ETH value of the given amount of LP tokens.\r\n   */\r\n  function _getTokenEthValue(uint256 amount, address lpToken) internal view returns (uint256) {\r\n    uint256 tokenPriceInEth = mpo.price(lpToken); // Fetch price of 1 lpToken in ETH\r\n    uint256 ethValue = amount * tokenPriceInEth;\r\n    return ethValue;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to calculate the total ETH value of all LP tokens in the markets.\r\n   * @return _totalLPValueETH The total ETH value of all LP tokens.\r\n   */\r\n  function _calculateTotalLPValue() internal view returns (uint256 _totalLPValueETH) {\r\n    uint256 marketLength = markets.length;\r\n    for (uint256 i = 0; i < marketLength; i++)\r\n      _totalLPValueETH += _calculateMarketLPValue(markets[i].marketAddress, markets[i].side);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to calculate the ETH value of LP tokens for a specific market.\r\n   * @param _market The address of the market.\r\n   * @param _marketSide The side of the market.\r\n   * @return _marketLPValueETH The ETH value of LP tokens for the specified market.\r\n   */\r\n  function _calculateMarketLPValue(\r\n    address _market,\r\n    MarketSide _marketSide\r\n  ) internal view returns (uint256 _marketLPValueETH) {\r\n    uint256 lpTokensLength = lpTokens.length;\r\n    for (uint256 i = 0; i < lpTokensLength; i++) {\r\n      uint256 _lpAmount = weights[_market][_marketSide][lpTokens[i]];\r\n      uint256 tokenEthValue = _getTokenEthValue(_lpAmount, lpTokens[i]);\r\n      _marketLPValueETH += tokenEthValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to check if a market exists.\r\n   * @param _marketAddress The address of the market.\r\n   * @param _marketSide The side of the market.\r\n   * @return True if the market exists, false otherwise.\r\n   */\r\n  function _marketExists(address _marketAddress, MarketSide _marketSide) internal view returns (bool) {\r\n    uint256 marketLength = markets.length;\r\n    for (uint256 j = 0; j < marketLength; j++) {\r\n      if (markets[j].marketAddress == _marketAddress && markets[j].side == _marketSide) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Setter Functions                                ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IVoter\r\n  function setLpTokens(address[] memory _lpTokens) external onlyOwner {\r\n    require(_lpTokens.length != 0, \"LpTokens array cannot be empty\");\r\n    lpTokens = _lpTokens;\r\n    emit LpTokensSet(_lpTokens);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function setMpo(address _mpo) external onlyOwner {\r\n    if (_mpo == address(0)) revert ZeroAddress();\r\n    mpo = MasterPriceOracle(_mpo);\r\n    emit MpoSet(_mpo);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function setGovernor(address _governor) public onlyOwner {\r\n    if (_governor == address(0)) revert ZeroAddress();\r\n    governor = _governor;\r\n    emit GovernorSet(_governor);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function addMarkets(Market[] calldata _markets) external onlyGovernance {\r\n    for (uint256 i = 0; i < _markets.length; i++) {\r\n      Market memory newMarket = _markets[i];\r\n      if (_marketExists(newMarket.marketAddress, newMarket.side)) revert MarketAlreadyExists();\r\n      markets.push(newMarket);\r\n    }\r\n    emit MarketsAdded(_markets);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function setMarketRewardAccumulators(\r\n    address[] calldata _markets,\r\n    MarketSide[] calldata _marketSides,\r\n    address[] calldata _rewardAccumulators\r\n  ) external onlyGovernance {\r\n    uint256 _length = _markets.length;\r\n    if (_marketSides.length != _length) revert MismatchedArrayLengths();\r\n    if (_rewardAccumulators.length != _length) revert MismatchedArrayLengths();\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      marketToRewardAccumulators[_markets[i]][_marketSides[i]] = _rewardAccumulators[i];\r\n      isAlive[_rewardAccumulators[i]] = true;\r\n    }\r\n    emit MarketRewardAccumulatorsSet(_markets, _marketSides, _rewardAccumulators);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function setBribes(address[] calldata _rewardAccumulators, address[] calldata _bribes) external onlyGovernance {\r\n    uint256 _length = _bribes.length;\r\n    if (_rewardAccumulators.length != _length) revert MismatchedArrayLengths();\r\n    for (uint256 i = 0; i < _length; i++) {\r\n      rewardAccumulatorToBribe[_rewardAccumulators[i]] = _bribes[i];\r\n    }\r\n    emit BribesSet(_rewardAccumulators, _bribes);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function setMaxVotingNum(uint256 _maxVotingNum) external onlyGovernance {\r\n    if (_maxVotingNum < MIN_MAXVOTINGNUM) revert MaximumVotingNumberTooLow();\r\n    if (_maxVotingNum == maxVotingNum) revert SameValue();\r\n    maxVotingNum = _maxVotingNum;\r\n    emit MaxVotingNumSet(_maxVotingNum);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function toggleRewardAccumulatorAlive(\r\n    address _market,\r\n    MarketSide _marketSide,\r\n    bool _isAlive\r\n  ) external onlyGovernance {\r\n    address _rewardAccumulator = marketToRewardAccumulators[_market][_marketSide];\r\n    if (_rewardAccumulator == address(0)) revert RewardAccumulatorDoesNotExist(_market);\r\n    isAlive[_rewardAccumulator] = _isAlive;\r\n    emit RewardAccumulatorAliveToggled(_market, _marketSide, _isAlive);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function toggleDistributionTimelockAlive(bool _isAlive) external onlyGovernance {\r\n    distributionTimelockAlive = _isAlive;\r\n    emit DistributionTimelockAliveToggled(_isAlive);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets historical prices for LP tokens at specific epochs\r\n   * @param epochTimestamp The timestamp of the epoch\r\n   * @param lpToken The LP token address\r\n   * @param price The price to set\r\n   */\r\n  function setHistoricalPrices(uint256 epochTimestamp, address lpToken, uint256 price) external onlyOwner {\r\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\r\n    historicalPrices[lpToken][epochStart] = price;\r\n    // emit HistoricalPriceSet(epochTimestamp, lpToken, price);\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the historical price for a specific LP token at a given epoch\r\n   * @param lpToken The LP token address\r\n   * @param epochTimestamp The timestamp of the epoch\r\n   * @return The historical price of the LP token at the specified epoch\r\n   */\r\n  function getHistoricalPrice(address lpToken, uint256 epochTimestamp) external view returns (uint256) {\r\n    uint256 epochStart = IonicTimeLibrary.epochStart(epochTimestamp);\r\n    return historicalPrices[lpToken][epochStart];\r\n  }\r\n\r\n  // ╔═══════════════════════════════════════════════════════════════════════════╗\r\n  // ║                           Pure/View Functions                             ║\r\n  // ╚═══════════════════════════════════════════════════════════════════════════╝\r\n\r\n  /// @inheritdoc IVoter\r\n  function epochStart(uint256 _timestamp) external pure returns (uint256) {\r\n    return IonicTimeLibrary.epochStart(_timestamp);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function epochNext(uint256 _timestamp) external pure returns (uint256) {\r\n    return IonicTimeLibrary.epochNext(_timestamp);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function epochVoteStart(uint256 _timestamp) external pure returns (uint256) {\r\n    return IonicTimeLibrary.epochVoteStart(_timestamp);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function epochVoteEnd(uint256 _timestamp) external pure returns (uint256) {\r\n    return IonicTimeLibrary.epochVoteEnd(_timestamp);\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function marketsLength() external view returns (uint256) {\r\n    return markets.length;\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function getAllLpRewardTokens() external view returns (address[] memory) {\r\n    return lpTokens;\r\n  }\r\n\r\n  /// @inheritdoc IVoter\r\n  function getVoteDetails(uint256 _tokenId, address _lpAsset) external view returns (VoteDetails memory) {\r\n    uint256 length = marketVote[_tokenId][_lpAsset].length;\r\n    address[] memory _marketVotes = new address[](length);\r\n    MarketSide[] memory _marketVoteSides = new MarketSide[](length);\r\n    uint256[] memory _votes = new uint256[](length);\r\n\r\n    for (uint256 i = 0; i < length; i++) {\r\n      _marketVotes[i] = marketVote[_tokenId][_lpAsset][i];\r\n      _marketVoteSides[i] = marketVoteSide[_tokenId][_lpAsset][i];\r\n      _votes[i] = votes[_tokenId][_marketVotes[i]][_marketVoteSides[i]][_lpAsset];\r\n    }\r\n\r\n    uint256 _usedWeight = usedWeights[_tokenId][_lpAsset];\r\n\r\n    return\r\n      VoteDetails({\r\n        marketVotes: _marketVotes,\r\n        marketVoteSides: _marketVoteSides,\r\n        votes: _votes,\r\n        usedWeight: _usedWeight\r\n      });\r\n  }\r\n}\r\n"
    },
    "contracts/veION/VoterLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.22;\r\n\r\nimport \"@openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./interfaces/IVoter.sol\";\r\nimport \"../PoolDirectory.sol\";\r\nimport { ICErc20 } from \"../compound/CTokenInterfaces.sol\";\r\nimport { ComptrollerExtensionInterface } from \"../compound/ComptrollerInterface.sol\";\r\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport { Ownable2StepUpgradeable } from \"@openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\r\nimport { veIONSecondExtension } from \"./veIONSecondExtension.sol\";\r\nimport { Voter } from \"./Voter.sol\";\r\n\r\ncontract VoterLens is Initializable, Ownable2StepUpgradeable {\r\n  struct BribeInfo {\r\n    address market;\r\n    address bribeSupply;\r\n    address bribeBorrow;\r\n  }\r\n\r\n  struct MarketVoteInfo {\r\n    address market;\r\n    IVoter.MarketSide side;\r\n    uint256 votes;\r\n    uint256 votesValueInEth;\r\n  }\r\n\r\n  struct IncentiveInfo {\r\n    address market;\r\n    address bribeSupply;\r\n    address[] rewardsSupply;\r\n    uint256[] rewardsSupplyAmounts;\r\n    uint256[] rewardsSupplyETHValues;\r\n    address bribeBorrow;\r\n    address[] rewardsBorrow;\r\n    uint256[] rewardsBorrowAmounts;\r\n    uint256[] rewardsBorrowETHValues;\r\n  }\r\n\r\n  address voter;\r\n  PoolDirectory poolDirectory;\r\n  IMasterPriceOracle mpo;\r\n  uint256 constant PRECISION = 1e18;\r\n  address veIONAddress;\r\n\r\n  function initialize(address _voter, PoolDirectory _poolDirectory) public initializer {\r\n    voter = _voter;\r\n    poolDirectory = _poolDirectory;\r\n    __Ownable2Step_init();\r\n  }\r\n\r\n  function getAllBribes() public view returns (BribeInfo[] memory _bribeInfo) {\r\n    uint256 count = 0;\r\n    uint256 totalMarketsLength = 0;\r\n    (, PoolDirectory.Pool[] memory activePools) = poolDirectory.getActivePools();\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      ComptrollerExtensionInterface comptroller = ComptrollerExtensionInterface(activePools[i].comptroller);\r\n      ICErc20[] memory markets = comptroller.getAllMarkets();\r\n      totalMarketsLength += markets.length;\r\n    }\r\n\r\n    _bribeInfo = new BribeInfo[](totalMarketsLength);\r\n\r\n    for (uint256 i = 0; i < activePools.length; i++) {\r\n      ComptrollerExtensionInterface comptroller = ComptrollerExtensionInterface(activePools[i].comptroller);\r\n      ICErc20[] memory markets = comptroller.getAllMarkets();\r\n\r\n      for (uint256 j = 0; j < markets.length; j++) {\r\n        address rewardAccumulatorSupply = IVoterView(voter).marketToRewardAccumulators(\r\n          address(markets[j]),\r\n          IVoter.MarketSide.Supply\r\n        );\r\n        address rewardAccumulatorBorrow = IVoterView(voter).marketToRewardAccumulators(\r\n          address(markets[j]),\r\n          IVoter.MarketSide.Borrow\r\n        );\r\n\r\n        address bribeSupply = IVoterView(voter).rewardAccumulatorToBribe(rewardAccumulatorSupply);\r\n        address bribeBorrow = IVoterView(voter).rewardAccumulatorToBribe(rewardAccumulatorBorrow);\r\n\r\n        _bribeInfo[count] = BribeInfo({\r\n          market: address(markets[j]),\r\n          bribeSupply: bribeSupply,\r\n          bribeBorrow: bribeBorrow\r\n        });\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  function getAllIncentivesForBribes() external view returns (IncentiveInfo[] memory _incentiveInfo) {\r\n    BribeInfo[] memory _bribeInfo = getAllBribes();\r\n    _incentiveInfo = new IncentiveInfo[](_bribeInfo.length);\r\n    for (uint256 i; i < _bribeInfo.length; i++) {\r\n      _incentiveInfo[i].market = _bribeInfo[i].market;\r\n      if (_bribeInfo[i].bribeSupply != address(0)) {\r\n        _incentiveInfo[i].bribeSupply = _bribeInfo[i].bribeSupply;\r\n        uint256 supplyRewardsLength = IBribeRewardsView(_bribeInfo[i].bribeSupply).rewardsListLength();\r\n        _incentiveInfo[i].rewardsSupply = new address[](supplyRewardsLength);\r\n        _incentiveInfo[i].rewardsSupplyAmounts = new uint256[](supplyRewardsLength);\r\n        _incentiveInfo[i].rewardsSupplyETHValues = new uint256[](supplyRewardsLength);\r\n        for (uint256 j; j < supplyRewardsLength; j++) {\r\n          _incentiveInfo[i].rewardsSupply[j] = IBribeRewardsView(_bribeInfo[i].bribeSupply).rewards(j);\r\n          _incentiveInfo[i].rewardsSupplyAmounts[j] = ERC20(_incentiveInfo[i].rewardsSupply[j]).balanceOf(\r\n            _bribeInfo[i].bribeSupply\r\n          );\r\n\r\n          uint256 tokenPrice = mpo.price(_incentiveInfo[i].rewardsSupply[j]);\r\n\r\n          if (tokenPrice != 0) {\r\n            uint256 decimals = ERC20(_incentiveInfo[i].rewardsSupply[j]).decimals();\r\n            _incentiveInfo[i].rewardsSupplyETHValues[j] =\r\n              (_incentiveInfo[i].rewardsSupplyAmounts[j] * 10 ** (18 - decimals) * tokenPrice) /\r\n              PRECISION;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (_bribeInfo[i].bribeBorrow != address(0)) {\r\n        _incentiveInfo[i].bribeBorrow = _bribeInfo[i].bribeBorrow;\r\n        uint256 borrowRewardsLength = IBribeRewardsView(_bribeInfo[i].bribeBorrow).rewardsListLength();\r\n        _incentiveInfo[i].rewardsBorrow = new address[](borrowRewardsLength);\r\n        _incentiveInfo[i].rewardsBorrowAmounts = new uint256[](borrowRewardsLength);\r\n        _incentiveInfo[i].rewardsBorrowETHValues = new uint256[](borrowRewardsLength);\r\n        for (uint256 j; j < borrowRewardsLength; j++) {\r\n          _incentiveInfo[i].rewardsBorrow[j] = IBribeRewardsView(_bribeInfo[i].bribeBorrow).rewards(j);\r\n          _incentiveInfo[i].rewardsBorrowAmounts[j] = ERC20(_incentiveInfo[i].rewardsBorrow[j]).balanceOf(\r\n            _bribeInfo[i].bribeBorrow\r\n          );\r\n\r\n          uint256 tokenPrice = mpo.price(_incentiveInfo[i].rewardsBorrow[j]);\r\n\r\n          if (tokenPrice != 0) {\r\n            uint256 decimals = (ERC20(_incentiveInfo[i].rewardsBorrow[j])).decimals();\r\n            _incentiveInfo[i].rewardsBorrowETHValues[j] =\r\n              (_incentiveInfo[i].rewardsBorrowAmounts[j] * 10 ** (18 - decimals) * tokenPrice) /\r\n              PRECISION;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  struct UserBribes {\r\n    uint256 tokenId;\r\n    address market;\r\n    address bribe;\r\n    address reward;\r\n    uint256 earned;\r\n  }\r\n\r\n  struct UserBribeVars {\r\n    uint256[] userTokens;\r\n    address[] lpTokens;\r\n    uint256 count;\r\n    IVoter.VoteDetails voteDetails;\r\n    address rewardAccumulator;\r\n    address bribeRewards;\r\n    uint256 bribesLength;\r\n    address reward;\r\n    uint256 rewardEarned;\r\n  }\r\n\r\n  function getUserBribeRewards(address _user) external view returns (UserBribes[] memory _userBribes) {\r\n    UserBribeVars memory vars;\r\n    vars.userTokens = veIONSecondExtension(veIONAddress).getOwnedTokenIds(_user);\r\n    vars.lpTokens = Voter(voter).getAllLpRewardTokens();\r\n    vars.count = 0;\r\n\r\n    for (uint256 i = 0; i < vars.userTokens.length; i++) {\r\n      for (uint256 j = 0; j < vars.lpTokens.length; j++) {\r\n        vars.voteDetails = IVoterView(voter).getVoteDetails(vars.userTokens[i], vars.lpTokens[j]);\r\n        for (uint256 k; k < vars.voteDetails.marketVotes.length; k++) {\r\n          vars.rewardAccumulator = IVoterView(voter).marketToRewardAccumulators(\r\n            vars.voteDetails.marketVotes[k],\r\n            vars.voteDetails.marketVoteSides[k]\r\n          );\r\n          vars.bribeRewards = IVoterView(voter).rewardAccumulatorToBribe(vars.rewardAccumulator);\r\n          vars.bribesLength = IBribeRewardsView(vars.bribeRewards).rewardsListLength();\r\n          for (uint256 x; x < vars.bribesLength; x++) {\r\n            vars.reward = IBribeRewardsView(vars.bribeRewards).rewards(x);\r\n            vars.rewardEarned = IBribeRewardsView(vars.bribeRewards).earned(vars.reward, vars.userTokens[i]);\r\n            if (vars.rewardEarned != 0) vars.count++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    _userBribes = new UserBribes[](vars.count);\r\n    vars.count = 0;\r\n    for (uint256 i = 0; i < vars.userTokens.length; i++) {\r\n      for (uint256 j = 0; j < vars.lpTokens.length; j++) {\r\n        vars.voteDetails = IVoterView(voter).getVoteDetails(vars.userTokens[i], vars.lpTokens[j]);\r\n        for (uint256 k; k < vars.voteDetails.marketVotes.length; k++) {\r\n          vars.rewardAccumulator = IVoterView(voter).marketToRewardAccumulators(\r\n            vars.voteDetails.marketVotes[k],\r\n            vars.voteDetails.marketVoteSides[k]\r\n          );\r\n          vars.bribeRewards = IVoterView(voter).rewardAccumulatorToBribe(vars.rewardAccumulator);\r\n          vars.bribesLength = IBribeRewardsView(vars.bribeRewards).rewardsListLength();\r\n          for (uint256 x; x < vars.bribesLength; x++) {\r\n            vars.reward = IBribeRewardsView(vars.bribeRewards).rewards(x);\r\n            vars.rewardEarned = IBribeRewardsView(vars.bribeRewards).earned(vars.reward, vars.userTokens[i]);\r\n            if (vars.rewardEarned != 0) {\r\n              _userBribes[vars.count].tokenId = vars.userTokens[i];\r\n              _userBribes[vars.count].market = vars.voteDetails.marketVotes[k];\r\n              _userBribes[vars.count].bribe = vars.bribeRewards;\r\n              _userBribes[vars.count].reward = vars.reward;\r\n              _userBribes[vars.count].earned = vars.rewardEarned;\r\n\r\n              vars.count++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function getAllMarketVotes(address lp) public view returns (MarketVoteInfo[] memory _marketVoteInfo) {\r\n    uint256 marketsLength = IVoter(voter).marketsLength();\r\n    _marketVoteInfo = new MarketVoteInfo[](marketsLength);\r\n    for (uint256 i; i < marketsLength; i++) {\r\n      IVoter.Market memory _market = IVoterView(voter).markets(i);\r\n      _marketVoteInfo[i].market = _market.marketAddress;\r\n      _marketVoteInfo[i].side = _market.side;\r\n      _marketVoteInfo[i].votes = IVoterView(voter).weights(_market.marketAddress, _market.side, lp);\r\n\r\n      _marketVoteInfo[i].votesValueInEth =\r\n        (_marketVoteInfo[i].votes * 10 ** (18 - ERC20(lp).decimals()) * mpo.price(lp)) /\r\n        PRECISION;\r\n    }\r\n  }\r\n\r\n  function getTotalMarketVotes() external view returns (uint256 _total) {\r\n    address[] memory lpTokens = IVoter(voter).getAllLpRewardTokens();\r\n    for (uint256 i = 0; i < lpTokens.length; i++) {\r\n      MarketVoteInfo[] memory marketVotes = getAllMarketVotes(lpTokens[i]);\r\n      for (uint256 j = 0; j < marketVotes.length; j++) {\r\n        _total += marketVotes[j].votesValueInEth;\r\n      }\r\n    }\r\n  }\r\n\r\n  function setMasterPriceOracle(address _masterPriceOracle) external onlyOwner {\r\n    mpo = IMasterPriceOracle(_masterPriceOracle);\r\n  }\r\n\r\n  function setVeIONAddress(address _veIONAddress) external onlyOwner {\r\n    veIONAddress = _veIONAddress;\r\n  }\r\n}\r\n\r\ninterface IVoterView {\r\n  function rewardAccumulatorToBribe(address rewardAccumulator) external view returns (address);\r\n  function marketToRewardAccumulators(address market, IVoter.MarketSide marketSide) external view returns (address);\r\n  function marketVote(uint256 tokenId, address lpAsset) external view returns (address[] memory);\r\n  function marketVoteSide(uint256 tokenId, address lpAsset) external view returns (IVoter.MarketSide[] memory);\r\n  function getVoteDetails(uint256 _tokenId, address _lpAsset) external view returns (IVoter.VoteDetails memory);\r\n  function markets(uint256 index) external view returns (IVoter.Market memory);\r\n  function weights(address market, IVoter.MarketSide marketSide, address lp) external view returns (uint256);\r\n}\r\n\r\ninterface IBribeRewardsView {\r\n  function rewards(uint256 index) external view returns (address);\r\n  function rewardsListLength() external view returns (uint256);\r\n  function earned(address token, uint256 tokenId) external view returns (uint256);\r\n}\r\n\r\ninterface IMasterPriceOracle {\r\n  function price(address underlying) external view returns (uint256);\r\n}\r\n"
    },
    "solmate/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\nabstract contract Auth {\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\r\n\r\n    address public owner;\r\n\r\n    Authority public authority;\r\n\r\n    constructor(address _owner, Authority _authority) {\r\n        owner = _owner;\r\n        authority = _authority;\r\n\r\n        emit OwnerUpdated(msg.sender, _owner);\r\n        emit AuthorityUpdated(msg.sender, _authority);\r\n    }\r\n\r\n    modifier requiresAuth() virtual {\r\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\r\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\r\n\r\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\r\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\r\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\r\n    }\r\n\r\n    function setAuthority(Authority newAuthority) public virtual {\r\n        // We check if the caller is the owner first because we want to ensure they can\r\n        // always swap out the authority even if it's reverting or using up a lot of gas.\r\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\r\n\r\n        authority = newAuthority;\r\n\r\n        emit AuthorityUpdated(msg.sender, newAuthority);\r\n    }\r\n\r\n    function setOwner(address newOwner) public virtual requiresAuth {\r\n        owner = newOwner;\r\n\r\n        emit OwnerUpdated(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\ninterface Authority {\r\n    function canCall(\r\n        address user,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) external view returns (bool);\r\n}\r\n"
    },
    "solmate/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport {Auth, Authority} from \"../Auth.sol\";\r\n\r\n/// @notice Role based Authority that supports up to 256 roles.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\r\ncontract RolesAuthority is Auth, Authority {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\r\n\r\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\r\n\r\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ROLE/USER STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => bytes32) public getUserRoles;\r\n\r\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\r\n\r\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\r\n\r\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\r\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\r\n    }\r\n\r\n    function doesRoleHaveCapability(\r\n        uint8 role,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) public view virtual returns (bool) {\r\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                           AUTHORIZATION LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function canCall(\r\n        address user,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            isCapabilityPublic[target][functionSig] ||\r\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                   ROLE CAPABILITY CONFIGURATION LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setPublicCapability(\r\n        address target,\r\n        bytes4 functionSig,\r\n        bool enabled\r\n    ) public virtual requiresAuth {\r\n        isCapabilityPublic[target][functionSig] = enabled;\r\n\r\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\r\n    }\r\n\r\n    function setRoleCapability(\r\n        uint8 role,\r\n        address target,\r\n        bytes4 functionSig,\r\n        bool enabled\r\n    ) public virtual requiresAuth {\r\n        if (enabled) {\r\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\r\n        } else {\r\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\r\n        }\r\n\r\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                       USER ROLE ASSIGNMENT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setUserRole(\r\n        address user,\r\n        uint8 role,\r\n        bool enabled\r\n    ) public virtual requiresAuth {\r\n        if (enabled) {\r\n            getUserRoles[user] |= bytes32(1 << role);\r\n        } else {\r\n            getUserRoles[user] &= ~bytes32(1 << role);\r\n        }\r\n\r\n        emit UserRoleUpdated(user, role, enabled);\r\n    }\r\n}\r\n"
    },
    "solmate/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n"
    },
    "solmate/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide z by the denominator.\r\n            z := div(z, denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // First, divide z - 1 by the denominator and add 1.\r\n            // We allow z - 1 to underflow if z is 0, because we multiply the\r\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\r\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            let y := x // We start y at x, which will help us make our initial estimate.\r\n\r\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\r\n\r\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\r\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\r\n\r\n            // We check y >= 2^(k + 8) but shift right by k bits\r\n            // each branch to ensure that if x >= 256, then y >= 256.\r\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\r\n                y := shr(128, y)\r\n                z := shl(64, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000000000000000)) {\r\n                y := shr(64, y)\r\n                z := shl(32, z)\r\n            }\r\n            if iszero(lt(y, 0x10000000000)) {\r\n                y := shr(32, y)\r\n                z := shl(16, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000)) {\r\n                y := shr(16, y)\r\n                z := shl(8, z)\r\n            }\r\n\r\n            // Goal was to get z*z*y within a small factor of x. More iterations could\r\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\r\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\r\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\r\n\r\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\r\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\r\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\r\n\r\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\r\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\r\n\r\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\r\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\r\n\r\n            // There is no overflow risk here since y < 2^136 after the first branch above.\r\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\r\n\r\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // If x+1 is a perfect square, the Babylonian method cycles between\r\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\r\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\r\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\r\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\r\n            z := sub(z, lt(div(x, z), z))\r\n        }\r\n    }\r\n\r\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Mod x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            z := mod(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n        assembly {\r\n            // Divide x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            r := div(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Add 1 to x * y if x % y > 0. Note this will\r\n            // return 0 instead of reverting if y is zero.\r\n            z := add(gt(mod(x, y), 0), div(x, y))\r\n        }\r\n    }\r\n}\r\n"
    },
    "solmate/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Safe unsigned integer casting library that reverts on overflow.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\r\nlibrary SafeCastLib {\r\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\r\n        require(x < 1 << 248);\r\n\r\n        y = uint248(x);\r\n    }\r\n\r\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\r\n        require(x < 1 << 224);\r\n\r\n        y = uint224(x);\r\n    }\r\n\r\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\r\n        require(x < 1 << 192);\r\n\r\n        y = uint192(x);\r\n    }\r\n\r\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\r\n        require(x < 1 << 160);\r\n\r\n        y = uint160(x);\r\n    }\r\n\r\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\r\n        require(x < 1 << 128);\r\n\r\n        y = uint128(x);\r\n    }\r\n\r\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\r\n        require(x < 1 << 96);\r\n\r\n        y = uint96(x);\r\n    }\r\n\r\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\r\n        require(x < 1 << 64);\r\n\r\n        y = uint64(x);\r\n    }\r\n\r\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\r\n        require(x < 1 << 32);\r\n\r\n        y = uint32(x);\r\n    }\r\n\r\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\r\n        require(x < 1 << 24);\r\n\r\n        y = uint24(x);\r\n    }\r\n\r\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\r\n        require(x < 1 << 16);\r\n\r\n        y = uint16(x);\r\n    }\r\n\r\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\r\n        require(x < 1 << 8);\r\n\r\n        y = uint8(x);\r\n    }\r\n}\r\n"
    },
    "solmate/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\nimport {ERC20} from \"../tokens/ERC20.sol\";\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}