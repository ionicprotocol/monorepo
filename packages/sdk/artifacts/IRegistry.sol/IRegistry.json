{"abi":[{"type":"function","name":"atomicUpdate","inputs":[{"name":"_newContract","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getAddress","inputs":[{"name":"name","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"getAddressByString","inputs":[{"name":"_name","type":"string","internalType":"string"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"importAddresses","inputs":[{"name":"_names","type":"bytes32[]","internalType":"bytes32[]"},{"name":"_destinations","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"importContracts","inputs":[{"name":"_destinations","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"requireAndGetAddress","inputs":[{"name":"name","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"stringToBytes32","inputs":[{"name":"_string","type":"string","internalType":"string"}],"outputs":[{"name":"result","type":"bytes32","internalType":"bytes32"}],"stateMutability":"pure"},{"type":"event","name":"LogRegistered","inputs":[{"name":"destination","type":"address","indexed":true,"internalType":"address"},{"name":"name","type":"bytes32","indexed":false,"internalType":"bytes32"}],"anonymous":false}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"atomicUpdate(address)":"648642e9","getAddress(bytes32)":"21f8a721","getAddressByString(string)":"e8f98f88","importAddresses(bytes32[],address[])":"ab0b8f77","importContracts(address[])":"10b68901","requireAndGetAddress(bytes32)":"46bcb49d","stringToBytes32(string)":"cfb51928"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"LogRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"atomicUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getAddressByString\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_destinations\",\"type\":\"address[]\"}],\"name\":\"importAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_destinations\",\"type\":\"address[]\"}],\"name\":\"importContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"requireAndGetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_string\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"atomicUpdate(address)\":{\"details\":\"this method ensure, that old and new contract is aware of it state in registry Note: BSC registry does not have this method. This method was introduced in later stage.\",\"params\":{\"_newContract\":\"address of contract that will replace old one\"}},\"getAddress(bytes32)\":{\"params\":{\"name\":\"contract name in a form of bytes32\"},\"returns\":{\"_0\":\"contract address registered under provided name\"}},\"getAddressByString(string)\":{\"params\":{\"_name\":\"contract name\"},\"returns\":{\"_0\":\"contract address assigned to the name or address(0) if not exists\"}},\"importAddresses(bytes32[],address[])\":{\"details\":\"imports new contract addresses and override old addresses, if they exist under provided name This method can be used for contracts that for some reason do not have `getName` method\",\"params\":{\"_destinations\":\"array of contract addresses\",\"_names\":\"array of contract names that we want to register\"}},\"importContracts(address[])\":{\"details\":\"imports new contracts and override old addresses, if they exist. Names of contracts are fetched directly from each contract by calling `getName`\",\"params\":{\"_destinations\":\"array of contract addresses\"}},\"requireAndGetAddress(bytes32)\":{\"details\":\"similar to `getAddress` but throws when contract name not exists\",\"params\":{\"name\":\"contract name\"},\"returns\":{\"_0\":\"contract address registered under provided name or throws, if does not exists\"}},\"stringToBytes32(string)\":{\"details\":\"helper method that converts string to bytes32, you can use to to generate contract name\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/external/umbrella/IRegistry.sol\":\"IRegistry\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@pythnetwork/pyth-sdk-solidity/=lib/pyth-sdk-solidity/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":flywheel-v2/=lib/flywheel-v2/src/\",\":flywheel/=lib/flywheel-v2/src/\",\":forge-std/=lib/forge-std/src/\",\":fuse-flywheel/=lib/fuse-flywheel/src/\",\":libcompound/=lib/fuse-flywheel/lib/libcompound/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":ops/=lib/ops/contracts/\",\":pyth-sdk-solidity/=lib/pyth-sdk-solidity/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/\",\":solmate/=lib/solmate/src/\",\":weird-erc20/=lib/fuse-flywheel/lib/libcompound/lib/solmate/lib/weird-erc20/src/\"]},\"sources\":{\"contracts/external/umbrella/IRegistry.sol\":{\"keccak256\":\"0xa212e02144777bf7a6d3b7995c0b0cc7be1ecd81aaca50e2ee537ab005d62ddb\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://31ee2f6fb1488db1708fc3d50e642467f512b2e6fc3a3df3003f9b4ef17ed07f\",\"dweb:/ipfs/QmVgSY8yuU6QPKu9tshiE8cZDMM5VaE2U9QoutUbquzWJj\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.10+commit.fc410830"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"destination","type":"address","indexed":true},{"internalType":"bytes32","name":"name","type":"bytes32","indexed":false}],"type":"event","name":"LogRegistered","anonymous":false},{"inputs":[{"internalType":"address","name":"_newContract","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"atomicUpdate"},{"inputs":[{"internalType":"bytes32","name":"name","type":"bytes32"}],"stateMutability":"view","type":"function","name":"getAddress","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"string","name":"_name","type":"string"}],"stateMutability":"view","type":"function","name":"getAddressByString","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"bytes32[]","name":"_names","type":"bytes32[]"},{"internalType":"address[]","name":"_destinations","type":"address[]"}],"stateMutability":"nonpayable","type":"function","name":"importAddresses"},{"inputs":[{"internalType":"address[]","name":"_destinations","type":"address[]"}],"stateMutability":"nonpayable","type":"function","name":"importContracts"},{"inputs":[{"internalType":"bytes32","name":"name","type":"bytes32"}],"stateMutability":"view","type":"function","name":"requireAndGetAddress","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"string","name":"_string","type":"string"}],"stateMutability":"pure","type":"function","name":"stringToBytes32","outputs":[{"internalType":"bytes32","name":"result","type":"bytes32"}]}],"devdoc":{"kind":"dev","methods":{"atomicUpdate(address)":{"details":"this method ensure, that old and new contract is aware of it state in registry Note: BSC registry does not have this method. This method was introduced in later stage.","params":{"_newContract":"address of contract that will replace old one"}},"getAddress(bytes32)":{"params":{"name":"contract name in a form of bytes32"},"returns":{"_0":"contract address registered under provided name"}},"getAddressByString(string)":{"params":{"_name":"contract name"},"returns":{"_0":"contract address assigned to the name or address(0) if not exists"}},"importAddresses(bytes32[],address[])":{"details":"imports new contract addresses and override old addresses, if they exist under provided name This method can be used for contracts that for some reason do not have `getName` method","params":{"_destinations":"array of contract addresses","_names":"array of contract names that we want to register"}},"importContracts(address[])":{"details":"imports new contracts and override old addresses, if they exist. Names of contracts are fetched directly from each contract by calling `getName`","params":{"_destinations":"array of contract addresses"}},"requireAndGetAddress(bytes32)":{"details":"similar to `getAddress` but throws when contract name not exists","params":{"name":"contract name"},"returns":{"_0":"contract address registered under provided name or throws, if does not exists"}},"stringToBytes32(string)":{"details":"helper method that converts string to bytes32, you can use to to generate contract name"}},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/=lib/openzeppelin-contracts/","@pythnetwork/pyth-sdk-solidity/=lib/pyth-sdk-solidity/","ds-test/=lib/forge-std/lib/ds-test/src/","flywheel-v2/=lib/flywheel-v2/src/","flywheel/=lib/flywheel-v2/src/","forge-std/=lib/forge-std/src/","fuse-flywheel/=lib/fuse-flywheel/src/","libcompound/=lib/fuse-flywheel/lib/libcompound/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","ops/=lib/ops/contracts/","pyth-sdk-solidity/=lib/pyth-sdk-solidity/","solidity-bytes-utils/=lib/solidity-bytes-utils/","solmate/=lib/solmate/src/","weird-erc20/=lib/fuse-flywheel/lib/libcompound/lib/solmate/lib/weird-erc20/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"none"},"compilationTarget":{"contracts/external/umbrella/IRegistry.sol":"IRegistry"},"evmVersion":"london","libraries":{}},"sources":{"contracts/external/umbrella/IRegistry.sol":{"keccak256":"0xa212e02144777bf7a6d3b7995c0b0cc7be1ecd81aaca50e2ee537ab005d62ddb","urls":["bzz-raw://31ee2f6fb1488db1708fc3d50e642467f512b2e6fc3a3df3003f9b4ef17ed07f","dweb:/ipfs/QmVgSY8yuU6QPKu9tshiE8cZDMM5VaE2U9QoutUbquzWJj"],"license":"MIT"}},"version":1},"id":98}